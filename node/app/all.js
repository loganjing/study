;
;
/*!
 * jQuery JavaScript Library v1.6.2
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Thu Jun 30 14:16:56 2011 -0400
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// (both of which we optimize for)
	quickExpr = /^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Check for digits
	rdigit = /\d/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Matches dashed string for camelizing
	rdashAlpha = /-([a-z])/ig,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	},

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// The deferred used on DOM ready
	readyList,

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = (context ? context.ownerDocument || context : document);

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return (context || rootjQuery).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if (selector.selector !== undefined) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.6.2",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + (this.selector ? " " : "") + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.done( fn );

		return this;
	},

	eq: function( i ) {
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, +i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {
		// Either a released hold or an DOMready/load event and not yet ready
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).unbind( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery._Deferred();

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	// A crude way of determining if an object is a window
	isWindow: function( obj ) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	},

	isNaN: function( obj ) {
		return obj == null || !rdigit.test( obj ) || isNaN( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		// Not own constructor property must be Object
		if ( obj.constructor &&
			!hasOwn.call(obj, "constructor") &&
			!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw msg;
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return (new Function( "return " + data ))();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	// (xml & tmp used internally)
	parseXML: function( data , xml , tmp ) {

		if ( window.DOMParser ) { // Standard
			tmp = new DOMParser();
			xml = tmp.parseFromString( data , "text/xml" );
		} else { // IE
			xml = new ActiveXObject( "Microsoft.XMLDOM" );
			xml.async = "false";
			xml.loadXML( data );
		}

		tmp = xml.documentElement;

		if ( ! tmp || ! tmp.nodeName || tmp.nodeName === "parsererror" ) {
			jQuery.error( "Invalid XML: " + data );
		}

		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Converts a dashed string to camelCased string;
	// Used by both the css and data modules
	camelCase: function( string ) {
		return string.replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// The extra typeof function check is to prevent crashes
			// in Safari 2 (See: #3039)
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array ) {

		if ( indexOf ) {
			return indexOf.call( array, elem );
		}

		for ( var i = 0, length = array.length; i < length; i++ ) {
			if ( array[ i ] === elem ) {
				return i;
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, key, value, exec, fn, pass ) {
		var length = elems.length;

		// Setting many attributes
		if ( typeof key === "object" ) {
			for ( var k in key ) {
				jQuery.access( elems, k, key[k], exec, fn, value );
			}
			return elems;
		}

		// Setting one attribute
		if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = !pass && exec && jQuery.isFunction(value);

			for ( var i = 0; i < length; i++ ) {
				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
			}

			return elems;
		}

		// Getting an attribute
		return length ? fn( elems[0], key ) : undefined;
	},

	now: function() {
		return (new Date()).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;

})();


var // Promise methods
	promiseMethods = "done fail isResolved isRejected promise then always pipe".split( " " ),
	// Static reference to slice
	sliceDeferred = [].slice;

jQuery.extend({
	// Create a simple deferred (one callbacks list)
	_Deferred: function() {
		var // callbacks list
			callbacks = [],
			// stored [ context , args ]
			fired,
			// to avoid firing when already doing so
			firing,
			// flag to know if the deferred has been cancelled
			cancelled,
			// the deferred itself
			deferred  = {

				// done( f1, f2, ...)
				done: function() {
					if ( !cancelled ) {
						var args = arguments,
							i,
							length,
							elem,
							type,
							_fired;
						if ( fired ) {
							_fired = fired;
							fired = 0;
						}
						for ( i = 0, length = args.length; i < length; i++ ) {
							elem = args[ i ];
							type = jQuery.type( elem );
							if ( type === "array" ) {
								deferred.done.apply( deferred, elem );
							} else if ( type === "function" ) {
								callbacks.push( elem );
							}
						}
						if ( _fired ) {
							deferred.resolveWith( _fired[ 0 ], _fired[ 1 ] );
						}
					}
					return this;
				},

				// resolve with given context and args
				resolveWith: function( context, args ) {
					if ( !cancelled && !fired && !firing ) {
						// make sure args are available (#8421)
						args = args || [];
						firing = 1;
						try {
							while( callbacks[ 0 ] ) {
								callbacks.shift().apply( context, args );
							}
						} finally {
							fired = [ context, args ];
							firing = 0;
						}
					}
					return this;
				},

				// resolve with this as context and given arguments
				resolve: function() {
					deferred.resolveWith( this, arguments );
					return this;
				},

				// Has this deferred been resolved?
				isResolved: function() {
					return !!( firing || fired );
				},

				// Cancel
				cancel: function() {
					cancelled = 1;
					callbacks = [];
					return this;
				}
			};

		return deferred;
	},

	// Full fledged deferred (two callbacks list)
	Deferred: function( func ) {
		var deferred = jQuery._Deferred(),
			failDeferred = jQuery._Deferred(),
			promise;
		// Add errorDeferred methods, then and promise
		jQuery.extend( deferred, {
			then: function( doneCallbacks, failCallbacks ) {
				deferred.done( doneCallbacks ).fail( failCallbacks );
				return this;
			},
			always: function() {
				return deferred.done.apply( deferred, arguments ).fail.apply( this, arguments );
			},
			fail: failDeferred.done,
			rejectWith: failDeferred.resolveWith,
			reject: failDeferred.resolve,
			isRejected: failDeferred.isResolved,
			pipe: function( fnDone, fnFail ) {
				return jQuery.Deferred(function( newDefer ) {
					jQuery.each( {
						done: [ fnDone, "resolve" ],
						fail: [ fnFail, "reject" ]
					}, function( handler, data ) {
						var fn = data[ 0 ],
							action = data[ 1 ],
							returned;
						if ( jQuery.isFunction( fn ) ) {
							deferred[ handler ](function() {
								returned = fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise().then( newDefer.resolve, newDefer.reject );
								} else {
									newDefer[ action ]( returned );
								}
							});
						} else {
							deferred[ handler ]( newDefer[ action ] );
						}
					});
				}).promise();
			},
			// Get a promise for this deferred
			// If obj is provided, the promise aspect is added to the object
			promise: function( obj ) {
				if ( obj == null ) {
					if ( promise ) {
						return promise;
					}
					promise = obj = {};
				}
				var i = promiseMethods.length;
				while( i-- ) {
					obj[ promiseMethods[i] ] = deferred[ promiseMethods[i] ];
				}
				return obj;
			}
		});
		// Make sure only one callback list will be used
		deferred.done( failDeferred.cancel ).fail( deferred.cancel );
		// Unexpose cancel
		delete deferred.cancel;
		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}
		return deferred;
	},

	// Deferred helper
	when: function( firstParam ) {
		var args = arguments,
			i = 0,
			length = args.length,
			count = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					// Strange bug in FF4:
					// Values changed onto the arguments object sometimes end up as undefined values
					// outside the $.when method. Cloning the object into a fresh array solves the issue
					deferred.resolveWith( deferred, sliceDeferred.call( args, 0 ) );
				}
			};
		}
		if ( length > 1 ) {
			for( ; i < length; i++ ) {
				if ( args[ i ] && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return deferred.promise();
	}
});



jQuery.support = (function() {

	var div = document.createElement( "div" ),
		documentElement = document.documentElement,
		all,
		a,
		select,
		opt,
		input,
		marginDiv,
		support,
		fragment,
		body,
		testElementParent,
		testElement,
		testElementStyle,
		tds,
		events,
		eventName,
		i,
		isSupported;

	// Preliminary tests
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName( "tbody" ).length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName( "link" ).length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute( "href" ) === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55$/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

	// Check if a radio maintains it's value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");
	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.firstChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	div.innerHTML = "";

	// Figure out if the W3C box model works as expected
	div.style.width = div.style.paddingLeft = "1px";

	body = document.getElementsByTagName( "body" )[ 0 ];
	// We use our own, invisible, body unless the body is already present
	// in which case we use a div (#9239)
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0
	};
	if ( body ) {
		jQuery.extend( testElementStyle, {
			position: "absolute",
			left: -1000,
			top: -1000
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	support.boxModel = div.offsetWidth === 2;

	if ( "zoom" in div.style ) {
		// Check if natively block-level elements act like inline-block
		// elements when setting their display to 'inline' and giving
		// them layout
		// (IE < 8 does this)
		div.style.display = "inline";
		div.style.zoom = 1;
		support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );

		// Check if elements with layout shrink-wrap their children
		// (IE 6 does this)
		div.style.display = "";
		div.innerHTML = "<div style='width:4px;'></div>";
		support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
	}

	div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
	tds = div.getElementsByTagName( "td" );

	// Check if table cells still have offsetWidth/Height when they are set
	// to display:none and there are still other visible table cells in a
	// table row; if so, offsetWidth/Height are not reliable for use when
	// determining if an element has been hidden directly using
	// display:none (it is still safe to use offsets if a parent element is
	// hidden; don safety goggles and see bug #4512 for more information).
	// (only IE 8 fails this test)
	isSupported = ( tds[ 0 ].offsetHeight === 0 );

	tds[ 0 ].style.display = "";
	tds[ 1 ].style.display = "none";

	// Check if empty table cells still have offsetWidth/Height
	// (IE < 8 fail this test)
	support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );
	div.innerHTML = "";

	// Check if div with explicit width and no margin-right incorrectly
	// gets computed margin-right based on width of container. For more
	// info see bug #3333
	// Fails in WebKit before Feb 2011 nightlies
	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	if ( document.defaultView && document.defaultView.getComputedStyle ) {
		marginDiv = document.createElement( "div" );
		marginDiv.style.width = "0";
		marginDiv.style.marginRight = "0";
		div.appendChild( marginDiv );
		support.reliableMarginRight =
			( parseInt( ( document.defaultView.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
	}

	// Remove the body element we added
	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );

	// Technique from Juriy Zaytsev
	// http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for( i in {
			submit: 1,
			change: 1,
			focusin: 1
		} ) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	// Null connected elements to avoid leaks in IE
	testElement = fragment = select = opt = body = marginDiv = div = input = null;

	return support;
})();

// Keep track of boxModel
jQuery.boxModel = jQuery.support.boxModel;




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([a-z])([A-Z])/g;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];

		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var internalKey = jQuery.expando, getByName = typeof name === "string", thisCache,

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ jQuery.expando ] : elem[ jQuery.expando ] && jQuery.expando;

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || (pvt && id && !cache[ id ][ internalKey ])) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ jQuery.expando ] = id = ++jQuery.uuid;
			} else {
				id = jQuery.expando;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
			// metadata on plain JS objects when the object is serialized using
			// JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ][ internalKey ] = jQuery.extend(cache[ id ][ internalKey ], name);
			} else {
				cache[ id ] = jQuery.extend(cache[ id ], name);
			}
		}

		thisCache = cache[ id ];

		// Internal jQuery data is stored in a separate object inside the object's data
		// cache in order to avoid key collisions between internal data and user-defined
		// data
		if ( pvt ) {
			if ( !thisCache[ internalKey ] ) {
				thisCache[ internalKey ] = {};
			}

			thisCache = thisCache[ internalKey ];
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should
		// not attempt to inspect the internal events object using jQuery.data, as this
		// internal data object is undocumented and subject to change.
		if ( name === "events" && !thisCache[name] ) {
			return thisCache[ internalKey ] && thisCache[ internalKey ].events;
		}

		return getByName ? 
			// Check for both converted-to-camel and non-converted data property names
			thisCache[ jQuery.camelCase( name ) ] || thisCache[ name ] :
			thisCache;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var internalKey = jQuery.expando, isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {
			var thisCache = pvt ? cache[ id ][ internalKey ] : cache[ id ];

			if ( thisCache ) {
				delete thisCache[ name ];

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !isEmptyDataObject(thisCache) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( pvt ) {
			delete cache[ id ][ internalKey ];

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		var internalCache = cache[ id ][ internalKey ];

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		if ( jQuery.support.deleteExpando || cache != window ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the entire user cache at once because it's faster than
		// iterating through each key, but we need to continue to persist internal
		// data if it existed
		if ( internalCache ) {
			cache[ id ] = {};
			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
			// metadata on plain JS objects when the object is serialized using
			// JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}

			cache[ id ][ internalKey ] = internalCache;

		// Otherwise, we need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		} else if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ jQuery.expando ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( jQuery.expando );
			} else {
				elem[ jQuery.expando ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var data = null;

		if ( typeof key === "undefined" ) {
			if ( this.length ) {
				data = jQuery.data( this[0] );

				if ( this[0].nodeType === 1 ) {
			    var attr = this[0].attributes, name;
					for ( var i = 0, l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( this[0], name, data[ name ] );
						}
					}
				}
			}

			return data;

		} else if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		var parts = key.split(".");
		parts[1] = parts[1] ? "." + parts[1] : "";

		if ( value === undefined ) {
			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

			// Try to fetch any internally stored data first
			if ( data === undefined && this.length ) {
				data = jQuery.data( this[0], key );
				data = dataAttr( this[0], key, data );
			}

			return data === undefined && parts[1] ?
				this.data( parts[0] ) :
				data;

		} else {
			return this.each(function() {
				var $this = jQuery( this ),
					args = [ parts[0], value ];

				$this.triggerHandler( "setData" + parts[1] + "!", args );
				jQuery.data( this, key, value );
				$this.triggerHandler( "changeData" + parts[1] + "!", args );
			});
		}
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		var name = "data-" + key.replace( rmultiDash, "$1-$2" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				!jQuery.isNaN( data ) ? parseFloat( data ) :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON
// property to be considered empty objects; this property always exists in
// order to make sure JSON.stringify does not expose internal metadata
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery.data( elem, deferDataKey, undefined, true );
	if ( defer &&
		( src === "queue" || !jQuery.data( elem, queueDataKey, undefined, true ) ) &&
		( src === "mark" || !jQuery.data( elem, markDataKey, undefined, true ) ) ) {
		// Give room for hard-coded callbacks to fire first
		// and eventually mark/queue something else on the element
		setTimeout( function() {
			if ( !jQuery.data( elem, queueDataKey, undefined, true ) &&
				!jQuery.data( elem, markDataKey, undefined, true ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.resolve();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = (type || "fx") + "mark";
			jQuery.data( elem, type, (jQuery.data(elem,type,undefined,true) || 0) + 1, true );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery.data( elem, key, undefined, true) || 1 ) - 1 );
			if ( count ) {
				jQuery.data( elem, key, count, true );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		if ( elem ) {
			type = (type || "fx") + "queue";
			var q = jQuery.data( elem, type, undefined, true );
			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery.data( elem, type, jQuery.makeArray(data), true );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			defer;

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift("inprogress");
			}

			fn.call(elem, function() {
				jQuery.dequeue(elem, type);
			});
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
		}

		if ( data === undefined ) {
			return jQuery.queue( this[0], type );
		}
		return this.each(function() {
			var queue = jQuery.queue( this, type, data );

			if ( type === "fx" && queue[0] !== "inprogress" ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";

		return this.queue( type, function() {
			var elem = this;
			setTimeout(function() {
				jQuery.dequeue( elem, type );
			}, time );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery._Deferred(), true ) )) {
				count++;
				tmp.done( resolve );
			}
		}
		resolve();
		return defer.promise();
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	rinvalidChar = /\:|^on/,
	formHook, boolHook;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.attr );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},
	
	prop: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.prop );
	},
	
	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = (value || "").split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ";
		for ( var i = 0, l = this.length; i < l; i++ ) {
			if ( (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret,
			elem = this[0];
		
		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ? 
					// handle most common string cases
					ret.replace(rreturn, "") : 
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return undefined;
		}

		var isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				for ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {
					var option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},
	
	attrFix: {
		// Always normalize to ensure hook usage
		tabindex: "tabIndex"
	},
	
	attr: function( elem, name, value, pass ) {
		var nType = elem.nodeType;
		
		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return undefined;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( !("getAttribute" in elem) ) {
			return jQuery.prop( elem, name, value );
		}

		var ret, hooks,
			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// Normalize the name if needed
		if ( notxml ) {
			name = jQuery.attrFix[ name ] || name;

			hooks = jQuery.attrHooks[ name ];

			if ( !hooks ) {
				// Use boolHook for boolean attributes
				if ( rboolean.test( name ) ) {

					hooks = boolHook;

				// Use formHook for forms and if the name contains certain characters
				} else if ( formHook && name !== "className" &&
					(jQuery.nodeName( elem, "form" ) || rinvalidChar.test( name )) ) {

					hooks = formHook;
				}
			}
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return undefined;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, name ) {
		var propName;
		if ( elem.nodeType === 1 ) {
			name = jQuery.attrFix[ name ] || name;
		
			if ( jQuery.support.getSetAttribute ) {
				// Use removeAttribute in browsers that support it
				elem.removeAttribute( name );
			} else {
				jQuery.attr( elem, name, "" );
				elem.removeAttributeNode( elem.getAttributeNode( name ) );
			}

			// Set corresponding property to false for boolean attributes
			if ( rboolean.test( name ) && (propName = jQuery.propFix[ name ] || name) in elem ) {
				elem[ propName ] = false;
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabIndex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		},
		// Use the value property for back compat
		// Use the formHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( formHook && jQuery.nodeName( elem, "button" ) ) {
					return formHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( formHook && jQuery.nodeName( elem, "button" ) ) {
					return formHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},
	
	prop: function( elem, name, value ) {
		var nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return undefined;
		}

		var ret, hooks,
			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return (elem[ name ] = value);
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== undefined ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},
	
	propHooks: {}
});

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		return jQuery.prop( elem, name ) ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !jQuery.support.getSetAttribute ) {

	// propFix is more comprehensive and contains all fixes
	jQuery.attrFix = jQuery.propFix;
	
	// Use this for any attribute on a form in IE6/7
	formHook = jQuery.attrHooks.name = jQuery.attrHooks.title = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			// Return undefined if nodeValue is empty string
			return ret && ret.nodeValue !== "" ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			// Check form objects in IE (multiple bugs related)
			// Only use nodeValue if the attribute node exists on the form
			var ret = elem.getAttributeNode( name );
			if ( ret ) {
				ret.nodeValue = value;
				return value;
			}
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return (elem.style.cssText = "" + value);
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	});
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return (elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0);
			}
		}
	});
});




var rnamespaces = /\.(.*)$/,
	rformElems = /^(?:textarea|input|select)$/i,
	rperiod = /\./g,
	rspaces = / /g,
	rescape = /[^\w\s.|`]/g,
	fcleanup = function( nm ) {
		return nm.replace(rescape, "\\$&");
	};

/*
 * A number of helper functions used for managing events.
 * Many of the ideas behind this code originated from
 * Dean Edwards' addEvent library.
 */
jQuery.event = {

	// Bind an event to an element
	// Original by Dean Edwards
	add: function( elem, types, handler, data ) {
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		if ( handler === false ) {
			handler = returnFalse;
		} else if ( !handler ) {
			// Fixes bug #7229. Fix recommended by jdalton
			return;
		}

		var handleObjIn, handleObj;

		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
		}

		// Make sure that the function being executed has a unique ID
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure
		var elemData = jQuery._data( elem );

		// If no elemData is found then we must be trying to bind to one of the
		// banned noData elements
		if ( !elemData ) {
			return;
		}

		var events = elemData.events,
			eventHandle = elemData.handle;

		if ( !events ) {
			elemData.events = events = {};
		}

		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.handle.apply( eventHandle.elem, arguments ) :
					undefined;
			};
		}

		// Add elem as a property of the handle function
		// This is to prevent a memory leak with non-native events in IE.
		eventHandle.elem = elem;

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = types.split(" ");

		var type, i = 0, namespaces;

		while ( (type = types[ i++ ]) ) {
			handleObj = handleObjIn ?
				jQuery.extend({}, handleObjIn) :
				{ handler: handler, data: data };

			// Namespaced event handlers
			if ( type.indexOf(".") > -1 ) {
				namespaces = type.split(".");
				type = namespaces.shift();
				handleObj.namespace = namespaces.slice(0).sort().join(".");

			} else {
				namespaces = [];
				handleObj.namespace = "";
			}

			handleObj.type = type;
			if ( !handleObj.guid ) {
				handleObj.guid = handler.guid;
			}

			// Get the current list of functions bound to this event
			var handlers = events[ type ],
				special = jQuery.event.special[ type ] || {};

			// Init the event handler queue
			if ( !handlers ) {
				handlers = events[ type ] = [];

				// Check for a special event handler
				// Only use addEventListener/attachEvent if the special
				// events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add the function to the element's handler list
			handlers.push( handleObj );

			// Keep track of which events have been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, pos ) {
		// don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		if ( handler === false ) {
			handler = returnFalse;
		}

		var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			events = elemData && elemData.events;

		if ( !elemData || !events ) {
			return;
		}

		// types is actually an event object here
		if ( types && types.type ) {
			handler = types.handler;
			types = types.type;
		}

		// Unbind all events for the element
		if ( !types || typeof types === "string" && types.charAt(0) === "." ) {
			types = types || "";

			for ( type in events ) {
				jQuery.event.remove( elem, type + types );
			}

			return;
		}

		// Handle multiple events separated by a space
		// jQuery(...).unbind("mouseover mouseout", fn);
		types = types.split(" ");

		while ( (type = types[ i++ ]) ) {
			origType = type;
			handleObj = null;
			all = type.indexOf(".") < 0;
			namespaces = [];

			if ( !all ) {
				// Namespaced event handlers
				namespaces = type.split(".");
				type = namespaces.shift();

				namespace = new RegExp("(^|\\.)" +
					jQuery.map( namespaces.slice(0).sort(), fcleanup ).join("\\.(?:.*\\.)?") + "(\\.|$)");
			}

			eventType = events[ type ];

			if ( !eventType ) {
				continue;
			}

			if ( !handler ) {
				for ( j = 0; j < eventType.length; j++ ) {
					handleObj = eventType[ j ];

					if ( all || namespace.test( handleObj.namespace ) ) {
						jQuery.event.remove( elem, origType, handleObj.handler, j );
						eventType.splice( j--, 1 );
					}
				}

				continue;
			}

			special = jQuery.event.special[ type ] || {};

			for ( j = pos || 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( handler.guid === handleObj.guid ) {
					// remove the given handler for the given type
					if ( all || namespace.test( handleObj.namespace ) ) {
						if ( pos == null ) {
							eventType.splice( j--, 1 );
						}

						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}

					if ( pos != null ) {
						break;
					}
				}
			}

			// remove generic event handler if no more handlers exist
			if ( eventType.length === 0 || pos != null && eventType.length === 1 ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				ret = null;
				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			var handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			delete elemData.events;
			delete elemData.handle;

			if ( jQuery.isEmptyObject( elemData ) ) {
				jQuery.removeData( elem, undefined, true );
			}
		}
	},
	
	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Event object or event type
		var type = event.type || event,
			namespaces = [],
			exclusive;

		if ( type.indexOf("!") >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.exclusive = exclusive;
		event.namespace = namespaces.join(".");
		event.namespace_re = new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)");
		
		// triggerHandler() and global events don't bubble or run the default action
		if ( onlyHandlers || !elem ) {
			event.preventDefault();
			event.stopPropagation();
		}

		// Handle a global trigger
		if ( !elem ) {
			// TODO: Stop taunting the data cache; remove global events and always attach to document
			jQuery.each( jQuery.cache, function() {
				// internalKey variable is just used to make it easier to find
				// and potentially change this stuff later; currently it just
				// points to jQuery.expando
				var internalKey = jQuery.expando,
					internalCache = this[ internalKey ];
				if ( internalCache && internalCache.events && internalCache.events[ type ] ) {
					jQuery.event.trigger( event, data, internalCache.handle.elem );
				}
			});
			return;
		}

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		event.target = elem;

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		var cur = elem,
			// IE doesn't like method names with a colon (#3533, #8272)
			ontype = type.indexOf(":") < 0 ? "on" + type : "";

		// Fire event on the current element, then bubble up the DOM tree
		do {
			var handle = jQuery._data( cur, "handle" );

			event.currentTarget = cur;
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Trigger an inline bound script
			if ( ontype && jQuery.acceptData( cur ) && cur[ ontype ] && cur[ ontype ].apply( cur, data ) === false ) {
				event.result = false;
				event.preventDefault();
			}

			// Bubble up to document, then to window
			cur = cur.parentNode || cur.ownerDocument || cur === event.target.ownerDocument && window;
		} while ( cur && !event.isPropagationStopped() );

		// If nobody prevented the default action, do it now
		if ( !event.isDefaultPrevented() ) {
			var old,
				special = jQuery.event.special[ type ] || {};

			if ( (!special._default || special._default.call( elem.ownerDocument, event ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction)() check here because IE6/7 fails that test.
				// IE<9 dies on focus to hidden element (#1486), may want to revisit a try/catch.
				try {
					if ( ontype && elem[ type ] ) {
						// Don't re-trigger an onFOO event when we call its FOO() method
						old = elem[ ontype ];

						if ( old ) {
							elem[ ontype ] = null;
						}

						jQuery.event.triggered = type;
						elem[ type ]();
					}
				} catch ( ieError ) {}

				if ( old ) {
					elem[ ontype ] = old;
				}

				jQuery.event.triggered = undefined;
			}
		}
		
		return event.result;
	},

	handle: function( event ) {
		event = jQuery.event.fix( event || window.event );
		// Snapshot the handlers list since a called handler may add/remove events.
		var handlers = ((jQuery._data( this, "events" ) || {})[ event.type ] || []).slice(0),
			run_all = !event.exclusive && !event.namespace,
			args = Array.prototype.slice.call( arguments, 0 );

		// Use the fix-ed Event rather than the (read-only) native event
		args[0] = event;
		event.currentTarget = this;

		for ( var j = 0, l = handlers.length; j < l; j++ ) {
			var handleObj = handlers[ j ];

			// Triggered event must 1) be non-exclusive and have no namespace, or
			// 2) have namespace(s) a subset or equal to those in the bound event.
			if ( run_all || event.namespace_re.test( handleObj.namespace ) ) {
				// Pass in a reference to the handler function itself
				// So that we can later remove it
				event.handler = handleObj.handler;
				event.data = handleObj.data;
				event.handleObj = handleObj;

				var ret = handleObj.handler.apply( this, args );

				if ( ret !== undefined ) {
					event.result = ret;
					if ( ret === false ) {
						event.preventDefault();
						event.stopPropagation();
					}
				}

				if ( event.isImmediatePropagationStopped() ) {
					break;
				}
			}
		}
		return event.result;
	},

	props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// store a copy of the original event object
		// and "clone" to set read-only properties
		var originalEvent = event;
		event = jQuery.Event( originalEvent );

		for ( var i = this.props.length, prop; i; ) {
			prop = this.props[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary
		if ( !event.target ) {
			// Fixes #1925 where srcElement might not be defined either
			event.target = event.srcElement || document;
		}

		// check if target is a textnode (safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Add relatedTarget, if necessary
		if ( !event.relatedTarget && event.fromElement ) {
			event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
		}

		// Calculate pageX/Y if missing and clientX/Y available
		if ( event.pageX == null && event.clientX != null ) {
			var eventDocument = event.target.ownerDocument || document,
				doc = eventDocument.documentElement,
				body = eventDocument.body;

			event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
			event.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);
		}

		// Add which for key events
		if ( event.which == null && (event.charCode != null || event.keyCode != null) ) {
			event.which = event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
		if ( !event.metaKey && event.ctrlKey ) {
			event.metaKey = event.ctrlKey;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		// Note: button is not normalized, so don't use it
		if ( !event.which && event.button !== undefined ) {
			event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));
		}

		return event;
	},

	// Deprecated, use jQuery.guid instead
	guid: 1E8,

	// Deprecated, use jQuery.proxy instead
	proxy: jQuery.proxy,

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady,
			teardown: jQuery.noop
		},

		live: {
			add: function( handleObj ) {
				jQuery.event.add( this,
					liveConvert( handleObj.origType, handleObj.selector ),
					jQuery.extend({}, handleObj, {handler: liveHandler, guid: handleObj.handler.guid}) );
			},

			remove: function( handleObj ) {
				jQuery.event.remove( this, liveConvert( handleObj.origType, handleObj.selector ), handleObj );
			}
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !this.preventDefault ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// timeStamp is buggy for some events on Firefox(#3843)
	// So we won't rely on the native value
	this.timeStamp = jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Checks if an event happened on an element within another element
// Used in jQuery.event.special.mouseenter and mouseleave handlers
var withinElement = function( event ) {

	// Check if mouse(over|out) are still within the same parent element
	var related = event.relatedTarget,
		inside = false,
		eventType = event.type;

	event.type = event.data;

	if ( related !== this ) {

		if ( related ) {
			inside = jQuery.contains( this, related );
		}

		if ( !inside ) {

			jQuery.event.handle.apply( this, arguments );

			event.type = eventType;
		}
	}
},

// In case of event delegation, we only need to rename the event.type,
// liveHandler will take care of the rest.
delegate = function( event ) {
	event.type = event.data;
	jQuery.event.handle.apply( this, arguments );
};

// Create mouseenter and mouseleave events
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		setup: function( data ) {
			jQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig );
		},
		teardown: function( data ) {
			jQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement );
		}
	};
});

// submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function( data, namespaces ) {
			if ( !jQuery.nodeName( this, "form" ) ) {
				jQuery.event.add(this, "click.specialSubmit", function( e ) {
					var elem = e.target,
						type = elem.type;

					if ( (type === "submit" || type === "image") && jQuery( elem ).closest("form").length ) {
						trigger( "submit", this, arguments );
					}
				});

				jQuery.event.add(this, "keypress.specialSubmit", function( e ) {
					var elem = e.target,
						type = elem.type;

					if ( (type === "text" || type === "password") && jQuery( elem ).closest("form").length && e.keyCode === 13 ) {
						trigger( "submit", this, arguments );
					}
				});

			} else {
				return false;
			}
		},

		teardown: function( namespaces ) {
			jQuery.event.remove( this, ".specialSubmit" );
		}
	};

}

// change delegation, happens here so we have bind.
if ( !jQuery.support.changeBubbles ) {

	var changeFilters,

	getVal = function( elem ) {
		var type = elem.type, val = elem.value;

		if ( type === "radio" || type === "checkbox" ) {
			val = elem.checked;

		} else if ( type === "select-multiple" ) {
			val = elem.selectedIndex > -1 ?
				jQuery.map( elem.options, function( elem ) {
					return elem.selected;
				}).join("-") :
				"";

		} else if ( jQuery.nodeName( elem, "select" ) ) {
			val = elem.selectedIndex;
		}

		return val;
	},

	testChange = function testChange( e ) {
		var elem = e.target, data, val;

		if ( !rformElems.test( elem.nodeName ) || elem.readOnly ) {
			return;
		}

		data = jQuery._data( elem, "_change_data" );
		val = getVal(elem);

		// the current data will be also retrieved by beforeactivate
		if ( e.type !== "focusout" || elem.type !== "radio" ) {
			jQuery._data( elem, "_change_data", val );
		}

		if ( data === undefined || val === data ) {
			return;
		}

		if ( data != null || val ) {
			e.type = "change";
			e.liveFired = undefined;
			jQuery.event.trigger( e, arguments[1], elem );
		}
	};

	jQuery.event.special.change = {
		filters: {
			focusout: testChange,

			beforedeactivate: testChange,

			click: function( e ) {
				var elem = e.target, type = jQuery.nodeName( elem, "input" ) ? elem.type : "";

				if ( type === "radio" || type === "checkbox" || jQuery.nodeName( elem, "select" ) ) {
					testChange.call( this, e );
				}
			},

			// Change has to be called before submit
			// Keydown will be called before keypress, which is used in submit-event delegation
			keydown: function( e ) {
				var elem = e.target, type = jQuery.nodeName( elem, "input" ) ? elem.type : "";

				if ( (e.keyCode === 13 && !jQuery.nodeName( elem, "textarea" ) ) ||
					(e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
					type === "select-multiple" ) {
					testChange.call( this, e );
				}
			},

			// Beforeactivate happens also before the previous element is blurred
			// with this event you can't trigger a change event, but you can store
			// information
			beforeactivate: function( e ) {
				var elem = e.target;
				jQuery._data( elem, "_change_data", getVal(elem) );
			}
		},

		setup: function( data, namespaces ) {
			if ( this.type === "file" ) {
				return false;
			}

			for ( var type in changeFilters ) {
				jQuery.event.add( this, type + ".specialChange", changeFilters[type] );
			}

			return rformElems.test( this.nodeName );
		},

		teardown: function( namespaces ) {
			jQuery.event.remove( this, ".specialChange" );

			return rformElems.test( this.nodeName );
		}
	};

	changeFilters = jQuery.event.special.change.filters;

	// Handle when the input is .focus()'d
	changeFilters.focus = changeFilters.beforeactivate;
}

function trigger( type, elem, args ) {
	// Piggyback on a donor event to simulate a different one.
	// Fake originalEvent to avoid donor's stopPropagation, but if the
	// simulated event prevents default then we do the same on the donor.
	// Don't pass args or remember liveFired; they apply to the donor event.
	var event = jQuery.extend( {}, args[ 0 ] );
	event.type = type;
	event.originalEvent = {};
	event.liveFired = undefined;
	jQuery.event.handle.call( elem, event );
	if ( event.isDefaultPrevented() ) {
		args[ 0 ].preventDefault();
	}
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0;

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};

		function handler( donor ) {
			// Donor event is always a native one; fix it and switch its type.
			// Let focusin/out handler cancel the donor focus/blur event.
			var e = jQuery.event.fix( donor );
			e.type = fix;
			e.originalEvent = {};
			jQuery.event.trigger( e, null, e.target );
			if ( e.isDefaultPrevented() ) {
				donor.preventDefault();
			}
		}
	});
}

jQuery.each(["bind", "one"], function( i, name ) {
	jQuery.fn[ name ] = function( type, data, fn ) {
		var handler;

		// Handle object literals
		if ( typeof type === "object" ) {
			for ( var key in type ) {
				this[ name ](key, data, type[key], fn);
			}
			return this;
		}

		if ( arguments.length === 2 || data === false ) {
			fn = data;
			data = undefined;
		}

		if ( name === "one" ) {
			handler = function( event ) {
				jQuery( this ).unbind( event, handler );
				return fn.apply( this, arguments );
			};
			handler.guid = fn.guid || jQuery.guid++;
		} else {
			handler = fn;
		}

		if ( type === "unload" && name !== "one" ) {
			this.one( type, data, fn );

		} else {
			for ( var i = 0, l = this.length; i < l; i++ ) {
				jQuery.event.add( this[i], type, handler, data );
			}
		}

		return this;
	};
});

jQuery.fn.extend({
	unbind: function( type, fn ) {
		// Handle object literals
		if ( typeof type === "object" && !type.preventDefault ) {
			for ( var key in type ) {
				this.unbind(key, type[key]);
			}

		} else {
			for ( var i = 0, l = this.length; i < l; i++ ) {
				jQuery.event.remove( this[i], type, fn );
			}
		}

		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.live( types, data, fn, selector );
	},

	undelegate: function( selector, types, fn ) {
		if ( arguments.length === 0 ) {
			return this.unbind( "live" );

		} else {
			return this.die( types, null, fn, selector );
		}
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},

	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery.data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery.data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

var liveMap = {
	focus: "focusin",
	blur: "focusout",
	mouseenter: "mouseover",
	mouseleave: "mouseout"
};

jQuery.each(["live", "die"], function( i, name ) {
	jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {
		var type, i = 0, match, namespaces, preType,
			selector = origSelector || this.selector,
			context = origSelector ? this : jQuery( this.context );

		if ( typeof types === "object" && !types.preventDefault ) {
			for ( var key in types ) {
				context[ name ]( key, data, types[key], selector );
			}

			return this;
		}

		if ( name === "die" && !types &&
					origSelector && origSelector.charAt(0) === "." ) {

			context.unbind( origSelector );

			return this;
		}

		if ( data === false || jQuery.isFunction( data ) ) {
			fn = data || returnFalse;
			data = undefined;
		}

		types = (types || "").split(" ");

		while ( (type = types[ i++ ]) != null ) {
			match = rnamespaces.exec( type );
			namespaces = "";

			if ( match )  {
				namespaces = match[0];
				type = type.replace( rnamespaces, "" );
			}

			if ( type === "hover" ) {
				types.push( "mouseenter" + namespaces, "mouseleave" + namespaces );
				continue;
			}

			preType = type;

			if ( liveMap[ type ] ) {
				types.push( liveMap[ type ] + namespaces );
				type = type + namespaces;

			} else {
				type = (liveMap[ type ] || type) + namespaces;
			}

			if ( name === "live" ) {
				// bind live handler
				for ( var j = 0, l = context.length; j < l; j++ ) {
					jQuery.event.add( context[j], "live." + liveConvert( type, selector ),
						{ data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType } );
				}

			} else {
				// unbind live handler
				context.unbind( "live." + liveConvert( type, selector ), fn );
			}
		}

		return this;
	};
});

function liveHandler( event ) {
	var stop, maxLevel, related, match, handleObj, elem, j, i, l, data, close, namespace, ret,
		elems = [],
		selectors = [],
		events = jQuery._data( this, "events" );

	// Make sure we avoid non-left-click bubbling in Firefox (#3861) and disabled elements in IE (#6911)
	if ( event.liveFired === this || !events || !events.live || event.target.disabled || event.button && event.type === "click" ) {
		return;
	}

	if ( event.namespace ) {
		namespace = new RegExp("(^|\\.)" + event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
	}

	event.liveFired = this;

	var live = events.live.slice(0);

	for ( j = 0; j < live.length; j++ ) {
		handleObj = live[j];

		if ( handleObj.origType.replace( rnamespaces, "" ) === event.type ) {
			selectors.push( handleObj.selector );

		} else {
			live.splice( j--, 1 );
		}
	}

	match = jQuery( event.target ).closest( selectors, event.currentTarget );

	for ( i = 0, l = match.length; i < l; i++ ) {
		close = match[i];

		for ( j = 0; j < live.length; j++ ) {
			handleObj = live[j];

			if ( close.selector === handleObj.selector && (!namespace || namespace.test( handleObj.namespace )) && !close.elem.disabled ) {
				elem = close.elem;
				related = null;

				// Those two events require additional checking
				if ( handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave" ) {
					event.type = handleObj.preType;
					related = jQuery( event.relatedTarget ).closest( handleObj.selector )[0];

					// Make sure not to accidentally match a child element with the same selector
					if ( related && jQuery.contains( elem, related ) ) {
						related = elem;
					}
				}

				if ( !related || related !== elem ) {
					elems.push({ elem: elem, handleObj: handleObj, level: close.level });
				}
			}
		}
	}

	for ( i = 0, l = elems.length; i < l; i++ ) {
		match = elems[i];

		if ( maxLevel && match.level > maxLevel ) {
			break;
		}

		event.currentTarget = match.elem;
		event.data = match.handleObj.data;
		event.handleObj = match.handleObj;

		ret = match.handleObj.origHandler.apply( match.elem, arguments );

		if ( ret === false || event.isPropagationStopped() ) {
			maxLevel = match.level;

			if ( ret === false ) {
				stop = false;
			}
			if ( event.isImmediatePropagationStopped() ) {
				break;
			}
		}
	}

	return stop;
}

function liveConvert( type, selector ) {
	return (type && type !== "*" ? type + "." : "") + selector.replace(rperiod, "`").replace(rspaces, "&");
}

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.bind( name, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}
	
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;
	
	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];
		
			parts.push( m[1] );
		
			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}
				
				set = posProcess( selector, set );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set;

	if ( !expr ) {
		return [];
	}

	for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
		var match,
			type = Expr.order[i];
		
		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			var left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( var type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				var found, item,
					filter = Expr.filter[ type ],
					left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							var pass = not ^ !!found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw "Syntax error, unrecognized expression: " + msg;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );
			
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			
			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},
	
	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},
		
		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}
			
			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					if ( type === "first" ) { 
						return true; 
					}

					node = elem;

				case "last":
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					return true;

				case "nth":
					var first = match[2],
						last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}
					
					var doneName = match[0],
						parent = elem.parentNode;
	
					if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
						var count = 0;
						
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						} 

						parent.sizcache = doneName;
					}
					
					var diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
		},
		
		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	
	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Utility function for retreiving the text value of an array of DOM nodes
Sizzle.getText = function( elems ) {
	var ret = "", elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		// Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		// Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += Sizzle.getText( elem.childNodes );
		}
	}

	return ret;
};

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}
	
		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
				
				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );
					
					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}
				
				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );
						
					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}
							
						} else {
							return makeArray( [], extra );
						}
					}
					
					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}
		
			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		// Check to see if it's possible to do matchesSelector
		// on a disconnected node (IE 9 fails this)
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( document.documentElement, "[test!='']:sizzle" );
	
		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try { 
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || !disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}
	
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem.sizcache = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;
			
			elem = elem[dir];

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem.sizcache = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833) 
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && ( typeof selector === "string" ?
			jQuery.filter( selector, this ).length > 0 :
			this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];
		
		// Array
		if ( jQuery.isArray( selectors ) ) {
			var match, selector,
				matches = {},
				level = 1;

			if ( cur && selectors.length ) {
				for ( i = 0, l = selectors.length; i < l; i++ ) {
					selector = selectors[i];

					if ( !matches[ selector ] ) {
						matches[ selector ] = POS.test( selector ) ?
							jQuery( selector, context || this.context ) :
							selector;
					}
				}

				while ( cur && cur.ownerDocument && cur !== context ) {
					for ( selector in matches ) {
						match = matches[ selector ];

						if ( match.jquery ? match.index( cur ) > -1 : jQuery( cur ).is( match ) ) {
							ret.push({ selector: selector, elem: cur, level: level });
						}
					}

					cur = cur.parentNode;
					level++;
				}
			}

			return ret;
		}

		// String
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {
		if ( !elem || typeof elem === "string" ) {
			return jQuery.inArray( this[0],
				// If it receives a string, the selector is used
				// If it receives nothing, the siblings are used
				elem ? jQuery( elem ) : this.parent().children() );
		}
		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( elem.parentNode.firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until ),
			// The variable 'args' was introduced in
			// https://github.com/jquery/jquery/commit/52a0238
			// to work around a bug in Chrome 10 (Dev) and should be removed when the bug is fixed.
			// http://code.google.com/p/v8/issues/detail?id=1050
			args = slice.call(arguments);

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, args.join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return (elem === qualifier) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return (jQuery.inArray( elem, qualifier ) >= 0) === keep;
	});
}




var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnocache = /<(?:script|object|embed|option|style)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	};

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( text ) {
		if ( jQuery.isFunction(text) ) {
			return this.each(function(i) {
				var self = jQuery( this );

				self.text( text.call(this, i, self.text()) );
			});
		}

		if ( typeof text !== "object" && text !== undefined ) {
			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
		}

		return jQuery.text( this );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		return this.each(function() {
			jQuery( this ).wrapAll( html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery(arguments[0]);
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery(arguments[0]).toArray() );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		if ( value === undefined ) {
			return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

		// See if we can take a shortcut and just use innerHTML
		} else if ( typeof value === "string" && !rnocache.test( value ) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

			value = value.replace(rxhtmlTag, "<$1></$2>");

			try {
				for ( var i = 0, l = this.length; i < l; i++ ) {
					// Remove element nodes and prevent memory leaks
					if ( this[i].nodeType === 1 ) {
						jQuery.cleanData( this[i].getElementsByTagName("*") );
						this[i].innerHTML = value;
					}
				}

			// If using innerHTML throws an exception, use the fallback method
			} catch(e) {
				this.empty().append( value );
			}

		} else if ( jQuery.isFunction( value ) ) {
			this.each(function(i){
				var self = jQuery( this );

				self.html( value.call(this, i, self.html()) );
			});

		} else {
			this.empty().append( value );
		}

		return this;
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || (l > 1 && i < lastIndex) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, evalScript );
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var internalKey = jQuery.expando,
		oldData = jQuery.data( src ),
		curData = jQuery.data( dest, oldData );

	// Switch to use the internal data object, if it exists, for the next
	// stage of data copying
	if ( (oldData = oldData[ internalKey ]) ) {
		var events = oldData.events;
				curData = curData[ internalKey ] = jQuery.extend({}, oldData);

		if ( events ) {
			delete curData.handle;
			curData.events = {};

			for ( var type in events ) {
				for ( var i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
				}
			}
		}
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc;

  // nodes may contain either an explicit document object,
  // a jQuery collection or context object.
  // If nodes[0] contains a valid object to assign to doc
  if ( nodes && nodes[0] ) {
    doc = nodes[0].ownerDocument || nodes[0];
  }

  // Ensure that an attr object doesn't incorrectly stand in as a document object
	// Chrome and Firefox seem to allow this to occur and will throw exception
	// Fixes #8950
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	if ( args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document &&
		args[0].charAt(0) === "<" && !rnocache.test( args[0] ) && (jQuery.support.checkClone || !rchecked.test( args[0] )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ args[0] ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ args[0] ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = (i > 0 ? this.clone(true) : this).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( "getElementsByTagName" in elem ) {
		return elem.getElementsByTagName( "*" );

	} else if ( "querySelectorAll" in elem ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
	if ( jQuery.nodeName( elem, "input" ) ) {
		fixDefaultChecked( elem );
	} else if ( "getElementsByTagName" in elem ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var clone = elem.cloneNode(true),
				srcElements,
				destElements,
				i;

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName
			// instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				cloneFixAttributes( srcElements[i], destElements[i] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType;

		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		var ret = [], j;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Trim whitespace, otherwise indexOf won't work as expected
					var tag = (rtagName.exec( elem ) || ["", ""])[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div");

					// Go to html and back, then peel off extra wrappers
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;
				}
			}

			// Resets defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );

				} else {
					if ( ret[i].nodeType === 1 ) {
						var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( ret[i] );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id, cache = jQuery.cache, internalKey = jQuery.expando, special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ] && cache[ id ][ internalKey ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});

function evalScript( i, elem ) {
	if ( elem.src ) {
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});
	} else {
		jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
	}

	if ( elem.parentNode ) {
		elem.parentNode.removeChild( elem );
	}
}



var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	// fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,
	rrelNum = /^[+\-]=/,
	rrelNumFilter = /[^+\-\.\de]+/g,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = [ "Left", "Right" ],
	cssHeight = [ "Top", "Bottom" ],
	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
	// Setting 'undefined' is a no-op
	if ( arguments.length === 2 && value === undefined ) {
		return this;
	}

	return jQuery.access( this, name, value, true, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	});
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity", "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Make sure that NaN and null values aren't set. See: #7116
			if ( type === "number" && isNaN( value ) || value == null ) {
				return;
			}

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && rrelNum.test( value ) ) {
				value = +value.replace( rrelNumFilter, "" ) + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

		// Make sure that we're working with the right name
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

		// cssFloat needs a special treatment
		if ( name === "cssFloat" ) {
			name = "float";
		}

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {};

		// Remember the old values, and insert the new ones
		for ( var name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	}
});

// DEPRECATED, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

jQuery.each(["height", "width"], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			var val;

			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWH( elem, name, extra );
				} else {
					jQuery.swap( elem, cssShow, function() {
						val = getWH( elem, name, extra );
					});
				}

				return val;
			}
		},

		set: function( elem, value ) {
			if ( rnumpx.test( value ) ) {
				// ignore negative width and height values #1599
				value = parseFloat( value );

				if ( value >= 0 ) {
					return value + "px";
				}

			} else {
				return value;
			}
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle;

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// Set the alpha filter to set the opacity
			var opacity = jQuery.isNaN( value ) ?
				"" :
				"alpha(opacity=" + value * 100 + ")",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
	// This hook cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				var ret;
				jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						ret = curCSS( elem, "margin-right", "marginRight" );
					} else {
						ret = elem.style.marginRight;
					}
				});
				return ret;
			}
		};
	}
});

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( !(defaultView = elem.ownerDocument.defaultView) ) {
			return undefined;
		}

		if ( (computedStyle = defaultView.getComputedStyle( elem, null )) ) {
			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			rsLeft = elem.runtimeStyle && elem.runtimeStyle[ name ],
			style = elem.style;

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {
			// Remember the original values
			left = style.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : (ret || 0);
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWH( elem, name, extra ) {

	// Start with offset property
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		which = name === "width" ? cssWidth : cssHeight;

	if ( val > 0 ) {
		if ( extra !== "border" ) {
			jQuery.each( which, function() {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + this ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + this ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + this + "Width" ) ) || 0;
				}
			});
		}

		return val + "px";
	}

	// Fall back to computed then uncomputed css if necessary
	val = curCSS( elem, name, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ] || 0;
	}
	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Add padding, border, margin
	if ( extra ) {
		jQuery.each( which, function() {
			val += parseFloat( jQuery.css( elem, "padding" + this ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + this + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + this ) ) || 0;
			}
		});
	}

	return val + "px";
}

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && (elem.style.display || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Document location
	ajaxLocation,

	// Document location segments
	ajaxLocParts;

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

			// For each dataType in the dataTypeExpression
			for(; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for(; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			// Complete callback (responseText is used internally)
			complete: function( jqXHR, status, responseText ) {
				// Store the response as specified by the jqXHR object
				responseText = jqXHR.responseText;
				// If successful, inject the HTML into all the matched elements
				if ( jqXHR.isResolved() ) {
					// #4825: Get the actual response in case
					// a dataFilter is present in ajaxSettings
					jqXHR.done(function( r ) {
						responseText = r;
					});
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.bind( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function ( target, settings ) {
		if ( !settings ) {
			// Only one parameter, we extend ajaxSettings
			settings = target;
			target = jQuery.extend( true, jQuery.ajaxSettings, settings );
		} else {
			// target was provided, we extend into it
			jQuery.extend( true, target, jQuery.ajaxSettings, settings );
		}
		// Flatten fields we don't want deep extended
		for( var field in { context: 1, url: 1 } ) {
			if ( field in settings ) {
				target[ field ] = settings[ field ];
			} else if( field in jQuery.ajaxSettings ) {
				target[ field ] = jQuery.ajaxSettings[ field ];
			}
		}
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": "*/*"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		/*
		 * conversation
		 */
		if($.getConversationID!=null) {
			if(options.url!=null && $.getConversationID()!=null && $.getConversationID()!=""){
				if(options.url.indexOf("conversationid")<0){
					if(options.url.indexOf("?")<0){
						options.url = options.url + "?";
						options.url = options.url + "conversationid=" + $.getConversationID();
					}
					else {
						options.url = options.url + "&conversationid=" + $.getConversationID();
					}
				}
			}
		}

		// Force options to be an object
		options = options || {};

		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery._Deferred(),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// ifModified key
			ifModifiedKey,
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// The jqXHR state
			state = 0,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, statusText, responses, headers ) {

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status ? 4 : 0;

			var isSuccess,
				success,
				error,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						// We have a parsererror
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = statusText;

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.resolveWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.done;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

		// Determine if a cross-domain request is in order
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefiler, stop there
		if ( state === 2 ) {
			return false;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( (ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", */*; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already
				jqXHR.abort();
				return false;

		}

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( status < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					jQuery.error( e );
				}
			}
		}

		return jqXHR;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && obj != null && typeof obj === "object" ) {
		// Serialize object item.
		for ( var name in obj ) {
			buildParams( prefix + "." + name + "", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

	// Fill responseXXX fields
	for( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		// Current and previous dataTypes
		current = dataTypes[ 0 ],
		prev,
		// Conversion expression
		conversion,
		// Conversion function
		conv,
		// Conversion functions (transitive conversion)
		conv1,
		conv2;

	// For each dataType in the chain
	for( i = 1; i < length; i++ ) {

		// Create converters map
		// with lowercased keys
		if ( i === 1 ) {
			for( key in s.converters ) {
				if( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

		// Get the dataTypes
		prev = current;
		current = dataTypes[ i ];

		// If current is auto dataType, update it to prev
		if( current === "*" ) {
			current = prev;
		// If no auto and dataTypes are actually different
		} else if ( prev !== "*" && prev !== current ) {

			// Get the converter
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

			// If there is no direct converter, search transitively
			if ( !conv ) {
				conv2 = undefined;
				for( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			// If we found no converter, dispatch an error
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			// If found converter is not an equivalence
			if ( conv !== true ) {
				// Convert with 1 or 2 converters accordingly
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
		( typeof s.data === "string" );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					// Add callback manually
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

		// Install callback
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

		// Clean-up function
		jqXHR.always(function() {
			// Set callback back to previous value
			window[ jsonpCallback ] = previous;
			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Delegate to script
		return "script";
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var xhr = s.xhr(),
						handle,
						i;

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
                    if(!!window.debug){
                        var start = $.log.start();
                    }
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occured
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {
                            if(!!window.debug){
                                $.log.end(start,"ajax url("+s.url+"),async:"+s.async+" from backend:");
                                start = $.log.start();
                            }
							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}
									responses.text = xhr.responseText;

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
                            if(!!window.debug){
                                $.log.end(start,"ajax url("+s.url+"),handler in client:");
                            }
						}
					};

					// if we're in sync mode or it's in cache
					// and has been retrieved directly (IE6 & IE7)
					// we need to manually fire the callback
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	],
	fxNow,
	requestAnimationFrame = window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.oRequestAnimationFrame;

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback);

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[i];

				if ( elem.style ) {
					display = elem.style.display;

					// Reset the inline display of this element to learn if it is
					// being hidden by cascaded rules or not
					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}

					// Set elements which have been overridden with display: none
					// in a stylesheet to whatever the default browser style is
					// for such an element
					if ( display === "" && jQuery.css( elem, "display" ) === "none" ) {
						jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
					}
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[i];

				if ( elem.style ) {
					display = elem.style.display;

					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data(elem, "olddisplay") || "";
					}
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				if ( this[i].style ) {
					var display = jQuery.css( this[i], "display" );

					if ( display !== "none" && !jQuery._data( this[i], "olddisplay" ) ) {
						jQuery._data( this[i], "olddisplay", display );
					}
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed(speed, easing, callback);

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}

		// Do not change referenced properties as per-property easing will be lost
		prop = jQuery.extend( {}, prop );

		return this[ optall.queue === false ? "each" : "queue" ](function() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			if ( optall.queue === false ) {
				jQuery._mark( this );
			}

			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p,
				display, e,
				parts, start, end, unit;

			// will store per property easing and be used to determine when an animation is complete
			opt.animatedProperties = {};

			for ( p in prop ) {

				// property name normalization
				name = jQuery.camelCase( p );
				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}

				val = prop[ name ];

				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
				if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
				}

				if ( val === "hide" && hidden || val === "show" && !hidden ) {
					return opt.complete.call( this );
				}

				if ( isElement && ( name === "height" || name === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height
					// animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {
						if ( !jQuery.support.inlineBlockNeedsLayout ) {
							this.style.display = "inline-block";

						} else {
							display = defaultDisplay( this.nodeName );

							// inline-level elements accept inline-block;
							// block-level elements need to be inline with layout
							if ( display === "inline" ) {
								this.style.display = "inline-block";

							} else {
								this.style.display = "inline";
								this.style.zoom = 1;
							}
						}
					}
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];

				if ( rfxtypes.test(val) ) {
					e[ val === "toggle" ? hidden ? "show" : "hide" : val ]();

				} else {
					parts = rfxnum.exec( val );
					start = e.cur();

					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ((end || 1) / e.cur()) * start;
							jQuery.style( this, p, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			}

			// For JS strict compliance
			return true;
		});
	},

	stop: function( clearQueue, gotoEnd ) {
		if ( clearQueue ) {
			this.queue([]);
		}

		this.each(function() {
			var timers = jQuery.timers,
				i = timers.length;
			// clear marker counters if we know they won't be
			if ( !gotoEnd ) {
				jQuery._unmark( true, this );
			}
			while ( i-- ) {
				if ( timers[i].elem === this ) {
					if (gotoEnd) {
						// force the next step to be the last
						timers[i](true);
					}

					timers.splice(i, 1);
				}
			}
		});

		// start the next in the queue if the last step wasn't forced
		if ( !gotoEnd ) {
			this.dequeue();
		}

		return this;
	}

});

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}

function clearFxNow() {
	fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show", 1),
	slideUp: genFx("hide", 1),
	slideToggle: genFx("toggle", 1),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

		// Queueing
		opt.old = opt.complete;
		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue !== false ) {
				jQuery.dequeue( this );
			} else if ( noUnmark !== false ) {
				jQuery._unmark( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		options.orig = options.orig || {};
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		(jQuery.fx.step[this.prop] || jQuery.fx.step._default)( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
		// Empty strings, null, undefined and "auto" are converted to 0,
		// complex values such as "rotate(1rad)" are returned as is,
		// simple values such as "10px" are parsed to Float.
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx,
			raf;

		this.startTime = fxNow || createFxNow();
		this.start = from;
		this.end = to;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );
		this.now = this.start;
		this.pos = this.state = 0;

		function t( gotoEnd ) {
			return self.step(gotoEnd);
		}

		t.elem = this.elem;

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			// Use requestAnimationFrame instead of setInterval if available
			if ( requestAnimationFrame ) {
				timerId = true;
				raf = function() {
					// When timerId gets set to null at any point, this stops
					if ( timerId ) {
						requestAnimationFrame( raf );
						fx.tick();
					}
				};
				requestAnimationFrame( raf );
			} else {
				timerId = setInterval( fx.tick, fx.interval );
			}
		}
	},

	// Simple 'show' function
	show: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any
		// flash of content
		this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom(this.cur(), 0);
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options,
			i, n;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.animatedProperties[ this.prop ] = true;

			for ( i in options.animatedProperties ) {
				if ( options.animatedProperties[i] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

					jQuery.each( [ "", "X", "Y" ], function (index, value) {
						elem.style[ "overflow" + value ] = options.overflow[index];
					});
				}

				// Hide the element if the "hide" operation was done
				if ( options.hide ) {
					jQuery(elem).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( options.hide || options.show ) {
					for ( var p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[p] );
					}
				}

				// Execute the complete function
				options.complete.call( elem );
			}

			return false;

		} else {
			// classical easing cannot be used with an Infinity duration
			if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;

				// Perform the easing function, defaults to swing
				this.pos = jQuery.easing[ options.animatedProperties[ this.prop ] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ((this.end - this.start) * this.pos);
			}
			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		for ( var timers = jQuery.timers, i = 0 ; i < timers.length ; ++i ) {
			if ( !timers[i]() ) {
				timers.splice(i--, 1);
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = (fx.prop === "width" || fx.prop === "height" ? Math.max(0, fx.now) : fx.now) + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

	if ( !elemdisplay[ nodeName ] ) {

		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );

		elem.remove();

		// If the simple way fails,
		// get element's real default display by attaching it to a temp iframe
		if ( display === "none" || display === "" ) {
			// No iframe to use yet, so create it
			if ( !iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}

			body.appendChild( iframe );

			// Create a cacheable copy of the iframe document on first call.
			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
			// document to it; WebKit & Firefox won't allow reusing the iframe document.
			if ( !iframeDoc || !iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( document.compatMode === "CSS1Compat" ? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}

			elem = iframeDoc.createElement( nodeName );

			iframeDoc.body.appendChild( elem );

			display = jQuery.css( elem, "display" );

			body.removeChild( iframe );
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	jQuery.fn.offset = function( options ) {
		var elem = this[0], box;

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		var doc = elem.ownerDocument,
			docElem = doc.documentElement;

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow(doc),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	jQuery.fn.offset = function( options ) {
		var elem = this[0];

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		jQuery.offset.initialize();

		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.offset = {
	initialize: function() {
		var body = document.body, container = document.createElement("div"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat( jQuery.css(body, "marginTop") ) || 0,
			html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";

		jQuery.extend( container.style, { position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px", height: "1px", visibility: "hidden" } );

		container.innerHTML = html;
		body.insertBefore( container, body.firstChild );
		innerDiv = container.firstChild;
		checkDiv = innerDiv.firstChild;
		td = innerDiv.nextSibling.firstChild.firstChild;

		this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
		this.doesAddBorderForTableAndCells = (td.offsetTop === 5);

		checkDiv.style.position = "fixed";
		checkDiv.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);
		checkDiv.style.position = checkDiv.style.top = "";

		innerDiv.style.overflow = "hidden";
		innerDiv.style.position = "relative";

		this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);

		this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);

		body.removeChild( container );
		jQuery.offset.initialize = jQuery.noop;
	},

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		jQuery.offset.initialize();

		if ( jQuery.offset.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if (options.top != null) {
			props.top = (options.top - curOffset.top) + curTop;
		}
		if (options.left != null) {
			props.left = (options.left - curOffset.left) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({
	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( ["Left", "Top"], function( i, name ) {
	var method = "scroll" + name;

	jQuery.fn[ method ] = function( val ) {
		var elem, win;

		if ( val === undefined ) {
			elem = this[ 0 ];

			if ( !elem ) {
				return null;
			}

			win = getWindow( elem );

			// Return the scroll offset
			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
				jQuery.support.boxModel && win.document.documentElement[ method ] ||
					win.document.body[ method ] :
				elem[ method ];
		}

		// Set the scroll offset
		return this.each(function() {
			win = getWindow( this );

			if ( win ) {
				win.scrollTo(
					!i ? val : jQuery( win ).scrollLeft(),
					 i ? val : jQuery( win ).scrollTop()
				);

			} else {
				this[ method ] = val;
			}
		});
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each([ "Height", "Width" ], function( i, name ) {

	var type = name.toLowerCase();

	// innerHeight and innerWidth
	jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem && elem.style ?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem && elem.style ?
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
			null;
	};

	jQuery.fn[ type ] = function( size ) {
		// Get window width or height
		var elem = this[0];
		if ( !elem ) {
			return size == null ? null : this;
		}

		if ( jQuery.isFunction( size ) ) {
			return this.each(function( i ) {
				var self = jQuery( this );
				self[ type ]( size.call( this, i, self[ type ]() ) );
			});
		}

		if ( jQuery.isWindow( elem ) ) {
			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
			// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
			var docElemProp = elem.document.documentElement[ "client" + name ];
			return elem.document.compatMode === "CSS1Compat" && docElemProp ||
				elem.document.body[ "client" + name ] || docElemProp;

		// Get document width or height
		} else if ( elem.nodeType === 9 ) {
			// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
			return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

		// Get or set width or height on the element
		} else if ( size === undefined ) {
			var orig = jQuery.css( elem, type ),
				ret = parseFloat( orig );

			return jQuery.isNaN( ret ) ? orig : ret;

		// Set the width or height on the element (default to pixels if value is unitless)
		} else {
			return this.css( type, typeof size === "string" ? size : size + "px" );
		}
	};

});


// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
/*if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
    define( "jquery", [], function () { return window.$; } );
}*/

})(window);

/**
* WAF
* @author JASON LIU
* @class js 
* @constructor
* @return (JS)
*/
var Namespace = {
	/*
	 * :
	 * @param {String} fullNS 
	 * @return 
	 */
	register : function(fullNS) {
		var nsArray = fullNS.split('.');
		var sEval = "";
		var sNS = "";
		for (var i = 0; i < nsArray.length; i++) {
			if (i != 0)
				sNS += ".";
			sNS += nsArray[i];
			sEval += "if (typeof(" + sNS + ") == 'undefined') " + sNS
					+ " = new Object();"
		}
		if (sEval != "")
			return eval(sEval);
	}
};

/**
* js function
* @author JASON LIU
* @class js 
* @constructor
* @return js function
*/
Function.prototype.GetName = function()
{
      var fnName = this.toString(); 
      fnName = fnName.substr(0, fnName.indexOf('(')); 
      fnName = fnName.replace(/^function/, ''); 
      return fnName.replace(/(^\s+)|(\s+$)/g, '');
};

/**
* jquery ajax
* @author JASON LIU
* @class js 
* @constructor
* @return js function
*/
function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				add( prefix, v );
			} else {
				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && obj != null && typeof obj === "object" ) {
		for ( var name in obj ) {
			buildParams( prefix + "." + name + "", obj[ name ], traditional, add );
		}

	} else {
		add( prefix, obj );
	}
}

/**
* WAF,jquery
* @author JASON LIU
* @class WAF
*/
var waf = $;
waf.extend({
			/**
			* :conversationid
			* @type {String}
			*/
		 	conversationid:null,
		 	context:null,
		 	localeResourceObj:null,
		 	
		 	/**
		 	 * 
		 	 */
		 	pageMsgAreaBox:null,
		 	
			/**
			 *ajax
			 */
			ajaxTimeout : 600000,
			
			/**
			 * 
			 */
			setPageMsgAreaBox:function(msgAreaBox){
				waf.pageMsgAreaBox=msgAreaBox;
			},
			/**
			 * 
			 */
			getPageMsgAreaBox:function(){
				return waf.pageMsgAreaBox;
			},
			/**
			 * :,
			 * @param {String} 
			 */
			registerNamespace : function(ns){
				var nsArray = fullNS.split('.');
				var sEval = "";
				var sNS = "";
				for (var i = 0; i < nsArray.length; i++) {
					if (i != 0)
						sNS += ".";
					sNS += nsArray[i];
					sEval += "if (typeof(" + sNS + ") == 'undefined') " + sNS
							+ " = new Object();"
				}
				if (sEval != "")
					return eval(sEval);
			},
			/**
			 * waf js 
			 * @param {subClass} 
			 * @param {superClass} 
			 */
			inherit : function(subClass, superClass) {
				if(superClass==null) return ;
				var Fun = function(){};//
				Fun.prototype = superClass.prototype;
				subClass.prototype = new Fun();
				subClass.prototype.constructor = subClass;
	
				// superClass 
				//
				subClass.superClass = superClass.prototype;
				if(superClass.prototype.constructor == Object.prototype.constructor){
					superClass.prototype.constructor = superClass;
				}
			},
			/**
			 * waf js 
			 * @param subClassName 
			 * @param superClass   
			 * @param prototype 	     
			 * @return JS
			 */
			defineClass:function(subClassName,superClass,prototype){
				var clzPath=subClassName.substr(0,subClassName.lastIndexOf('.'));
				var ns=Namespace.register(clzPath);
				var subClass=eval(subClassName + "=function(){};");

				waf.inherit(subClass,superClass);

				for(var p in prototype){
					eval(subClassName + ".prototype." + p.toString() + "=prototype." + p.toString());
				}
			},
			/**
			 * : 
			 * @param {clazz} 
			 */
			createObject:function(clazz){
				var obj=new clazz();
				if(clazz.superClass!=null){
					obj.superClass=clazz.superClass;
				}
				//JS AOP
				waf.aspectClassFun(clazz,obj);
				return obj;
			},
			/**
			 * :JSAOP
			 * @param {} url
			 * @return {}
			 */
			aspectClassFun:function(clazz,object){
				var clazz_temp=clazz;
				while(clazz_temp!=null && clazz_temp!=undefined) {
					for(var p in clazz_temp.prototype){
						var methodName=p.toString();
						var beforeMethodFun=p.toString() + "_before";
						var afterMethodFun=p.toString() + "_after";
						var aroundMethodFun=p.toString() + "_replace";
						if(eval("object." + beforeMethodFun)!=null) {
							waf.aspectBefore(object,p.toString(),eval("object." + beforeMethodFun));
						}
						if(eval("object." + afterMethodFun)!=null){
							waf.aspectAfter(object,p.toString(),eval("object." + afterMethodFun));
						}
						if(eval("object." + aroundMethodFun)!=null){
							waf.aspectAround(object,p.toString(),eval("object." + aroundMethodFun));
						}
					}
					clazz_temp=clazz_temp.superClass;
				}
			},
			/**
			 * URL
			 * @param {url} url 
			 * @return URL
			 */
			getUrlParams:function(url){
			  var args=new Object();   
			  var query=location.search.substring(1);//   
			  var pairs=query.split("&");//   
			  for(var i=0;i<pairs.length;i++)   
			  {   
				  var pos=pairs[i].indexOf('=');//name=value   
				  if(pos==-1) continue;//   
				  var argname=pairs[i].substring(0,pos);//name   
				  var value=pairs[i].substring(pos+1);//value   
				  args[argname]=unescape(value);//   
			  }
			  return args;
			},
			/**
			 * :conversationid
			 * @return conversationid
			 */
			getConversationID:function(){
				return waf.conversationid;
			},
			/**
			 * conversationid
			 * @param value of String conversation id
			 */
			setConversationID:function(value){
				waf.conversationid=value;
			},
			/**
			 * :document.location.hrefdocument.location.replace
			 * @param url url
			 */
			redirect:function(url,caption) {
				var newUrl=url;

				var conversationID=waf.getConversationID();
				if(url.indexOf("conversationid")<0 && conversationID!=null){
					newUrl=newUrl + "&conversationid=" + conversationID;
				}

				document.location.replace(newUrl);
			},
			/**
			 * :
			 */
			 getContext:function() {
			 	if(waf.context==null){
			 		waf.context={AIS:null,currentUser:null,currentCallerID:null,currentUserName:null,currentCompanyID:null,currentCompanyName:null,currentCompany:null,contextID:null,locale:null,readAIS:null,solution:null};
			 	}
			 	return waf.context;
			 },
			 /**
			  * :
			  */
			 createContext:function(contextID,AIS,currentCallID,currentUserName,locale,unknow,local2,readAIS,solution,companyID,companyName) {
			 	waf.getContext().contextID=contextID;
			 	waf.getContext().AIS=AIS;
			 	waf.getContext().currentCallID=currentCallID;
			 	waf.getContext().currentUserName=currentUserName;
			 	waf.getContext().currentUser={id:currentCallID,name:currentUserName};
			 	waf.getContext().currentCompanyID=companyID;
			 	waf.getContext().currentCompanyName=companyName;
			 	waf.getContext().currentCompany={id:companyID,name:companyName};
			 	waf.getContext().locale=locale;
			 	waf.getContext().readAIS=readAIS;
			 	waf.getContext().solution=solution;
			 },
			/**
			 * :json
			 */
			isMultiLangValue:function(json){
                if(!json || json == null) return false;
				if(json.l1!==undefined && json.l2!==undefined && json.l3!==undefined){
					return true;
				}
				if(json.L1!==undefined && json.L2!==undefined && json.L3!==undefined){
					return true;
				}
				return false;
			},
			/**
			 * :json
			 */
			isEnumValue:function(json){
                if(!json || json == null) return false;
				if(json.isenum!==undefined && json.alias!==undefined && json.value!==undefined){
					return true;
				}
				return false;
			},
			/**
			 * :JS
			 * @param url js  
			 */
			loadJSLibrary : function(url) {
				waf.getScript(url);
			},
			/**
			 * aop--
			 * @param target 
			 * @param method 
			 * @param advice 
			 */
			aspectBefore:function(target,method, advice){
				waf.aop.before({target:target,method:method.toString()},advice);
			},
			/**
			 *  aop--
			 * @param target 
			 * @param method 
			 * @param advice 
			 */
			aspectAfter:function(target,method,advice){
				waf.aop.after({target:target,method:method.toString()},advice);
			},
			/**
			 *  aop--
			 * @param target 
			 * @param method 
			 * @param advice 
			 */
			aspectAround:function(target,method,advice){
				waf.aop.around({target:target,method:method.toString()},advice);
			},
			/**
			 * :JS
			 * @param method 
			 * @param clazz  JS
			 * @param obj	 
			 */
			proxyCall:function(methodName,objectName){
				var fun=null;
				if(objectName==null){
					objectName="jsBinder";
				}
				if( typeof(methodName)=="object") {
					fun=methodName;
				}
				else {
					if(typeof(objectName)=="object"){
						//fun=eval(objectName.GetName() + "." + methodName);
					}
					else {
						fun=eval(objectName + "." + methodName);
					}
				}
				
				var paramArray=[];
				if(arguments.length>2) {
					paramArray=new Array();
					for(var nIndex=2;nIndex<arguments.length;nIndex++) {
						paramArray.push(arguments[nIndex]);
					}
				}
				fun.apply(jsBinder,paramArray);
			},
			/**
			 * ajax
			 * @param uiItems 
			 */
			updateAjaxUIComponent:function(uiItems) {
				try{
					for (var index in uiItems) {
						var uiItem=uiItems[index];
						var cmpType,cmpID,cmpStatus,properties,events;
						cmpType=uiItem.componentType;
						cmpID=uiItem.componentID;
						cmpStatus=uiItem.status;
						if(cmpStatus=="update"){
							//
							properties=uiItem.properties;
							for(var pIndex in properties){
								var property=properties[pIndex];
								var funStr=null;
								if(typeof(property.value)=="string") {
									funStr="waf('#" + cmpID + "')." + cmpType + "('option','" + property.property + "','" + property.value + "')"
								}
								else {
									funStr="waf('#" + cmpID + "')." + cmpType + "('option','" + property.property + "'," + property.value + ")"
								}
								//
								eval(funStr);
							}

							//
							events=uiItem.events;
							for(var pIndex in events){
								var event=events[pIndex];
								var funStr=null;
								if(typeof(event.value)=="string") {
									funStr="waf('#" + cmpID + "')." + cmpType + "('option','" + event.event + "','" + event.value + "')"
								}
								else {
									funStr="waf('#" + cmpID + "')." + cmpType + "('option','" + event.event + "'," + event.value + ")"
								}
								//
								eval(funStr);
							}
						}
					}
				}
				catch(exception){
					alert(exception);
				} 
			},
			/**
			 * ajax
			 */
			executeAjaxScript:function(wafScript){
				if(wafScript.scriptType=="javascript"){
					eval(wafScript.script);
				}
			},
			/**
			 * 
			 * @param {} option
			 * @return {}
			 */
			invokeService:function(options) {
				options.url=waf.getContextPath() + "/service.do?method=invokeService";
				options.data={service:options.service,serviceMethod:options.serviceMethod,parameters:waf.toJSONString(options.parameters)};
				var urlParam=waf.getUrlParams();
				if(urlParam.mock=="true") {
					if(options.mockdata!=null) {
						options.success(eval("_self.mockdata." + options.mockdata));
						return null;
					}
				}
				
				waf.doPost(options);
			},
			/**
			 *  ajax post
			 * @param option ajaxoption
			 */
			doPost : function(option) {
				//URL
				if(option.url==null){
					if(option.param!=null) {
						option.url="?method=" + option.action + "&" + option.param;
					}
					else {
						option.url="?method=" + option.action;
					}
				}
				
				//conversation id
				//option.url= option.url + "&conversationid=" + waf.getConversationID();

				//json
				if(option.dataType==null){
					option.dataType="json"
				}
				
				//ajaxTimeout
				if(option.timeout==null) {
					option.timeout=this.ajaxTimeout;
				}

				//
				if(option.async==null){
					option.async=true;
				}

				//
				if(option.showBlock==null){
					option.showBlock=true;
				}
				
				var timer=null;
				var requestOption={
					url:option.url,
					data:option.data,
					/* ajaxjson */
					dataType:option.dataType,
					type:'POST',
					async:option.async,
					timeout:option.timeout,
					success:function(obj,textStatus){
						//BODY
                        if(option.showBlock==true){
                        	clearTimeout(timer);
							waf.block.hide();
						}
						if(obj==null){
							option.success(null);
							return ;
						}
						if(obj.result=="success") {
							if(option.success!=null) {
								//
								if(obj.isAutoExecuteUpdateUIItem==true && (obj.uiItems!=undefined || obj.uiItems!=null)){
									waf.updateAjaxUIComponent(obj.uiItems);
								}

								//ajax
								if(obj.isAutoExecuteScript==true && (obj.script!=undefined || obj.script!=null)){
									waf.executeAjaxScript(obj.script);
								}

								//
								option.success(obj.data,obj.uiItems,obj.script);
							}
						}
						else if(obj.result=="error") {
							if(option.error!=null){
								option.error(obj.summary,obj.detailInfo)
							}
							else {
								waf.msgBox.showError({ 		
								        	summaryMsg:obj.summary,
                                            detailMsg:obj.detailInfo
								});
							}
						}
					},
					error:function(response, textStatus, errorThrown) {
						//BODY
                        if(option.showBlock==true){
                        	clearTimeout(timer);
							waf.block.hide();
						}
						if(textStatus != "abort"){
							//todo:alert(":");
							var nExMsgStartIdx=response.responseText.indexOf("<title>");
							var nExMsgEndIdx=response.responseText.indexOf("</title>");
							var strErrorSummary=response.responseText.substr(nExMsgStartIdx+7,nExMsgEndIdx-nExMsgStartIdx-7);
							
							if(option.error!=null){
								option.error(response,strErrorSummary,errorThrown);
								return ;
							}
							
							if(response.responseText.indexOf("WafBizException")>=0 || response.responseText.indexOf("EASBizException")>=0){
								waf.msgBox.showError({
									summaryMsg:strErrorSummary
								});
							}
							else {
								if(response.responseText.indexOf("waf error page flag")<=0 && response.responseText.indexOf("loginForm")>0){
									response.responseText="please login first!";
								}
								
								waf.msgBox.showError({
										   title:waf.localeResourceObj.ERROR_MSGBOX_TITLE,   		
										   summaryMsg:waf.localeResourceObj.ERROR_MSGBOX_SUMMARY,				
										   detailMsg:waf.localeResourceObj.ERROR_MSGBOX_DETAILMSG 		
								});
							}
						}
					},
                    complete:function(jqXHR, textStatus){
                        if(option.complete && waf.isFunction(option.complete)){
                            option.complete.call(this, jqXHR, textStatus);
                        }
                        //BODY
                        if(option.showBlock==true){
                        	clearTimeout(timer);
							waf.block.hide();
						}
                    }
				};
				
				//BODY
				if(option.showBlock==true){
					timer=setTimeout(function(){
						waf.block.show({text:waf.localeResourceObj.AJAX_ASYNC_BLOCK_INFO});
					},
					500);
				}
				return waf.ajax(requestOption);
			},
			/**
			 * ajax get
			 * @param option ajaxoption
			 */
			doGet : function(option) {
				//URL
				if(option.url==null){
					if(option.param!=null) {
						option.url="?method=" + option.action + "&" + option.param;
					}
					else {
						option.url="?method=" + option.action;
					}
				}
				
				//conversation id
				//option.url= option.url + "&conversationid=" + waf.getConversationID();
				
				//json
				if(option.dataType==null){
					option.dataType="json"
				}

				//ajaxTimeout
				if(option.timeout==null) {
					option.timeout=this.ajaxTimeout;
				}

				//
				if(option.async==null){
					option.async=true;
				}

				//
				if(option.showBlock==null){
					option.showBlock=true;
				}
				
				var timer=null;
				var requestOption={
					url:option.url,
                    data:option.data,
					/* ajaxjson */
					dataType:option.dataType,
					type:'get',
					timeout:option.timeout,
					async:option.async,
					success:function(obj,textStatus){
						if(obj==null){
							option.success(null);
							return ;
						}
						//BODY
                        if(option.showBlock==true){
                        	clearTimeout(timer);
							waf.block.hide();
						}
						if(obj.result=="success") {
							if(option.success!=null) {
								//
								if(obj.isAutoExecuteUpdateUIItem==true && (obj.uiItems!=undefined || obj.uiItems!=null)){
									waf.updateAjaxUIComponent(obj.uiItems);
								}

								//ajax
								if(obj.isAutoExecuteScript==true && (obj.script!=undefined || obj.script!=null)){
									waf.executeAjaxScript(obj.script);
								}

								//
								option.success(obj.data,obj.uiItems,obj.script);
							}
						}
						else if(obj.result=="error") {
							if(option.error!=null){
								option.error(obj.summary,obj.detailInfo)
							}
							else {
								waf.msgBox.showError({ 		
								        	summaryMsg:obj.summary,
                                            detailMsg:obj.detailInfo
								});
							}
						}
					},
					error:function(response, textStatus, errorThrown) {
						//BODY
                        if(option.showBlock==true){
                        	clearTimeout(timer);
							waf.block.hide();
						}
						if(textStatus != "abort"){
							//todo:alert(":");
							var nExMsgStartIdx=response.responseText.indexOf("<title>");
							var nExMsgEndIdx=response.responseText.indexOf("</title>");
							var strErrorSummary=response.responseText.substr(nExMsgStartIdx+7,nExMsgEndIdx-nExMsgStartIdx-7);
							
							if(option.error!=null){
								option.error(response,strErrorSummary,errorThrown);
								return ;
							}
							
							if(response.responseText.indexOf("WafBizException")>=0 || response.responseText.indexOf("EASBizException")>=0){
								waf.msgBox.showError({
									summaryMsg:strErrorSummary
								});
							}
							else {
								if(response.responseText.indexOf("waf error page flag")<=0 && response.responseText.indexOf("loginForm")>0){
									response.responseText="please login first!";
								}
								waf.msgBox.showError({
										   title:waf.localeResourceObj.ERROR_MSGBOX_TITLE,   		
										   summaryMsg:waf.localeResourceObj.ERROR_MSGBOX_SUMMARY,				
										   detailMsg:waf.localeResourceObj.ERROR_MSGBOX_DETAILMSG 		
								});
							}
						}
					},
                    complete:function(jqXHR, textStatus){
                        if(option.complete && waf.isFunction(option.complete)){
                            option.complete.call(this, jqXHR, textStatus);
                        }
                        //BODY
                        if(option.showBlock==true){
                        	clearTimeout(timer);
							waf.block.hide();
						}
                    }
				};
				 
				//BODY
				if(option.showBlock==true){
					timer=setTimeout(function(){
						waf.block.show({text:waf.localeResourceObj.AJAX_ASYNC_BLOCK_INFO});
					},
					500);
				}
				/*  */
				return waf.ajax(requestOption);
			},
			/**
			 * 
			 * @param option ajaxoption
			 */
			doSubmit : function(option) {
				//URL
				if(option.url==null){
					if(option.param!=null) {
						option.url="?method=" + option.action + "&" + option.param;
					}
					else {
						option.url="?method=" + option.action;
					}
				}

				//conversation id
				//option.url= option.url + "&conversationid=" + waf.getConversationID();

				//json
				if(option.dataType==null){
					option.dataType="json";
				}

				//ajaxTimeout
				if(option.timeout==null) {
					option.timeout=this.ajaxTimeout;
				}

				//form
				if(option.form==null){
					option.form="form";
				}

				//
				if(option.async==null){
					option.async=true;
				}
				
				//
				if(option.showBlock==null){
					option.showBlock=true;
				}
				
				var timer=null;
				var requestOption={
					url:option.url,
					data:option.data,
					/* ajaxjson */
					dataType:option.dataType,
					type:'POST',
					async:option.async,
					timeout:option.timeout,
					success:function(obj,textStatus){
						if(obj==null){
							option.success(null);
							return ;
						}
						//BODY
                        if(option.showBlock==true){
                        	clearTimeout(timer);
							waf.block.hide();
						}
						if(obj.result=="success") {
							if(option.success!=null) {
								//
								if(obj.isAutoExecuteUpdateUIItem==true && (obj.uiItems!=undefined || obj.uiItems!=null)){
									waf.updateAjaxUIComponent(obj.uiItems);
								}

								//ajax
								if(obj.isAutoExecuteScript==true && (obj.script!=undefined || obj.script!=null)){
									waf.executeAjaxScript(obj.script);
								}

								//
								option.success(obj.data,obj.uiItems,obj.script);
							}
						}
						else if(obj.result=="error") {
                            if(option.error!=null){
                                option.error(obj.summary,obj.detailInfo)
                            }
                            else {
                                waf.msgBox.showError({
                                    summaryMsg:obj.summary,
                                    detailMsg:obj.detailInfo
                                });
                            }
						}
					},
					error:function(response, textStatus, errorThrown) {
						//BODY
                        if(option.showBlock==true){
                        	clearTimeout(timer);
							waf.block.hide();
						}
						if(textStatus != "abort"){
							//todo:alert(":");
							var nExMsgStartIdx=response.responseText.indexOf("<title>");
							var nExMsgEndIdx=response.responseText.indexOf("</title>");
							var strErrorSummary=response.responseText.substr(nExMsgStartIdx+7,nExMsgEndIdx-nExMsgStartIdx-7);
							
							if(option.error!=null){
								option.error(response,strErrorSummary,errorThrown);
								return ;
							}
							
							if(response.responseText.indexOf("WafBizException")>=0 || response.responseText.indexOf("EASBizException")>=0){
								waf.msgBox.showError({
									summaryMsg:strErrorSummary
								});
							}
							else {
								if(response.responseText.indexOf("waf error page flag")<=0 && response.responseText.indexOf("loginForm")>0){
									response.responseText="please login first!";
								}
								waf.msgBox.showError({
										   title:waf.localeResourceObj.ERROR_MSGBOX_TITLE,   		
										   summaryMsg:waf.localeResourceObj.ERROR_MSGBOX_SUMMARY,				
										   detailMsg:waf.localeResourceObj.ERROR_MSGBOX_DETAILMSG 	
								});
							}
						}
					},
                    complete:function(jqXHR, textStatus){
                        if(option.complete && waf.isFunction(option.complete)){
                            option.complete.call(this, jqXHR, textStatus);
                        }
                        //BODY
                        if(option.showBlock==true){
                        	clearTimeout(timer);
							waf.block.hide();
						}
                    }
				};
				
				//BODY
				if(option.showBlock==true){
					timer=setTimeout(function(){
						waf.block.show({text:waf.localeResourceObj.AJAX_ASYNC_BLOCK_INFO});
					},
					500);
				}

				/* */
                $('#' + option.form).trigger("onSubmit");
				/*  */
				$('#' + option.form).ajaxSubmit(requestOption);
			},
			/**
			 * URL
			 * @param url url 
			 * @return url
			 */
			encodeURI: function(url){
				var f1=url.substring(0,url.indexOf("?"));
				if(f1=="")
					f1="?"
				var f2=url.substring(url.indexOf("?")+1);

				return encodeURI(f1) + encodeURIComponent(f2);
			},
			/**
			 * : URL
			 * @param part url /
			 * @return url 
			 */
			encodeURIComponent: function(part){
				var newPart=part.toString();
				newPart=newPart.replace("\\","\\\\");
				newPart=newPart.replace("\"","\\\"");
				newPart=newPart.replace("\'","\\\\");
				return encodeURIComponent(newPart);
			},
			/**
			 * : JSON
			 * @param jsonStr of String jsonStr
			 */
			toJSONObject : function(jsonStr){
				return waf.secureEvalJSON(jsonStr);
			},
			/**
			 * : 
			 * @param object of object js
			 * @return json
			 */
			toJSONString : function(object) {
				return waf.toJSON(object);
			},
			/**
			 * :URLJSON
			 * @param tourl url
			 * @return JSON 
			 */
			convertQueryStrToJson:function(tourl){
				if(!tourl)return null;
					var paramsArr=tourl.split('?')[1].split('&');    
				    var args={},argsStr=[],param,name,value;
				   	args['url']=encodeURIComponent(tourl.split('?')[0]); //url,"?"
				    for(var i=0;i<paramsArr.length;i++){
					   param=paramsArr[i].split('=');
					   name=param[0],value=param[1];
					   if(name=="")name="unkown";
					   if(typeof args[name]=="undefined"){ //
					    args[name]=value;
					   }else if(typeof args[name]=="string"){ //
					    args[name]=[args[name]];
					    args[name].push(value);
					   }else{ //
					    args[name].push(value);
					   }
				    }
				    var showArg=function(x){   //
				        if(typeof(x)=="string"&&!/\d+/.test(x)) return "'"+x+"'";   //
				        if(x instanceof Array) return "["+x+"]"; //
				        return x;   //
				    }
				    args.toString=function(){//json
				        for(var i in args) argsStr.push(i+':'+showArg(args[i]));
				        return '{'+argsStr.join(',')+'}';
				    }
				    
				    return args; //json
			},
			/**
			 * : conversation,httpconversation id
			 * @return 
			 */
			conversationProcess:function(){
					//
					waf("iframe").each(function(){
						var url=waf(this).attr("src");
						if(url!=null){
							url=waf.appendConversationToURL(url);
							waf(this).attr("src",url);
						}
					});
			},
			/**
			 * :conversationid
			 * @param dom attribute
			 * @return 
			 */
			appendConversationToAttr:function(attr){
				if(attr.value!=null){
					if(attr.value.indexOf("conversationid")<0){
						if(attr.value.indexOf("?")<0){
							attr.value=attr.value + "?";
						}
						attr.value = attr.value + "&conversationid=" + conversationid;
					}
				}
			},
			/**
			 * :conversationid
			 * @param url url
			 * @return 
			 */
			appendConversationToURL:function(url){
				if(waf.conversationid==null) 
					return url;
					
				if(url!=null){
					if(url.indexOf("conversationid")<0){
						if(url.indexOf("?")<0){
							url=url + "?";
							url=url + "conversationid=" + waf.getConversationID();
						}
						else {
							url = url + "&conversationid=" + waf.getConversationID();
						}
					}
				}
				return url;
			},
			/**
			 * 
			 * @return  :http://{domain}:{port}/{}
			 */
			getContextPath:function(){
				var href=window.location.href;
				var host=window.location.host;
				var origin=document.location.origin;
				var f1=href.substring(href.indexOf(host))
				var f2=f1.substring(f1.indexOf("/"));
				var root=f2.split("/");
				return "/" + root[1];
			},
			/**
			 * :
			 * @param {} url
			 */
			openModalDialog:function(url,arguments,parameter) {
				url=waf.appendConversationToURL(url);
				return window.showModalDialog(url,arguments,parameter);
			},
			/** 
			 * :
			 * @return 
			 */
			openNativeWindow:function(url,title,height,width,top,left,menubar,toolbar,scrollbars,resizable,location,status){
				//,
				var param="";

				//
				if(height==null) {
					height=600;
				} 
				param=param + "height=" + height + ",";

				if(width==null)
					width=800;
				param=param + "width=" + width + ",";

				if(top==null)
					top=(window.screen.availHeight-30-height)/2 + ","; 
				param=param + "top=" + top + ",";

				if(left==null)
					left=(window.screen.availWidth-30-width)/2 + ",";
				param=param + "left=" + left + ",";

				if(toolbar==null)
					toolbar="no";
				param=param + "toolbar=" + toolbar + ",";

				if(menubar==null)
					menubar="no";
				param=param + "menubar=" + menubar + ","

				if(scrollbars==null)
					scrollbars="no";
				param=param + "scrollbars=" + scrollbars + ",";

				if(resizable==null)
					resizable="no";
				param=param + "resizable=" + resizable + ",";

				if(location==null)
					location="no";
				param=param + "location=" + location + ",";

				if(status==null)
					status="no";
				param=param + "status=" + status + ",";
				
				//conversationid
				if(url.indexOf("conversationid")<0) {
					if(url.indexOf("?")<0) {
						url = url + "?";
					}
					url = url + "&conversationid=" + waf.getConversationID();
				}

				window.open (url, null,param);	
			},
			/*
			 * 
			 */
			getCmpType:function(ctrlrole) {
	            if ("linkButton" === ctrlrole) {
	                return "wafLinkButton";
	            } else if ("autoComplete" === ctrlrole) {
	                return "autocomplete";
	            } else if ("checkbox" === ctrlrole) {
	                return "wafCheckbox";
	            } else if ("datePicker" === ctrlrole) {
	                return "datepicker";
	            } else if ("promptBox" === ctrlrole) {
	                return "wafPromptBox";
	            } else if ("form" === ctrlrole) {
	                return "wafForm";
	            } else if ("grid" === ctrlrole || "editGrid" === ctrlrole) {
	                return "wafGrid";
	            } else if ("labelContainer" === ctrlrole) {
	                return "labelContainer";
	            } else if ("menuButton" === ctrlrole) {
	                return "wafMenuButton";
	            } else if ("menuItem" === ctrlrole) {
	                return "wafMenuItem";
	            } else if ("msgArea" === ctrlrole) {
	                return "wafMsgArea";
	            } else if ("multiLangArea" === ctrlrole) {
	                return "wafMultiLangArea";
	            } else if ("multiLangBox" === ctrlrole) {
	                return "wafMultiLangBox";
	            } else if ("numberField" === ctrlrole) {
	                return "wafNumberField";
	            } else if ("password" === ctrlrole) {
	                return "wafPassword";
	            } else if ("progressBar" === ctrlrole) {
	                return "wafProgressBar";
	            } else if ("radio" === ctrlrole) {
	                return "wafRadio";
	            } else if ("section" === ctrlrole) {
	                return "wafSection";
	            } else if ("select" === ctrlrole) {
	                return "wafSelect";
	            } else if ("text" === ctrlrole) {
	                return "wafText";
	            } else if ("textarea" === ctrlrole) {
	                return "wafTextarea";
	            } else if ("toolBar" === ctrlrole) {
	                return "wafToolBar";
	            } else if ("tree" === ctrlrole) {
	                return "wafTree";
	            } else if ("columnLayout" === ctrlrole) {
	                return "wafColumnLayout";
	            } else if ("column" === ctrlrole) {
	                return "wafColumn";
	            } else if ("radioGroup" === ctrlrole){
				    return "wafRadioGroup";
				}
	    	},
            formatNumber: function(number, precision){
                if(typeof number === "undefined" || number === null  ) return "";

                if(isNaN( parseFloat(number)) || !isFinite(number)){
                    throw new Error(number+" is not a number.");
                }

                var result = number + "";

                if(typeof precision === "undefined" || precision === null  ) return result;

                if(isNaN( parseInt(precision)) || !isFinite(precision)){
                    throw new Error(precision+" is not a number.");
                }

                precision = parseInt(precision);
                if(precision < 0){
                    precision = 0;
                }

                if(result.indexOf(".") == -1){
                    if(precision === 0) return result;
                    result += ".";
                    for(var i = 0; i < precision; i++){
                        result += "0";
                    }
                }else{
                    var arr = result.split(".");

                    var offset = precision - arr[1].length;
                    if(offset > 0){ //
                        for(var j = 0; j < offset; j++){
                            result += "0";
                        }
                    }else{ //
                        result = arr[0] + (precision === 0? "" : ".");
                        for(var j = 0; j < precision; j++){
                            result += arr[1][j];
                        }
                    }

                }


                return result;
            },
            
        /**
         * :
         */
        isInFramePage:function () {
            if(window.parent.jsBinder){
                return window.parent.jsBinder.isInFramePage;
            }else if(window.top.jsBinder){
                return window.top.jsBinder.isInFramePage;
            }
            return false;
        },   
        /**
         * :wafpageiframe
         */
        addPageTab:function (options) {
            if(window.top.jsBinder){
                window.top.jsBinder.addPageTab(options);
                return;
            }

            if(window.parent.jsBinder){
                window.parent.jsBinder.addPageTab(options);
                return;
            }
        },
        /**
         * :wafpageiframe
         */
        removePageTab:function (tabpk) {
            if(window.top.jsBinder){
                window.top.jsBinder.removePageTab(tabpk);
                return;
            }

            if(window.parent.jsBinder){
                window.parent.jsBinder.removePageTab(tabpk);
                return;
            }
        },
        /**
         * :iframe
         */
        closeCurPageTab:function () {
            if(window.top.jsBinder){
                window.top.jsBinder.closeCurPageTab();
                return;
            }

            if(window.parent.jsBinder){
                window.parent.jsBinder.closeCurPageTab();
                return;
            }
        }
});
(function ($) {
    $.type = $.type || {};
    $.extend($.type, {
        isBoolean:function (o) {
            return typeof o === 'boolean';
        },
        isObject:function (o) {
            return (o && (typeof o === 'object' || $.isFunction(o))) || false;
        },
        isString:function (o) {
            return typeof o === 'string';
        },
        isNumber:function (o) {
            return typeof o === 'number' && isFinite(o);
        },
        isNull:function (o) {
            return o === null;
        },
        isUndefined:function (o) {
            return typeof o === 'undefined';
        },
        isValue:function (o) {
            return (this.isObject(o) || this.isString(o) || this.isNumber(o) || this.isBoolean(o));
        },
        isEmpty:function (o) {
            if (!this.isString(o) && this.isValue(o)) {
                return false;
            } else if (!this.isValue(o)) {
                return true;
            }
            o = $.trim(o).replace(/\&nbsp\;/ig, '').replace(/\&#160\;/ig, '');
            return o === "";
        },
        isJson:function (o) {
            var isJson = typeof(o) == "object" && Object.prototype.toString.call(o).toLowerCase() == "[object object]" && !o.length;
            return isJson;
        },
        isEquals:function (x, y) {
            var seen = [];

            return (function equals(x, y) {
                // If both x and y are null or undefined and exactly the same
                if (x === y) {
                    return true;
                }

                // If they are not strictly equal, they both need to be Objects
                if (!( x instanceof Object ) || !( y instanceof Object )) {
                    return false;
                }

                // They must have the exact same prototype chain, the closest we can do is
                // test the constructor.
                if (x.constructor !== y.constructor) {
                    return false;
                }

                for (var p in x) {
                    // Inherited properties were tested using x.constructor === y.constructor
                    if (x.hasOwnProperty(p)) {
                        // Allows comparing x[ p ] and y[ p ] when set to undefined
                        if (!y.hasOwnProperty(p)) {
                            return false;
                        }

                        // If they have the same strict value or identity then they are equal
                        if (x[ p ] === y[ p ]) {
                            continue;
                        }

                        // Numbers, Strings, Functions, Booleans must be strictly equal
                        if (typeof( x[ p ] ) !== "object") {
                            return false;
                        }

                        // Test cyclicality                        
                        if ($.inArray(x[ p ], seen) >= 0) {
                            throw new Error("Cannot compare some cyclical objects");
                        }
                        seen.push(x[ p ]);

                        // Objects and Arrays must be tested recursively
                        if (!equals(x[ p ], y[ p ])) {
                            return false;
                        }
                    }
                }

                for (p in y) {
                    // allows x[ p ] to be set to undefined
                    if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) {
                        return false;
                    }
                }
                return true;
            })(x, y);
        }
    });


    $.colorutil = $.colorutil || {};

    $.extend($.colorutil, {
        rgbToHex:function (rgbString) {
            var parts = rgbString.match(/^rgba\((\d+),\s*(\d+),\s*(\d+),(\d+)\)$/);

            delete (parts[0]);
            for (var i = 1; i <= 3; ++i) {
                parts[i] = parseInt(parts[i]).toString(16);
                if (parts[i].length == 1) parts[i] = '0' + parts[i];
            }
            return '#' + parts.join('').toUpperCase(); // "#0070FF"
        }
    });


    $.keyutil = $.keyutil || {};
    $.extend($.keyutil, {
        getKeyCodeArr:function(){
            var arr = [];
            for(var p in $.ui.keyCode){
                arr.push($.ui.keyCode[p]);
            }
            return arr;
        }
    });

    $.wafutil = $.wafutil || {};
    $.extend($.wafutil, {
        scrollWid:undefined,
        getMultiValue:function (value) {
            if (typeof value === "object") {
                if (waf.isMultiLangValue && waf.isMultiLangValue(value)) {
                    var local = "l2" || (waf.getContext().locale ? waf.getContext().locale : "l2");
                    return value[local]
                } else {
                    return value;
                }
            } else {
                return value;
            }
        },
        getValueByPath:function (data, path) {
            var paths = path.split("."),
                current = data;
            for (var i = 0, length = paths.length; i < length; i++) {
                if (i == length - 1) {
                    return current[paths[i]];
                } else {
                    if (current[paths[i]] == null) {
                        return null;
                    }
                    current = current[paths[i]];
                }
            }
            return null;
        },
        replaceSpecialChar:function (str, dest) {
            return String(str).replace(/[!"#$%&'()*+,.\/:;<=>?@\[\\\]\^`{|}~]/g, dest);
        },
        isViewOperateState: function(opts) {
            if(opts && opts["operateState"]) {
                if(opts["operateState"].toUpperCase() === "view".toUpperCase()) {
                    return true;
                } else if(opts["operateState"].toUpperCase() === "edit".toUpperCase()) {
                    return false;
                }
            }
            var params = waf.getUrlParams();
            return params && params["operateState"] && (params["operateState"].toUpperCase() == "view".toUpperCase());
        },
        getViewDisplayType: function(opts) {
            var viewDisplayType = "wordonly";
            if(opts && opts["viewDisplayType"]) {
                viewDisplayType = opts["viewDisplayType"];
            } else {
                var params = waf.getUrlParams();
                if(params && params["viewDisplayType"]) {
                    viewDisplayType = params["viewDisplayType"];
                }
            }
            return viewDisplayType;
        },
        htmlDecode:function (value) {
            if (value && (value == '&nbsp;' || value == '&#160;' || (value.length === 1 && value.charCodeAt(0) === 160))) {
                return "";
            }
            return !value ? value : String(value).replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&quot;/g, '"').replace(/&amp;/g, "&").replace(/&#39;/g, "'");
        },
        htmlEncode:function (value) {
            return !value ? value : String(value).replace(/&/g, "&amp;").replace(/\"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\'/g, "&#39;");
        },
        getVerticalScrollBarWidth:function () {
            if ($.wafutil.scrollWid === undefined) {
                var scrollBarHelper = document.createElement("div");
                // if MSIE
                // scroll bar100px
                scrollBarHelper.style.cssText = "overflow:scroll;width:100px;height:100px;";
                // else OTHER Browsers:
                // scrollBarHelper.style.cssText = "overflow:scroll;";
                document.body.appendChild(scrollBarHelper);
                if (scrollBarHelper) {
                    $.wafutil.scrollWid = {
                        horizontal:scrollBarHelper.offsetHeight - scrollBarHelper.clientHeight,
                        vertical:scrollBarHelper.offsetWidth - scrollBarHelper.clientWidth
                    }
                }
                document.body.removeChild(scrollBarHelper);
            }
            return $.wafutil.scrollWid.vertical;
        },
        getHorizontalScrollBarHeight:function () {
            if ($.wafutil.scrollWid === undefined) {
                var scrollBarHelper = document.createElement("div");
                // if MSIE
                // scroll bar100px
                scrollBarHelper.style.cssText = "overflow:scroll;width:100px;height:100px;";
                // else OTHER Browsers:
                // scrollBarHelper.style.cssText = "overflow:scroll;";
                document.body.appendChild(scrollBarHelper);
                if (scrollBarHelper) {
                    $.wafutil.scrollWid = {
                        horizontal:scrollBarHelper.offsetHeight - scrollBarHelper.clientHeight,
                        vertical:scrollBarHelper.offsetWidth - scrollBarHelper.clientWidth
                    }
                }
                document.body.removeChild(scrollBarHelper);
            }
            return $.wafutil.scrollWid.horizontal;
        },
        replaceAll:function(str,source,target){
            if(str){
                while(str.indexOf(source)>-1){
                    str = str.replace(source,target);
                }
            }
            return str;
        },
        format:function (format) {
            var args = $.makeArray(arguments).slice(1);
            if (format === undefined) {
                format = "";
            }
            return format.replace(/\{(\d+)\}/g, function (m, i) {
                return args[i];
            });
        },
        compatibleWithOnchange:function(){
            waf.aspectAfter($.Widget,"_createWidget",function(){
                if(this.options.onchange && this.options.value!=undefined){
                    var value = this.options.value;
                    if(this.element.attr("ctrlrole") === "numberField"){
                        value = $.wafNumberField.format(this.options.value,this.options);
                    }
                    this._trigger("onchange", "onchange", {"previous":null, "current":value})
                }
            });
            waf.aspectAfter($.datepicker,"_attachDatepicker",function(target){
                var inst = target;
                var onChange = $.datepicker._get(inst, 'onchange')
                if(onChange){
                    onChange.apply((inst.input ? inst.input[0] : null), [{"previous" : null, "current" : inst.defaultValue}, inst])
                }
            });
        },
        disableAll:function(){
            waf("input.ui-numberfield").wafNumberField("disable");
            waf("input.ui-text").wafText("disable");
            waf("textarea.ui-multiLangArea-input").wafMultiLangArea("disable");
            waf("input.ui-multiLangBox-input").wafMultiLangBox("disable");
            waf("div.ui-radiogroup-div").wafRadioGroup("disable");
            waf("input.ui-wafcheckbox").wafCheckbox("disable");
            waf("input.ui-radio").wafRadio("disable");
            waf("select.ui-select").wafSelect("disable");
            waf("input.hasDatepicker").wafDatePicker("disable");
            waf("input.ui-f7").wafPromptBox("disable");
            waf("input.ui-timepicker").wafTimePicker("disable");
            waf("textarea.ui-textarea").wafTextarea("disable");
            waf("table.ui-jqgrid-btable").wafGrid("option","editable",false);
        },
        clear:function(arr){
            arr.length = 0;
        },
        insertAt:function(arr,index,obj){
            arr.splice(index,0,obj);
        },
        removeAt:function(arr,index){
            arr.splice(index,1);
        },
        remove:function(arr,obj){
            var index=$.inArray(obj,arr);
            if (index>=0){
                $.wafutil.removeAt(arr,index);
            }
        },
        namedItem:function(arr,value,prop){
            //arrhtml 
            prop = prop || "id";
            if(arr.length>0){
                var len = arr.length,elem;
                for(var i=0;i<len;i++){
                    if($(arr[i]).attr(prop) == value){
                        return arr[i];
                    }
                }
            }
        },
        parseDate:function (format, date) {
            var tsp = {m:1, d:1, y:1970, h:0, i:0, s:0, u:0}, k, hl, dM, regdate = /[\\\/:_;.,\t\T\s-]/;
            if (date && date !== null && date !== undefined) {
                date = $.trim(date);
                date = date.split(regdate);
                if ($.jgrid.formatter.date.masks[format] !== undefined) {
                    format = $.jgrid.formatter.date.masks[format];
                }
                format = format.split(regdate);
                var dfmt = $.jgrid.formatter.date.monthNames;
                var afmt = $.jgrid.formatter.date.AmPm;
                var h12to24 = function (ampm, h) {
                    if (ampm === 0) {
                        if (h === 12) {
                            h = 0;
                        }
                    }
                    else {
                        if (h !== 12) {
                            h += 12;
                        }
                    }
                    return h;
                };
                for (k = 0, hl = format.length; k < hl; k++) {
                    if (format[k] == 'M') {
                        dM = $.inArray(date[k], dfmt);
                        if (dM !== -1 && dM < 12) {
                            date[k] = dM + 1;
                            tsp.m = date[k];
                        }
                    }
                    if (format[k] == 'F') {
                        dM = $.inArray(date[k], dfmt);
                        if (dM !== -1 && dM > 11) {
                            date[k] = dM + 1 - 12;
                            tsp.m = date[k];
                        }
                    }
                    if (format[k] == 'a') {
                        dM = $.inArray(date[k], afmt);
                        if (dM !== -1 && dM < 2 && date[k] == afmt[dM]) {
                            date[k] = dM;
                            tsp.h = h12to24(date[k], tsp.h);
                        }
                    }
                    if (format[k] == 'A') {
                        dM = $.inArray(date[k], afmt);
                        if (dM !== -1 && dM > 1 && date[k] == afmt[dM]) {
                            date[k] = dM - 2;
                            tsp.h = h12to24(date[k], tsp.h);
                        }
                    }
                    if (date[k] !== undefined) {
                        tsp[format[k].toLowerCase()] = parseInt(date[k], 10);
                    }
                }
                tsp.m = parseInt(tsp.m, 10) - 1;
                var ty = tsp.y;
                if (ty >= 70 && ty <= 99) {
                    tsp.y = 1900 + tsp.y;
                }
                else if (ty >= 0 && ty <= 69) {
                    tsp.y = 2000 + tsp.y;
                }
                if (tsp.j !== undefined) {
                    tsp.d = tsp.j;
                }
                if (tsp.n !== undefined) {
                    tsp.m = parseInt(tsp.n, 10) - 1;
                }
            }
            return new Date(tsp.y, tsp.m, tsp.d, tsp.h, tsp.i, tsp.s, tsp.u);
        },
        //createor.name
        getAccessor:function (obj, expr) {
            var ret, p, prm = [], i;
            if (typeof expr === 'function') {
                return expr(obj);
            }
            ret = obj[expr];
            if (ret === undefined) {
                try {
                    if (typeof expr === 'string') {
                        prm = expr.split('.');
                    }
                    i = prm.length;
                    if (i) {
                        ret = obj;
                        while (ret && i--) {
                            p = prm.shift();
                            ret = ret[p];
                        }
                    }
                } catch (e) {
                }
            }
            if (typeof ret === "function") {
                return ret;
            } else {
                return $.wafutil.getMultiValue(ret); //modiby by jlg.
            }

        },
        getTemplateEngine:function(engine){
            return new TemplateEngine(engine||"Hogan");
        },
        getQueryObject:function(source){
            return new QueryObject(source, null);
        },
        getLazyOption:function(id){
            var option;
            if(window._serverOptions_ && id && $.isArray(window._serverOptions_)){
                var op = jlinq.from(window._serverOptions_).equals("id",id).select();
                option =  $.extend(true,{},op&&op[0]&&op[0].option?op[0].option:{});
                if(!!window.debug && op.length>0){
                    $.log.lazyLog({type:op[0].type,id:op[0].id});
                }
            }
            return option || {};
        },
        initLazyOptions:function(){
            //all_options
            var op = $("#all_options");
            if(op.length){eval(op.html());}
            if(window._serverOptions_){
                //all_dataBinders
                op = $("#all_dataBinders");
                if(op.length){eval(op.html());}
                //bind linkbutton
                $("body").undelegate(".ui-linkbutton","click");
                $("body").delegate(".ui-linkbutton","click",function(e){
                    if(!$(e.target).data("wafLinkButton")){
                        var lb = $(e.target);
                        if($(e.target).hasClass("ui-lb-text")){
                            lb = $(e.target).closest(".ui-linkbutton");
                        }
                        var op = $.wafutil.getLazyOption(lb.attr("id"));
                        $(lb).wafLinkButton(op);
                        $(lb).trigger("click");
                    }
                });
                //execute eage component
                op = $("#all_imm_option");
                if(op.length){
                    eval(op.html());
                    var len = (window.immediate_option&&window.immediate_option.length) || 0,tmp,initFun,component;
                    for(var i=0;i<len;i++){
                        tmp = window.immediate_option[i];
                        if(tmp&&tmp.id&&tmp.id!=""){
                            component = waf.wafPageComponentLib.get(tmp.type);
                            initFun = component.initFun;
                            initFun&&initFun(tmp.option, $("#"+tmp.id));
                        }
                    }
                }
            }

        }
    });


    $.fn.handleFunction = function (eventName, eventFunction) {
        var tag = $(this);
        tag.unbind(eventName);
        if (eventFunction && eventFunction != null) {
            if ($.isFunction(eventFunction)) {
                tag.bind(eventName, eventFunction);
            } else if (typeof eventFunction === "string") {
                if (eventFunction.indexOf("(") > -1) {
                    tag.bind(eventName, function () {
                        return eval(eventFunction);
                    });
                } else {
                    var fun = eval(eventFunction);
                    if ($.isFunction(fun)) {
                        tag.bind(eventName, fun);
                    }
                }
            }
        }
    }

    jQuery.fn.outerHTML = function () {
        return $("<div></div>").append(this.eq(0).clone()).html();
    };

    $.browserUtil = $.browserUtil || {};
    $.extend($.browserUtil,{
        getIEVersion:function(){
            var ie = /MSIE (\d+)/.exec(navigator.userAgent);
            if(ie&&ie!=null&&$.isArray(ie)){
                return ie[1];
            }
        },
        userBrowser:function () {
            var browserName = navigator.userAgent.toLowerCase();
            if (/msie/i.test(browserName) && !/opera/.test(browserName)) {
                return "ie";
            } else if (/firefox/i.test(browserName)) {
                return "firefox";
            } else if (/chrome/i.test(browserName) && /webkit/i.test(browserName) && /mozilla/i.test(browserName)) {
                return "chrome";
            } else if (/opera/i.test(browserName)) {
                return "opera";
            } else if (/webkit/i.test(browserName) && !(/chrome/i.test(browserName) && /webkit/i.test(browserName) && /mozilla/i.test(browserName))) {
                return "webkit";
            } else {
                return "unknow";
            }
        }
    });

    $.ieHack = $.ieHack || {};
    $.ieHack.resizeFunctions = [];
    var widthVar = "resize$Width",
        heightVar = "resize$Height";
    $.extend($.ieHack, {
        //ieresize
        hackResize:function (srcFun, elem) {
            $.ieHack.resizeFunctions.push(srcFun);
        },
        resize:function(){
            var elem = $("body");
            var winNewWidth = $(window).width(), winNewHeight = $(window).height(), resizeTimeout;
            var win$Width = elem.data(widthVar) || -1, win$Height = elem.data(heightVar) || -1;
            if (win$Width != winNewWidth || win$Height != winNewHeight) {
                window.clearTimeout(resizeTimeout);
                resizeTimeout = window.setTimeout(function(){
                    if($.ieHack.resizeFunctions.length>0){
                        for(var i=0;i<$.ieHack.resizeFunctions.length;i++){
                            $.ieHack.resizeFunctions[i].call(elem);
                        }
                    }
                }, 10);
            }
            //Update the width and height
            $(elem).data(widthVar, winNewWidth);
            $(elem).data(heightVar, winNewHeight);
        }
    });

    $.defineCustomeClass = function (subClassName, superClass, prototype) {
        var clzPath = subClassName.substr(0, subClassName.lastIndexOf('.'));
        var ns = Namespace.register(clzPath);
        var h = prototype.hasOwnProperty("constructor"), str;

        if (h) {
            str = subClassName + "=" + prototype.constructor.toString() + ";"
        } else {
            if (superClass != null) {
                str = subClassName + "=" + superClass.prototype.constructor.toString() + ";"
            } else {
                str = subClassName + "=function(){};";
            }
        }

        var subClass = eval(str);
        waf.inherit(subClass, superClass);

        for (var p in prototype) {
            eval(subClassName + ".prototype." + p.toString() + "=prototype." + p.toString());
        }
    };


    var QueryObject = (function(){
        function QueryObject(d, q) {
            if (typeof(d) == "string") {
                d = $.data(d);
            }
            var self = this,
                _data = d,
                _usecase = true,
                _trim = false,
                _query = q,
                _stripNum = /[\$,%]/g,
                _lastCommand = null,
                _lastField = null,
                _orDepth = 0,
                _negate = false,
                _queuedOperator = "",
                _sorting = [],
                _useProperties = true;
            if (typeof(d) == "object" && d.push) {
                if (d.length > 0) {
                    if (typeof(d[0]) != "object") {
                        _useProperties = false;
                    } else {
                        _useProperties = true;
                    }
                }
            } else {
                throw "data provides is not an array";
            }
            this._hasData = function () {
                return _data === null ? false : _data.length === 0 ? false : true;
            };
            this._getStr = function (s) {
                var phrase = [];
                if (_trim) {
                    phrase.push("jQuery.trim(");
                }
                phrase.push("String(" + s + ")");
                if (_trim) {
                    phrase.push(")");
                }
                if (!_usecase) {
                    phrase.push(".toLowerCase()");
                }
                return phrase.join("");
            };
            this._strComp = function (val) {
                if (typeof(val) == "string") {
                    return".toString()";
                } else {
                    return"";
                }
            };
            this._group = function (f, u) {
                return({field:f.toString(), unique:u, items:[]});
            };
            this._toStr = function (phrase) {
                if (_trim) {
                    phrase = $.trim(phrase);
                }
                phrase = phrase.toString().replace(/\\/g, '\\\\').replace(/\"/g, '\\"');
                return _usecase ? phrase : phrase.toLowerCase();
            };
            this._funcLoop = function (func) {
                var results = [];
                $.each(_data, function (i, v) {
                    results.push(func(v));
                });
                return results;
            };
            this._append = function (s) {
                var i;
                if (_query === null) {
                    _query = "";
                } else {
                    _query += _queuedOperator === "" ? " && " : _queuedOperator;
                }
                for (i = 0; i < _orDepth; i++) {
                    _query += "(";
                }
                if (_negate) {
                    _query += "!";
                }
                _query += "(" + s + ")";
                _negate = false;
                _queuedOperator = "";
                _orDepth = 0;
            };
            this._setCommand = function (f, c) {
                _lastCommand = f;
                _lastField = c;
            };
            this._resetNegate = function () {
                _negate = false;
            };
            this._repeatCommand = function (f, v) {
                if (_lastCommand === null) {
                    return self;
                }
                if (f !== null && v !== null) {
                    return _lastCommand(f, v);
                }
                if (_lastField === null) {
                    return _lastCommand(f);
                }
                if (!_useProperties) {
                    return _lastCommand(f);
                }
                return _lastCommand(_lastField, f);
            };
            this._equals = function (a, b) {
                return(self._compare(a, b, 1) === 0);
            };
            this._compare = function (a, b, d) {
                var toString = Object.prototype.toString;
                if (d === undefined) {
                    d = 1;
                }
                if (a === undefined) {
                    a = null;
                }
                if (b === undefined) {
                    b = null;
                }
                if (a === null && b === null) {
                    return 0;
                }
                if (a === null && b !== null) {
                    return 1;
                }
                if (a !== null && b === null) {
                    return -1;
                }
                if (toString.call(a) === '[object Date]' && toString.call(b) === '[object Date]') {
                    if (a < b) {
                        return -d;
                    }
                    if (a > b) {
                        return d;
                    }
                    return 0;
                }
                if (!_usecase && typeof(a) !== "number" && typeof(b) !== "number") {
                    a = String(a).toLowerCase();
                    b = String(b).toLowerCase();
                }
                if (a < b) {
                    return -d;
                }
                if (a > b) {
                    return d;
                }
                return 0;
            };
            this._performSort = function () {
                if (_sorting.length === 0) {
                    return;
                }
                _data = self._doSort(_data, 0);
            };
            this._doSort = function (d, q) {
                var by = _sorting[q].by,
                    dir = _sorting[q].dir,
                    type = _sorting[q].type,
                    dfmt = _sorting[q].datefmt;
                if (q == _sorting.length - 1) {
                    return self._getOrder(d, by, dir, type, dfmt);
                }
                q++;
                var values = self._getGroup(d, by, dir, type, dfmt);
                var results = [];
                for (var i = 0; i < values.length; i++) {
                    var sorted = self._doSort(values[i].items, q);
                    for (var j = 0; j < sorted.length; j++) {
                        results.push(sorted[j]);
                    }
                }
                return results;
            };
            this._getOrder = function (data, by, dir, type, dfmt) {
                var sortData = [], _sortData = [], newDir = dir == "a" ? 1 : -1, i, ab, j,
                    findSortKey;

                if (type === undefined) {
                    type = "text";
                }
                if (type == 'float' || type == 'number' || type == 'currency' || type == 'numeric') {
                    findSortKey = function ($cell) {
                        var key = parseFloat(String($cell).replace(_stripNum, ''));
                        return isNaN(key) ? 0.00 : key;
                    };
                } else if (type == 'int' || type == 'integer') {
                    findSortKey = function ($cell) {
                        return $cell ? parseFloat(String($cell).replace(_stripNum, '')) : 0;
                    };
                } else if (type == 'date' || type == 'datetime') {
                    findSortKey = function ($cell) {
                        return $.wafutil.parseDate(dfmt, $cell).getTime();
                    };
                } else if ($.isFunction(type)) {
                    findSortKey = type;
                } else {
                    findSortKey = function ($cell) {
                        if (!$cell) {
                            $cell = "";
                        }
                        return $.trim(String($cell).toUpperCase());
                    };
                }
                $.each(data, function (i, v) {
                    ab = by !== "" ? $.jgrid.getAccessor(v, by) : v;
                    if (ab === undefined) {
                        ab = "";
                    }
                    ab = findSortKey(ab, v);
                    _sortData.push({ 'vSort':ab, 'index':i});
                });

                _sortData.sort(function (a, b) {
                    a = a.vSort;
                    b = b.vSort;
                    return self._compare(a, b, newDir);
                });
                j = 0;
                var nrec = data.length;
                // overhead, but we do not change the original data.
                while (j < nrec) {
                    i = _sortData[j].index;
                    sortData.push(data[i]);
                    j++;
                }
                return sortData;
            };
            this._getGroup = function (data, by, dir, type, dfmt) {
                var results = [],
                    group = null,
                    last = null, val;
                $.each(self._getOrder(data, by, dir, type, dfmt), function (i, v) {
                    val = $.jgrid.getAccessor(v, by);
                    if (val === undefined) {
                        val = "";
                    }
                    if (!self._equals(last, val)) {
                        last = val;
                        if (group !== null) {
                            results.push(group);
                        }
                        group = self._group(by, val);
                    }
                    group.items.push(v);
                });
                if (group !== null) {
                    results.push(group);
                }
                return results;
            };
            this.ignoreCase = function () {
                _usecase = false;
                return self;
            };
            this.useCase = function () {
                _usecase = true;
                return self;
            };
            this.trim = function () {
                _trim = true;
                return self;
            };
            this.noTrim = function () {
                _trim = false;
                return self;
            };
            this.execute = function () {
                var match = _query, results = [];
                if (match === null) {
                    return self;
                }
                $.each(_data, function () {
                    if (eval(match)) {
                        results.push(this);
                    }
                });
                _data = results;
                return self;
            };
            this.data = function () {
                return _data;
            };
            this.select = function (f) {
                self._performSort();
                if (!self._hasData()) {
                    return[];
                }
                self.execute();
                if ($.isFunction(f)) {
                    var results = [];
                    $.each(_data, function (i, v) {
                        results.push(f(v));
                    });
                    return results;
                }
                return _data;
            };
            this.hasMatch = function () {
                if (!self._hasData()) {
                    return false;
                }
                self.execute();
                return _data.length > 0;
            };
            this.andNot = function (f, v, x) {
                _negate = !_negate;
                return self.and(f, v, x);
            };
            this.orNot = function (f, v, x) {
                _negate = !_negate;
                return self.or(f, v, x);
            };
            this.not = function (f, v, x) {
                return self.andNot(f, v, x);
            };
            this.and = function (f, v, x) {
                _queuedOperator = " && ";
                if (f === undefined) {
                    return self;
                }
                return self._repeatCommand(f, v, x);
            };
            this.or = function (f, v, x) {
                _queuedOperator = " || ";
                if (f === undefined) {
                    return self;
                }
                return self._repeatCommand(f, v, x);
            };
            this.orBegin = function () {
                _orDepth++;
                return self;
            };
            this.orEnd = function () {
                if (_query !== null) {
                    _query += ")";
                }
                return self;
            };
            this.isNot = function (f) {
                _negate = !_negate;
                return self.is(f);
            };
            this.is = function (f) {
                self._append('this.' + f);
                self._resetNegate();
                return self;
            };
            this._compareValues = function (func, f, v, how, t) {
                var fld;
                if (_useProperties) {
                    fld = 'jQuery.jgrid.getAccessor(this,\'' + f + '\')';
                } else {
                    fld = 'this';
                }
                if (v === undefined) {
                    v = null;
                }
                //var val=v===null?f:v,
                var val = v,
                    swst = t.stype === undefined ? "text" : t.stype;
                if (v !== null) {
                    switch (swst) {
                        case 'int':
                        case 'integer':
                            val = (isNaN(Number(val)) || val === "") ? '0' : val; // To be fixed with more inteligent code
                            fld = 'parseInt(' + fld + ',10)';
                            val = 'parseInt(' + val + ',10)';
                            break;
                        case 'float':
                        case 'number':
                        case 'numeric':
                            val = String(val).replace(_stripNum, '');
                            val = (isNaN(Number(val)) || val === "") ? '0' : val; // To be fixed with more inteligent code
                            fld = 'parseFloat(' + fld + ')';
                            val = 'parseFloat(' + val + ')';
                            break;
                        case 'date':
                        case 'datetime':
                            val = String($.jgrid.parseDate(t.newfmt || 'Y-m-d', val).getTime());
                            fld = 'jQuery.jgrid.parseDate("' + t.srcfmt + '",' + fld + ').getTime()';
                            break;
                        default :
                            fld = self._getStr(fld);
                            val = self._getStr('"' + self._toStr(val) + '"');
                    }
                }
                self._append(fld + ' ' + how + ' ' + val);
                self._setCommand(func, f);
                self._resetNegate();
                return self;
            };
            this.equals = function (f, v, t) {
                return self._compareValues(self.equals, f, v, "==", t);
            };
            this.notEquals = function (f, v, t) {
                return self._compareValues(self.equals, f, v, "!==", t);
            };
            this.isNull = function (f, v, t) {
                return self._compareValues(self.equals, f, null, "===", t);
            };
            this.greater = function (f, v, t) {
                return self._compareValues(self.greater, f, v, ">", t);
            };
            this.less = function (f, v, t) {
                return self._compareValues(self.less, f, v, "<", t);
            };
            this.greaterOrEquals = function (f, v, t) {
                return self._compareValues(self.greaterOrEquals, f, v, ">=", t);
            };
            this.lessOrEquals = function (f, v, t) {
                return self._compareValues(self.lessOrEquals, f, v, "<=", t);
            };
            this.startsWith = function (f, v) {
                var val = (v === undefined || v === null) ? f : v,
                    length = _trim ? $.trim(val.toString()).length : val.toString().length;
                if (_useProperties) {
                    self._append(self._getStr('jQuery.jgrid.getAccessor(this,\'' + f + '\')') + '.substr(0,' + length + ') == ' + self._getStr('"' + self._toStr(v) + '"'));
                } else {
                    length = _trim ? $.trim(v.toString()).length : v.toString().length;
                    self._append(self._getStr('this') + '.substr(0,' + length + ') == ' + self._getStr('"' + self._toStr(f) + '"'));
                }
                self._setCommand(self.startsWith, f);
                self._resetNegate();
                return self;
            };
            this.endsWith = function (f, v) {
                var val = (v === undefined || v === null) ? f : v,
                    length = _trim ? $.trim(val.toString()).length : val.toString().length;
                if (_useProperties) {
                    self._append(self._getStr('jQuery.jgrid.getAccessor(this,\'' + f + '\')') + '.substr(' + self._getStr('jQuery.jgrid.getAccessor(this,\'' + f + '\')') + '.length-' + length + ',' + length + ') == "' + self._toStr(v) + '"');
                } else {
                    self._append(self._getStr('this') + '.substr(' + self._getStr('this') + '.length-"' + self._toStr(f) + '".length,"' + self._toStr(f) + '".length) == "' + self._toStr(f) + '"');
                }
                self._setCommand(self.endsWith, f);
                self._resetNegate();
                return self;
            };
            this.contains = function (f, v) {
                if (_useProperties) {
                    self._append(self._getStr('jQuery.jgrid.getAccessor(this,\'' + f + '\')') + '.indexOf("' + self._toStr(v) + '",0) > -1');
                } else {
                    self._append(self._getStr('this') + '.indexOf("' + self._toStr(f) + '",0) > -1');
                }
                self._setCommand(self.contains, f);
                self._resetNegate();
                return self;
            };
            this.groupBy = function (by, dir, type, datefmt) {
                if (!self._hasData()) {
                    return null;
                }
                return self._getGroup(_data, by, dir, type, datefmt);
            };
            this.orderBy = function (by, dir, stype, dfmt) {
                dir = dir === undefined || dir === null ? "a" : $.trim(dir.toString().toLowerCase());
                if (stype === null || stype === undefined) {
                    stype = "text";
                }
                if (dfmt === null || dfmt === undefined) {
                    dfmt = "Y-m-d";
                }
                if (dir == "desc" || dir == "descending") {
                    dir = "d";
                }
                if (dir == "asc" || dir == "ascending") {
                    dir = "a";
                }
                _sorting.push({by:by, dir:dir, type:stype, datefmt:dfmt});
                return self;
            };
        }
        return QueryObject;
    })();

    var TemplateEngine = (function(){
        function TemplateEngine(engine){
            this.name = engine;
            this.engine = eval(engine);
        }
        $.extend(TemplateEngine.prototype,{
            compile:function(t){
                switch(this.name){
                    case "Hogan":
                        return Hogan.compile(t);
                }
            },
            render:function(cr,values){
                switch(this.name){
                    case "Hogan":
                        return cr.render(values);
                }
            }
        });
        return TemplateEngine;
    })();

    $.popup = $.popup || {};
    $.extend($.popup,{
        showRemind:function(target,msg){
            $(target).powerFloat({
                targetMode: "remind",
                eventType: "none",
                target:msg,
                zIndex:$(target).zIndex()+10,
                position:'1-4',
                offsets: {x:20,y:0}
            });
        }
    });

    $.log = $.log ||{};
    $.extend($.log,{
        debugMsg:[],
        lazyInits:[],
        start:function(){
            return new Date().getTime();
        },
        end:function(start,msg){
            var end= new Date().getTime(),span = end-start;
            try{
                var info = {msg:msg,time:span};
                $.log.debugMsg.push(info);
            }catch(e){}
        },
        lazyLog:function(p){
            $.log.lazyInits.push(p);
        }
    });

})(jQuery);


/**
 * WAF
 * @author JASON LIU
 * @constructor
 */
waf.extend({
    /**
     * :UI Component
     */
    wafPageComponentLib:new Map(),
    wafCmpTypeLib:new Map(),
    lazyOptions:[],
    immeOptions:[],
    /**
     * :
     */
    registerComponent:function (type, options) {
        var component = new Object();
        component.type = type;
        component.createDOMFun = options.createDOMFun;
        component.initFun = options.initFun;
        component.deleteFun = options.deleteFun;
        component.modifyFun = options.modifyFun;
        component.lazyInit = options.lazyInit == undefined || options.lazyInit;
        //,,,
        if (waf.wafPageComponentLib.get(type) != null) {
            alert(type + "'s namespace already exists!");
        }
        //
        waf.wafPageComponentLib.put(type, component);
    },
    /**
     * :
     * @param {} type
     * @param {} option
     * @return {}
     */
    getComponentDef:function(type){
        return waf.wafPageComponentLib.get(type);
    },
    /**
     * :
     */
    createDOM:function (type, option) {
        var component = waf.wafPageComponentLib.get(type);
        var createDOMFun = component.createDOMFun;
        if(component.lazyInit){
            waf.lazyOptions.push({"type":type,"option":option,id:(option&&option.id)?option.id:""});
        }else{
            waf.immeOptions.push({"type":type,"option":option,id:(option&&option.id)?option.id:""});
        }

        return createDOMFun(option);
    },
    initComponent:function(type,option,el){
        var component = waf.wafPageComponentLib.get(type);
        var initFun = component.initFun;
        return initFun(option, el);
    },
    /**
     * :
     *     :idnull,
     */
    removeComponent:function (type, option) {
        var component = waf.wafPageComponentLib.get(type);
        /*
         * ,iddom
         * :
         */
        if (component.deleteFun == undefined || component.deleteFun == null) {
            if(option.id) waf("#"+option.id).remove();
        }
        else {
            component.deleteFun(option);
        }
    },
    /**
     * :
     */
    updateComponent:function (type, option) {
        var component = waf.wafPageComponentLib.get(type);
        /*
         * ,id
         * :
         */
        if (component.modifyFun == undefined || component.modifyFun == null) {
            if(option.id){
                var wafCmp = waf("#" + option.id);
                var updateScript = "waf('#" + option.id + "')." + waf.getCmpTypeByTag(component.type) + "('option'," + waf.toJSONString(option)+")";
                eval(updateScript);
            }
        }
        else {
            component.modifyFun(option);
        }
    },
    appendDOM:function(target,doms){
        if(doms instanceof jQuery && $(doms).data("domcreated")){
             return;
        }
        if($.isArray(doms)){
            for(var i=0;i<doms.length;i++){
                $(target).append(doms[i]);
            }
        }else{            
            $(target).append(doms);
        }
    },
    getCmpTypeByTag:function(tagType){
        if(waf.wafCmpTypeLib){
            return waf.wafCmpTypeLib.get(tagType);
        }
    },
    /**
     * :
     */
    appendWebCom:function (type, parent, option) {
        require([type], function() {
            var comDom = waf.createDOM(type, option);
            waf.appendDOM(parent, comDom);
            waf.initComponent(type, option, comDom);
        });
    }
});

waf(function(){
    //tagTypecmpType
    waf.wafCmpTypeLib.put("datePicker","wafDatePicker");
    waf.wafCmpTypeLib.put("text","wafText");
    waf.wafCmpTypeLib.put("password","wafPassword");
    waf.wafCmpTypeLib.put("autoComplete","autocomplete");
    waf.wafCmpTypeLib.put("select","wafSelect");
    waf.wafCmpTypeLib.put("option","wafSelect");
    waf.wafCmpTypeLib.put("optGroup","wafSelect");
    waf.wafCmpTypeLib.put("selectFilter","wafSelect");
    waf.wafCmpTypeLib.put("checkbox","wafCheckbox");
    waf.wafCmpTypeLib.put("radio","wafRadio");
    waf.wafCmpTypeLib.put("textarea","wafTextarea");
    waf.wafCmpTypeLib.put("menuButton","wafMenuButton");
    waf.wafCmpTypeLib.put("menuItem","wafMenuItem");
    waf.wafCmpTypeLib.put("grid","wafGrid");
    waf.wafCmpTypeLib.put("editGrid","wafGrid");
    waf.wafCmpTypeLib.put("gridColumn","wafGrid");
    waf.wafCmpTypeLib.put("pager","wafGrid");
    waf.wafCmpTypeLib.put("gridHeaderGroup","wafGrid");
    waf.wafCmpTypeLib.put("gridDataGroup","wafGrid");
    waf.wafCmpTypeLib.put("labelContainer","wafLabelContainer");
    waf.wafCmpTypeLib.put("msgArea","wafMsgArea");
    waf.wafCmpTypeLib.put("promptBox","wafPromptBox");
    waf.wafCmpTypeLib.put("promptIframe","wafPromptIframe");
    waf.wafCmpTypeLib.put("promptQuick","wafPromptQuick");
    waf.wafCmpTypeLib.put("promptGrid","wafPromptGrid");
    waf.wafCmpTypeLib.put("promptTree","wafPromptTree");
    waf.wafCmpTypeLib.put("numberField","wafNumberField");
    waf.wafCmpTypeLib.put("form","wafForm");
    waf.wafCmpTypeLib.put("toolBar","wafToolBar");
    waf.wafCmpTypeLib.put("linkButton","wafLinkButton");
    waf.wafCmpTypeLib.put("validator","wafValidator");
    waf.wafCmpTypeLib.put("panel","wafPanel");
    waf.wafCmpTypeLib.put("columnLayout","wafColumnLayout");
    waf.wafCmpTypeLib.put("column","wafColumn");
    waf.wafCmpTypeLib.put("section","wafSection");
    waf.wafCmpTypeLib.put("tree","wafTree");
    waf.wafCmpTypeLib.put("tabPanel","wafTabs");
    waf.wafCmpTypeLib.put("tab","wafTab");
    waf.wafCmpTypeLib.put("floatBar","wafFloatBar");
    waf.wafCmpTypeLib.put("outline","wafOutline");
    waf.wafCmpTypeLib.put("label","wafLabel");
    waf.wafCmpTypeLib.put("hidden","wafHidden");
    waf.wafCmpTypeLib.put("multiLangArea","wafMultiLangArea");
    waf.wafCmpTypeLib.put("multiLangBox","wafMultiLangBox");
    waf.wafCmpTypeLib.put("fileUpload","wafFileUploadUI");
    waf.wafCmpTypeLib.put("progressBar","wafProgressBar");
    waf.wafCmpTypeLib.put("radioGroup","wafRadioGroup");
    waf.wafCmpTypeLib.put("img","wafImg");
    waf.wafCmpTypeLib.put("timePicker","wafTimePicker");
    waf.wafCmpTypeLib.put("infoBlock","wafInfoBlock");
	waf.wafCmpTypeLib.put("dataView","wafDataView");
});

$.dynamicutil = $.dynamicutil || {};
$.extend($.dynamicutil, {
    removeChildren:function(container, source){
        source = $(source);

        var ctrlrole = source.attr("ctrlrole");
        if(ctrlrole){
            var id=source.attr("id");
            waf.removeComponent(ctrlrole,{id:id})
        }else{
            $(source,container).remove();
        }
    },
    appendChildren:function(container, source, pos){
        if($.type.isString(source)){
            //
            source = $("<label>"+source+"</label>");
        }else{
            source = $(source);
        }


        //pos
        if(!$.isNaN(pos)){
            var target = container.children("*").not("script").eq(pos);
            if(target&&target.length>0){
                $.each(source,function(i,v){
                    $(v).insertBefore(target);
                });
                return;
            }
        }
        $.each(source,function(i,v){
            container.append(v);
        });
    },
    addContextPath: function(opts, key, defaultUrl){
        var url = $.trim(opts[key]),
            contextPath = waf.getContextPath();

        if(url){
            if((url.charAt(0) != "?") && (url.indexOf(contextPath) != 0)){
                opts[key] = contextPath + url;
            }
        }else if(defaultUrl){
            opts[key] = contextPath + defaultUrl;
        }
    }
});


/*!
 * jQuery UI 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
(function( $, undefined ) {

// prevent duplicate loading
// this is only a problem because we proxy existing functions
// and we don't want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
	return;
}

$.extend( $.ui, {
	version: "1.8.16",

	keyCode: {
		ALT: 18,
		BACKSPACE: 8,
		CAPS_LOCK: 20,
		COMMA: 188,
		COMMAND: 91,
		COMMAND_LEFT: 91, // COMMAND
		COMMAND_RIGHT: 93,
		CONTROL: 17,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		INSERT: 45,
		LEFT: 37,
		MENU: 93, // COMMAND_RIGHT
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SHIFT: 16,
		SPACE: 32,
		TAB: 9,
		UP: 38,
		WINDOWS: 91 // COMMAND
	}
});

// plugins
$.fn.extend({
	propAttr: $.fn.prop || $.fn.attr,

	_focus: $.fn.focus,
	focus: function( delay, fn ) {
		return typeof delay === "number" ?
			this.each(function() {
				var elem = this;
				setTimeout(function() {
					$( elem ).focus();
					if ( fn ) {
						fn.call( elem );
					}
				}, delay );
			}) :
			this._focus.apply( this, arguments );
	},

	scrollParent: function() {
		var scrollParent;
		if (($.browser.msie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.curCSS(this,'position',1)) && (/(auto|scroll)/).test($.curCSS(this,'overflow',1)+$.curCSS(this,'overflow-y',1)+$.curCSS(this,'overflow-x',1));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.curCSS(this,'overflow',1)+$.curCSS(this,'overflow-y',1)+$.curCSS(this,'overflow-x',1));
			}).eq(0);
		}

		return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.each( [ "Width", "Height" ], function( i, name ) {
	var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
		type = name.toLowerCase(),
		orig = {
			innerWidth: $.fn.innerWidth,
			innerHeight: $.fn.innerHeight,
			outerWidth: $.fn.outerWidth,
			outerHeight: $.fn.outerHeight
		};

	function reduce( elem, size, border, margin ) {
		$.each( side, function() {
			size -= parseFloat( $.curCSS( elem, "padding" + this, true) ) || 0;
			if ( border ) {
				size -= parseFloat( $.curCSS( elem, "border" + this + "Width", true) ) || 0;
			}
			if ( margin ) {
				size -= parseFloat( $.curCSS( elem, "margin" + this, true) ) || 0;
			}
		});
		return size;
	}

	$.fn[ "inner" + name ] = function( size ) {
		if ( size === undefined ) {
			return orig[ "inner" + name ].call( this );
		}

		return this.each(function() {
			$( this ).css( type, reduce( this, size ) + "px" );
		});
	};

	$.fn[ "outer" + name] = function( size, margin ) {
		if ( typeof size !== "number" ) {
			return orig[ "outer" + name ].call( this, size );
		}

		return this.each(function() {
			$( this).css( type, reduce( this, size, true, margin ) + "px" );
		});
	};
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		var map = element.parentNode,
			mapName = map.name,
			img;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName )
		? !element.disabled
		: "a" == nodeName
			? element.href || isTabIndexNotNaN
			: isTabIndexNotNaN)
		// the element and all of its ancestors must be visible
		&& visible( element );
}

function visible( element ) {
	return !$( element ).parents().andSelf().filter(function() {
		return $.curCSS( this, "visibility" ) === "hidden" ||
			$.expr.filters.hidden( this );
	}).length;
}

$.extend( $.expr[ ":" ], {
	data: function( elem, i, match ) {
		return !!$.data( elem, match[ 3 ] );
	},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support
$(function() {
	var body = document.body,
		div = body.appendChild( div = document.createElement( "div" ) );

	$.extend( div.style, {
		minHeight: "100px",
		height: "auto",
		padding: 0,
		borderWidth: 0
	});

	$.support.minHeight = div.offsetHeight === 100;
	$.support.selectstart = "onselectstart" in div;

	// set display to none to avoid a layout bug in IE
	// http://dev.jquery.com/ticket/4014
	body.removeChild( div ).style.display = "none";
});





// deprecated
$.extend( $.ui, {
	// $.ui.plugin is deprecated.  Use the proxy pattern instead.
	plugin: {
		add: function( module, option, set ) {
			var proto = $.ui[ module ].prototype;
			for ( var i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode ) {
				return;
			}
	
			for ( var i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},
	
	// will be deprecated when we switch to jQuery 1.4 - use jQuery.contains()
	contains: function( a, b ) {
		return document.compareDocumentPosition ?
			a.compareDocumentPosition( b ) & 16 :
			a !== b && a.contains( b );
	},
	
	// only used by resizable
	hasScroll: function( el, a ) {
	
		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}
	
		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;
	
		if ( el[ scroll ] > 0 ) {
			return true;
		}
	
		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},
	
	// these are odd functions, fix the API or move into individual plugins
	isOverAxis: function( x, reference, size ) {
		//Determines when x coordinate is over "b" element axis
		return ( x > reference ) && ( x < ( reference + size ) );
	},
	isOver: function( y, x, top, left, height, width ) {
		//Determines when x, y coordinates is over "b" element
		return $.ui.isOverAxis( y, top, height ) && $.ui.isOverAxis( x, left, width );
	}
});

})( jQuery );

/*!
 * jQuery UI Widget 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function( $, undefined ) {

// jQuery 1.4+
if ( $.cleanData ) {
	var _cleanData = $.cleanData;
	$.cleanData = function( elems ) {
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			try {
				$( elem ).triggerHandler( "remove" );
			// http://bugs.jquery.com/ticket/8235
			} catch( e ) {}
		}
		_cleanData( elems );
	};
} else {
	var _remove = $.fn.remove;
	$.fn.remove = function( selector, keepData ) {
		return this.each(function() {
			if ( !keepData ) {
				if ( !selector || $.filter( selector, [ this ] ).length ) {
					$( "*", this ).add( [ this ] ).each(function() {
						try {
							$( this ).triggerHandler( "remove" );
						// http://bugs.jquery.com/ticket/8235
						} catch( e ) {}
					});
				}
			}
			return _remove.call( $(this), selector, keepData );
		});
	};
}

$.widget = function( name, base, prototype ) {
	var namespace = name.split( "." )[ 0 ],
		fullName;
	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName ] = function( elem ) {
		return !!$.data( elem, name );
	};

	$[ namespace ] = $[ namespace ] || {};
	$[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without initializing for simple inheritance
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	var basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
//	$.each( basePrototype, function( key, val ) {
//		if ( $.isPlainObject(val) ) {
//			basePrototype[ key ] = $.extend( {}, val );
//		}
//	});
	basePrototype.options = $.extend( true, {}, basePrototype.options );
	$[ namespace ][ name ].prototype = $.extend( true, basePrototype, {
		namespace: namespace,
		widgetName: name,
		widgetEventPrefix: $[ namespace ][ name ].prototype.widgetEventPrefix || name,
		widgetBaseClass: fullName
	}, prototype );

	$.widget.bridge( name, $[ namespace ][ name ] );
};

$.widget.bridge = function( name, object ) {
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = Array.prototype.slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.extend.apply( null, [ true, options ].concat(args) ) :
			options;

		// prevent calls to internal methods
		if ( isMethodCall && options.charAt( 0 ) === "_" ) {
			return returnValue;
		}

		if ( isMethodCall ) {
			this.each(function() {
                if(!!window.debug){
                    var start1 = $.log.start();
                }
                var instance = $.data( this, name );
                if(!instance){
                    var initOps = $(this).data("_OPTIONS_");
                    if(!initOps){
                        initOps = $.wafutil.getLazyOption($(this).attr("id"));
                    }
                    if(initOps){
                        $.data( this, name, new object( initOps, this ) );
                        instance = $.data( this, name );
                        if(!!window.debug){
                            $.log.end(start1,((initOps&&initOps.id)?initOps.id:"")+"-"+name+"-"+"Init when invoke method"+":");
                        }
                    }
                }
                if(!!window.debug){
                    var start = $.log.start();
                }
				var methodValue = instance && $.isFunction( instance[options] ) ?
						instance[ options ].apply( instance, args ) :
						instance;
                if(!!window.debug && instance){
                    $.log.end(start,((instance.element.attr("id"))?instance.element.attr("id"):"")+"-"+name+"-"+options+":");
                }
				// TODO: add this back in 1.9 and use $.error() (see #5972)
//				if ( !instance ) {
//					throw "cannot call methods on " + name + " prior to initialization; " +
//						"attempted to call method '" + options + "'";
//				}
//				if ( !$.isFunction( instance[options] ) ) {
//					throw "no such method '" + options + "' for " + name + " widget instance";
//				}
//				var methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
                if(!!window.debug){
                    var start = $.log.start();
                }
				var instance = $.data( this, name );
				if ( instance ) {
					instance.option( options || {} )._init();
                    if(!!window.debug){
                        $.log.end(start,((instance.element.attr("id"))?instance.element.attr("id"):"")+"-"+name+"-"+"Option"+":");
                    }
				} else {
					$.data( this, name, new object( options, this ) );
                    if(!!window.debug){
                        $.log.end(start,((options&&options.id)?options.id:"")+"-"+name+"-"+"Init"+":");
                    }
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( options, element ) {
	// allow instantiation without initializing for simple inheritance
	if ( arguments.length ) {
		this._createWidget( options, element );
	}
};

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	options: {
		disabled: false
	},
	_createWidget: function( options, element ) {
		// $.widget.bridge stores the plugin instance, but we do it anyway
		// so that it's stored even before the _create function runs
		$.data( element, this.widgetName, this );
		this.element = $( element );
		this.options = $.extend( true, {},
			this.options,
			this._getCreateOptions(),
			options );
		//1.9
		this.bindings = $();
		var self = this;
		this.element.bind( "remove." + this.widgetName, function() {
			self.destroy();
		});

		this._create();
		this._trigger( "create" );
		this._init();
	},
	_getCreateOptions: function() {
		return $.metadata && $.metadata.get( this.element[0] )[ this.widgetName ];
	},
	_create: function() {},
	_init: function() {},

	destroy: function() {
		this.element
			.unbind( "." + this.widgetName )
			.removeData( this.widgetName );
		this.widget()
			.unbind( "." + this.widgetName )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetBaseClass + "-disabled " +
				"ui-state-disabled" );
		//1.9				
		this.bindings.unbind( "." + this.widgetName );
	},

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.extend( {}, this.options );
		}

		if  (typeof key === "string" ) {
			if ( value === undefined ) {
				return this.options[ key ];
			}
			options = {};
			options[ key ] = value;
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var self = this;
		$.each( options, function( key, value ) {
			self._setOption( key, value );
		});

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				[ value ? "addClass" : "removeClass"](
					this.widgetBaseClass + "-disabled" + " " +
					"ui-state-disabled" )
				.attr( "aria-disabled", value );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_trigger: function( type, event, data ) {
		var callback = this.options[ type ];

		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		data = data || {};

		// copy original event properties over to the new event
		// this would happen if we could call $.event.fix instead of $.Event
		// but we don't have a way to force an event to be fixed multiple times
		if ( event.originalEvent ) {
			for ( var i = $.event.props.length, prop; i; ) {
				prop = $.event.props[ --i ];
				event[ prop ] = event.originalEvent[ prop ];
			}
		}

		this.element.trigger( event, data );

		return !( $.isFunction(callback) &&
			callback.call( this.element[0], event, data ) === false ||
			event.isDefaultPrevented() );
	},
	//1.9
	_bind: function( element, handlers ) {
		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
		} else {
			// accept selectors, DOM elements
			element = $( element );
			this.bindings = this.bindings.add( element );
		}

		var instance = this;
		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}
			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + "." + instance.widgetName,
				selector = match[2];
			if ( selector ) {
				instance.widget().delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},
	//1.9	
	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},
	// 
	_initByOptions: function() {
		for(var i = 0, length = arguments.length; i < length; i++) {
			var key = arguments[i],
				value = this.options[key];

			if(key != null && value != null) {
				this._setOption(key, value);
			}
		}
	}
};

})( jQuery );

/*!
 * jQuery UI Mouse 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
/*
$( document ).mouseup( function( e ) {
	mouseHandled = false;
});
*/
$.widget("ui.mouse", {
	options: {
		cancel: ':input,option',
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var self = this;

		this.element
			.bind('mousedown.'+this.widgetName, function(event) {
				return self._mouseDown(event);
			})
			.bind('click.'+this.widgetName, function(event) {
				if (true === $.data(event.target, self.widgetName + '.preventClickEvent')) {
				    $.removeData(event.target, self.widgetName + '.preventClickEvent');
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind('.'+this.widgetName);
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return };

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var self = this,
			btnIsLeft = (event.which == 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel == "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				self.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
			$.removeData(event.target, this.widgetName + '.preventClickEvent');
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return self._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return self._mouseUp(event);
		};
		$(event.target.ownerDocument)
			.bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.bind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();
		
		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.browser.msie && !(event.target.ownerDocument.documentMode >= 9) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(event.target.ownerDocument)
			.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		mouseHandled = false;

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target == this._mouseDownEvent.target) {
			    $.data(event.target, this.widgetName + '.preventClickEvent', true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(event) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(event) {},
	_mouseDrag: function(event) {},
	_mouseStop: function(event) {},
	_mouseCapture: function(event) { return true; }
});

})(jQuery);

/*
 * jQuery UI Position 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Position
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var horizontalPositions = /left|center|right/,
	verticalPositions = /top|center|bottom/,
	center = "center",
	_position = $.fn.position,
	_offset = $.fn.offset;

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var target = $( options.of ),
		targetElem = target[0],
		collision = ( options.collision || "flip" ).split( " " ),
		offset = options.offset ? options.offset.split( " " ) : [ 0, 0 ],
		targetWidth,
		targetHeight,
		basePosition;

	if ( targetElem.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: 0, left: 0 };
	// TODO: use $.isWindow() in 1.9
	} else if ( targetElem.setTimeout ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( targetElem.preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
		targetWidth = targetHeight = 0;
		basePosition = { top: options.of.pageY, left: options.of.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		basePosition = target.offset();
	}

	// force my and at to have valid horizontal and veritcal positions
	// if a value is missing or invalid, it will be converted to center 
	$.each( [ "my", "at" ], function() {
		var pos = ( options[this] || "" ).split( " " );
		if ( pos.length === 1) {
			pos = horizontalPositions.test( pos[0] ) ?
				pos.concat( [center] ) :
				verticalPositions.test( pos[0] ) ?
					[ center ].concat( pos ) :
					[ center, center ];
		}
		pos[ 0 ] = horizontalPositions.test( pos[0] ) ? pos[ 0 ] : center;
		pos[ 1 ] = verticalPositions.test( pos[1] ) ? pos[ 1 ] : center;
		options[ this ] = pos;
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	// normalize offset option
	offset[ 0 ] = parseInt( offset[0], 10 ) || 0;
	if ( offset.length === 1 ) {
		offset[ 1 ] = offset[ 0 ];
	}
	offset[ 1 ] = parseInt( offset[1], 10 ) || 0;

	if ( options.at[0] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[0] === center ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[1] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[1] === center ) {
		basePosition.top += targetHeight / 2;
	}

	basePosition.left += offset[ 0 ];
	basePosition.top += offset[ 1 ];

	return this.each(function() {
		var elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseInt( $.curCSS( this, "marginLeft", true ) ) || 0,
			marginTop = parseInt( $.curCSS( this, "marginTop", true ) ) || 0,
			collisionWidth = elemWidth + marginLeft +
				( parseInt( $.curCSS( this, "marginRight", true ) ) || 0 ),
			collisionHeight = elemHeight + marginTop +
				( parseInt( $.curCSS( this, "marginBottom", true ) ) || 0 ),
			position = $.extend( {}, basePosition ),
			collisionPosition;

		if ( options.my[0] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[0] === center ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[1] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[1] === center ) {
			position.top -= elemHeight / 2;
		}

		// prevent fractions (see #5280)
		position.left = Math.round( position.left );
		position.top = Math.round( position.top );

		collisionPosition = {
			left: position.left - marginLeft,
			top: position.top - marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[i] ] ) {
				$.ui.position[ collision[i] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: offset,
					my: options.my,
					at: options.at
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}
		elem.offset( $.extend( position, { using: options.using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft();
			position.left = over > 0 ? position.left - over : Math.max( position.left - data.collisionPosition.left, position.left );
		},
		top: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop();
			position.top = over > 0 ? position.top - over : Math.max( position.top - data.collisionPosition.top, position.top );
		}
	},

	flip: {
		left: function( position, data ) {
			if ( data.at[0] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft(),
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					-data.targetWidth,
				offset = -2 * data.offset[ 0 ];
			position.left += data.collisionPosition.left < 0 ?
				myOffset + atOffset + offset :
				(over > 0) && (position.left + myOffset + atOffset + offset) > 0?
				//over > 0 ?  modify by peng_zhou1 
					myOffset + atOffset + offset :
					0;
		},
		top: function( position, data ) {
			if ( data.at[1] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop(),
				myOffset = data.my[ 1 ] === "top" ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					-data.targetHeight,
				offset = -2 * data.offset[ 1 ];
			position.top += data.collisionPosition.top < 0 ?
				myOffset + atOffset + offset :
				(over > 0) && (position.top + myOffset + atOffset + offset) > 0?
				//over > 0 ?  modify by peng_zhou1 
					myOffset + atOffset + offset :
					0;
		}
	}
};

// offset setter from jQuery 1.4
if ( !$.offset.setOffset ) {
	$.offset.setOffset = function( elem, options ) {
		// set position first, in-case top/left are set even on static elem
		if ( /static/.test( $.curCSS( elem, "position" ) ) ) {
			elem.style.position = "relative";
		}
		var curElem   = $( elem ),
			curOffset = curElem.offset(),
			curTop    = parseInt( $.curCSS( elem, "top",  true ), 10 ) || 0,
			curLeft   = parseInt( $.curCSS( elem, "left", true ), 10)  || 0,
			props     = {
				top:  (options.top  - curOffset.top)  + curTop,
				left: (options.left - curOffset.left) + curLeft
			};
		
		if ( 'using' in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	};

	$.fn.offset = function( options ) {
		var elem = this[ 0 ];
		if ( !elem || !elem.ownerDocument ) { return null; }
		if ( options ) { 
			return this.each(function() {
				$.offset.setOffset( this, options );
			});
		}
		return _offset.call( this );
	};
}

}( jQuery ));

/*
 * jQuery UI Draggable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Draggables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false
	},
	_create: function() {

		if (this.options.helper == 'original' && !(/^(?:r|a|f)/).test(this.element.css("position")))
			this.element[0].style.position = 'relative';

		(this.options.addClasses && this.element.addClass("ui-draggable"));
		(this.options.disabled && this.element.addClass("ui-draggable-disabled"));

		this._mouseInit();

	},

	destroy: function() {
		if(!this.element.data('draggable')) return;
		this.element
			.removeData("draggable")
			.unbind(".draggable")
			.removeClass("ui-draggable"
				+ " ui-draggable-dragging"
				+ " ui-draggable-disabled");
		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).is('.ui-resizable-handle'))
			return false;

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle)
			return false;
		
		if ( o.iframeFix ) {
			$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
				$('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>')
				.css({
					width: this.offsetWidth+"px", height: this.offsetHeight+"px",
					position: "absolute", opacity: "0.001", zIndex: 1000
				})
				.css($(this).offset())
				.appendTo("body");
			});
		}

		return true;

	},

		_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css("position");
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.helper.addClass("ui-draggable-dragging");
		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		
		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) $.ui.ddmanager.dragStart(this, event);
		
		return true;
	},

	_mouseDrag: function(event, noPropagation) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger('drag', event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		//if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';
		
		//modified by liyue 2012-11-06
		if(!this.options.axis || this.options.axis != "x") this.helper.offset(this.position);
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			dropped = $.ui.ddmanager.drop(this, event);

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}
		
		//if the original element is removed, don't bother to continue if helper is set to "original"
		if((!this.element[0] || !this.element[0].parentNode) && this.options.helper == "original")
			return false;

		if((this.options.revert == "invalid" && !dropped) || (this.options.revert == "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			var self = this;
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(self._trigger("stop", event) !== false) {
					self._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},
	
	_mouseUp: function(event) {
		if (this.options.iframeFix === true) {
			$("div.ui-draggable-iframeFix").each(function() { 
				this.parentNode.removeChild(this); 
			}); //Remove frame helpers
		}
		
		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) $.ui.ddmanager.dragStop(this, event);
		
		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},
	
	cancel: function() {
		
		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}
		
		return this;
		
	},

	_getHandle: function(event) {

		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
		$(this.options.handle, this.element)
			.find("*")
			.andSelf()
			.each(function() {
				if(this == event.target) handle = true;
			});

		return handle;

	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == 'clone' ? this.element.clone().removeAttr('id') : this.element);

		if(!helper.parents('body').length)
			helper.appendTo((o.appendTo == 'parent' ? this.element[0].parentNode : o.appendTo));

		if(helper[0] != this.element[0] && !(/(fixed|absolute)/).test(helper.css("position")))
			helper.css("position", "absolute");

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			o.containment == 'document' ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
			o.containment == 'document' ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
			(o.containment == 'document' ? 0 : $(window).scrollLeft()) + $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			(o.containment == 'document' ? 0 : $(window).scrollTop()) + ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor != Array) {
		        var c = $(o.containment);
			var ce = c[0]; if(!ce) return;
			var co = c.offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				(parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0),
				(parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0),
				(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
				(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;

		} else if(o.containment.constructor == Array) {
			this.containment = o.containment;
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options
		         var containment;
		         if(this.containment) {
				 if (this.relative_container){
				     var co = this.relative_container.offset();
				     containment = [ this.containment[0] + co.left,
						     this.containment[1] + co.top,
						     this.containment[2] + co.left,
						     this.containment[3] + co.top ];
				 }
				 else {
				     containment = this.containment;
				 }

				if(event.pageX - this.offset.click.left < containment[0]) pageX = containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < containment[1]) pageY = containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > containment[2]) pageX = containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > containment[3]) pageY = containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? (!(top - this.offset.click.top < containment[1] || top - this.offset.click.top > containment[3]) ? top : (!(top - this.offset.click.top < containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? (!(left - this.offset.click.left < containment[0] || left - this.offset.click.left > containment[2]) ? left : (!(left - this.offset.click.left < containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] != this.element[0] && !this.cancelHelperRemoval) this.helper.remove();
		//if($.ui.ddmanager) $.ui.ddmanager.current = null;
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		if(type == "drag") this.positionAbs = this._convertPositionTo("absolute"); //The absolute position has to be recalculated after plugins
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function(event) {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.extend($.ui.draggable, {
	version: "1.8.16"
});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, 'sortable');
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: 'valid/invalid'
				if(this.shouldRevert) this.instance.options.revert = true;

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper == 'original')
					this.instance.currentItem.css({ top: 'auto', left: 'auto' });

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), self = this;

		var checkPos = function(o) {
			var dyClick = this.offset.click.top, dxClick = this.offset.click.left;
			var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;
			var itemHeight = o.height, itemWidth = o.width;
			var itemTop = o.top, itemLeft = o.left;

			return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);
		};

		$.each(inst.sortables, function(i) {
			
			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;
			
			if(this.instance._intersectsWith(this.instance.containerCache)) {

				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(self).clone().removeAttr('id').appendTo(this.instance.element).data("sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) this.instance._mouseDrag(event);

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;
					
					//Prevent reverting on this forced stop
					this.instance.options.revert = false;
					
					// The out event needs to be triggered independently
					this.instance._trigger('out', event, this.instance._uiHash(this.instance));
					
					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) this.instance.placeholder.remove();

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			};

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function(event, ui) {
		var t = $('body'), o = $(this).data('draggable').options;
		if (t.css("cursor")) o._cursor = t.css("cursor");
		t.css("cursor", o.cursor);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if (o._cursor) $('body').css("cursor", o._cursor);
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data('draggable').options;
		if(t.css("opacity")) o._opacity = t.css("opacity");
		t.css('opacity', o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if(o._opacity) $(ui.helper).css('opacity', o._opacity);
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function(event, ui) {
		var i = $(this).data("draggable");
		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') i.overflowOffset = i.scrollParent.offset();
	},
	drag: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') {

			if(!o.axis || o.axis != 'x') {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
			}

			if(!o.axis || o.axis != 'y') {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
			}

		} else {

			if(!o.axis || o.axis != 'x') {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
			}

			if(!o.axis || o.axis != 'y') {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(i, event);

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options;
		i.snapElements = [];

		$(o.snap.constructor != String ? ( o.snap.items || ':data(draggable)' ) : o.snap).each(function() {
			var $t = $(this); var $o = $t.offset();
			if(this != i.element[0]) i.snapElements.push({
				item: this,
				width: $t.outerWidth(), height: $t.outerHeight(),
				top: $o.top, left: $o.left
			});
		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options;
		var d = o.snapTolerance;

		var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (var i = inst.snapElements.length - 1; i >= 0; i--){

			var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,
				t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;

			//Yes, I know, this is insane ;)
			if(!((l-d < x1 && x1 < r+d && t-d < y1 && y1 < b+d) || (l-d < x1 && x1 < r+d && t-d < y2 && y2 < b+d) || (l-d < x2 && x2 < r+d && t-d < y1 && y1 < b+d) || (l-d < x2 && x2 < r+d && t-d < y2 && y2 < b+d))) {
				if(inst.snapElements[i].snapping) (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode != 'inner') {
				var ts = Math.abs(t - y2) <= d;
				var bs = Math.abs(b - y1) <= d;
				var ls = Math.abs(l - x2) <= d;
				var rs = Math.abs(r - x1) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
			}

			var first = (ts || bs || ls || rs);

			if(o.snapMode != 'outer') {
				var ts = Math.abs(t - y1) <= d;
				var bs = Math.abs(b - y2) <= d;
				var ls = Math.abs(l - x1) <= d;
				var rs = Math.abs(r - x2) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first))
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		};

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function(event, ui) {

		var o = $(this).data("draggable").options;

		var group = $.makeArray($(o.stack)).sort(function(a,b) {
			return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
		});
		if (!group.length) { return; }
		
		var min = parseInt(group[0].style.zIndex) || 0;
		$(group).each(function(i) {
			this.style.zIndex = min + i;
		});

		this[0].style.zIndex = min + group.length;

	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("draggable").options;
		if(t.css("zIndex")) o._zIndex = t.css("zIndex");
		t.css('zIndex', o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("draggable").options;
		if(o._zIndex) $(ui.helper).css('zIndex', o._zIndex);
	}
});

})(jQuery);

/*
 * jQuery UI Droppable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Droppables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.mouse.js
 *	jquery.ui.draggable.js
 */
(function( $, undefined ) {

$.widget("ui.droppable", {
	widgetEventPrefix: "drop",
	options: {
		accept: '*',
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: 'default',
		tolerance: 'intersect'
	},
	_create: function() {

		var o = this.options, accept = o.accept;
		this.isover = 0; this.isout = 1;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		//Store the droppable's proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses && this.element.addClass("ui-droppable"));

	},

	destroy: function() {
		var drop = $.ui.ddmanager.droppables[this.options.scope];
		for ( var i = 0; i < drop.length; i++ )
			if ( drop[i] == this )
				drop.splice(i, 1);

		this.element
			.removeClass("ui-droppable ui-droppable-disabled")
			.removeData("droppable")
			.unbind(".droppable");

		return this;
	},

	_setOption: function(key, value) {

		if(key == 'accept') {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.addClass(this.options.activeClass);
		(draggable && this._trigger('activate', event, this.ui(draggable)));
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
		(draggable && this._trigger('deactivate', event, this.ui(draggable)));
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);
			this._trigger('over', event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('out', event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; // Bail if draggable and droppable are same element

		var childrenIntersection = false;
		this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function() {
			var inst = $.data(this, 'droppable');
			if(
				inst.options.greedy
				&& !inst.options.disabled
				&& inst.options.scope == draggable.options.scope
				&& inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))
				&& $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) return false;

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('drop', event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.extend($.ui.droppable, {
	version: "1.8.16"
});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) return false;

	var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;
	var l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case 'fit':
			return (l <= x1 && x2 <= r
				&& t <= y1 && y2 <= b);
			break;
		case 'intersect':
			return (l < x1 + (draggable.helperProportions.width / 2) // Right Half
				&& x2 - (draggable.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (draggable.helperProportions.height / 2) // Bottom Half
				&& y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
			break;
		case 'pointer':
			var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),
				isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
			return isOver;
			break;
		case 'touch':
			return (
					(y1 >= t && y1 <= b) ||	// Top edge touching
					(y2 >= t && y2 <= b) ||	// Bottom edge touching
					(y1 < t && y2 > b)		// Surrounded vertically
				) && (
					(x1 >= l && x1 <= r) ||	// Left edge touching
					(x2 >= l && x2 <= r) ||	// Right edge touching
					(x1 < l && x2 > r)		// Surrounded horizontally
				);
			break;
		default:
			return false;
			break;
		}

};

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { 'default': [] },
	prepareOffsets: function(t, event) {

		var m = $.ui.ddmanager.droppables[t.options.scope] || [];
		var type = event ? event.type : null; // workaround for #2317
		var list = (t.currentItem || t.element).find(":data(droppable)").andSelf();

		droppablesLoop: for (var i = 0; i < m.length; i++) {

			if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue;	//No disabled and non-accepted
			for (var j=0; j < list.length; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; //Filter out elements in the current dragged item
			m[i].visible = m[i].element.css("display") != "none"; if(!m[i].visible) continue; 									//If the element is not visible, continue

			if(type == "mousedown") m[i]._activate.call(m[i], event); //Activate the droppable if used directly from draggables

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(!this.options) return;
			if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance))
				dropped = dropped || this._drop.call(this, event);

			if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = 1; this.isover = 0;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parents( ":not(body,html)" ).bind( "scroll.droppable", function() {
			if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
		});
	},
	drag: function(draggable, event) {

		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);

		//Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) return;
			var intersects = $.ui.intersect(draggable, this, this.options.tolerance);

			var c = !intersects && this.isover == 1 ? 'isout' : (intersects && this.isover == 0 ? 'isover' : null);
			if(!c) return;

			var parentInstance;
			if (this.options.greedy) {
				var parent = this.element.parents(':data(droppable):eq(0)');
				if (parent.length) {
					parentInstance = $.data(parent[0], 'droppable');
					parentInstance.greedyChild = (c == 'isover' ? 1 : 0);
				}
			}

			// we just moved into a greedy child
			if (parentInstance && c == 'isover') {
				parentInstance['isover'] = 0;
				parentInstance['isout'] = 1;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = 1; this[c == 'isout' ? 'isover' : 'isout'] = 0;
			this[c == "isover" ? "_over" : "_out"].call(this, event);

			// we just moved out of a greedy child
			if (parentInstance && c == 'isout') {
				parentInstance['isout'] = 0;
				parentInstance['isover'] = 1;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parents( ":not(body,html)" ).unbind( "scroll.droppable" );
		//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
	}
};

})(jQuery);

/*
 * jQuery UI Resizable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Resizables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.resizable", $.ui.mouse, {
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		zIndex: 1000
	},
	_create: function() {

		var self = this, o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Opera fix for relative positioning
			if (/relative/.test(this.element.css('position')) && $.browser.opera)
				this.element.css({ position: 'relative', top: 'auto', left: 'auto' });

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({
					position: this.element.css('position'),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css('top'),
					left: this.element.css('left')
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				"resizable", this.element.data('resizable')
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css('resize');
			this.originalElement.css('resize', 'none');

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: 'static', zoom: 1, display: 'block' }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css('margin') });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? "e,s,se" : { n: '.ui-resizable-n', e: '.ui-resizable-e', s: '.ui-resizable-s', w: '.ui-resizable-w', se: '.ui-resizable-se', sw: '.ui-resizable-sw', ne: '.ui-resizable-ne', nw: '.ui-resizable-nw' });
		if(this.handles.constructor == String) {

			if(this.handles == 'all') this.handles = 'n,e,s,w,se,sw,ne,nw';
			var n = this.handles.split(","); this.handles = {};

			for(var i = 0; i < n.length; i++) {

				var handle = $.trim(n[i]), hname = 'ui-resizable-'+handle;
				var axis = $('<div class="ui-resizable-handle ' + hname + '"></div>');

				// increase zIndex of sw, se, ne, nw axis
				//TODO : this modifies original option
				if(/sw|se|ne|nw/.test(handle)) axis.css({ zIndex: ++o.zIndex });

				//TODO : What's going on here?
				if ('se' == handle) {
					axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
				};

				//Insert into internal handles object and append to element
				this.handles[handle] = '.ui-resizable-'+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			target = target || this.element;

			for(var i in this.handles) {

				if(this.handles[i].constructor == String)
					this.handles[i] = $(this.handles[i], this.element).show();

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					var axis = $(this.handles[i], this.element), padWrapper = 0;

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					var padPos = [ 'padding',
						/ne|nw|n/.test(i) ? 'Top' :
						/se|sw|s/.test(i) ? 'Bottom' :
						/^e$/.test(i) ? 'Right' : 'Left' ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What's that good for? There's not anything to be executed left
				if(!$(this.handles[i]).length)
					continue;

			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $('.ui-resizable-handle', this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!self.resizing) {
				if (this.className)
					var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				//Axis, default = se
				self.axis = axis && axis[1] ? axis[1] : 'se';
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.hover(function() {
					if (o.disabled) return;
					$(this).removeClass("ui-resizable-autohide");
					self._handles.show();
				},
				function(){
					if (o.disabled) return;
					if (!self.resizing) {
						$(this).addClass("ui-resizable-autohide");
						self._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	destroy: function() {

		this._mouseDestroy();

		var _destroy = function(exp) {
			$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
				.removeData("resizable").unbind(".resizable").find('.ui-resizable-handle').remove();
		};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			var wrapper = this.element;
			wrapper.after(
				this.originalElement.css({
					position: wrapper.css('position'),
					width: wrapper.outerWidth(),
					height: wrapper.outerHeight(),
					top: wrapper.css('top'),
					left: wrapper.css('left')
				})
			).remove();
		}

		this.originalElement.css('resize', this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var handle = false;
		for (var i in this.handles) {
			if ($(this.handles[i])[0] == event.target) {
				handle = true;
			}
		}

		return !this.options.disabled && handle;
	},

	_mouseStart: function(event) {

		var o = this.options, iniPos = this.element.position(), el = this.element;

		this.resizing = true;
		this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };

		// bugfix for http://dev.jquery.com/ticket/1749
		if (el.is('.ui-draggable') || (/absolute/).test(el.css('position'))) {
			el.css({ position: 'absolute', top: iniPos.top, left: iniPos.left });
		}

		//Opera fixing relative position
		if ($.browser.opera && (/relative/).test(el.css('position')))
			el.css({ position: 'relative', top: 'auto', left: 'auto' });

		this._renderProxy();

		var curleft = num(this.helper.css('left')), curtop = num(this.helper.css('top'));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio == 'number') ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

	    var cursor = $('.ui-resizable-' + this.axis).css('cursor');
	    $('body').css('cursor', cursor == 'auto' ? this.axis + '-resize' : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var el = this.helper, o = this.options, props = {},
			self = this, smp = this.originalMousePosition, a = this.axis;

		var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;
		var trigger = this._change[a];
		if (!trigger) return false;

		// Calculate the attrs that will be change
		var data = trigger.apply(this, [event, dx, dy]), ie6 = $.browser.msie && $.browser.version < 7, csdif = this.sizeDiff;

		// Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey)
			data = this._updateRatio(data, event);

		data = this._respectSize(data, event);

		// plugins callbacks need to be called first
		this._propagate("resize", event);

		el.css({
			top: this.position.top + "px", left: this.position.left + "px",
			width: this.size.width + "px", height: this.size.height + "px"
		});

		if (!this._helper && this._proportionallyResizeElements.length)
			this._proportionallyResize();

		this._updateCache(data);

		// calling the user callback at the end
		this._trigger('resize', event, this.ui());

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var o = this.options, self = this;

		if(this._helper) {
			var pr = this._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
				soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
				soffsetw = ista ? 0 : self.sizeDiff.width;

			var s = { width: (self.helper.width()  - soffsetw), height: (self.helper.height() - soffseth) },
				left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,
				top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;

			if (!o.animate)
				this.element.css($.extend(s, { top: top, left: left }));

			self.helper.height(self.size.height);
			self.helper.width(self.size.width);

			if (this._helper && !o.animate) this._proportionallyResize();
		}

		$('body').css('cursor', 'auto');

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) this.helper.remove();
		return false;

	},

    _updateVirtualBoundaries: function(forceAspectRatio) {
        var o = this.options, pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b;

        b = {
            minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
            maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
            minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
            maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
        };

        if(this._aspectRatio || forceAspectRatio) {
            // We want to create an enclosing box whose aspect ration is the requested one
            // First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
            pMinWidth = b.minHeight * this.aspectRatio;
            pMinHeight = b.minWidth / this.aspectRatio;
            pMaxWidth = b.maxHeight * this.aspectRatio;
            pMaxHeight = b.maxWidth / this.aspectRatio;

            if(pMinWidth > b.minWidth) b.minWidth = pMinWidth;
            if(pMinHeight > b.minHeight) b.minHeight = pMinHeight;
            if(pMaxWidth < b.maxWidth) b.maxWidth = pMaxWidth;
            if(pMaxHeight < b.maxHeight) b.maxHeight = pMaxHeight;
        }
        this._vBoundaries = b;
    },

	_updateCache: function(data) {
		var o = this.options;
		this.offset = this.helper.offset();
		if (isNumber(data.left)) this.position.left = data.left;
		if (isNumber(data.top)) this.position.top = data.top;
		if (isNumber(data.height)) this.size.height = data.height;
		if (isNumber(data.width)) this.size.width = data.width;
	},

	_updateRatio: function(data, event) {

		var o = this.options, cpos = this.position, csize = this.size, a = this.axis;

		if (isNumber(data.height)) data.width = (data.height * this.aspectRatio);
		else if (isNumber(data.width)) data.height = (data.width / this.aspectRatio);

		if (a == 'sw') {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a == 'nw') {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function(data, event) {

		var el = this.helper, o = this._vBoundaries, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,
				ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
					isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height);

		if (isminw) data.width = o.minWidth;
		if (isminh) data.height = o.minHeight;
		if (ismaxw) data.width = o.maxWidth;
		if (ismaxh) data.height = o.maxHeight;

		var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;
		var cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);

		if (isminw && cw) data.left = dw - o.minWidth;
		if (ismaxw && cw) data.left = dw - o.maxWidth;
		if (isminh && ch)	data.top = dh - o.minHeight;
		if (ismaxh && ch)	data.top = dh - o.maxHeight;

		// fixing jump error on top/left - bug #2330
		var isNotwh = !data.width && !data.height;
		if (isNotwh && !data.left && data.top) data.top = null;
		else if (isNotwh && !data.top && data.left) data.left = null;

		return data;
	},

	_proportionallyResize: function() {

		var o = this.options;
		if (!this._proportionallyResizeElements.length) return;
		var element = this.helper || this.element;

		for (var i=0; i < this._proportionallyResizeElements.length; i++) {

			var prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				var b = [prel.css('borderTopWidth'), prel.css('borderRightWidth'), prel.css('borderBottomWidth'), prel.css('borderLeftWidth')],
					p = [prel.css('paddingTop'), prel.css('paddingRight'), prel.css('paddingBottom'), prel.css('paddingLeft')];

				this.borderDif = $.map(b, function(v, i) {
					var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;
					return border + padding;
				});
			}

			if ($.browser.msie && !(!($(element).is(':hidden') || $(element).parents(':hidden').length)))
				continue;

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		};

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $('<div style="overflow:hidden;"></div>');

			// fix ie6 offset TODO: This seems broken
			var ie6 = $.browser.msie && $.browser.version < 7, ie6offset = (ie6 ? 1 : 0),
			pxyoffset = ( ie6 ? 2 : -1 );

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() + pxyoffset,
				height: this.element.outerHeight() + pxyoffset,
				position: 'absolute',
				left: this.elementOffset.left - ie6offset +'px',
				top: this.elementOffset.top - ie6offset +'px',
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx, dy) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n != "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

$.extend($.ui.resizable, {
	version: "1.8.16"
});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "alsoResize", {

	start: function (event, ui) {
		var self = $(this).data("resizable"), o = self.options;

		var _store = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				el.data("resizable-alsoresize", {
					width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
					left: parseInt(el.css('left'), 10), top: parseInt(el.css('top'), 10),
					position: el.css('position') // to reset Opera on stop()
				});
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var self = $(this).data("resizable"), o = self.options, os = self.originalSize, op = self.originalPosition;

		var delta = {
			height: (self.size.height - os.height) || 0, width: (self.size.width - os.width) || 0,
			top: (self.position.top - op.top) || 0, left: (self.position.left - op.left) || 0
		},

		_alsoResize = function (exp, c) {
			$(exp).each(function() {
				var el = $(this), start = $(this).data("resizable-alsoresize"), style = {}, 
					css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ['width', 'height'] : ['width', 'height', 'top', 'left'];

				$.each(css, function (i, prop) {
					var sum = (start[prop]||0) + (delta[prop]||0);
					if (sum && sum >= 0)
						style[prop] = sum || null;
				});

				// Opera fixing relative position
				if ($.browser.opera && /relative/.test(el.css('position'))) {
					self._revertToRelativePosition = true;
					el.css({ position: 'absolute', top: 'auto', left: 'auto' });
				}

				el.css(style);
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function (event, ui) {
		var self = $(this).data("resizable"), o = self.options;

		var _reset = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				// reset position for Opera - no need to verify it was changed
				el.css({ position: el.data("resizable-alsoresize").position });
			});
		};

		if (self._revertToRelativePosition) {
			self._revertToRelativePosition = false;
			if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {
				$.each(o.alsoResize, function (exp) { _reset(exp); });
			}else{
				_reset(o.alsoResize);
			}
		}

		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "animate", {

	stop: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options;

		var pr = self._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
					soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
						soffsetw = ista ? 0 : self.sizeDiff.width;

		var style = { width: (self.size.width - soffsetw), height: (self.size.height - soffseth) },
					left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,
						top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;

		self.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(self.element.css('width'), 10),
						height: parseInt(self.element.css('height'), 10),
						top: parseInt(self.element.css('top'), 10),
						left: parseInt(self.element.css('left'), 10)
					};

					if (pr && pr.length) $(pr[0]).css({ width: data.width, height: data.height });

					// propagating resize, and updating values for each animation step
					self._updateCache(data);
					self._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add("resizable", "containment", {

	start: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options, el = self.element;
		var oc = o.containment,	ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
		if (!ce) return;

		self.containerElement = $(ce);

		if (/document/.test(oc) || oc == document) {
			self.containerOffset = { left: 0, top: 0 };
			self.containerPosition = { left: 0, top: 0 };

			self.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i'm a node, so compute top, left, right, bottom
		else {
			var element = $(ce), p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

			self.containerOffset = element.offset();
			self.containerPosition = element.position();
			self.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			var co = self.containerOffset, ch = self.containerSize.height,	cw = self.containerSize.width,
						width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			self.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options,
				ps = self.containerSize, co = self.containerOffset, cs = self.size, cp = self.position,
				pRatio = self._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = self.containerElement;

		if (ce[0] != document && (/static/).test(ce.css('position'))) cop = co;

		if (cp.left < (self._helper ? co.left : 0)) {
			self.size.width = self.size.width + (self._helper ? (self.position.left - co.left) : (self.position.left - cop.left));
			if (pRatio) self.size.height = self.size.width / o.aspectRatio;
			self.position.left = o.helper ? co.left : 0;
		}

		if (cp.top < (self._helper ? co.top : 0)) {
			self.size.height = self.size.height + (self._helper ? (self.position.top - co.top) : self.position.top);
			if (pRatio) self.size.width = self.size.height * o.aspectRatio;
			self.position.top = self._helper ? co.top : 0;
		}

		self.offset.left = self.parentData.left+self.position.left;
		self.offset.top = self.parentData.top+self.position.top;

		var woset = Math.abs( (self._helper ? self.offset.left - cop.left : (self.offset.left - cop.left)) + self.sizeDiff.width ),
					hoset = Math.abs( (self._helper ? self.offset.top - cop.top : (self.offset.top - co.top)) + self.sizeDiff.height );

		var isParent = self.containerElement.get(0) == self.element.parent().get(0),
		    isOffsetRelative = /relative|absolute/.test(self.containerElement.css('position'));

		if(isParent && isOffsetRelative) woset -= self.parentData.left;

		if (woset + self.size.width >= self.parentData.width) {
			self.size.width = self.parentData.width - woset;
			if (pRatio) self.size.height = self.size.width / self.aspectRatio;
		}

		if (hoset + self.size.height >= self.parentData.height) {
			self.size.height = self.parentData.height - hoset;
			if (pRatio) self.size.width = self.size.height * self.aspectRatio;
		}
	},

	stop: function(event, ui){
		var self = $(this).data("resizable"), o = self.options, cp = self.position,
				co = self.containerOffset, cop = self.containerPosition, ce = self.containerElement;

		var helper = $(self.helper), ho = helper.offset(), w = helper.outerWidth() - self.sizeDiff.width, h = helper.outerHeight() - self.sizeDiff.height;

		if (self._helper && !o.animate && (/relative/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

		if (self._helper && !o.animate && (/static/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function(event, ui) {

		var self = $(this).data("resizable"), o = self.options, cs = self.size;

		self.ghost = self.originalElement.clone();
		self.ghost
			.css({ opacity: .25, display: 'block', position: 'relative', height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass('ui-resizable-ghost')
			.addClass(typeof o.ghost == 'string' ? o.ghost : '');

		self.ghost.appendTo(self.helper);

	},

	resize: function(event, ui){
		var self = $(this).data("resizable"), o = self.options;
		if (self.ghost) self.ghost.css({ position: 'relative', height: self.size.height, width: self.size.width });
	},

	stop: function(event, ui){
		var self = $(this).data("resizable"), o = self.options;
		if (self.ghost && self.helper) self.helper.get(0).removeChild(self.ghost.get(0));
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options, cs = self.size, os = self.originalSize, op = self.originalPosition, a = self.axis, ratio = o._aspectRatio || event.shiftKey;
		o.grid = typeof o.grid == "number" ? [o.grid, o.grid] : o.grid;
		var ox = Math.round((cs.width - os.width) / (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) / (o.grid[1]||1)) * (o.grid[1]||1);

		if (/^(se|s|e)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
		}
		else if (/^(ne)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
		}
		else if (/^(sw)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.left = op.left - ox;
		}
		else {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
			self.position.left = op.left - ox;
		}
	}

});

var num = function(v) {
	return parseInt(v, 10) || 0;
};

var isNumber = function(value) {
	return !isNaN(parseInt(value, 10));
};

})(jQuery);

/*
 * jQuery UI Selectable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Selectables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.selectable", $.ui.mouse, {
	options: {
		appendTo: 'body',
		autoRefresh: true,
		distance: 0,
		filter: '*',
		tolerance: 'touch'
	},
	_create: function() {
		var self = this;

		this.element.addClass("ui-selectable");

		this.dragged = false;

		// cache selectee children based on filter
		var selectees;
		this.refresh = function() {
			selectees = $(self.options.filter, self.element[0]);
			selectees.each(function() {
				var $this = $(this);
				var pos = $this.offset();
				$.data(this, "selectable-item", {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass('ui-selected'),
					selecting: $this.hasClass('ui-selecting'),
					unselecting: $this.hasClass('ui-unselecting')
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass("ui-selectee");

		this._mouseInit();

		this.helper = $("<div class='ui-selectable-helper'></div>");
	},

	destroy: function() {
		this.selectees
			.removeClass("ui-selectee")
			.removeData("selectable-item");
		this.element
			.removeClass("ui-selectable ui-selectable-disabled")
			.removeData("selectable")
			.unbind(".selectable");
		this._mouseDestroy();

		return this;
	},

	_mouseStart: function(event) {
		var self = this;

		this.opos = [event.pageX, event.pageY];

		if (this.options.disabled)
			return;

		var options = this.options;

		this.selectees = $(options.filter, this.element[0]);

		this._trigger("start", event);

		$(options.appendTo).append(this.helper);
		// position helper (lasso)
		this.helper.css({
			"left": event.clientX,
			"top": event.clientY,
			"width": 0,
			"height": 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter('.ui-selected').each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.startselected = true;
			if (!event.metaKey) {
				selectee.$element.removeClass('ui-selected');
				selectee.selected = false;
				selectee.$element.addClass('ui-unselecting');
				selectee.unselecting = true;
				// selectable UNSELECTING callback
				self._trigger("unselecting", event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().andSelf().each(function() {
			var selectee = $.data(this, "selectable-item");
			if (selectee) {
				var doSelect = !event.metaKey || !selectee.$element.hasClass('ui-selected');
				selectee.$element
					.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
					.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				// selectable (UN)SELECTING callback
				if (doSelect) {
					self._trigger("selecting", event, {
						selecting: selectee.element
					});
				} else {
					self._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {
		var self = this;
		this.dragged = true;

		if (this.options.disabled)
			return;

		var options = this.options;

		var x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
		if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});

		this.selectees.each(function() {
			var selectee = $.data(this, "selectable-item");
			//prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element == self.element[0])
				return;
			var hit = false;
			if (options.tolerance == 'touch') {
				hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
			} else if (options.tolerance == 'fit') {
				hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
			}

			if (hit) {
				// SELECT
				if (selectee.selected) {
					selectee.$element.removeClass('ui-selected');
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass('ui-unselecting');
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass('ui-selecting');
					selectee.selecting = true;
					// selectable SELECTING callback
					self._trigger("selecting", event, {
						selecting: selectee.element
					});
				}
			} else {
				// UNSELECT
				if (selectee.selecting) {
					if (event.metaKey && selectee.startselected) {
						selectee.$element.removeClass('ui-selecting');
						selectee.selecting = false;
						selectee.$element.addClass('ui-selected');
						selectee.selected = true;
					} else {
						selectee.$element.removeClass('ui-selecting');
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass('ui-unselecting');
							selectee.unselecting = true;
						}
						// selectable UNSELECTING callback
						self._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey && !selectee.startselected) {
						selectee.$element.removeClass('ui-selected');
						selectee.selected = false;

						selectee.$element.addClass('ui-unselecting');
						selectee.unselecting = true;
						// selectable UNSELECTING callback
						self._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var self = this;

		this.dragged = false;

		var options = this.options;

		$('.ui-unselecting', this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass('ui-unselecting');
			selectee.unselecting = false;
			selectee.startselected = false;
			self._trigger("unselected", event, {
				unselected: selectee.element
			});
		});
		$('.ui-selecting', this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass('ui-selecting').addClass('ui-selected');
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			self._trigger("selected", event, {
				selected: selectee.element
			});
		});
		this._trigger("stop", event);

		this.helper.remove();

		return false;
	}

});

$.extend($.ui.selectable, {
	version: "1.8.16"
});

})(jQuery);

/*
 * jQuery UI Sortable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Sortables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.sortable", $.ui.mouse, {
	widgetEventPrefix: "sort",
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: 'auto',
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: '> *',
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000
	},
	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass("ui-sortable");

		//Get the items
		this.refresh();

		//Let's determine if the items are being displayed horizontally
		this.floating = this.items.length ? o.axis === 'x' || (/left|right/).test(this.items[0].item.css('float')) || (/inline|table-cell/).test(this.items[0].item.css('display')) : false;

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

	},

	destroy: function() {
		this.element
			.removeClass("ui-sortable ui-sortable-disabled")
			.removeData("sortable")
			.unbind(".sortable");
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- )
			this.items[i].item.removeData("sortable-item");

		return this;
	},

	_setOption: function(key, value){
		if ( key === "disabled" ) {
			this.options[ key ] = value;
	
			this.widget()
				[ value ? "addClass" : "removeClass"]( "ui-sortable-disabled" );
		} else {
			// Don't call widget base _setOption for disable as it adds ui-state-disabled class
			$.Widget.prototype._setOption.apply(this, arguments);
		}
	},

	_mouseCapture: function(event, overrideHandle) {

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type == 'static') return false;

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		var currentItem = null, self = this, nodes = $(event.target).parents().each(function() {
			if($.data(this, 'sortable-item') == self) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, 'sortable-item') == self) currentItem = $(event.target);

		if(!currentItem) return false;
		if(this.options.handle && !overrideHandle) {
			var validHandle = false;

			$(this.options.handle, currentItem).find("*").andSelf().each(function() { if(this == event.target) validHandle = true; });
			if(!validHandle) return false;
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var o = this.options, self = this;
		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css("position", "absolute");
		this.cssPosition = this.helper.css("position");

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
		if(this.helper[0] != this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		if(o.cursor) { // cursor option
			if ($('body').css("cursor")) this._storedCursor = $('body').css("cursor");
			$('body').css("cursor", o.cursor);
		}

		if(o.opacity) { // opacity option
			if (this.helper.css("opacity")) this._storedOpacity = this.helper.css("opacity");
			this.helper.css("opacity", o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css("zIndex")) this._storedZIndex = this.helper.css("zIndex");
			this.helper.css("zIndex", o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML')
			this.overflowOffset = this.scrollParent.offset();

		//Call callbacks
		this._trigger("start", event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions)
			this._cacheHelperProportions();


		//Post 'activate' events to possible containers
		if(!noActivation) {
			 for (var i = this.containers.length - 1; i >= 0; i--) { this.containers[i]._trigger("activate", event, self._uiHash(this)); }
		}

		//Prepare possible droppables
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.dragging = true;

		this.helper.addClass("ui-sortable-helper");
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			var o = this.options, scrolled = false;
			if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;

			} else {

				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);

				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
				$.ui.ddmanager.prepareOffsets(this, event);
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo("absolute");

		//Set the helper position
		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';

		//Rearrange
		for (var i = this.items.length - 1; i >= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);
			if (!intersection) continue;

			if(itemElement != this.currentItem[0] //cannot intersect with itself
				&&	this.placeholder[intersection == 1 ? "next" : "prev"]()[0] != itemElement //no useless actions that have been done before
				&&	!$.ui.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked
				&& (this.options.type == 'semi-dynamic' ? !$.ui.contains(this.element[0], itemElement) : true)
				//&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container
			) {

				this.direction = intersection == 1 ? "down" : "up";

				if (this.options.tolerance == "pointer" || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger("change", event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		//Call callbacks
		this._trigger('sort', event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) return;

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			$.ui.ddmanager.drop(this, event);

		if(this.options.revert) {
			var self = this;
			var cur = self.placeholder.offset();

			self.reverting = true;

			$(this.helper).animate({
				left: cur.left - this.offset.parent.left - self.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
				top: cur.top - this.offset.parent.top - self.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
			}, parseInt(this.options.revert, 10) || 500, function() {
				self._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		var self = this;

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper == "original")
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			else
				this.currentItem.show();

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i >= 0; i--){
				this.containers[i]._trigger("deactivate", null, self._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", null, self._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			if(this.options.helper != "original" && this.helper && this.helper[0].parentNode) this.helper.remove();

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var str = []; o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));
			if(res) str.push((o.key || res[1]+'[]')+'='+(o.key && o.expression ? res[1] : res[2]));
		});

		if(!str.length && o.key) {
			str.push(o.key + '=');
		}

		return str.join('&');

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var ret = []; o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || 'id') || ''); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height;

		var l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height;

		var dyClick = this.offset.click.top,
			dxClick = this.offset.click.left;

		var isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;

		if(	   this.options.tolerance == "pointer"
			|| this.options.forcePointerForContainers
			|| (this.options.tolerance != "pointer" && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height'])
		) {
			return isOverElement;
		} else {

			return (l < x1 + (this.helperProportions.width / 2) // Right Half
				&& x2 - (this.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (this.helperProportions.height / 2) // Bottom Half
				&& y2 - (this.helperProportions.height / 2) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight && isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement)
			return false;

		return this.floating ?
			( ((horizontalDirection && horizontalDirection == "right") || verticalDirection == "down") ? 2 : 1 )
			: ( verticalDirection && (verticalDirection == "down" ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating && horizontalDirection) {
			return ((horizontalDirection == "right" && isOverRightHalf) || (horizontalDirection == "left" && !isOverRightHalf));
		} else {
			return verticalDirection && ((verticalDirection == "down" && isOverBottomHalf) || (verticalDirection == "up" && !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta != 0 && (delta > 0 ? "down" : "up");
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta != 0 && (delta > 0 ? "right" : "left");
	},

	refresh: function(event) {
		this._refreshItems(event);
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor == String
			? [options.connectWith]
			: options.connectWith;
	},
	
	_getItemsAsjQuery: function(connected) {

		var self = this;
		var items = [];
		var queries = [];
		var connectWith = this._connectWith();

		if(connectWith && connected) {
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], 'sortable');
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), inst]);
					}
				};
			};
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), this]);

		for (var i = queries.length - 1; i >= 0; i--){
			queries[i][0].each(function() {
				items.push(this);
			});
		};

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(":data(sortable-item)");

		for (var i=0; i < this.items.length; i++) {

			for (var j=0; j < list.length; j++) {
				if(list[j] == this.items[i].item[0])
					this.items.splice(i,1);
			};

		};

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];
		var items = this.items;
		var self = this;
		var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];
		var connectWith = this._connectWith();

		if(connectWith) {
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], 'sortable');
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				};
			};
		}

		for (var i = queries.length - 1; i >= 0; i--) {
			var targetData = queries[i][1];
			var _queries = queries[i][0];

			for (var j=0, queriesLength = _queries.length; j < queriesLength; j++) {
				var item = $(_queries[j]);

				item.data('sortable-item', targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			};
		};

	},

	refreshPositions: function(fast) {

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
		if(this.offsetParent && this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		for (var i = this.items.length - 1; i >= 0; i--){
			var item = this.items[i];

			//We ignore calculating positions of all connected containers when we're not over them
			if(item.instance != this.currentContainer && this.currentContainer && item.item[0] != this.currentItem[0])
				continue;

			var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			var p = t.offset();
			item.left = p.left;
			item.top = p.top;
		};

		if(this.options.custom && this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (var i = this.containers.length - 1; i >= 0; i--){
				var p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			};
		}

		return this;
	},

	_createPlaceholder: function(that) {

		var self = that || this, o = self.options;

		if(!o.placeholder || o.placeholder.constructor == String) {
			var className = o.placeholder;
			o.placeholder = {
				element: function() {

					var el = $(document.createElement(self.currentItem[0].nodeName))
						.addClass(className || self.currentItem[0].className+" ui-sortable-placeholder")
						.removeClass("ui-sortable-helper")[0];

					if(!className)
						el.style.visibility = "hidden";

					return el;
				},
				update: function(container, p) {

					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className && !o.forcePlaceholderSize) return;

					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(self.currentItem.innerHeight() - parseInt(self.currentItem.css('paddingTop')||0, 10) - parseInt(self.currentItem.css('paddingBottom')||0, 10)); };
					if(!p.width()) { p.width(self.currentItem.innerWidth() - parseInt(self.currentItem.css('paddingLeft')||0, 10) - parseInt(self.currentItem.css('paddingRight')||0, 10)); };
				}
			};
		}

		//Create the placeholder
		self.placeholder = $(o.placeholder.element.call(self.element, self.currentItem));

		//Append it after the actual current item
		self.currentItem.after(self.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(self, self.placeholder);

	},

	_contactContainers: function(event) {
		
		// get innermost container that intersects with item 
		var innermostContainer = null, innermostIndex = null;		
		
		
		for (var i = this.containers.length - 1; i >= 0; i--){

			// never consider a container that's located within the item itself 
			if($.ui.contains(this.currentItem[0], this.containers[i].element[0]))
				continue;

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we've already found a container and it's more "inner" than this, then continue 
				if(innermostContainer && $.ui.contains(this.containers[i].element[0], innermostContainer.element[0]))
					continue;

				innermostContainer = this.containers[i]; 
				innermostIndex = i;
					
			} else {
				// container doesn't intersect. trigger "out" event if necessary 
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}
		
		// if no intersecting containers found, return 
		if(!innermostContainer) return; 

		// move the item into the container if it's not there already
		if(this.containers.length === 1) {
			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} else if(this.currentContainer != this.containers[innermostIndex]) { 

			//When entering a new container, we will find the item with the least distance and append our item near it 
			var dist = 10000; var itemWithLeastDistance = null; var base = this.positionAbs[this.containers[innermostIndex].floating ? 'left' : 'top']; 
			for (var j = this.items.length - 1; j >= 0; j--) { 
				if(!$.ui.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue; 
				var cur = this.items[j][this.containers[innermostIndex].floating ? 'left' : 'top']; 
				if(Math.abs(cur - base) < dist) { 
					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j]; 
				} 
			} 

			if(!itemWithLeastDistance && !this.options.dropOnEmpty) //Check if dropOnEmpty is enabled 
				return; 

			this.currentContainer = this.containers[innermostIndex]; 
			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true); 
			this._trigger("change", event, this._uiHash()); 
			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this)); 

			//Update the placeholder 
			this.options.placeholder.update(this.currentContainer, this.placeholder); 
		
			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this)); 
			this.containers[innermostIndex].containerCache.over = 1;
		} 
	
		
	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == 'clone' ? this.currentItem.clone() : this.currentItem);

		if(!helper.parents('body').length) //Add the helper to the DOM if that didn't happen already
			$(o.appendTo != 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);

		if(helper[0] == this.currentItem[0])
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };

		if(helper[0].style.width == '' || o.forceHelperSize) helper.width(this.currentItem.width());
		if(helper[0].style.height == '' || o.forceHelperSize) helper.height(this.currentItem.height());

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			0 - this.offset.relative.left - this.offset.parent.left,
			0 - this.offset.relative.top - this.offset.parent.top,
			$(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			var ce = $(o.containment)[0];
			var co = $(o.containment).offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition == 'relative' && !(this.scrollParent[0] != document && this.scrollParent[0] != this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? (!(top - this.offset.click.top < this.containment[1] || top - this.offset.click.top > this.containment[3]) ? top : (!(top - this.offset.click.top < this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? (!(left - this.offset.click.left < this.containment[0] || left - this.offset.click.left > this.containment[2]) ? left : (!(left - this.offset.click.left < this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == 'down' ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var self = this, counter = this.counter;

		window.setTimeout(function() {
			if(counter == self.counter) self.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
		},0);

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var delayedTriggers = [], self = this;

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort && this.currentItem.parent().length) this.placeholder.before(this.currentItem);
		this._noFinalSort = null;

		if(this.helper[0] == this.currentItem[0]) {
			for(var i in this._storedCSS) {
				if(this._storedCSS[i] == 'auto' || this._storedCSS[i] == 'static') this._storedCSS[i] = '';
			}
			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside && !noPropagation) delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
		if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !noPropagation) delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
		if(!$.ui.contains(this.element[0], this.currentItem[0])) { //Node was moved out of the current element
			if(!noPropagation) delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
			for (var i = this.containers.length - 1; i >= 0; i--){
				if($.ui.contains(this.containers[i].element[0], this.currentItem[0]) && !noPropagation) {
					delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
					delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.containers[i]));
				}
			};
		};

		//Post events to containers
		for (var i = this.containers.length - 1; i >= 0; i--){
			if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if(this._storedCursor) $('body').css("cursor", this._storedCursor); //Reset cursor
		if(this._storedOpacity) this.helper.css("opacity", this._storedOpacity); //Reset opacity
		if(this._storedZIndex) this.helper.css("zIndex", this._storedZIndex == 'auto' ? '' : this._storedZIndex); //Reset z-index

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
				for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}
			return false;
		}

		if(!noPropagation) this._trigger("beforeStop", event, this._uiHash());

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;

		if(!noPropagation) {
			for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
			this._trigger("stop", event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(inst) {
		var self = inst || this;
		return {
			helper: self.helper,
			placeholder: self.placeholder || $([]),
			position: self.position,
			originalPosition: self.originalPosition,
			offset: self.positionAbs,
			item: self.currentItem,
			sender: inst ? inst.element : null
		};
	}

});

$.extend($.ui.sortable, {
	version: "1.8.16"
});

})(jQuery);

(function($, undefined) {

    // used to prevent race conditions with remote data sources
    var requestIndex = 0;

    $.widget("ui.wafAutoCompleteTemplate", {
        options: {
            appendTo: "body",
            autoFocus: false,
            delay: 300,
            minlength: 0,
            position: {
                my: "left top",
                at: "left bottom",
                collision: "flip"
            },
            source: null
        },

        pending: 0,

        _create: function() {
            var self = this;

            this._initElement();
            this._initSource();
            this.response = function() {
                return self._response.apply(self, arguments);
            };
            this._initMenu();

            if($.fn.bgiframe) {
                this.menu.element.bgiframe();
            }
        },

        _initElement: function(){
            var self = this,
                suppressKeyPress;

            this.element
                .addClass("ui-autocomplete-input")
                .attr("autocomplete", "off")                
                .attr({
                    role: "textbox",
                    "aria-autocomplete": "list",
                    "aria-haspopup": "true"
                })
                .bind("keydown.wafAutoCompleteTemplate", function(event) {
                    if(self.options.disabled || self.element.propAttr("readOnly")) {
                        return;
                    }

                    suppressKeyPress = false;
                    var keyCode = $.ui.keyCode;
                    switch(event.keyCode) {
                    case keyCode.PAGE_UP:
                        self._move("previousPage", event);
                        event.preventDefault();
                        break;
                    case keyCode.PAGE_DOWN:
                        self._move("nextPage", event);
                        event.preventDefault();
                        break;
                    case keyCode.UP:
                        self._move("previous", event);
                        // prevent moving cursor to beginning of text field in some browsers
                        event.preventDefault();
                        break;
                    case keyCode.DOWN:
                        self._move("next", event);
                        // prevent moving cursor to end of text field in some browsers
                        event.preventDefault();
                        break;
                    case keyCode.ENTER:
                    case keyCode.NUMPAD_ENTER:
                        // when menu is open and has focus
                        if(self.menu.active) {
                            // #6055 - Opera still allows the keypress to occur
                            // which causes forms to submit
                            suppressKeyPress = true;
                            event.preventDefault();
                            event.stopPropagation();
                        }
                        //passthrough - ENTER and TAB both select the current element
                    case keyCode.TAB:
                        if(!self.menu.active) {
                            return;
                        }
                        self.menu.select(event);
                        break;
                    case keyCode.ESCAPE:
                        self.element.val(self.term);
                        self.close(event);
                        break;
                    default:
                        // keypress is triggered before the input value is changed
                        clearTimeout(self.searching);
                        self.searching = setTimeout(function() {
                            // only search if the value has changed
                            if(self.term != self.element.val()) {
                                self.selectedItem = null;
                                self.search(null, event);
                            }
                        }, self.options.delay);
                        break;
                    }
                })
                .bind("keypress.wafAutoCompleteTemplate", function(event) {
                    if(suppressKeyPress) {
                        suppressKeyPress = false;
                        event.preventDefault();
                    }
                })
                .bind("focus.wafAutoCompleteTemplate", function() {
                    if(self.options.disabled) {
                        return;
                    }

                    self.selectedItem = null;
                    self.previous = self.element.val();
                })
                .bind("blur.wafAutoCompleteTemplate", function(event) {
                    if(self.options.disabled) {
                        return;
                    }

                    clearTimeout(self.searching);
                    // clicks on the menu (or a button to trigger a search) will cause a blur event
                    self.closing = setTimeout(function() {
                        self.close(event);
                        self._change(event);
                    }, 150);
                });
        },

        _initMenu: function(){
            var self = this,
                doc = this.element[0].ownerDocument;

            this.menu = $("<ul></ul>")
                .addClass("ui-autocomplete")
                .appendTo(this.options.appendTo || $("body", doc)[0])
                // prevent the close-on-blur in case of a "slow" click on the menu (long mousedown)
                .mousedown(function(event) {
                    // clicking on the scrollbar causes focus to shift to the body
                    // but we can't detect a mouseup or a click immediately afterward
                    // so we have to track the next mousedown and close the menu if
                    // the user clicks somewhere outside of the autocomplete
                    var menuElement = self.menu.element[0];
                    if(!$(event.target).closest(".ui-menu-item").length) {
                        setTimeout(function() {
                            $(document).one('mousedown', function(event) {
                                if(event.target !== self.element[0] && event.target !== menuElement 
                                    && !$.ui.contains(menuElement, event.target)) {
                                    self.close();
                                }
                            });
                        }, 1);
                    }

                    // use another timeout to make sure the blur-event-handler on the input was already triggered
                    setTimeout(function() {
                        clearTimeout(self.closing);
                    }, 13);
                }).menuForAutocomplete({
                    focus: function( event, ui ) {
                        var item = self._getItemData(ui.item);
                        if ( false !== self._trigger( "onfocus", event, { item: item } ) ) {
                            // use value to match what will end up in the input, if it was a key event
                            if ( /^key/.test(event.originalEvent.type) ) {
                                self._setValue(item, "focus");
                            }
                        }
                    },
                    selected: function( event, ui ) {
                        var item = self._getItemData(ui.item),
                            previous = self.previous;

                        // only trigger when focus was lost (click on menu)
                        if ( self.element[0] !== doc.activeElement ) {
                            self.element.focus();
                            self.previous = previous;
                            // #6109 - IE triggers two focus events and the second
                            // is asynchronous, so we need to reset the previous
                            // term synchronously and asynchronously :-(
                            setTimeout(function() {
                                self.previous = previous;
                                self.selectedItem = item;
                            }, 1);
                        }

                        if ( false !== self._trigger( "onselect", event, { item: item } ) ) {
                            self._setValue(item, "select");
                        }
                        // reset the term after the select event
                        // this allows custom select handling to work properly
                        self.term = self.element.val();

                        self.close( event );
                        self.selectedItem = item;
                    },
                    blur: function( event, ui ) {
                        // don't set the value of the text field if it's already correct
                        // this prevents moving the cursor unnecessarily
                        if ( self.menu.element.is(":visible") &&
                            ( self.element.val() !== self.term ) ) {
                            self.element.val( self.term );
                        }
                    }
                }).zIndex(this.element.zIndex() + 1)
                // workaround for jQuery bug #5781 http://dev.jquery.com/ticket/5781
                .css({
                    top: 0,
                    left: 0
                }).hide().data("menuForAutocomplete");
        },

        _getItemData: function(item){
            return item.data("item.wafAutoCompleteTemplate");
        },

        _setValue: function(item, type) {
            this.element.val(item.value);
        },

        destroy: function() {
            this.element
                .removeClass("ui-autocomplete-input")
                .removeAttr("autocomplete")
                .removeAttr("role")
                .removeAttr("aria-autocomplete")
                .removeAttr("aria-haspopup");
            this.menu.element.remove();
            $.Widget.prototype.destroy.call(this);
        },

        _setOption: function(key, value) {
            $.Widget.prototype._setOption.apply(this, arguments);
            if(key === "source") {
                this._initSource();
            }
            if(key === "appendTo") {
                this.menu.element.appendTo( $( value || "body", this.element[0].ownerDocument )[0] );
            }
            if(key === "disabled" && value && this.xhr) {
                this.xhr.abort();
            }
        },

        _initSource: function() {
            var self = this,
                array, url;
            if($.isArray(this.options.source)) {
                array = this.options.source;
                this.source = function(request, response) {
                    response($.wafAutoCompleteTools.filter(array, request.term));
                };
            } else if(typeof this.options.source === "string") {
                url = this.options.source;
                this.source = function(request, response) {
                    if(self.xhr) {
                        self.xhr.abort();
                    }
                    self.xhr = $.ajax({
                        url: url,
                        data: request,
                        dataType: "json",
                        autocompleteRequest: ++requestIndex,
                        success: function(data, status) {
                            if(this.autocompleteRequest === requestIndex) {
                                response(data);
                            }
                        },
                        error: function() {
                            if(this.autocompleteRequest === requestIndex) {
                                response([]);
                            }
                        }
                    });
                };
            } else {
                this.source = this.options.source;
            }
        },

        search: function(value, event) {
            value = value != null ? value : this.element.val();

            // always save the actual value, not the one passed as an argument
            this.term = this.element.val();

            if(value.length < this.options.minlength) {
                return this.close(event);
            }

            clearTimeout(this.closing);
            if(this._trigger("onsearch", event) === false) {
                return;
            }

            return this._search(value);
        },

        _search: function(value) {
            this._block(true);
            this.source({term: value}, this.response);
        },

        _block: function(isLoading){
            if(isLoading){
                this.pending++;
                this.element.addClass("ui-autocomplete-loading");
            }else{
                this.pending--;
                if(!this.pending) {
                    this.element.removeClass("ui-autocomplete-loading");
                }
            }
        },

        _response: function(content) {
            if(!this.options.disabled && content && content.length) {
                content = this._normalize(content);
                this._suggest(content);
                this._trigger("onopen");
            } else {
                this.close();
            }
            this._block(false);
        },

        close: function(event) {
            clearTimeout(this.closing);
            if(this.menu.element.is(":visible")) {
                this.menu.element.hide();
                this.menu.deactivate();
                this._trigger("onclose", event);
            }
        },

        _change: function( event ) {
            if ( this.previous !== this.element.val() ) {
                this._trigger( "onchange", event, { item: this.selectedItem } );
            }
        },

        _normalize: function(items) {
            // assume all items have the right format when the first item is complete
            if(items.length && items[0].label && items[0].value) {
                return items;
            }
            return $.map(items, function(item) {
                if(typeof item === "string") {
                    return {
                        label: item,
                        value: item
                    };
                }
                return $.extend({
                    label: item.label || item.value,
                    value: item.value || item.label
                }, item);
            });
        },

        _suggest: function(items) {
            var ul = this.menu.element.empty().zIndex(this.element.zIndex() + 1),
                pos = this._getPosition();

            this._renderMenu(ul, items);
            // TODO refresh should check if the active item is still in the dom, removing the need for a manual deactivate
            this.menu.deactivate();
            this.menu.refresh();

            // size and position menu
            ul.show();
            this._resizeMenu();
            ul.position(pos);

            if(this.options.autoFocus) {
                this.menu.next(new $.Event("mouseover"));
            }
        },

        _getPosition: function(){
            return $.extend({
                of: this.element
            }, this.options.position );
        },

        _resizeMenu: function() {
            var ul = this.menu.element;
            ul.outerWidth( Math.max(
                ul.width( "" ).outerWidth(),
                this.element.outerWidth()
            ) );
        },

        _renderMenu: function( ul, items ) {
            var self = this;
            $.each( items, function( index, item ) {
                self._renderItem( ul, item );
            });
        },

        _renderItem: function( ul, item) {
            return $( "<li></li>" )
                .data( "item.wafAutoCompleteTemplate", item )
                .append( $( "<a></a>" ).text( item.label ) )
                .appendTo( ul );
        },

        _move: function(direction, event) {
            if(!this.menu.element.is(":visible")) {
                this.search(null, event);
                return;
            }
            if(this.menu.first() && /^previous/.test(direction) || this.menu.last() && /^next/.test(direction)) {
                this.element.val(this.term);
                this.menu.deactivate();
                return;
            }
            this.menu[direction](event);
        },

        widget: function() {
            return this.menu.element;
        }
    });

    $.wafAutoCompleteTools = $.wafAutoCompleteTools || {};
    $.extend($.wafAutoCompleteTools, {
        escapeRegex: function(value) {
            return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        },
        filter: function(array, term) {
            var matcher = new RegExp($.wafAutoCompleteTools.escapeRegex(term), "i");
            return $.grep(array, function(value) {
                return matcher.test(value.label || value.value || value);
            });
        }
    });
}(jQuery));
/*
 * jQuery UI Menu (not officially released)
 *
 * This widget isn't yet finished and the API is subject to change. We plan to finish
 * it for the next release. You're welcome to give it a try anyway and give us feedback,
 * as long as you're okay with migrating your code later on. We can help with that, too.
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Menu
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 */
(function($) {

    $.widget("ui.menuForAutocomplete", {
        _create: function() {
            var self = this;
            this.element
                .addClass("ui-menu ui-widget ui-widget-content ui-corner-all")
                .attr({
                role: "listbox",
                "aria-activedescendant": "ui-active-menuitem"
                })
                .click(function (event) {
                if(!$(event.target).closest(".ui-menu-item a").length) {
                    return;
                }
                // temporary
                event.preventDefault();
                event.stopPropagation();
                self.select(event);
            });
            this.refresh();
        },

        refresh: function() {
            var self = this;

            // don't refresh list items that are already adapted
            var items = this.element.children("li:not(.ui-menu-item):has(a)")
                .addClass("ui-menu-item")
                .attr("role", "menuitem");

            items.children("a")
                .addClass("ui-corner-all")
                .attr("tabindex", -1)
            // mouseenter doesn't work with event delegation
            .mouseenter(function(event) {
                self.activate(event, $(this).parent());
                })
                .mouseleave(function () {
                self.deactivate();
            });
        },

        activate: function(event, item) {
            this.deactivate();
            if(this.hasScroll()) {
                var offset = item.offset().top - this.element.offset().top,
                    scroll = this.element.scrollTop(),
                    elementHeight = this.element.height();
                if(offset < 0) {
                    this.element.scrollTop(scroll + offset);
                } else if(offset >= elementHeight) {
                    this.element.scrollTop(scroll + offset - elementHeight + item.height());
                }
            }
            this.active = item.eq(0)
                .children("a")
                .addClass("ui-state-hover")
                .attr("id", "ui-active-menuitem")
                .end();
            this._trigger("focus", event, { item:item });
        },

        deactivate: function() {
            if(!this.active) {
                return;
            }

            this.active.children("a")
                .removeClass("ui-state-hover")
                .removeAttr("id");
            this._trigger("blur");
            this.active = null;
        },

        next: function(event) {
            this.move("next", ".ui-menu-item:first", event);
        },

        previous: function(event) {
            this.move("prev", ".ui-menu-item:last", event);
        },

        first: function() {
            return this.active && !this.active.prevAll(".ui-menu-item").length;
        },

        last: function() {
            return this.active && !this.active.nextAll(".ui-menu-item").length;
        },

        move: function(direction, edge, event) {
            if(!this.active) {
                this.activate(event, this.element.children(edge));
                return;
            }
            var next = this.active[direction + "All"](".ui-menu-item").eq(0);
            if(next.length) {
                this.activate(event, next);
            } else {
                this.activate(event, this.element.children(edge));
            }
        },

        // TODO merge with previousPage
        nextPage: function(event) {
            if(this.hasScroll()) {
                // TODO merge with no-scroll-else
                if(!this.active || this.last()) {
                    this.activate(event, this.element.children(".ui-menu-item:first"));
                    return;
                }
                var base = this.active.offset().top,
                    height = this.element.height(),
                    result = this.element.children(".ui-menu-item").filter(function() {
                        var close = $(this).offset().top - base - height + $(this).height();
                        // TODO improve approximation
                        return close < 10 && close > -10;
                    });

                // TODO try to catch this earlier when scrollTop indicates the last page anyway
                if(!result.length) {
                    result = this.element.children(".ui-menu-item:last");
                }
                this.activate(event, result);
            } else {
                this.activate(event, this.element.children(".ui-menu-item")
                    .filter(!this.active || this.last() ? ":first" : ":last"));
            }
        },

        // TODO merge with nextPage
        previousPage: function(event) {
            if(this.hasScroll()) {
                // TODO merge with no-scroll-else
                if(!this.active || this.first()) {
                    this.activate(event, this.element.children(".ui-menu-item:last"));
                    return;
                }

                var base = this.active.offset().top,
                    height = this.element.height();
                result = this.element.children(".ui-menu-item").filter(function() {
                    var close = $(this).offset().top - base + height - $(this).height();
                    // TODO improve approximation
                    return close < 10 && close > -10;
                });

                // TODO try to catch this earlier when scrollTop indicates the last page anyway
                if(!result.length) {
                    result = this.element.children(".ui-menu-item:first");
                }
                this.activate(event, result);
            } else {
                this.activate(event, this.element.children(".ui-menu-item")
                    .filter(!this.active || this.first() ? ":last" : ":first"));
            }
        },

        hasScroll: function() {
            return this.element.height() < this.element[$.fn.prop ? "prop" : "attr"]("scrollHeight");
        },

        select: function(event) {
            this._trigger("selected", event, {
                item: this.active
            });
        }
    });
}(jQuery));
/*
 * jQuery UI Button 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Button
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var lastActive, startXPos, startYPos, clickDragged,
	baseClasses = "ui-button ui-widget ui-lb-default ui-corner-all",
	stateClasses = "ui-state-hover ui-state-active ",
	typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
	formResetHandler = function() {
		var buttons = $( this ).find( ":ui-button" );
		setTimeout(function() {
			buttons.button( "refresh" );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			if ( form ) {
				radios = $( form ).find( "[name='" + name + "']" );
			} else {
				radios = $( "[name='" + name + "']", radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( "ui.button", {
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( "form" )
			.unbind( "reset.button" )
			.bind( "reset.button", formResetHandler );

		if ( typeof this.options.disabled !== "boolean" ) {
			this.options.disabled = this.element.propAttr( "disabled" );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( "title" );

		var self = this,
			options = this.options,
			toggleButton = this.type === "checkbox" || this.type === "radio",
			hoverClass = "ui-state-hover" + ( !toggleButton ? " ui-state-active" : "" ),
			focusClass = "ui-state-focus";

		if ( options.label === null ) {
			options.label = this.buttonElement.html();
		}

		if ( this.element.is( ":disabled" ) ) {
			options.disabled = true;
		}

		this.buttonElement
			.addClass( baseClasses )
			.attr( "role", "button" )
			.bind( "mouseenter.button", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( "ui-state-hover" );
				if ( this === lastActive ) {
					$( this ).addClass( "ui-state-active" );
				}
			})
			.bind( "mouseleave.button", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( hoverClass );
			})
			.bind( "click.button", function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		this.element
			.bind( "focus.button", function() {
				// no need to check disabled, focus won't be triggered anyway
				self.buttonElement.addClass( focusClass );
			})
			.bind( "blur.button", function() {
				self.buttonElement.removeClass( focusClass );
			});

		if ( toggleButton ) {
			this.element.bind( "change.button", function() {
				if ( clickDragged ) {
					return;
				}
				self.refresh();
			});
			// if mouse moves between mousedown and mouseup (drag) set clickDragged flag
			// prevents issue where button state changes but checkbox/radio checked state
			// does not in Firefox (see ticket #6970)
			this.buttonElement
				.bind( "mousedown.button", function( event ) {
					if ( options.disabled ) {
						return;
					}
					clickDragged = false;
					startXPos = event.pageX;
					startYPos = event.pageY;
				})
				.bind( "mouseup.button", function( event ) {
					if ( options.disabled ) {
						return;
					}
					if ( startXPos !== event.pageX || startYPos !== event.pageY ) {
						clickDragged = true;
					}
			});
		}

		if ( this.type === "checkbox" ) {
			this.buttonElement.bind( "click.button", function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).toggleClass( "ui-state-active" );
				self.buttonElement.attr( "aria-pressed", self.element[0].checked );
			});
		} else if ( this.type === "radio" ) {
			this.buttonElement.bind( "click.button", function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).addClass( "ui-state-active" );
				self.buttonElement.attr( "aria-pressed", "true" );

				var radio = self.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( "widget" )[ 0 ];
					})
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			});
		} else {
			this.buttonElement
				.bind( "mousedown.button", function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					lastActive = this;
					$( document ).one( "mouseup", function() {
						lastActive = null;
					});
				})
				.bind( "mouseup.button", function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( "ui-state-active" );
				})
				.bind( "keydown.button", function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode == $.ui.keyCode.SPACE || event.keyCode == $.ui.keyCode.ENTER ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				.bind( "keyup.button", function() {
					$( this ).removeClass( "ui-state-active" );
				});

			if ( this.buttonElement.is("a") ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn't work)
						$( this ).click();
					}
				});
			}
		}

		// TODO: pull out $.Widget's handling for the disabled option into
		// $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
		// be overridden by individual plugins
		this._setOption( "disabled", options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {

		if ( this.element.is(":checkbox") ) {
			this.type = "checkbox";
		} else if ( this.element.is(":radio") ) {
			this.type = "radio";
		} else if ( this.element.is("input") ) {
			this.type = "input";
		} else {
			this.type = "button";
		}

		if ( this.type === "checkbox" || this.type === "radio" ) {
			// we don't search against the document in case the element
			// is disconnected from the DOM
			var ancestor = this.element.parents().filter(":last"),
				labelSelector = "label[for='" + this.element.attr("id") + "']";
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( "ui-helper-hidden-accessible" );

			var checked = this.element.is( ":checked" );
			if ( checked ) {
				this.buttonElement.addClass( "ui-state-active" );
			}
			this.buttonElement.attr( "aria-pressed", checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	destroy: function() {
		this.element
			.removeClass( "ui-helper-hidden-accessible" );
		this.buttonElement
			.removeClass( baseClasses + " " + stateClasses + " " + typeClasses )
			.removeAttr( "role" )
			.removeAttr( "aria-pressed" )
			.html( this.buttonElement.find(".ui-button-text").html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( "title" );
		}

		$.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );
		if ( key === "disabled" ) {
			if ( value ) {
				this.element.propAttr( "disabled", true );
			} else {
				this.element.propAttr( "disabled", false );
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		var isDisabled = this.element.is( ":disabled" );
		if ( isDisabled !== this.options.disabled ) {
			this._setOption( "disabled", isDisabled );
		}
		if ( this.type === "radio" ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( ":checked" ) ) {
					$( this ).button( "widget" )
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", "true" );
				} else {
					$( this ).button( "widget" )
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				}
			});
		} else if ( this.type === "checkbox" ) {
			if ( this.element.is( ":checked" ) ) {
				this.buttonElement
					.addClass( "ui-state-active" )
					.attr( "aria-pressed", "true" );
			} else {
				this.buttonElement
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === "input" ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( "<span></span>" )
				.addClass( "ui-button-text" )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary && icons.secondary,
			buttonClasses = [];  

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon-default " + icons.primary + "'>&nbsp;&nbsp;</span>" );
			}

			if ( icons.secondary ) {
				buttonElement.append( "<span class='ui-button-icon-secondary ui-icon-default " + icons.secondary + "'>&nbsp;&nbsp;</span>" );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );

				if ( !this.hasTitle ) {
					buttonElement.attr( "title", buttonText );
				}
			}
		} else {
			buttonClasses.push( "ui-button-text-only" );
		}
		buttonElement.addClass( buttonClasses.join( " " ) );
	}
});

$.widget( "ui.buttonset", {
	options: {
		items: ":button, :submit, :reset, :checkbox, :radio, a, :data(button)"
	},

	_create: function() {
		this.element.addClass( "ui-buttonset" );
	},
	
	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === "disabled" ) {
			this.buttons.button( "option", key, value );
		}

		$.Widget.prototype._setOption.apply( this, arguments );
	},
	
	refresh: function() {
		var ltr = this.element.css( "direction" ) === "ltr";
		
		this.buttons = this.element.find( this.options.items )
			.filter( ":ui-button" )
				.button( "refresh" )
			.end()
			.not( ":ui-button" )
				.button()
			.end()
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
				.filter( ":first" )
					.addClass( ltr ? "ui-corner-left" : "ui-corner-right" )
				.end()
				.filter( ":last" )
					.addClass( ltr ? "ui-corner-right" : "ui-corner-left" )
				.end()
			.end();
	},

	destroy: function() {
		this.element.removeClass( "ui-buttonset" );
		this.buttons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-left ui-corner-right" )
			.end()
			.button( "destroy" );

		$.Widget.prototype.destroy.call( this );
	}
});

}( jQuery ) );

/*
 * jQuery UI Dialog 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Dialog
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *  jquery.ui.button.js
 *	jquery.ui.draggable.js
 *	jquery.ui.mouse.js
 *	jquery.ui.position.js
 *	jquery.ui.resizable.js
 */
(function( $, undefined ) {

var uiDialogClasses =
		'ui-dialog ' +
		'ui-widget ' +
		'ui-widget-content ' +
		'ui-corner-all ',
	sizeRelatedOptions = {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},
	resizableRelatedOptions = {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	},
	// support for jQuery 1.3.2 - handle common attrFn methods for dialog
	attrFn = $.attrFn || {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true,
		click: true
	};

$.widget("ui.dialog", {
	options: {
		autoOpen: true,
		buttons: {},
		closeOnEscape: true,
		closeText: 'close',
		dialogClass: '',
		draggable: true,
		hide: null,
		height: 'auto',
		maxHeight: false,
		maxWidth: false,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: 'center',
			at: 'center',
			collision: 'fit',
			// ensure that the titlebar is never outside the document
			using: function(pos) {
				var topOffset = $(this).css(pos).offset().top;
				if (topOffset < 0) {
					$(this).css('top', pos.top - topOffset);
				}
			}
		},
		resizable: true,
		show: null,
		stack: true,
		title: '',
		width: 300,
		zIndex: 8000
	},

	_create: function() {
		this.originalTitle = this.element.attr('title');
		// #5742 - .attr() might return a DOMElement
		if ( typeof this.originalTitle !== "string" ) {
			this.originalTitle = "";
		}

		this.options.title = this.options.title || this.originalTitle;
		var self = this,
			options = self.options,

			title = options.title || '&#160;',
			titleId = $.ui.dialog.getTitleId(self.element),

			uiDialog = (self.uiDialog = $('<div></div>'))
				.appendTo(document.body)
				.hide()
				.addClass(uiDialogClasses + options.dialogClass)
				.css({
					zIndex: options.zIndex
				})
				// setting tabIndex makes the div focusable
				// setting outline to 0 prevents a border on focus in Mozilla
				.attr('tabIndex', -1).css('outline', 0).keydown(function(event) {
					if (options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
						event.keyCode === $.ui.keyCode.ESCAPE) {
						
						self.close(event);
						event.preventDefault();
					}
				})
				.attr({
					role: 'dialog',
					'aria-labelledby': titleId
				})
				.mousedown(function(event) {
					self.moveToTop(false, event);
				}),

			uiDialogContent = self.element
				.show()
				.removeAttr('title')
				.addClass(
					'ui-dialog-content ' +
					'ui-widget-content')
				.appendTo(uiDialog),

			uiDialogTitlebar = (self.uiDialogTitlebar = $('<div></div>'))
				.addClass(
					'ui-dialog-titlebar ' +
					'ui-widget-header ' +
					'ui-corner-all ' +
					'ui-helper-clearfix'
				)
				.prependTo(uiDialog),

			uiDialogTitlebarClose = $('<a href="#"></a>')
				.addClass(
					'ui-dialog-titlebar-close ' +
					'ui-corner-all'
				)
				.attr('role', 'button')
				.hover(
					function() {
						uiDialogTitlebarClose.addClass('ui-state-hover');
					},
					function() {
						uiDialogTitlebarClose.removeClass('ui-state-hover');
					}
				)
				.focus(function() {
					uiDialogTitlebarClose.addClass('ui-state-focus');
				})
				.blur(function() {
					uiDialogTitlebarClose.removeClass('ui-state-focus');
				})
				.click(function(event) {
					self.close(event);
					return false;
				})
				.appendTo(uiDialogTitlebar),

			uiDialogTitlebarCloseText = (self.uiDialogTitlebarCloseText = $('<span></span>'))
				.addClass(
					'ui-icon ' +
					'ui-icon-closethick'
				)
				.text(options.closeText)
				.appendTo(uiDialogTitlebarClose),

			uiDialogTitle = $('<span></span>')
				.addClass('ui-dialog-title')
				.attr('id', titleId)
				.html(title)
				.prependTo(uiDialogTitlebar);

		//handling of deprecated beforeclose (vs beforeClose) option
		//Ticket #4669 http://dev.jqueryui.com/ticket/4669
		//TODO: remove in 1.9pre
		if ($.isFunction(options.beforeclose) && !$.isFunction(options.beforeClose)) {
			options.beforeClose = options.beforeclose;
		}

		uiDialogTitlebar.find("*").add(uiDialogTitlebar).disableSelection();

		if (options.draggable && $.fn.draggable) {
			self._makeDraggable();
		}
		if (options.resizable && $.fn.resizable) {
			self._makeResizable();
		}

		self._createButtons(options.buttons);
		self._isOpen = false;

		if ($.fn.bgiframe) {
			uiDialog.bgiframe();
		}
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	destroy: function() {
		var self = this;
		
		if (self.overlay) {
			self.overlay.destroy();
            self.overlay = null;
		}
		self.uiDialog.hide();
		self.element
			.unbind('.dialog')
			.removeData('dialog')
			.removeClass('ui-dialog-content ui-widget-content')
			.hide().appendTo('body');
		self.uiDialog.remove();

		if (self.originalTitle) {
			self.element.attr('title', self.originalTitle);
		}

		return self;
	},

	widget: function() {
		return this.uiDialog;
	},

    isLoadding:function(target){
        var overLayerId = "loading-indicator-"+$(this.element).attr("id")+"-overlay";
        if($("#"+overLayerId).length>0) {
            var msg = "";
			if(target&&(target=="max" || target=="min" || target=="close" || target=="move")){
               if(target=="max"){
                   msg=($.window&&$.window.loadding&&$.window.loadding.max)?$.window.loadding.max:"you cannot max window when loadding page!";
                   target = this.element.parent().find(".ui-dialog-titlebar .waf-ui-dialog-titlebar-"+target);
               }else if(target=="min"){
                   msg=($.window&&$.window.loadding&&$.window.loadding.min)?$.window.loadding.min:"you cannot min window when loadding page!";
                   target = this.element.parent().find(".ui-dialog-titlebar .waf-ui-dialog-titlebar-"+target);
               }else if(target=="close"){
                   msg=($.window&&$.window.loadding&&$.window.loadding.close)?$.window.loadding.close:"you cannot close window when loadding page!";
                   target = this.element.parent().find(".ui-dialog-titlebar .waf-ui-dialog-titlebar-"+target);
               }else if(target=="move"){
                   msg=($.window&&$.window.loadding&&$.window.loadding.move)?$.window.loadding.move:"you cannot move window when loadding page!";
                   target = this.element.parent().find(".ui-dialog-titlebar");
               }
			}
            $.popup.showRemind(target,msg);
            return true;
        }
        return false;
    },

	close: function(event) {
		var self = this,
			maxZ, thisZ;

        if(this.isLoadding("close")) return false;

		
		if (false === self._trigger('beforeClose', event)) {
			return;
		}
		//if (this.element[0].id.indexOf("autoDiv") >= 0 || this.element[0].id.indexOf("frameDiv-") >= 0) {
		if($(this.element).hasClass("ui-wafwin")) {
			var targetId = $(this.element).data('curWinTarget.wafwin');

			if(targetId != '') {
				top.win_mgr_Map.remove(targetId);
			} else {
				top.win_mgr_Map.removeLastOne();
			}
			$(this.element).children("iframe").remove();
			$("#postForm").remove();
		}

		if (self.overlay) {
			self.overlay.destroy();
            self.overlay = null;
		}
		self.uiDialog.unbind('keypress.ui-dialog');

		self._isOpen = false;

		if (self.options.hide) {
			self.uiDialog.hide(self.options.hide, function() {
				self._trigger('close', event);
			});
		} else {
			self.uiDialog.hide();
			self._trigger('close', event);
		}

		$.ui.dialog.overlay.resize();

		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		if (self.options.modal) {
			maxZ = 0;
			$('.ui-dialog').each(function() {
				if (this !== self.uiDialog[0]) {
					thisZ = $(this).css('z-index');
					if(!isNaN(thisZ)) {
						maxZ = Math.max(maxZ, thisZ);
					}
				}
			});
			$.ui.dialog.maxZ = maxZ;
		}

		return self;
	},

	isOpen: function() {
		return this._isOpen;
	},

	// the force parameter allows us to move modal dialogs to their correct
	// position on open
	moveToTop: function(force, event) {
		var self = this,
			options = self.options,
			saveScroll;

		if ((options.modal && !force) ||
			(!options.stack && !options.modal)) {
			return self._trigger('focus', event);
		}

		if (options.zIndex > $.ui.dialog.maxZ) {
			$.ui.dialog.maxZ = options.zIndex;
		}
		if (self.overlay) {
			$.ui.dialog.maxZ += 1;
			self.overlay.$el.css('z-index', $.ui.dialog.overlay.maxZ = $.ui.dialog.maxZ);
		}

		//Save and then restore scroll since Opera 9.5+ resets when parent z-Index is changed.
		//  http://ui.jquery.com/bugs/ticket/3193
		saveScroll = { scrollTop: self.element.scrollTop(), scrollLeft: self.element.scrollLeft() };
		$.ui.dialog.maxZ += 1;
		self.uiDialog.css('z-index', $.ui.dialog.maxZ);
		self.element.attr(saveScroll);
		self._trigger('focus', event);

		return self;
	},

	open: function() {
		if (this._isOpen) { return; }

		var self = this,
			options = self.options,
			uiDialog = self.uiDialog;

		self.overlay = options.modal ? new $.ui.dialog.overlay(self) : null;
		self._size();
		self._position(options.position);
		uiDialog.show(options.show);
		self.moveToTop(true);

		// prevent tabbing out of modal dialogs
		if (options.modal) {
			uiDialog.bind('keypress.ui-dialog', function(event) {
				if (event.keyCode !== $.ui.keyCode.TAB) {
					return;
				}

				var tabbables = $(':tabbable', this),
					first = tabbables.filter(':first'),
					last  = tabbables.filter(':last');

				if (event.target === last[0] && !event.shiftKey) {
					first.focus(1);
					return false;
				} else if (event.target === first[0] && event.shiftKey) {
					last.focus(1);
					return false;
				}
			});
		}

		// set focus to the first tabbable element in the content area or the first button
		// if there are no tabbable elements, set focus on the dialog itself
		$(self.element.find(':tabbable').get().concat(
			uiDialog.find('.ui-dialog-buttonpane :tabbable').get().concat(
				uiDialog.get()))).eq(0).focus();

		self._isOpen = true;
		self._trigger('open');

		return self;
	},

	_createButtons: function(buttons) {
		var self = this,
			hasButtons = false,
			uiDialogButtonPane = $('<div></div>')
				.addClass(
					'ui-dialog-buttonpane ' +
					'ui-widget-content ' +
					'ui-helper-clearfix'
				),
			uiButtonSet = $( "<div></div>" )
				.addClass( "ui-dialog-buttonset" )
				.appendTo( uiDialogButtonPane );

		// if we already have a button pane, remove it
		self.uiDialog.find('.ui-dialog-buttonpane').remove();

		if (typeof buttons === 'object' && buttons !== null) {
			$.each(buttons, function() {
				return !(hasButtons = true);
			});
		}
		if (hasButtons) {
			$.each(buttons, function(name, props) {
				props = $.isFunction( props ) ?
					{ click: props, text: name } :
					props;
				var button = $('<button type="button"></button>')
					.click(function() {
						props.click.apply(self.element[0], arguments);
					})
					.appendTo(uiButtonSet);
				// can't use .attr( props, true ) with jQuery 1.3.2.
				$.each( props, function( key, value ) {
					if ( key === "click" ) {
						return;
					}
					if ( key in attrFn ) {
						button[ key ]( value );
					} else {
						button.attr( key, value );
					}
				});
				if ($.fn.button) {
					button.button();
				}
			});
			uiDialogButtonPane.appendTo(self.uiDialog);
		}
	},

	_makeDraggable: function() {
		var self = this,
			options = self.options,
			doc = $(document),
			heightBeforeDrag;

		function filteredUi(ui) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		self.uiDialog.draggable({
			cancel: '.ui-dialog-content, .ui-dialog-titlebar-close',
			handle: '.ui-dialog-titlebar',
			containment: 'document',
			start: function(event, ui) {
				if(self.isLoadding("move")){
				    return false;
				}
                if($(this).length>0){
                    heightBeforeDrag = $(this)[0].style.height === "auto" ? "auto" : $(this).height();
                }else{
                    heightBeforeDrag = options.height === "auto" ? "auto" : $(this).height();
                }
				$(this).height($(this).height()).addClass("ui-dialog-dragging");
				self._trigger('dragStart', event, filteredUi(ui));
			},
			drag: function(event, ui) {
                if(self.isLoadding("move")){
                    return false;
                }
				self._trigger('drag', event, filteredUi(ui));
			},
			stop: function(event, ui) {
                if(self.isLoadding("move")){
                    return false;
                }
				options.position = [ui.position.left - doc.scrollLeft(),
					ui.position.top - doc.scrollTop()];
				$(this).removeClass("ui-dialog-dragging").height(heightBeforeDrag);
				self._trigger('dragStop', event, filteredUi(ui));
				$.ui.dialog.overlay.resize();
			}
		});
	},

	_makeResizable: function(handles) {
		handles = (handles === undefined ? this.options.resizable : handles);
		var self = this,
			options = self.options,
			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = self.uiDialog.css('position'),
			resizeHandles = (typeof handles === 'string' ?
				handles	:
				'n,e,s,w,se,sw,ne,nw'
			);

		function filteredUi(ui) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		self.uiDialog.resizable({
			cancel: '.ui-dialog-content',
			containment: 'document',
			alsoResize: self.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: self._minHeight(),
			handles: resizeHandles,
			start: function(event, ui) {
				$(this).addClass("ui-dialog-resizing");
				self._trigger('resizeStart', event, filteredUi(ui));
			},
			resize: function(event, ui) {
				self._trigger('resize', event, filteredUi(ui));
			},
			stop: function(event, ui) {
				$(this).removeClass("ui-dialog-resizing");
				options.height = $(this).height();
				options.width = $(this).width();
				self._trigger('resizeStop', event, filteredUi(ui));
				$.ui.dialog.overlay.resize();
			}
		})
		.css('position', position)
		.find('.ui-resizable-se').addClass('ui-icon ui-icon-grip-diagonal-se');
	},

	_minHeight: function() {
		var options = this.options;

		if (options.height === 'auto') {
			return options.minHeight;
		} else {
			return Math.min(options.minHeight, options.height);
		}
	},

	_position: function(position) {
		var myAt = [],
			offset = [0, 0],//this.uiDialog.parent().scrollTop()
			isVisible;

		if (position) {
			// deep extending converts arrays to objects in jQuery <= 1.3.2 :-(
	//		if (typeof position == 'string' || $.isArray(position)) {
	//			myAt = $.isArray(position) ? position : position.split(' ');

			if (typeof position === 'string' || (typeof position === 'object' && '0' in position)) {
				myAt = position.split ? position.split(' ') : [position[0], position[1]];
				if (myAt.length === 1) {
					myAt[1] = myAt[0];
				}

				$.each(['left', 'top'], function(i, offsetPosition) {
					if (+myAt[i] === myAt[i]) {
						offset[i] = myAt[i];
						myAt[i] = offsetPosition;
					}
				});

				position = {
					my: myAt.join(" "),
					at: myAt.join(" "),
					offset: offset.join(" ")
				};
			} 

			position = $.extend({}, $.ui.dialog.prototype.options.position, position);
		} else {
			position = $.ui.dialog.prototype.options.position;
		}
		
		//create by liyue
		if(position.offset && position.offset instanceof Array){
			position.offset=position.offset.join(" ");
		}

		// need to show the dialog to get the actual offset in the position plugin
		isVisible = this.uiDialog.is(':visible');
		if (!isVisible) {
			this.uiDialog.show();
		}
		
		
		this.uiDialog
			// workaround for jQuery bug #5781 http://dev.jquery.com/ticket/5781
			.css({ top: 0, left: 0 })
			.position($.extend({ of: window }, position));
			//.position($.extend({ of: this.uiDialog.parent() }, position));
		if (!isVisible) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var self = this,
			resizableOptions = {},
			resize = false;

		$.each( options, function( key, value ) {
			self._setOption( key, value );
			
			if ( key in sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
		}
		if ( this.uiDialog.is( ":data(resizable)" ) ) {
			this.uiDialog.resizable( "option", resizableOptions );
		}
	},

	_setOption: function(key, value){
		var self = this,
			uiDialog = self.uiDialog;

		switch (key) {
			//handling of deprecated beforeclose (vs beforeClose) option
			//Ticket #4669 http://dev.jqueryui.com/ticket/4669
			//TODO: remove in 1.9pre
			case "beforeclose":
				key = "beforeClose";
				break;
			case "buttons":
				self._createButtons(value);
				break;
			case "closeText":
				// ensure that we always pass a string
				self.uiDialogTitlebarCloseText.text("" + value);
				break;
			case "dialogClass":
				uiDialog
					.removeClass(self.options.dialogClass)
					.addClass(uiDialogClasses + value);
				break;
			case "disabled":
				if (value) {
					uiDialog.addClass('ui-dialog-disabled');
				} else {
					uiDialog.removeClass('ui-dialog-disabled');
				}
				break;
			case "draggable":
				var isDraggable = uiDialog.is( ":data(draggable)" );
				if ( isDraggable && !value ) {
					uiDialog.draggable( "destroy" );
				}
				
				if ( !isDraggable && value ) {
					self._makeDraggable();
				}
				break;
			case "position":
				self._position(value);
				break;
			case "resizable":
				// currently resizable, becoming non-resizable
				var isResizable = uiDialog.is( ":data(resizable)" );
				if (isResizable && !value) {
					uiDialog.resizable('destroy');
				}

				// currently resizable, changing handles
				if (isResizable && typeof value === 'string') {
					uiDialog.resizable('option', 'handles', value);
				}

				// currently non-resizable, becoming resizable
				if (!isResizable && value !== false) {
					self._makeResizable(value);
				}
				break;
			case "title":
				// convert whatever was passed in o a string, for html() to not throw up
				$(".ui-dialog-title", self.uiDialogTitlebar).html("" + (value || '&#160;'));
				break;
		}

		$.Widget.prototype._setOption.apply(self, arguments);
	},

	_size: function() {
		/* If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		 * divs will both have width and height set, so we need to reset them
		 */
		var options = this.options,
			nonContentHeight,
			minContentHeight,
			isVisible = this.uiDialog.is( ":visible" );

		// reset content sizing
		this.element.show().css({
			width: 'auto',
			minHeight: 0,
			height: 0
		});

		if (options.minWidth > options.width) {
			options.width = options.minWidth;
		}

		// reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: 'auto',
				width: options.width
			})
			.height();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
		
		if ( options.height === "auto" ) {
			// only needed for IE6 support
			if ( $.support.minHeight ) {
				this.element.css({
					minHeight: minContentHeight,
					height: "auto"
				});
			} else {
				this.uiDialog.show();
				var autoHeight = this.element.css( "height", "auto" ).height();
				if ( !isVisible ) {
					this.uiDialog.hide();
				}
				this.element.height( Math.max( autoHeight, minContentHeight ) );
			}
		} else {
			//this.element.height( Math.max( options.height - nonContentHeight, 0 ) );
			//update by liyue ,ie8 is different from other
			var ua = navigator.userAgent.toLowerCase(); 
//			if(ua.match(/msie ([\d.]+)/)){
//				this.element.height(options.height);
//			}else{
				this.element.height( Math.max( options.height - nonContentHeight, 0 ) );
//			}
		}

		if (this.uiDialog.is(':data(resizable)')) {
			this.uiDialog.resizable('option', 'minHeight', this._minHeight());
		}
	}
});

$.extend($.ui.dialog, {
	version: "1.8.16",

	uuid: 0,
	maxZ: 0,

	getTitleId: function($el) {
		var id = $el.attr('id');
		if (!id) {
			this.uuid += 1;
			id = this.uuid;
		}
		return 'ui-dialog-title-' + id;
	},

	overlay: function(dialog) {
		this.$el = $.ui.dialog.overlay.create(dialog);
	}
});

$.extend($.ui.dialog.overlay, {
	instances: [],
	// reuse old instances due to IE memory leak with alpha transparency (see #5185)
	oldInstances: [],
	maxZ: 0,
	events: $.map('focus,mousedown,mouseup,keydown,keypress,click'.split(','),
		function(event) { return event + '.dialog-overlay'; }).join(' '),
	create: function(dialog) {
		if (this.instances.length === 0) {
			// prevent use of anchors and inputs
			// we use a setTimeout in case the overlay is created from an
			// event that we're going to be cancelling (see #2804)
			setTimeout(function() {
				// handle $(el).dialog().dialog('close') (see #4065)
				if ($.ui.dialog.overlay.instances.length) {
					$(document).bind($.ui.dialog.overlay.events, function(event) {
						// stop events if the z-index of the target is < the z-index of the overlay
						// we cannot return true when we don't want to cancel the event (#3523)
						if ($(event.target).zIndex() < $.ui.dialog.overlay.maxZ) {
							return false;
						}
					});
				}
			}, 1);

			// allow closing by pressing the escape key
			$(document).bind('keydown.dialog-overlay', function(event) {
				if (dialog.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
					event.keyCode === $.ui.keyCode.ESCAPE) {
					
					dialog.close(event);
					event.preventDefault();
				}
			});

			// handle window resize
			$(window).bind('resize.dialog-overlay', $.ui.dialog.overlay.resize);
		}

		var $el = (this.oldInstances.pop() || $('<div></div>').addClass('ui-widget-overlay'))
			.appendTo(document.body)
			.css({
				width: this.width(),
				height: this.height()
			});

		if ($.fn.bgiframe) {
			$el.bgiframe();
		}

		this.instances.push($el);
		return $el;
	},

	destroy: function($el) {
		var indexOf = $.inArray($el, this.instances);
		if (indexOf != -1){
			this.oldInstances.push(this.instances.splice(indexOf, 1)[0]);
		}

		if (this.instances.length === 0) {
			$([document, window]).unbind('.dialog-overlay');
		}

		$el.remove();
		
		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		var maxZ = 0;
		$.each(this.instances, function() {
			maxZ = Math.max(maxZ, this.css('z-index'));
		});
		this.maxZ = maxZ;
	},

	height: function() {
		var scrollHeight,
			offsetHeight;
		// handle IE 6
		if ($.browser.msie && $.browser.version < 7) {
			scrollHeight = Math.max(
				document.documentElement.scrollHeight,
				document.body.scrollHeight
			);
			offsetHeight = Math.max(
				document.documentElement.offsetHeight,
				document.body.offsetHeight
			);

			if (scrollHeight < offsetHeight) {
				return $(window).height() + 'px';
			} else {
				return scrollHeight + 'px';
			}
		// handle "good" browsers
		} else {
//			return $(document.body).height() + 'px';
            //            var bodyHeight = $(document.body).height();
//            var pageHeight = $(document.body).children("div.page_margins").height();
			var bodyHeight = $(document.body).outerHeight();
            var pageHeight = $(document.body).children("div.page_margins").outerHeight();
            if(bodyHeight<pageHeight){
                bodyHeight = pageHeight;
            }
            return bodyHeight + 'px';
		}
	},

	width: function() {
		var scrollWidth,
			offsetWidth;
		// handle IE
		if ( $.browser.msie ) {
			scrollWidth = Math.max(
				document.documentElement.scrollWidth,
				document.body.scrollWidth
			);
			offsetWidth = Math.max(
				document.documentElement.offsetWidth,
				document.body.offsetWidth
			);

			if (scrollWidth < offsetWidth) {
				return $(window).width() + 'px';
			} else {
				return scrollWidth + 'px';
			}
		// handle "good" browsers
		} else {
//			return $(document.body).width() + 'px';
            //            var bodyWidth = $(document.body).width();
//            var pageWidth = $(document.body).children("div.page_margins").width();
			var bodyWidth = $(document.body).outerWidth();
            var pageWidth = $(document.body).children("div.page_margins").outerWidth();

            if(bodyWidth<pageWidth){
                bodyWidth = pageWidth;
            }
            return bodyWidth + 'px';
		}
	},

	resize: function() {
		/* If the dialog is draggable and the user drags it past the
		 * right edge of the window, the document becomes wider so we
		 * need to stretch the overlay. If the user then drags the
		 * dialog back to the left, the document will become narrower,
		 * so we need to shrink the overlay to the appropriate size.
		 * This is handled by shrinking the overlay before setting it
		 * to the full document size.
		 */
        //modify by jlg.ie8
        var $overlays = $([]);
        $.each($.ui.dialog.overlay.instances, function() {
            $overlays = $overlays.add(this);
        });
        $.ieHack.hackResize(function(){
            $overlays.css({
                width: 0,
                height: 0
            }).css({
                    width: $.ui.dialog.overlay.width(),
                    height: $.ui.dialog.overlay.height()
                });
        },$overlays);


	}
});

$.extend($.ui.dialog.overlay.prototype, {
	destroy: function() {
		$.ui.dialog.overlay.destroy(this.$el);
	}
});

}(jQuery));

/*
 * jQuery UI Slider 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {

	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null
	},

	_create: function() {
		var self = this,
			o = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
			handleCount = ( o.values && o.values.length ) || 1,
			handles = [];

		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" +
				( o.disabled ? " ui-slider-disabled ui-disabled" : "" ) );

		this.range = $([]);

		if ( o.range ) {
			if ( o.range === true ) {
				if ( !o.values ) {
					o.values = [ this._valueMin(), this._valueMin() ];
				}
				if ( o.values.length && o.values.length !== 2 ) {
					o.values = [ o.values[0], o.values[0] ];
				}
			}

			this.range = $( "<div></div>" )
				.appendTo( this.element )
				.addClass( "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header" + 
				( ( o.range === "min" || o.range === "max" ) ? " ui-slider-range-" + o.range : "" ) );
		}

		for ( var i = existingHandles.length; i < handleCount; i += 1 ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( self.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.add( this.range ).filter( "a" )
			.click(function( event ) {
				event.preventDefault();
			})
			.hover(function() {
				if ( !o.disabled ) {
					$( this ).addClass( "ui-state-hover" );
				}
			}, function() {
				$( this ).removeClass( "ui-state-hover" );
			})
			.focus(function() {
				if ( !o.disabled ) {
					$( ".ui-slider .ui-state-focus" ).removeClass( "ui-state-focus" );
					$( this ).addClass( "ui-state-focus" );
				} else {
					$( this ).blur();
				}
			})
			.blur(function() {
				$( this ).removeClass( "ui-state-focus" );
			});

		this.handles.each(function( i ) {
			$( this ).data( "index.ui-slider-handle", i );
		});

		this.handles
			.keydown(function( event ) {
				var ret = true,
					index = $( this ).data( "index.ui-slider-handle" ),
					allowed,
					curVal,
					newVal,
					step;
	
				if ( self.options.disabled ) {
					return;
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						ret = false;
						if ( !self._keySliding ) {
							self._keySliding = true;
							$( this ).addClass( "ui-state-active" );
							allowed = self._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}
	
				step = self.options.step;
				if ( self.options.values && self.options.values.length ) {
					curVal = newVal = self.values( index );
				} else {
					curVal = newVal = self.value();
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = self._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = self._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = self._trimAlignValue( curVal + ( (self._valueMax() - self._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = self._trimAlignValue( curVal - ( (self._valueMax() - self._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === self._valueMax() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === self._valueMin() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal - step );
						break;
				}
	
				self._slide( event, index, newVal );
	
				return ret;
	
			})
			.keyup(function( event ) {
				var index = $( this ).data( "index.ui-slider-handle" );
	
				if ( self._keySliding ) {
					self._keySliding = false;
					self._stop( event, index );
					self._change( event, index );
					$( this ).removeClass( "ui-state-active" );
				}
	
			});

		this._refreshValue();

		this._animateOff = false;
	},

	destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-slider-disabled" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" )
			.removeData( "slider" )
			.unbind( ".slider" );

		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function( event ) {
		var o = this.options,
			position,
			normValue,
			distance,
			closestHandle,
			self,
			index,
			allowed,
			offset,
			mouseOverHandle;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		self = this;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - self.values(i) );
			if ( distance > thisDistance ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		// workaround for bug #3736 (if both handles of a range are at 0,
		// the first is always used as the one with least distance,
		// and moving it is obviously prevented by preventing negative ranges)
		if( o.range === true && this.values(1) === o.min ) {
			index += 1;
			closestHandle = $( this.handles[index] );
		}

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		self._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();
		
		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().andSelf().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function( event ) {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );
		
		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},
	
	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) && 
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case "disabled":
				if ( value ) {
					this.handles.filter( ".ui-state-focus" ).blur();
					this.handles.removeClass( "ui-state-hover" );
					this.handles.propAttr( "disabled", true );
					this.element.addClass( "ui-disabled" );
				} else {
					this.handles.propAttr( "disabled", false );
					this.element.removeClass( "ui-disabled" );
				}
				break;
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		}
	},
	
	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},
	
	_refreshValue: function() {
		var oRange = this.options.range,
			o = this.options,
			self = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			valPercent,
			_set = {},
			lastValPercent,
			value,
			valueMin,
			valueMax;

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i, j ) {
				valPercent = ( self.values(i) - self._valueMin() ) / ( self._valueMax() - self._valueMin() ) * 100;
				_set[ self.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( self.options.range === true ) {
					if ( self.orientation === "horizontal" ) {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ self.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	}

});

$.extend( $.ui.slider, {
	version: "1.8.16"
});

}(jQuery));

/*
 * jQuery UI Tabs 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Tabs
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var tabId = 0,
	listId = 0;

function getNextTabId() {
	return ++tabId;
}

function getNextListId() {
	return ++listId;
}

$.widget( "ui.tabs", {
	options: {
		add: null,
		ajaxOptions: null,
		cache: false,
		cookie: null, // e.g. { expires: 7, path: '/', domain: 'jquery.com', secure: true }
		collapsible: false,
		disable: null,
		disabled: [],
		enable: null,
		event: "click",
		fx: null, // e.g. { height: 'toggle', opacity: 'toggle', duration: 200 }
		idPrefix: "ui-tabs-",
		load: null,
		panelTemplate: "<div></div>",
		remove: null,
		select: null,
		show: null,
		spinner: "<em>Loading&#8230;</em>",
		tabTemplate: "<li><a href='#{href}'><span>#{label}</span></a></li>"
	},

	_create: function() {
		this._tabify( true );
	},

	_setOption: function( key, value ) {
		if ( key == "selected" ) {
			if (this.options.collapsible && value == this.options.selected ) {
				return;
			}
			this.select( value );
		} else {
			this.options[ key ] = value;
			this._tabify();
		}
	},

	_tabId: function( a ) {
		return a.title && a.title.replace( /\s/g, "_" ).replace( /[^\w\u00c0-\uFFFF-]/g, "" ) ||
			this.options.idPrefix + getNextTabId();
	},

	_sanitizeSelector: function( hash ) {
		// we need this because an id may contain a ":"
		return hash.replace( /:/g, "\\:" );
	},

	_cookie: function() {
		var cookie = this.cookie ||
			( this.cookie = this.options.cookie.name || "ui-tabs-" + getNextListId() );
		return $.cookie.apply( null, [ cookie ].concat( $.makeArray( arguments ) ) );
	},

	_ui: function( tab, panel ) {
		return {
			tab: tab,
			panel: panel,
			index: this.anchors.index( tab )
		};
	},

	_cleanup: function() {
		// restore all former loading tabs labels
		this.lis.filter( ".ui-state-processing" )
			.removeClass( "ui-state-processing" )
			.find( "span:data(label.tabs)" )
				.each(function() {
					var el = $( this );
					el.html( el.data( "label.tabs" ) ).removeData( "label.tabs" );
				});
	},

	_tabify: function( init ) {
		var self = this,
			o = this.options,
			fragmentId = /^#.+/; // Safari 2 reports '#' for an empty hash

		this.list = this.element.find( "ol,ul" ).eq( 0 );
		this.lis = $( " > li:has(a[href])", this.list );
		this.anchors = this.lis.map(function() {
			return $( "a", this )[ 0 ];
		});
		this.panels = $( [] );

		this.anchors.each(function( i, a ) {
			var href = $( a ).attr( "href" );
			// For dynamically created HTML that contains a hash as href IE < 8 expands
			// such href to the full page url with hash and then misinterprets tab as ajax.
			// Same consideration applies for an added tab with a fragment identifier
			// since a[href=#fragment-identifier] does unexpectedly not match.
			// Thus normalize href attribute...
			var hrefBase = href.split( "#" )[ 0 ],
				baseEl;
			if ( hrefBase && ( hrefBase === location.toString().split( "#" )[ 0 ] ||
					( baseEl = $( "base" )[ 0 ]) && hrefBase === baseEl.href ) ) {
				href = a.hash;
				a.href = href;
			}

			// inline tab
			if ( fragmentId.test( href ) ) {
				self.panels = self.panels.add( self.element.find( self._sanitizeSelector( href ) ) );
			// remote tab
			// prevent loading the page itself if href is just "#"
			} else if ( href && href !== "#" ) {
				// required for restore on destroy
				$.data( a, "href.tabs", href );

				// TODO until #3808 is fixed strip fragment identifier from url
				// (IE fails to load from such url)
				$.data( a, "load.tabs", href.replace( /#.*$/, "" ) );

				var id = self._tabId( a );
				a.href = "#" + id;
				var $panel = self.element.find( "#" + id );
				if ( !$panel.length ) {
					$panel = $( o.panelTemplate )
						.attr( "id", id )
						.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
						.insertAfter( self.panels[ i - 1 ] || self.list );
					$panel.data( "destroy.tabs", true );
				}
				self.panels = self.panels.add( $panel );
			// invalid tab href
			} else {
				o.disabled.push( i );
			}
		});

		// initialization from scratch
		if ( init ) {
			// attach necessary classes for styling
			this.element.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" );
			this.list.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" );
			this.lis.addClass( "ui-state-default ui-corner-top" );
			this.panels.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" );

			// Selected tab
			// use "selected" option or try to retrieve:
			// 1. from fragment identifier in url
			// 2. from cookie
			// 3. from selected class attribute on <li>
			if ( o.selected === undefined ) {
				if ( location.hash ) {
					this.anchors.each(function( i, a ) {
						if ( a.hash == location.hash ) {
							o.selected = i;
							return false;
						}
					});
				}
				if ( typeof o.selected !== "number" && o.cookie ) {
					o.selected = parseInt( self._cookie(), 10 );
				}
				if ( typeof o.selected !== "number" && this.lis.filter( ".ui-tabs-selected" ).length ) {
					o.selected = this.lis.index( this.lis.filter( ".ui-tabs-selected" ) );
				}
				o.selected = o.selected || ( this.lis.length ? 0 : -1 );
			} else if ( o.selected === null ) { // usage of null is deprecated, TODO remove in next release
				o.selected = -1;
			}

			// sanity check - default to first tab...
			o.selected = ( ( o.selected >= 0 && this.anchors[ o.selected ] ) || o.selected < 0 )
				? o.selected
				: 0;

			// Take disabling tabs via class attribute from HTML
			// into account and update option properly.
			// A selected tab cannot become disabled.
			o.disabled = $.unique( o.disabled.concat(
				$.map( this.lis.filter( ".ui-state-disabled" ), function( n, i ) {
					return self.lis.index( n );
				})
			) ).sort();

			if ( $.inArray( o.selected, o.disabled ) != -1 ) {
				o.disabled.splice( $.inArray( o.selected, o.disabled ), 1 );
			}

			// highlight selected tab
			this.panels.addClass( "ui-tabs-hide" );
			this.lis.removeClass( "ui-tabs-selected ui-state-active" );
			// check for length avoids error when initializing empty list
			if ( o.selected >= 0 && this.anchors.length ) {
				self.element.find( self._sanitizeSelector( self.anchors[ o.selected ].hash ) ).removeClass( "ui-tabs-hide" );
				this.lis.eq( o.selected ).addClass( "ui-tabs-selected ui-state-active" );

				// seems to be expected behavior that the show callback is fired
				self.element.queue( "tabs", function() {
					self._trigger( "show", null,
						self._ui( self.anchors[ o.selected ], self.element.find( self._sanitizeSelector( self.anchors[ o.selected ].hash ) )[ 0 ] ) );
				});

				this.load( o.selected );
			}

			// clean up to avoid memory leaks in certain versions of IE 6
			// TODO: namespace this event
			$( window ).bind( "unload", function() {
				self.lis.add( self.anchors ).unbind( ".tabs" );
				self.lis = self.anchors = self.panels = null;
			});
		// update selected after add/remove
		} else {
			o.selected = this.lis.index( this.lis.filter( ".ui-tabs-selected" ) );
		}

		// update collapsible
		// TODO: use .toggleClass()
		this.element[ o.collapsible ? "addClass" : "removeClass" ]( "ui-tabs-collapsible" );

		// set or update cookie after init and add/remove respectively
		if ( o.cookie ) {
			this._cookie( o.selected, o.cookie );
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.lis[ i ] ); i++ ) {
			$( li )[ $.inArray( i, o.disabled ) != -1 &&
				// TODO: use .toggleClass()
				!$( li ).hasClass( "ui-tabs-selected" ) ? "addClass" : "removeClass" ]( "ui-state-disabled" );
		}

		// reset cache if switching from cached to not cached
		if ( o.cache === false ) {
			this.anchors.removeData( "cache.tabs" );
		}

		// remove all handlers before, tabify may run on existing tabs after add or option change
		this.lis.add( this.anchors ).unbind( ".tabs" );

		if ( o.event !== "mouseover" ) {
			var addState = function( state, el ) {
				if ( el.is( ":not(.ui-state-disabled)" ) ) {
					el.addClass( "ui-state-" + state );
				}
			};
			var removeState = function( state, el ) {
				el.removeClass( "ui-state-" + state );
			};
			this.lis.bind( "mouseover.tabs" , function() {
				addState( "hover", $( this ) );
			});
			this.lis.bind( "mouseout.tabs", function() {
				removeState( "hover", $( this ) );
			});
			this.anchors.bind( "focus.tabs", function() {
				addState( "focus", $( this ).closest( "li" ) );
			});
			this.anchors.bind( "blur.tabs", function() {
				removeState( "focus", $( this ).closest( "li" ) );
			});
		}

		// set up animations
		var hideFx, showFx;
		if ( o.fx ) {
			if ( $.isArray( o.fx ) ) {
				hideFx = o.fx[ 0 ];
				showFx = o.fx[ 1 ];
			} else {
				hideFx = showFx = o.fx;
			}
		}

		// Reset certain styles left over from animation
		// and prevent IE's ClearType bug...
		function resetStyle( $el, fx ) {
			$el.css( "display", "" );
			if ( !$.support.opacity && fx.opacity ) {
				$el[ 0 ].style.removeAttribute( "filter" );
			}
		}

		// Show a tab...
		var showTab = showFx
			? function( clicked, $show ) {
				$( clicked ).closest( "li" ).addClass( "ui-tabs-selected ui-state-active" );
				$show.hide().removeClass( "ui-tabs-hide" ) // avoid flicker that way
					.animate( showFx, showFx.duration || "normal", function() {
						resetStyle( $show, showFx );
						self._trigger( "show", null, self._ui( clicked, $show[ 0 ] ) );
					});
			}
			: function( clicked, $show ) {
				$( clicked ).closest( "li" ).addClass( "ui-tabs-selected ui-state-active" );
				$show.removeClass( "ui-tabs-hide" );
				self._trigger( "show", null, self._ui( clicked, $show[ 0 ] ) );
			};

		// Hide a tab, $show is optional...
		var hideTab = hideFx
			? function( clicked, $hide ) {
				$hide.animate( hideFx, hideFx.duration || "normal", function() {
					self.lis.removeClass( "ui-tabs-selected ui-state-active" );
					$hide.addClass( "ui-tabs-hide" );
					resetStyle( $hide, hideFx );
					self.element.dequeue( "tabs" );
				});
			}
			: function( clicked, $hide, $show ) {
				self.lis.removeClass( "ui-tabs-selected ui-state-active" );
				$hide.addClass( "ui-tabs-hide" );
				self.element.dequeue( "tabs" );
			};

		// attach tab event handler, unbind to avoid duplicates from former tabifying...
		this.anchors.bind( o.event + ".tabs", function() {
			var el = this,
				$li = $(el).closest( "li" ),
				$hide = self.panels.filter( ":not(.ui-tabs-hide)" ),
				$show = self.element.find( self._sanitizeSelector( el.hash ) );

			// If tab is already selected and not collapsible or tab disabled or
			// or is already loading or click callback returns false stop here.
			// Check if click handler returns false last so that it is not executed
			// for a disabled or loading tab!
			if ( ( $li.hasClass( "ui-tabs-selected" ) && !o.collapsible) ||
				$li.hasClass( "ui-state-disabled" ) ||
				$li.hasClass( "ui-state-processing" ) ||
				self.panels.filter( ":animated" ).length ||
				self._trigger( "select", null, self._ui( this, $show[ 0 ] ) ) === false ) {
				this.blur();
				return false;
			}

			o.selected = self.anchors.index( this );

			self.abort();

			// if tab may be closed
			if ( o.collapsible ) {
				if ( $li.hasClass( "ui-tabs-selected" ) ) {
					o.selected = -1;

					if ( o.cookie ) {
						self._cookie( o.selected, o.cookie );
					}

					self.element.queue( "tabs", function() {
						hideTab( el, $hide );
					}).dequeue( "tabs" );

					this.blur();
					return false;
				} else if ( !$hide.length ) {
					if ( o.cookie ) {
						self._cookie( o.selected, o.cookie );
					}

					self.element.queue( "tabs", function() {
						showTab( el, $show );
					});

					// TODO make passing in node possible, see also http://dev.jqueryui.com/ticket/3171
					self.load( self.anchors.index( this ) );

					this.blur();
					return false;
				}
			}

			if ( o.cookie ) {
				self._cookie( o.selected, o.cookie );
			}

			// show new tab
			if ( $show.length ) {
				if ( $hide.length ) {
					self.element.queue( "tabs", function() {
						hideTab( el, $hide );
					});
				}
				self.element.queue( "tabs", function() {
					showTab( el, $show );
				});

				self.load( self.anchors.index( this ) );
			} else {
				throw "jQuery UI Tabs: Mismatching fragment identifier.";
			}

			// Prevent IE from keeping other link focussed when using the back button
			// and remove dotted border from clicked link. This is controlled via CSS
			// in modern browsers; blur() removes focus from address bar in Firefox
			// which can become a usability and annoying problem with tabs('rotate').
			if ( $.browser.msie ) {
				this.blur();
			}
		});

		// disable click in any case
		this.anchors.bind( "click.tabs", function(){
			return false;
		});
	},

    _getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		// also sanitizes numerical indexes to valid values.
		if ( typeof index == "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$=" + index + "]" ) );
		}

		return index;
	},

	destroy: function() {
		var o = this.options;

		this.abort();

		this.element
			.unbind( ".tabs" )
			.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" )
			.removeData( "tabs" );

		this.list.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" );

		this.anchors.each(function() {
			var href = $.data( this, "href.tabs" );
			if ( href ) {
				this.href = href;
			}
			var $this = $( this ).unbind( ".tabs" );
			$.each( [ "href", "load", "cache" ], function( i, prefix ) {
				$this.removeData( prefix + ".tabs" );
			});
		});

		this.lis.unbind( ".tabs" ).add( this.panels ).each(function() {
			if ( $.data( this, "destroy.tabs" ) ) {
				$( this ).remove();
			} else {
				$( this ).removeClass([
					"ui-state-default",
					"ui-corner-top",
					"ui-tabs-selected",
					"ui-state-active",
					"ui-state-hover",
					"ui-state-focus",
					"ui-state-disabled",
					"ui-tabs-panel",
					"ui-widget-content",
					"ui-corner-bottom",
					"ui-tabs-hide"
				].join( " " ) );
			}
		});

		if ( o.cookie ) {
			this._cookie( null, o.cookie );
		}

		return this;
	},

	add: function( url, label, index ) {
		if ( index === undefined ) {
			index = this.anchors.length;
		}

		var self = this,
			o = this.options,
			$li = $( o.tabTemplate.replace( /#\{href\}/g, url ).replace( /#\{label\}/g, label ) ),
			id = !url.indexOf( "#" ) ? url.replace( "#", "" ) : this._tabId( $( "a", $li )[ 0 ] );

		$li.addClass( "ui-state-default ui-corner-top" ).data( "destroy.tabs", true );

		// try to find an existing element before creating a new one
		var $panel = self.element.find( "#" + id );
		if ( !$panel.length ) {
			$panel = $( o.panelTemplate )
				.attr( "id", id )
				.data( "destroy.tabs", true );
		}
		$panel.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide" );

		if ( index >= this.lis.length ) {
			$li.appendTo( this.list );
			$panel.appendTo( this.list[ 0 ].parentNode );
		} else {
			$li.insertBefore( this.lis[ index ] );
			$panel.insertBefore( this.panels[ index ] );
		}

		o.disabled = $.map( o.disabled, function( n, i ) {
			return n >= index ? ++n : n;
		});

		this._tabify();

		if ( this.anchors.length == 1 ) {
			o.selected = 0;
			$li.addClass( "ui-tabs-selected ui-state-active" );
			$panel.removeClass( "ui-tabs-hide" );
			this.element.queue( "tabs", function() {
				self._trigger( "show", null, self._ui( self.anchors[ 0 ], self.panels[ 0 ] ) );
			});

			this.load( 0 );
		}

		this._trigger( "add", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		return this;
	},

	remove: function( index ) {
		index = this._getIndex( index );
		var o = this.options,
			$li = this.lis.eq( index ).remove(),
			$panel = this.panels.eq( index ).remove();

		// If selected tab was removed focus tab to the right or
		// in case the last tab was removed the tab to the left.
		if ( $li.hasClass( "ui-tabs-selected" ) && this.anchors.length > 1) {
			this.select( index + ( index + 1 < this.anchors.length ? 1 : -1 ) );
		}

		o.disabled = $.map(
			$.grep( o.disabled, function(n, i) {
				return n != index;
			}),
			function( n, i ) {
				return n >= index ? --n : n;
			});

		this._tabify();

		this._trigger( "remove", null, this._ui( $li.find( "a" )[ 0 ], $panel[ 0 ] ) );
		return this;
	},

	enable: function( index ) {
		index = this._getIndex( index );
		var o = this.options;
		if ( $.inArray( index, o.disabled ) == -1 ) {
			return;
		}

		this.lis.eq( index ).removeClass( "ui-state-disabled" );
		o.disabled = $.grep( o.disabled, function( n, i ) {
			return n != index;
		});

		this._trigger( "enable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		return this;
	},

	disable: function( index ) {
		index = this._getIndex( index );
		var self = this, o = this.options;
		// cannot disable already selected tab
		if ( index != o.selected ) {
			this.lis.eq( index ).addClass( "ui-state-disabled" );

			o.disabled.push( index );
			o.disabled.sort();

			this._trigger( "disable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		}

		return this;
	},

	select: function( index ) {
		index = this._getIndex( index );
		if ( index == -1 ) {
			if ( this.options.collapsible && this.options.selected != -1 ) {
				index = this.options.selected;
			} else {
				return this;
			}
		}
		this.anchors.eq( index ).trigger( this.options.event + ".tabs" );
		return this;
	},

	load: function( index ) {
		index = this._getIndex( index );
		var self = this,
			o = this.options,
			a = this.anchors.eq( index )[ 0 ],
			url = $.data( a, "load.tabs" );

		this.abort();

		// not remote or from cache
		if ( !url || this.element.queue( "tabs" ).length !== 0 && $.data( a, "cache.tabs" ) ) {
			this.element.dequeue( "tabs" );
			return;
		}

		// load remote from here on
		this.lis.eq( index ).addClass( "ui-state-processing" );

		if ( o.spinner ) {
			var span = $( "span", a );
			span.data( "label.tabs", span.html() ).html( o.spinner );
		}

		this.xhr = $.ajax( $.extend( {}, o.ajaxOptions, {
			url: url,
			success: function( r, s ) {
				self.element.find( self._sanitizeSelector( a.hash ) ).html( r );

				// take care of tab labels
				self._cleanup();

				if ( o.cache ) {
					$.data( a, "cache.tabs", true );
				}

				self._trigger( "load", null, self._ui( self.anchors[ index ], self.panels[ index ] ) );
				try {
					o.ajaxOptions.success( r, s );
				}
				catch ( e ) {}
			},
			error: function( xhr, s, e ) {
				// take care of tab labels
				self._cleanup();

				self._trigger( "load", null, self._ui( self.anchors[ index ], self.panels[ index ] ) );
				try {
					// Passing index avoid a race condition when this method is
					// called after the user has selected another tab.
					// Pass the anchor that initiated this request allows
					// loadError to manipulate the tab content panel via $(a.hash)
					o.ajaxOptions.error( xhr, s, index, a );
				}
				catch ( e ) {}
			}
		} ) );

		// last, so that load event is fired before show...
		self.element.dequeue( "tabs" );

		return this;
	},

	abort: function() {
		// stop possibly running animations
		this.element.queue( [] );
		this.panels.stop( false, true );

		// "tabs" queue must not contain more than two elements,
		// which are the callbacks for the latest clicked tab...
		this.element.queue( "tabs", this.element.queue( "tabs" ).splice( -2, 2 ) );

		// terminate pending requests from other tabs
		if ( this.xhr ) {
			this.xhr.abort();
			delete this.xhr;
		}

		// take care of tab labels
		this._cleanup();
		return this;
	},

	url: function( index, url ) {
		this.anchors.eq( index ).removeData( "cache.tabs" ).data( "load.tabs", url );
		return this;
	},

	length: function() {
		return this.anchors.length;
	}
});

$.extend( $.ui.tabs, {
	version: "1.8.16"
});

/*
 * Tabs Extensions
 */

/*
 * Rotate
 */
$.extend( $.ui.tabs.prototype, {
	rotation: null,
	rotate: function( ms, continuing ) {
		var self = this,
			o = this.options;

		var rotate = self._rotate || ( self._rotate = function( e ) {
			clearTimeout( self.rotation );
			self.rotation = setTimeout(function() {
				var t = o.selected;
				self.select( ++t < self.anchors.length ? t : 0 );
			}, ms );
			
			if ( e ) {
				e.stopPropagation();
			}
		});

		var stop = self._unrotate || ( self._unrotate = !continuing
			? function(e) {
				if (e.clientX) { // in case of a true click
					self.rotate(null);
				}
			}
			: function( e ) {
				t = o.selected;
				rotate();
			});

		// start rotation
		if ( ms ) {
			this.element.bind( "tabsshow", rotate );
			this.anchors.bind( o.event + ".tabs", stop );
			rotate();
		// stop rotation
		} else {
			clearTimeout( self.rotation );
			this.element.unbind( "tabsshow", rotate );
			this.anchors.unbind( o.event + ".tabs", stop );
			delete this._rotate;
			delete this._unrotate;
		}

		return this;
	}
});

})( jQuery );


    /*
     * jQuery UI Datepicker 1.8.16
     *
     * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
     * Dual licensed under the MIT or GPL Version 2 licenses.
     * http://jquery.org/license
     *
     * http://docs.jquery.com/UI/Datepicker
     *
     * Depends:
     *    jquery.ui.core.js
     */
    (function( $, undefined ) {

    $.extend($.ui, { datepicker: { version: "1.8.16" } });

    var PROP_NAME = 'datepicker';
    var dpuuid = new Date().getTime();
    var instActive;

    /* Date picker manager.
       Use the singleton instance of this class, $.datepicker, to interact with the date picker.
       Settings for (groups of) date pickers are maintained in an instance object,
       allowing multiple different settings on the same page. */

    function Datepicker() {
        this.debug = false; // Change this to true to start debugging
        this._curInst = null; // The current instance in use
        this._keyEvent = false; // If the last event was a key event
        this._disabledInputs = []; // List of date picker inputs that have been disabled
        this._datepickerShowing = false; // True if the popup picker is showing , false if not
        this._inDialog = false; // True if showing within a "dialog", false if not
        this._mainDivId = 'ui-datepicker-div'; // The ID of the main datepicker division
        this._inlineClass = 'ui-datepicker-inline'; // The name of the inline marker class
        this._appendClass = 'ui-datepicker-append'; // The name of the append marker class
        this._frameClass = 'ui-datepicker-frame'; // The name of the frame marker class
        this._layoutClass = 'ui-datepicker-layout'; // The name of the frame marker class
        this._inputFrameClass = 'ui-datepicker-inputframe'; // The name of the input frame marker class
        this._iconTriggerClass = 'ui-datepicker-iconTrigger'; // The name of the trigger marker class
        this._triggerClass = 'ui-datepicker-trigger'; // The name of the trigger marker class
        this._dialogClass = 'ui-datepicker-dialog'; // The name of the dialog marker class
        this._disableClass = 'ui-datepicker-disabled'; // The name of the disabled covering marker class
        this._unselectableClass = 'ui-datepicker-unselectable'; // The name of the unselectable cell marker class
        this._currentClass = 'ui-datepicker-current-day'; // The name of the current day marker class
        this._dayOverClass = 'ui-datepicker-days-cell-over'; // The name of the day hover marker class
        this.regional = []; // Available regional settings, indexed by language code
        this.regional[''] = { // Default regional settings
            closeText: 'Done', // Display text for close link
            prevText: 'Prev', // Display text for previous month link
            nextText: 'Next', // Display text for next month link
            currentText: 'Today', // Display text for current month link
            monthNames: ['January','February','March','April','May','June',
                'July','August','September','October','November','December'], // Names of months for drop-down and formatting
            monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], // For formatting
            dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // For formatting
            dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], // For formatting
            dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'], // Column headings for days starting at Sunday
            weekHeader: 'Wk', // Column header for week of the year
            dateFormat: 'mm/dd/yy', // See format options on parseDate
            firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
            isRTL: false, // True if right-to-left language, false if left-to-right
            showMonthAfterYear: false, // True if the year select precedes month, false for month then year
            yearSuffix: '' // Additional text to append to the year in the month headers
        };
        this._defaults = { // Global defaults for all the date picker instances
            showOn: 'button', // 'focus' for popup on focus,
                // 'button' for trigger button, or 'both' for either
            showAnim: 'fadeIn', // Name of jQuery animation for popup
            showOptions: {}, // Options for enhanced animations
            defaultDate: null, // Used when field is blank: actual date,
                // +/-number for offset from today, null for today
            appendText: '', // Display text following the input box, e.g. showing the format
            buttonText: '...', // Text for trigger button
            buttonImage: '', // URL for trigger button image
            buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
            hideIfNoPrevNext: false, // True to hide next/previous month links
                // if not applicable, false to just disable them
            navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
            gotoCurrent: false, // True if today link goes back to current selection instead
            changeMonth: false, // True if month can be selected directly, false if only prev/next
            changeYear: false, // True if year can be selected directly, false if only prev/next
            yearRange: 'c-10:c+10', // Range of years to display in drop-down,
                // either relative to today's year (-nn:+nn), relative to currently displayed year
                // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
            showOtherMonths: false, // True to show dates in other months, false to leave blank
            selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
            showWeek: false, // True to show week of the year, false to not show it
            calculateWeek: this.iso8601Week, // How to calculate the week of the year,
                // takes a Date and returns the number of the week for it
            shortYearCutoff: '+10', // Short year values < this are in the current century,
                // > this are in the previous century,
                // string value starting with '+' for current year + value
            minDate: null, // The earliest selectable date, or null for no limit
            maxDate: null, // The latest selectable date, or null for no limit
            duration: 'fast', // Duration of display/closure
            beforeShowDay: null, // Function that takes a date and returns an array with
                // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or '',
                // [2] = cell title (optional), e.g. $.datepicker.noWeekends
            beforeShow: null, // Function that takes an input field and
                // returns a set of custom settings for the date picker
            onSelect: null, // Define a callback function when a date is selected
            onChangeMonthYear: null, // Define a callback function when the month or year is changed
            onClose: null, // Define a callback function when the datepicker is closed
            onchange: null, //  Define a callback function when the date is change
            numberOfMonths: 1, // Number of months to show at a time
            showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
            stepMonths: 1, // Number of months to step back/forward
            stepBigMonths: 12, // Number of months to step back/forward for the big links
            altField: '', // Selector for an alternate field to store selected dates into
            altFormat: '', // The date format to use for the alternate field
            constrainInput: false, // The input is constrained by the current date format
            showButtonPanel: false, // True to show button panel, false to not show it
            autoSize: false, // True to size the input for the date format, false to leave as is
            disabled: false, // The initial disabled state
            width: null,
            height: null,
            readonly: false,
            style: null,
            tagClass: null,
            tabindex: 0,
            hidden: false,
            editable: true,
            type: 'date',
            _hour: 0,
            _minute: 0,
            _second: 0,
            _millisec: 0,
            iframeLevel: 0,
            inIframe: false
        };
        $.extend(this._defaults, this.regional['']);
        this.dpDiv = bindHover($('<div id="' + this._mainDivId + '" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'));
    }

    $.extend(Datepicker.prototype, {
        handleFunctions: ["onclick", "onblur", "ondblclick", "onfocus",
                          "onkeyup", "onkeypress", "onkeydown", "onmouseover", "onmouseup",
                          "onmouseout", "onmousemove", "onmousedown"],
        /* Class name added to elements to indicate already configured with a date picker. */
        markerClassName: 'ui-datepicker-input',

        //Keep track of the maximum number of rows displayed (see #7043)
        maxRows: 4,

        /* Debug logging (if enabled). */
        log: function () {
            if (this.debug)
                console.log.apply('', arguments);
        },

        // TODO rename to "widget" when switching to widget factory
        _widgetDatepicker: function() {
            return this.dpDiv;
        },

        /* Override the default settings for all instances of the date picker.
           @param  settings  object - the new settings to use as defaults (anonymous object)
           @return the manager object */
        setDefaults: function(settings) {
            extendRemove(this._defaults, settings || {});
            return this;
        },

        /* Attach the date picker to a jQuery selection.
           @param  target    element - the target input field or division or span
           @param  settings  object - the new settings to use for this date picker instance (anonymous) */
        _attachDatepicker: function(target, settings) {
            // check for settings on the control itself - in namespace 'date:'
            var inlineSettings = null;
            for (var attrName in this._defaults) {
                var attrValue = target.getAttribute('date:' + attrName);
                if (attrValue) {
                    inlineSettings = inlineSettings || {};
                    try {
                        inlineSettings[attrName] = eval(attrValue);
                    } catch (err) {
                        inlineSettings[attrName] = attrValue;
                    }
                }
            }
            var nodeName = target.nodeName.toLowerCase();
            var inline = (nodeName == 'div' || nodeName == 'span');
            if (!target.id) {
                this.uuid += 1;
                target.id = 'dp' + this.uuid;
            }
            var inst = this._newInst($(target), inline);
            settings.altField = settings.altField || ("#" + settings.id + "_el");
            settings.altFormat = settings.altFormat || 'yy-mm-dd';
            settings.displayField = settings.displayField || ("#" + settings.id + "_view");
            inst.settings = $.extend({}, settings || {}, inlineSettings || {});
            if (nodeName == 'input') {
                this._connectDatepicker(target, inst);
            } else if (inline) {
                this._inlineDatepicker(target, inst);
            }
            //
            if(settings.value){
                var date = settings.value;
                if($.type.isString(date)){
                    date = this.parseDateTime("yy-mm-dd", "hh:mm:ss", date);
                }
                this._setValueDatepicker(target, date, true);
                this._setDefaultValueDatepicker(target, date);
            }
            return inst;
        },

        /* Create a new instance object. */
        _newInst: function(target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, '\\\\$1'); // escape jQuery meta chars
            return {id: id, input: target, // associated target
                selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
                drawMonth: 0, drawYear: 0, // month being drawn
                inline: inline, // is datepicker inline or not
                dpDiv: (!inline ? this.dpDiv : // presentation div
                bindHover($('<div class="' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')))};
        },

        /* Attach the date picker to an input field. */
        _connectDatepicker: function(target, inst) {
            var input = $(target),
                self = this;

            inst.append = $([]);
            inst.trigger = $([]);

            if(input.data('domcreated')) {
                inst.trigger = $.datepicker._getFrame(input).find("." + this._iconTriggerClass).eq(0);
            } else {
                this._packageDatepicker(input, inst);
            input.attr("data-domcreated","true");
            }
            this._enter2tab(input);
            this._attachments(input, inst);
            this._attachmentsInput(input, inst);

            input.addClass("hasDatepicker")
                .addClass(this.markerClassName)
                .attr("ctrlrole", "datePicker")
                .keydown(this._doKeyDown)
                .keypress(this._doKeyPress)
                .keyup(this._doKeyUp)
                .bind("setData.datepicker", function(event, key, value) {
                    inst.settings[key] = value;
                })
                .bind("getData.datepicker", function(event, key) {
                    return this._get(inst, key);
                })
                .bind("blur.datepicker", function(event){
                    if(!$.datepicker._datepickerShowing){
                        try {
                            self._getDateFromField(inst);
                            self._updateInput(inst);
                        } catch(err) {
                            var orgDate = $.datepicker._getDate(inst, true);
                            self._setDate(inst, null);
                            self._updateInput(inst);
                            self._updateDatepicker(inst);
                            self._updateAlternate(inst);
                            if(!$.datepicker._triggerOnChange(inst, orgDate, null)) {
                                self._setDate(inst, orgDate);
                                self._updateInput(inst);
                                self._updateDatepicker(inst);
                                self._updateAlternate(inst);
                            } else {
                                inst.input.trigger('change', true);
                                inst.input.val('');
                                inst.lastVal = '';
                            }
                        }
                    }
                });

            $(input[0].form).bind('reset', function(){
                self._reset(target, inst);
            });

            $.each(this.handleFunctions, function(i, v) {
                var eventName = v.substr(2),
                    eventFunction = self._get(inst, v);
                input.unbind(eventName + ".wafDatePickerInner");
                if (eventFunction && eventFunction != null) {
                    if ($.isFunction(eventFunction)) {
                        input.bind(eventName, eventFunction);
                    } else if (typeof eventFunction === "string") {
                        if (eventFunction.indexOf("(") > -1) {
                            input.bind(eventName, function () {
                                return eval(eventFunction);
                            });
                        } else {
                            var fun = eval(eventFunction);
                            if ($.isFunction(fun)) {
                                input.bind(eventName, fun);
                            }
                        }
                    }
                }
            });

            this._autoSize(inst);
            $.data(target, PROP_NAME, inst);

            var _frame = this._getFrame(input),
                isView = this._isViewOperateState(inst),
                displayType = this._getViewDisplayType(inst),
                view = $(this._get(inst, 'displayField'));
            if("wordonly" === displayType) {
                var isHidden = this._get(inst, 'hidden');
                _frame[isHidden || isView ? 'hide' : 'show']();
                view[isHidden || !isView ? 'hide' : 'show']();
                if(inst.settings.disabled) {
                    this._disableDatepicker(target);
                }
            } else if("disable" === displayType) {
                var isDisabled = this._get(inst, 'disabled');
                this[isDisabled || isView ? '_disableDatepicker' : '_enableDatepicker'](input[0]);
                view.hide();
            } else {
                if(inst.settings.disabled) {
                    this._disableDatepicker(target);
                }
            }
        },

        _formatOutput: function(inst, date){
            if(!inst || !date){
                return '';
            }
            return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
        },

        _updateInput: function(inst){
            var date = this._getDate(inst, true),
                dateStr = this._formatOutput(inst, date),
                displayField = $(this._get(inst, 'displayField'));

            inst.input.val(dateStr);
            displayField.text(dateStr);
            inst.lastVal = dateStr;
        },

        _reset: function(target, inst) {
            var self = this;
            setTimeout(function(){
                self._setDate(inst, inst.defaultValue, true);
                self._updateInput(inst);
                self._updateDatepicker(inst);
                self._updateAlternate(inst);
            }, 10);
        },

        _enter2tab: function(input){
            if($.fn.enter2tab){
                $(input).enter2tab();
            }
        },

        _packageDatepicker: function(input, inst){
            input.wrap("<div class='" + this._frameClass + "'></div>");
            input.wrap("<div class='" + this._layoutClass + "'></div>");
            inst.trigger = $("<span></span>").addClass(this._iconTriggerClass).insertAfter(input).wrap("<div class='ui-datepicker-icon'></div>");
            input.wrap("<div class='" + this._inputFrameClass + "'></div>");
            input.attr('data-domcreated', "true");
            
            var altField = this._get(inst, 'altField');
            if (altField) {
                $(altField).insertAfter(input);
            }
        },

        /* Make attachments based on settings. */
        _attachments: function(input, inst) {
            var appendText = this._get(inst, 'appendText');
            var isRTL = this._get(inst, 'isRTL');
            var _frame = $.datepicker._getFrame(input);
            if (inst.append)
                inst.append.remove();
            if (appendText) {
                inst.append = $('<span class="' + this._appendClass + '">' + appendText + '</span>');
                _frame[isRTL ? 'before' : 'after'](inst.append);
            }

            input.unbind('focus.datepicker');
            input.unbind('blur.datepicker');
            inst.trigger.unbind('click.datepicker');
            var showOn = this._get(inst, 'showOn');
            if (showOn == 'focus' || showOn == 'both') {
                input.bind('focus.datepicker', this._showDatepicker);
            }
            if (showOn == 'button' || showOn == 'both') {
                inst.trigger.bind('click.datepicker', function() {
                    if ($.datepicker._datepickerShowing && $.datepicker._lastInput == input[0])
                        $.datepicker._hideDatepicker();
                    else
                        $.datepicker._showDatepicker(input[0]);
                    return false;
                });
            }
            input.bind('focus.datepicker', function(){
                inst.trigger.addClass("triggerFocus");
            });
            input.bind('blur.datepicker', function(){
                inst.trigger.removeClass("triggerFocus");
            });
        },

        //this.options.readonly || !this.options.editable
        _attachmentsInput: function(input, inst, name, value){
            var _frame = $.datepicker._getFrame(input),
                self = this;
            if(!name){
                input.attr({'tabindex': this._get(inst, 'tabindex'),
                            'readonly': (this._get(inst, 'readonly') || !this._get(inst, 'editable'))});
                _frame.attr('style', this._get(inst, 'style'));
                _frame.addClass(this._get(inst, 'tagClass'));
                _frame.width(this._get(inst, 'width')).height(this._get(inst, 'height'));
                this._get(inst, 'disabled') ? this._disableDatepicker(input[0]) : this._enableDatepicker(input[0]);
            } else if(name == "tabindex") {
                if(value) {
                    input.attr('tabindex', value);
                } else {
                    input.removeAttr('tabindex');
                }
            } else if(name == "readonly") {
                input.attr('readonly', (value || !this._get(inst, 'editable')));
            } else if(name == "editable") {
                input.attr('readonly', (this._get(inst, 'readonly') || !value));
            } else if(name == "style") {
                _frame.attr('style', value);
            } else if(name == "tagClass") {
                _frame.removeClass(this._get(inst, 'tagClass')).addClass(value);
            } else if(name == "width" || name == "height") {
                _frame.css(name, value ? value : '');
            } else if(name == "hidden") {
                var isView = this._isViewOperateState(inst),
                    displayType = this._getViewDisplayType(inst),
                    view = $(this._get(inst, 'displayField'));

                if(isView && ("wordonly" === displayType)) {
                    _frame[value || isView ? 'hide' : 'show']();
                    view[value || !isView ? 'hide' : 'show']();
                } else {
                    _frame[value ? 'hide' : 'show']();
                    view.hide();
                }
            } else if(name == "operateState") {
                var isView = this._isViewOperateState(inst),
                    displayType = this._getViewDisplayType(inst),
                    view = $(this._get(inst, 'displayField'));

                if("wordonly" === displayType) {
                    var isHidden = this._get(inst, 'hidden');
                    _frame[isHidden || isView ? 'hide' : 'show']();
                    view[isHidden || !isView ? 'hide' : 'show']();
                } else if("disable" === displayType) {
                    var isDisabled = this._get(inst, 'disabled');
                    this[isDisabled || isView ? '_disableDatepicker' : '_enableDatepicker'](input[0]);
                    view.hide();
                }
            } else if(name == "disabled") {
                value ? this._disableDatepicker(input[0]) : this._enableDatepicker(input[0]);
            } else if(name == "viewDisplayType") {
                var isView = this._isViewOperateState(inst),
                    displayType = this._getViewDisplayType(inst);
                if(isView) {
                    this._displayTypeCancel(inst, input);
                    this["_" + value + "DisplayTypeOK"](inst, input);
                }
            } else if($.isPlainObject(name)) {
                $.each(name, function(idx, item) {
                    self._attachmentsInput(input, inst, idx, item);
                });
            }
        },

        _displayTypeCancel: function(inst, input){
            this._wordonlyDisplayTypeCancel(inst, input);
            this._disableDisplayTypeCancel(inst, input);
        },

        _wordonlyDisplayTypeCancel: function(inst, input) {
            var isHidden = this._get(inst, 'hidden'),
                _frame = $.datepicker._getFrame(input),
                view = $(this._get(inst, 'displayField'));
            _frame[isHidden ? 'hide' : 'show']();
            view.hide();
        },

        _wordonlyDisplayTypeOK: function(inst, input) {
            var isHidden = this._get(inst, 'hidden'),
                _frame = $.datepicker._getFrame(input),
                view = $(this._get(inst, 'displayField'));
            _frame.hide();
            view[isHidden ? 'hide' : 'show']();
        },

        _disableDisplayTypeCancel: function(inst, input) {
            this._get(inst, 'disabled') ? this._disableDatepicker(input[0]) : this._enableDatepicker(input[0]);
        },

        _disableDisplayTypeOK: function(inst, input) {
            this._disableDatepicker(input[0]);
        },

        _isViewOperateState: function(inst) {
            var operateState = this._get(inst, 'operateState');
            if(operateState && operateState.toUpperCase() === "view".toUpperCase()){
                return true;
            }
            var params = waf.getUrlParams();
            return params && params["operateState"] && (params["operateState"].toUpperCase() == "view".toUpperCase());
        },

        _getViewDisplayType: function(inst) {
            var viewDisplayType = "wordonly",
                instValue = this._get(inst, 'viewDisplayType');
            if(instValue) {
                viewDisplayType = instValue;
            } else {
                var params = waf.getUrlParams();
                if(params && params["viewDisplayType"]) {
                    viewDisplayType = params["viewDisplayType"];
                }
            }
            return viewDisplayType;
        },

        /* Apply the maximum length for the date format. */
        _autoSize: function(inst) {
            if (this._get(inst, 'autoSize') && !inst.inline) {
                var date = new Date(2009, 12 - 1, 20); // Ensure double digits
                var dateFormat = this._get(inst, 'dateFormat');
                if (dateFormat.match(/[DM]/)) {
                    var findMax = function(names) {
                        var max = 0;
                        var maxI = 0;
                        for (var i = 0; i < names.length; i++) {
                            if (names[i].length > max) {
                                max = names[i].length;
                                maxI = i;
                            }
                        }
                        return maxI;
                    };
                    date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
                        'monthNames' : 'monthNamesShort'))));
                    date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
                        'dayNames' : 'dayNamesShort'))) + 20 - date.getDay());
                }
                inst.input.attr('size', this._formatDate(inst, date).length);
            }
        },

        /* Attach an inline date picker to a div. */
        _inlineDatepicker: function(target, inst) {
            var divSpan = $(target);
            if (divSpan.hasClass(this.markerClassName))
                return;
            divSpan.addClass(this.markerClassName).append(inst.dpDiv).
                bind("setData.datepicker", function(event, key, value){
                    inst.settings[key] = value;
                }).bind("getData.datepicker", function(event, key){
                    return this._get(inst, key);
                });
            $.data(target, PROP_NAME, inst);
            this._setDate(inst, this._getDefaultDate(inst), true);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);
            //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
            if( inst.settings.disabled ) {
                this._disableDatepicker( target );
            }
            // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
            // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
            inst.dpDiv.css( "display", "block" );
        },

        /* Pop-up the date picker in a "dialog" box.
           @param  input     element - ignored
           @param  date      string or Date - the initial date to display
           @param  onSelect  function - the function to call when a date is selected
           @param  settings  object - update the dialog date picker instance's settings (anonymous object)
           @param  pos       int[2] - coordinates for the dialog's position within the screen or
                             event - with x/y coordinates or
                             leave empty for default (screen centre)
           @return the manager object */
        _dialogDatepicker: function(input, date, onSelect, settings, pos) {
            var inst = this._dialogInst; // internal instance
            if (!inst) {
                this.uuid += 1;
                var id = 'dp' + this.uuid;
                this._dialogInput = $('<input type="text" id="' + id +
                    '" style="position: absolute; top: -100px; width: 0px; z-index: -10;"/>');
                this._dialogInput.keydown(this._doKeyDown);
                $('body').append(this._dialogInput);
                inst = this._dialogInst = this._newInst(this._dialogInput, false);
                inst.settings = {};
                $.data(this._dialogInput[0], PROP_NAME, inst);
            }
            extendRemove(inst.settings, settings || {});
            date = (date && date.constructor == Date ? this._formatDate(inst, date) : date);
            this._dialogInput.val(date);

            this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
            if (!this._pos) {
                var browserWidth = document.documentElement.clientWidth;
                var browserHeight = document.documentElement.clientHeight;
                var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = // should use actual width/height below
                    [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
            }

            // move input on screen for focus, but hidden behind dialog
            this._dialogInput.css('left', (this._pos[0] + 20) + 'px').css('top', this._pos[1] + 'px');
            inst.settings.onSelect = onSelect;
            this._inDialog = true;
            this.dpDiv.addClass(this._dialogClass);
            this._showDatepicker(this._dialogInput[0]);
            if ($.blockUI)
                $.blockUI(this.dpDiv);
            $.data(this._dialogInput[0], PROP_NAME, inst);
            return this;
        },

        /* Detach a datepicker from its control.
           @param  target    element - the target input field or division or span */
        _destroyDatepicker: function(target) {
            var $target = $(target);
            var inst = $.data(target, PROP_NAME);
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            var nodeName = target.nodeName.toLowerCase();
            $.removeData(target, PROP_NAME);
            if (nodeName == 'input') {
                inst.append.remove();
                inst.trigger.parent().remove();
                $target.unwrap().unwrap().unwrap();
                $target.removeClass(this.markerClassName)
                    .removeAttr("ctrlrole")
                    .unbind('focus', this._showDatepicker)
                    .unbind('keydown', this._doKeyDown)
                    .unbind('keypress', this._doKeyPress)
                    .unbind('keyup', this._doKeyUp);
            } else if (nodeName == 'div' || nodeName == 'span')
                $target.removeClass(this.markerClassName).empty();
        },

        /* Enable the date picker to a jQuery selection.
           @param  target    element - the target input field or division or span */
        _enableDatepicker: function(target) {
            var $target = $(target);
            var inst = $.data(target, PROP_NAME);
        if (!$target.hasClass(this.markerClassName) || !inst) {
                return;
            }
            var nodeName = target.nodeName.toLowerCase();
            if (nodeName == 'input') {
                $target.removeClass('ui-state-disabled');
                var frame = this._getFrame($target);
                if(frame)frame.removeClass('ui-state-disabled');
                target.disabled = false;
                inst.trigger.filter('button').
                    each(function() { this.disabled = false; }).end().
                    filter('img').css({opacity: '1.0', cursor: ''});
            }
            else if (nodeName == 'div' || nodeName == 'span') {
                var inline = $target.children('.' + this._inlineClass);
                inline.children().removeClass('ui-state-disabled');
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                    removeAttr("disabled");
            }
            this._disabledInputs = $.map(this._disabledInputs,
                function(value) { return (value == target ? null : value); }); // delete entry
        },

        /* Disable the date picker to a jQuery selection.
           @param  target    element - the target input field or division or span */
        _disableDatepicker: function(target) {
            var $target = $(target);
            var inst = $.data(target, PROP_NAME);
        if (!$target.hasClass(this.markerClassName)  || !inst) {
                return;
            }
            var nodeName = target.nodeName.toLowerCase();
            if (nodeName == 'input') {
                $target.addClass('ui-state-disabled');
                var frame = this._getFrame($target);
                if(frame)frame.addClass('ui-state-disabled');
                target.disabled = true;
                inst.trigger.filter('button').
                    each(function() { this.disabled = true; }).end().
                    filter('img').css({opacity: '0.5', cursor: 'default'});
            }
            else if (nodeName == 'div' || nodeName == 'span') {
                var inline = $target.children('.' + this._inlineClass);
                inline.children().addClass('ui-state-disabled');
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                    attr("disabled", "disabled");
            }
            this._disabledInputs = $.map(this._disabledInputs,
                function(value) { return (value == target ? null : value); }); // delete entry
            this._disabledInputs[this._disabledInputs.length] = target;
        },

        /* Is the first field in a jQuery collection disabled as a datepicker?
           @param  target    element - the target input field or division or span
           @return boolean - true if disabled, false if enabled */
        _isDisabledDatepicker: function(target) {
            if (!target) {
                return false;
            }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] == target)
                    return true;
            }
            return false;
        },

        /* Retrieve the instance data for the target control.
           @param  target  element - the target input field or division or span
           @return  object - the associated instance data
           @throws  error if a jQuery problem getting data */
        _getInst: function(target) {
            try {
                return $.data(target, PROP_NAME);
            }
            catch (err) {
                throw 'Missing instance data for this datepicker';
            }
        },

        /* Update or retrieve the settings for a date picker attached to an input field or division.
           @param  target  element - the target input field or division or span
           @param  name    object - the new settings to update or
                           string - the name of the setting to change or retrieve,
                           when retrieving also 'all' for all instance settings or
                           'defaults' for all global defaults
           @param  value   any - the new value for the setting
                           (omit if above is an object or to retrieve a value) */
        _optionDatepicker: function(target, name, value) {
            var inst = this._getInst(target);
            if (arguments.length == 2 && typeof name == 'string') {
                return (name == 'defaults' ? $.extend({}, $.datepicker._defaults) :
                    (inst ? (name == 'all' ? $.extend({}, inst.settings) :
                    this._get(inst, name)) : null));
            }
            var settings = name || {};
            if (typeof name == 'string') {
                settings = {};
                settings[name] = value;
            }
            if (inst) {
                if (this._curInst == inst) {
                    this._hideDatepicker();
                }
                var date = this._getDateDatepicker(target, true);
                var minDate = this._getMinMaxDate(inst, 'min');
                var maxDate = this._getMinMaxDate(inst, 'max');

                extendRemove(inst.settings, settings);
                this._attachmentsInput($(target), inst, name, value);
                // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
                if (minDate !== null && settings['dateFormat'] !== undefined && settings['minDate'] === undefined)
                    inst.settings.minDate = this._formatDate(inst, minDate);
                if (maxDate !== null && settings['dateFormat'] !== undefined && settings['maxDate'] === undefined)
                    inst.settings.maxDate = this._formatDate(inst, maxDate);
                this._attachments($(target), inst);
                this._autoSize(inst);
                if(settings.value){
                    var date = settings.value;
                    if($.type.isString(date)){
                        date = this.parseDateTime("yy-mm-dd", "hh:mm:ss", date);
                    }
                    this._setValueDatepicker(target, date);
                }else{
                    this._setDate(inst, date);
                }
                this._updateInput(inst);
                this._updateAlternate(inst);
                this._updateDatepicker(inst);
            }
        },

        // change method deprecated
        _changeDatepicker: function(target, name, value) {
            this._optionDatepicker(target, name, value);
        },

        /* Redraw the date picker attached to an input field or division.
           @param  target  element - the target input field or division or span */
        _refreshDatepicker: function(target) {
            var inst = this._getInst(target);
            if (inst) {
                this._updateDatepicker(inst);
            }
        },

        /* Set the dates for a jQuery selection.
           @param  target   element - the target input field or division or span
           @param  date     Date - the new date */
        _setDateDatepicker: function(target, date, nochange) {
            var inst = this._getInst(target),
                orgDate = inst ? this._getDate(inst, true) : null,
                newDate = this._restrictMinMax(inst, this._determineDate(inst, date)),
                nochange = !! nochange;

            this._setDate(inst, newDate, true);
            this._updateInput(inst);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);
            if(!nochange && !this._isEqual(inst, orgDate, newDate)) {
                if(!this._triggerOnChange(inst, orgDate, newDate)) {
                    this._setDate(inst, orgDate, true);
                    this._updateInput(inst);
                    this._updateDatepicker(inst);
                    this._updateAlternate(inst);
                    return;
                }
            }

            if(!nochange) {
                inst.input.trigger('change', true);
            }
        },

        _setDefaultValueDatepicker: function(target, date) {
            var inst = this._getInst(target);
            inst.defaultValue = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
        },

        _setValueDatepicker: function(target, date, nochange){
            this._setDateDatepicker(target, date, nochange);
        },

        _isEqual: function(inst, prev, cur) {
            var orgYear = prev != null ? prev.getFullYear() : null,
                orgMonth = prev != null ? prev.getMonth() : null,
                orgDate = prev != null ? prev.getDate() : null,
                currentYear = cur != null ? cur.getFullYear() : null,
                currentMonth = cur != null ? cur.getMonth() : null,
                currentDate = cur != null ? cur.getDate() : null;

            return (orgYear == currentYear) && (orgMonth == currentMonth) && (orgDate == currentDate);
        },

        /* Get the date(s) for the first entry in a jQuery selection.
           @param  target     element - the target input field or division or span
           @param  noDefault  boolean - true if no default date is to be used
           @return Date - the current date */
        _getDateDatepicker: function(target, noDefault) {
            var inst = this._getInst(target);
            return (inst ? this._getDate(inst, true) : null);
        },

        _getValueDatepicker: function(target, noDefault) {
            return this._getDateDatepicker(target, noDefault);
        },

        /* Handle keystrokes. */
        _doKeyDown: function(event) {
            var inst = $.datepicker._getInst(event.target);
            var handled = true;
            var isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
            inst._keyEvent = true;
            if ($.datepicker._datepickerShowing)
                switch (event.keyCode) {
                    case 9: if($.datepicker._get(inst, 'type') == 'datetime'){
                                inst.dpDiv.find('.ui_tpicker_hour .ui-slider-handle').focus();
                            }else{
                                $.datepicker._hideDatepicker();
                            }
                            break; // hide on tab out
                    case 13: var sel = $('td.' + $.datepicker._dayOverClass + ':not(.' +
                                        $.datepicker._currentClass + ')', inst.dpDiv);
                            if (sel[0])
                                $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0], true);
                            else
                                $.datepicker._hideDatepicker();
                            break; // select the value on enter
                    case 27: $.datepicker._hideDatepicker();
                            break; // hide on escape
                    case 33:$.datepicker._adjustDate(event.target, (event.originalEvent.altKey ?
                                -$.datepicker._get(inst, 'stepBigMonths') :
                                -$.datepicker._get(inst, 'stepMonths')), 'M');
                            break; // previous month/year on page up/+ ctrl
                    case 34:$.datepicker._adjustDate(event.target, (event.originalEvent.altKey ?
                                +$.datepicker._get(inst, 'stepBigMonths') :
                                +$.datepicker._get(inst, 'stepMonths')), 'M');
                            break; // next month/year on page down/+ ctrl
                    case 35:
                            $.datepicker._clearDate(event.target);
                            break; // clear on ctrl or command +end
                    case 36:
                            $.datepicker._gotoToday(event.target);
                            break; // current on ctrl or command +home
                    case 37:
                            $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), 'D');
                            // next month/year on alt +left on Mac
                            break;
                    case 38:
                            $.datepicker._adjustDate(event.target, -7, 'D');
                            break; // -1 week on ctrl or command +up
                    case 39:
                            $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), 'D');
                            // next month/year on alt +right
                            break;
                    case 40:
                            $.datepicker._adjustDate(event.target, +7, 'D');
                            break; // +1 week on ctrl or command +down
                    default: handled = false;
                }
            //else if (event.keyCode == 36 && event.ctrlKey) // display the date picker on ctrl+home
            else if (event.keyCode == 40) {
                $.datepicker._showDatepicker(this);
            }
            else {
                handled = false;
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
            }
        },

        /* Filter entered characters - based on date format. */
        _doKeyPress: function(event) {
            var inst = $.datepicker._getInst(event.target);
            if ($.datepicker._get(inst, 'constrainInput')) {
                var chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
                var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode);
                return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
            }
        },

        /* Synchronise manual entry and field/alternate field. */
        _doKeyUp: function(event) {
            if(event.keyCode == 9)return;

            var inst = $.datepicker._getInst(event.target),
                text = inst.input.val(),
                nowDate = new Date();
            if(text != inst.lastVal) {
                try {
                    var date = $.datepicker._getDateFromField(inst);

                    if (date || !text) { // only if valid
                        date = this._restrictMinMax(inst, date);
                        var orgDate = $.datepicker._getDate(inst, true);
                        if(!$.datepicker._isEqual(inst, orgDate, date)){
                            this._setDate(inst, date, true);
                            $.datepicker._updateDatepicker(inst);
                            $.datepicker._updateAlternate(inst);

                            if(!$.datepicker._triggerOnChange(inst, orgDate, date)){
                                this._setDate(inst, orgDate, true);
                                $.datepicker._updateDatepicker(inst);
                                $.datepicker._updateAlternate(inst);
                                return true;
                            }

                            inst.input.trigger('change', true);
                            inst.lastVal = text;
                        }
                    }
                } catch (err) {
                    $.datepicker.log(err);
                }
            }
            return true;
        },

        _getDateFromField: function(inst) {
            var date = null;
            if(inst){
                date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'), (inst.input ? inst.input.val() : null), $.datepicker._getFormatConfig(inst));
            }
            return date;
        },

        /* Pop-up the date picker for a given input field.
           If false returned from beforeShow event handler do not show.
           @param  input  element - the input field attached to the date picker or
                          event - if triggered by focus */
        _showDatepicker: function(input, isTrigger) {
            if($.browser.msie){
                // IEfocus
                if(isTrigger){
                    $.datepicker._ieHack = true;
                }else if($.datepicker._ieHack){
                    $.datepicker._ieHack = false;
                    return false;
                }
            }else{
                if(isTrigger)return;
            }


            input = input.target || input;
            var inst = $.datepicker._getInst(input);

            if (input.nodeName.toLowerCase() != 'input') // find from button/image trigger
                input = $('input', input.parentNode)[0];

            if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._get(inst, 'readonly') ||
                $.datepicker._isViewOperateState(inst) || $.datepicker._lastInput == input) // already here
                return;

            if ($.datepicker._curInst && $.datepicker._curInst != inst) {
                $.datepicker._curInst.dpDiv.stop(true, true);
                if ( inst && $.datepicker._datepickerShowing ) {
                    $.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
                }
            }
            var beforeShow = $.datepicker._get(inst, 'beforeShow');
            var beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
            if(beforeShowSettings === false){
                //false
                return;
            }
            extendRemove(inst.settings, beforeShowSettings);
            inst.lastVal = null;
            $.datepicker._lastInput = input;
            $.datepicker._setDateFromField(inst, true);

            if ($.datepicker._inDialog) // hide cursor
                input.value = '';
            if (!$.datepicker._pos) { // position below input
                $.datepicker._pos = $.datepicker._findPos(input);
                $.datepicker._pos[1] += $.datepicker._getFrame(input)[0].offsetHeight; // add the height
            }
            var isFixed = false;
            $(input).parents().each(function() {
                isFixed |= $(this).css('position') == 'fixed';
                return !isFixed;
            });
            if (isFixed && $.browser.opera) { // correction for Opera when fixed and scrolled
                $.datepicker._pos[0] -= document.documentElement.scrollLeft;
                $.datepicker._pos[1] -= document.documentElement.scrollTop;
            }
            var offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
            $.datepicker._pos = null,
                dpDiv = inst.dpDiv;
            //to avoid flashes on Firefox
            dpDiv.empty();
            // determine sizing offscreen
            dpDiv.css({top:0, left:0, position: 'absolute', display: 'block'});
            $.datepicker._updateDatepicker(inst);
            // fix width for dynamic number of date pickers
            // and adjust position before showing
            offset = $.datepicker._checkOffset(inst, offset, isFixed);
            //dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
            //'static' : (isFixed ? 'fixed' : 'absolute')), display: 'none',
            //left: offset.left + 'px', top: offset.top + 'px'});

            var iframeLevel = this._get(inst, "iframeLevel"),
//                inIframe = this._get(inst, "inIframe"),
                inIframe = false,
//                baseDocument = $.wafIframe.getIframeTarget(iframeLevel),
                baseTarget = inIframe ? baseDocument.body : 'body',
                frame = $.datepicker._getFrame(input);

            dpDiv.appendTo(baseTarget);
            dpDiv.position($.extend({of: frame}, {
                    my : "left top",
                    at : "left bottom"
                }));

            if(inIframe) {
                var offset = $.wafIframe.getIframeTargetOffset(iframeLevel);
                dpDiv.css("left", parseInt(dpDiv.css("left")) + offset.left);
                dpDiv.css("top", parseInt(dpDiv.css("top")) + offset.top);
            }

            if (!inst.inline) {
                var showAnim = $.datepicker._get(inst, 'showAnim');
                var duration = $.datepicker._get(inst, 'duration');
                var postProcess = function() {
                    var cover = dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
                    if( !! cover.length ){
                        var borders = $.datepicker._getBorders(dpDiv);
                        cover.css({left: -borders[0], top: -borders[1],
                            width: dpDiv.outerWidth(), height: dpDiv.outerHeight()});
                    }
                };
                dpDiv.zIndex($(input).zIndex()+100);
                $.datepicker._datepickerShowing = true;
                if ($.effects && $.effects[showAnim])
                    dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
                else
                    dpDiv[showAnim || 'show']((showAnim ? duration : null), postProcess);
                if (!showAnim || !duration)
                    postProcess();
                if (inst.input.is(':visible') && !inst.input.is(':disabled'))
                    inst.input.trigger('focus', true);
                $.datepicker._curInst = inst;
            }

            $(document).bind('mousedown', $.datepicker._checkExternalClick);
        },

        _getFrame: function(input){
            return $(input).closest('.' + this._frameClass).eq(0);
        },

        _getLayout: function(input){
            return $(input).closest('.' + this._layoutClass).eq(0);
        },


        /* Generate the date picker content. */
        _updateDatepicker: function(inst) {
            var self = this;
            self.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
            var borders = $.datepicker._getBorders(inst.dpDiv);
            instActive = inst; // for delegate hover events
            inst.dpDiv.empty().append(this._generateHTML(inst));
            var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
            if( !!cover.length ){ //avoid call to outerXXXX() when not in IE6
                cover.css({left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()})
            }
            //inst.dpDiv.find('.' + this._dayOverClass + ' a').mouseover();
            var numMonths = this._getNumberOfMonths(inst);
            var cols = numMonths[1];
            var width = 17;
            inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
            if (cols > 1)
                inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', (width * cols) + 'em');
            inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? 'add' : 'remove') +
                'Class']('ui-datepicker-multi');
            inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') +
                'Class']('ui-datepicker-rtl');
            if (inst == $.datepicker._curInst && $.datepicker._datepickerShowing && inst.input &&
                    // #6694 - don't focus the input if it's already focused
                    // this breaks the change event in IE
                    inst.input.is(':visible') && !inst.input.is(':disabled') && inst.input[0] != document.activeElement)
                inst.input.trigger('focus', true);
            // deffered render of the years select (to avoid flashes on Firefox)
            if( inst.yearshtml ){
                var origyearshtml = inst.yearshtml;
                setTimeout(function(){
                    //assure that inst.yearshtml didn't change.
                    if( origyearshtml === inst.yearshtml && inst.yearshtml ){
                        inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
                    }
                    origyearshtml = inst.yearshtml = null;
                }, 0);
            }
        },

        /* Retrieve the size of left and top borders for an element.
           @param  elem  (jQuery object) the element of interest
           @return  (number[2]) the left and top borders */
        _getBorders: function(elem) {
            var convert = function(value) {
                return {thin: 1, medium: 2, thick: 3}[value] || value;
            };
            return [parseFloat(convert(elem.css('border-left-width'))),
                parseFloat(convert(elem.css('border-top-width')))];
        },

        /* Check positioning to remain on screen. */
        _checkOffset: function(inst, offset, isFixed) {
            var dpWidth = inst.dpDiv.outerWidth();
            var dpHeight = inst.dpDiv.outerHeight();
            var inputWidth = inst.input ? inst.input.outerWidth() : 0;
            var inputHeight = inst.input ? inst.input.outerHeight() : 0;
            var viewWidth = document.documentElement.clientWidth + $(document).scrollLeft();
            var viewHeight = document.documentElement.clientHeight + $(document).scrollTop();

            offset.left -= (this._get(inst, 'isRTL') ? (dpWidth - inputWidth) : 0);
            offset.left -= (isFixed && offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
            offset.top -= (isFixed && offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

            // now check if datepicker is showing outside window viewport - move to a better place if so.
            offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
                Math.abs(offset.left + dpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
                Math.abs(dpHeight + inputHeight) : 0);

            return offset;
        },

        /* Find an object's position on the screen. */
        _findPos: function(obj) {
            var inst = this._getInst(obj);
            var isRTL = this._get(inst, 'isRTL');
            while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
                obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
            }
            var position = $(this._getFrame(obj)).offset();
            return [position.left, position.top];
        },

        /* Hide the date picker from view.
           @param  input  element - the input field attached to the date picker */
        _hideDatepicker: function(input) {
            var inst = this._curInst;
            if (!inst || (input && inst != $.data(input, PROP_NAME)))
                return;
            if (this._datepickerShowing) {
                var showAnim = this._get(inst, 'showAnim');
                var duration = this._get(inst, 'duration');
                var postProcess = function() {
                    $.datepicker._tidyDialog(inst);
                    if($.browser.msie){
                        $.datepicker._ieHack = false;
                    }
                };
                if ($.effects && $.effects[showAnim])
                    inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
                else
                    inst.dpDiv[(showAnim == 'slideDown' ? 'slideUp' :
                        (showAnim == 'fadeIn' ? 'fadeOut' : 'hide'))]((showAnim ? duration : null), postProcess);
                if (!showAnim)
                    postProcess();
                this._datepickerShowing = false;
                var onClose = this._get(inst, 'onClose');
                if (onClose)
                    onClose.apply((inst.input ? inst.input[0] : null),
                        [(inst.input ? inst.input.val() : ''), inst]);
                this._lastInput = null;
                $(document).unbind('mousedown', $.datepicker._checkExternalClick);
                if (this._inDialog) {
                    this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' });
                    if ($.blockUI) {
                        $.unblockUI();
                        $('body').append(this.dpDiv);
                    }
                }
                this._inDialog = false;
            }
        },

        _finishDatepicker: function(input) {
            var inst = this._curInst;
            if (!inst || (input && inst != $.data(input, PROP_NAME)))
                return;

            var selectedDate = this._getSelectedDate(inst, inst.selectedYear, inst.selectedMonth, inst.selectedDay);
            this._flushDate(inst, selectedDate, true);
            inst.input.trigger('focus', true);

            this._hideDatepicker(input);
        },

        /* Tidy up after a dialog display. */
        _tidyDialog: function(inst) {
            inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
        },

        /* Close date picker if clicked elsewhere. */
        _checkExternalClick: function(event) {
            if (!$.datepicker._curInst)
                return;

            var $target = $(event.target),
                inst = $.datepicker._getInst($target[0]);

            if ( ( ( $target[0].id != $.datepicker._mainDivId &&
                    $target.parents('#' + $.datepicker._mainDivId).length == 0 &&
                    !$target.hasClass($.datepicker.markerClassName) &&
                    !$target.closest("." + $.datepicker._triggerClass).length &&
                    $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
                ( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst != inst ) )
                $.datepicker._hideDatepicker();
        },

        /* Adjust one of the date sub-fields. */
        _adjustDate: function(id, offset, period) {
            var target = $(id);
            var inst = this._getInst(target[0]);
            if (this._isDisabledDatepicker(target[0])) {
                return;
            }
            this._adjustInstDate(inst, offset +
                (period == 'M' ? this._get(inst, 'showCurrentAtPos') : 0), // undo positioning
                period);
            this._updateDatepicker(inst);
        },

        /* Action for current link. */
        _gotoToday: function(id) {
            var target = $(id);
            var inst = this._getInst(target[0]);
            if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
                inst.selectedDay = inst.currentDay;
                inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                inst.drawYear = inst.selectedYear = inst.currentYear;
            }
            else {
                var date = new Date();
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
            }
            this._notifyChange(inst);
            this._adjustDate(target);
        },

        /* Action for selecting a new month/year. */
        _selectMonthYear: function(id, select, period) {
            var target = $(id);
            var inst = this._getInst(target[0]);
            inst['selected' + (period == 'M' ? 'Month' : 'Year')] =
            inst['draw' + (period == 'M' ? 'Month' : 'Year')] =
                parseInt(select.options[select.selectedIndex].value,10);
            this._notifyChange(inst);
            this._adjustDate(target);
        },

        /* Action for selecting a day. */
        _selectDay: function(id, month, year, td, fromEnter) {
            fromEnter = !!fromEnter;
            var target = $(id);
            if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                return;
            }
            var inst = this._getInst(target[0]),
                day = $('a', td).html(),
                selectDate = this._getSelectedDate(inst, year, month, day);

            this._setSelectDate(target, selectDate);
            this._flushDate(inst, selectDate, fromEnter);

            if (inst.inline)
                this._updateDatepicker(inst);
            else {
                this._hideDatepicker();
                this._lastInput = inst.input[0];
                inst.input.trigger("focus", true); // restore focus
                this._lastInput = null;
            }
        },

        _getSelectedDate: function(inst, year, month, day){
            if(year == null){
                year = inst.selectedYear;
            }
            if(month == null){
                month = inst.selectedMonth;
            }
            if(day == null){
                day = inst.selectedDay;
            }
            return new Date(year, month, day);
        },

        /* Erase the input field and hide the date picker. */
        _clearDate: function(id) {
            var inst = this._getInst($(id)[0]);

            this._setSelectDate(id, null);
            this._flushDate(inst, null);

            if (inst.inline)
                this._updateDatepicker(inst);
            else {
                this._hideDatepicker();
                this._lastInput = inst.input[0];
                inst.input.trigger("focus", true); // restore focus
                this._lastInput = null;
            }
        },

        _triggerOnSelect: function(inst, date){
            var dateStr = this._formatOutput(inst, date),
                onSelect = this._get(inst, 'onSelect');

            if (onSelect)
                onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
        },

        /* Update the input field with the selected date. */
        _setSelectDate: function(id, date, trigger) {
            trigger = !!trigger;
            var inst = this._getInst($(id)[0])
                nowDate = new Date(),
                origMonth = inst.selectedMonth,
                origYear = inst.selectedYear;

            this._triggerOnSelect(inst, date);

            inst.selectedDay = (date ? date.getDate() : nowDate.getDate());
            inst.selectedMonth = inst.drawMonth = (date ? date.getMonth() : nowDate.getMonth());
            inst.selectedYear = inst.drawYear = (date ? date.getFullYear() : nowDate.getFullYear());

            if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear))
                this._notifyChange(inst);
        },
        _flushDate: function(inst, date, fromEnter) {
            var orgDate = inst ? this._getDate(inst, true) : null;

            if(!this._isEqual(inst, orgDate, date)) {
                this._setDate(inst, date, true);
                this._updateInput(inst);
                this._updateAlternate(inst);
                if(!this._triggerOnChange(inst, orgDate, date)) {
                    this._setDate(inst, orgDate, true);
                    this._updateInput(inst);
                    this._updateAlternate(inst);
                    return;
                }

                inst.input.trigger('change', true);
            }
        },
        /* Update any alternate field to synchronise with the main field. */
        _updateAlternate: function(inst) {
            var altField = this._get(inst, 'altField');
            if (altField) { // update alternate field too
                var altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
                var date = this._getDate(inst, true, true);
                var dateStr = $.datepicker.formatDateTime(altFormat, 'hh:mm:ss', date)
                $(altField).each(function() { $(this).val(dateStr); });
            }
        },

        /* Notify change of date. */
        _triggerOnChange: function(inst, orgDate, newDate) {
            var onChange = this._get(inst, 'onchange'),
                result = true;
            if (onChange){
                result = onChange.apply((inst.input ? inst.input[0] : null), [{"previous" : orgDate, "current" : newDate}, inst]);
            }
            /*
            if(result !== false){
                inst.input.trigger('change'); // fire the change event
            }
            */
            return result !== false;
        },

        /* Set as beforeShowDay function to prevent selection of weekends.
           @param  date  Date - the date to customise
           @return [boolean, string] - is this date selectable?, what is its CSS class? */
        noWeekends: function(date) {
            var day = date.getDay();
            return [(day > 0 && day < 6), ''];
        },

        /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
           @param  date  Date - the date to get the week for
           @return  number - the number of the week within the year that contains this date */
        iso8601Week: function(date) {
            var checkDate = new Date(date.getTime());
            // Find Thursday of this week starting on Monday
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
            var time = checkDate.getTime();
            checkDate.setMonth(0); // Compare with Jan 1
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
        },

        /* Parse a string value into a date object.
           See formatDate below for the possible formats.

           @param  format    string - the expected format of the date
           @param  value     string - the date in the above format
           @param  settings  Object - attributes include:
                             shortYearCutoff  number - the cutoff year for determining the century (optional)
                             dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
                             dayNames         string[7] - names of the days from Sunday (optional)
                             monthNamesShort  string[12] - abbreviated names of the months (optional)
                             monthNames       string[12] - names of the months (optional)
           @return  Date - the extracted date value or null if value is blank */
        parseDate: function (format, value, settings) {
            if (format == null || value == null)
                throw 'Invalid arguments';
            value = (typeof value == 'object' ? value.toString() : value + '');
            if (value == '')
                return null;
            var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;
            shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
                    new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
            var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
            var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
            var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
            var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
            var year = -1;
            var month = -1;
            var day = -1;
            var doy = -1;
            var literal = false;
            // Check whether a format character is doubled
            var lookAhead = function(match) {
                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
                if (matches)
                    iFormat++;
                return matches;
            };
            // Extract a number from the string value
            var getNumber = function(match) {
                var isDoubled = lookAhead(match);
                var size = (match == '@' ? 14 : (match == '!' ? 20 :
                    (match == 'y' && isDoubled ? 4 : (match == 'o' ? 3 : 2))));
                var digits = new RegExp('^\\d{1,' + size + '}');
                var num = value.substring(iValue).match(digits);
                if (!num)
                    throw 'Missing number at position ' + iValue;
                iValue += num[0].length;
                return parseInt(num[0], 10);
            };
            // Extract a name from the string value and convert to an index
            var getName = function(match, shortNames, longNames) {
                var names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
                    return [ [k, v] ];
                }).sort(function (a, b) {
                    return -(a[1].length - b[1].length);
                });
                var index = -1;
                $.each(names, function (i, pair) {
                    var name = pair[1];
                    if (value.substr(iValue, name.length).toLowerCase() == name.toLowerCase()) {
                        index = pair[0];
                        iValue += name.length;
                        return false;
                    }
                });
                if (index != -1)
                    return index + 1;
                else
                    throw 'Unknown name at position ' + iValue;
            };
            // Confirm that a literal character matches the string value
            var checkLiteral = function() {
                if (value.charAt(iValue) != format.charAt(iFormat))
                    throw 'Unexpected literal at position ' + iValue;
                iValue++;
            };
            var iValue = 0;
            for (var iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal)
                    if (format.charAt(iFormat) == "'" && !lookAhead("'"))
                        literal = false;
                    else
                        checkLiteral();
                else
                    switch (format.charAt(iFormat)) {
                        case 'd':
                            day = getNumber('d');
                            break;
                        case 'D':
                            getName('D', dayNamesShort, dayNames);
                            break;
                        case 'o':
                            doy = getNumber('o');
                            break;
                        case 'm':
                            month = getNumber('m');
                            break;
                        case 'M':
                            month = getName('M', monthNamesShort, monthNames);
                            break;
                        case 'y':
                            year = getNumber('y');
                            break;
                        case '@':
                            var date = new Date(getNumber('@'));
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case '!':
                            var date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "'":
                            if (lookAhead("'"))
                                checkLiteral();
                            else
                                literal = true;
                            break;
                        default:
                            checkLiteral();
                    }
            }
            if (iValue < value.length){
                throw "Extra/unparsed characters found in date: " + value.substring(iValue);
            }
            if (year == -1)
                year = new Date().getFullYear();
            else if (year < 100)
                year += new Date().getFullYear() - new Date().getFullYear() % 100 +
                    (year <= shortYearCutoff ? 0 : -100);
            if (doy > -1) {
                month = 1;
                day = doy;
                do {
                    var dim = this._getDaysInMonth(year, month - 1);
                    if (day <= dim)
                        break;
                    month++;
                    day -= dim;
                } while (true);
            }
            var date = this._daylightSavingAdjust(new Date(year, month - 1, day));
            if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day)
                throw 'Invalid date'; // E.g. 31/02/00
            return date;
        },

        /* Standard date formats. */
        ATOM: 'yy-mm-dd', // RFC 3339 (ISO 8601)
        COOKIE: 'D, dd M yy',
        ISO_8601: 'yy-mm-dd',
        RFC_822: 'D, d M y',
        RFC_850: 'DD, dd-M-y',
        RFC_1036: 'D, d M y',
        RFC_1123: 'D, d M yy',
        RFC_2822: 'D, d M yy',
        RSS: 'D, d M y', // RFC 822
        TICKS: '!',
        TIMESTAMP: '@',
        W3C: 'yy-mm-dd', // ISO 8601

        _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
            Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

        /* Format a date object into a string value.
           The format can be combinations of the following:
           d  - day of month (no leading zero)
           dd - day of month (two digit)
           o  - day of year (no leading zeros)
           oo - day of year (three digit)
           D  - day name short
           DD - day name long
           m  - month of year (no leading zero)
           mm - month of year (two digit)
           M  - month name short
           MM - month name long
           y  - year (two digit)
           yy - year (four digit)
           @ - Unix timestamp (ms since 01/01/1970)
           ! - Windows ticks (100ns since 01/01/0001)
           '...' - literal text
           '' - single quote

           @param  format    string - the desired format of the date
           @param  date      Date - the date value to format
           @param  settings  Object - attributes include:
                             dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
                             dayNames         string[7] - names of the days from Sunday (optional)
                             monthNamesShort  string[12] - abbreviated names of the months (optional)
                             monthNames       string[12] - names of the months (optional)
           @return  string - the date in the above format */
        formatDate: function (format, date, settings) {
            if (!date)
                return '';
            var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
            var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
            var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
            var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
            // Check whether a format character is doubled
            var lookAhead = function(match) {
                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
                if (matches)
                    iFormat++;
                return matches;
            };
            // Format a number, with leading zero if necessary
            var formatNumber = function(match, value, len) {
                var num = '' + value;
                if (lookAhead(match))
                    while (num.length < len)
                        num = '0' + num;
                return num;
            };
            // Format a name, short or long as requested
            var formatName = function(match, value, shortNames, longNames) {
                return (lookAhead(match) ? longNames[value] : shortNames[value]);
            };
            var output = '';
            var literal = false;
            if (date)
                for (var iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal)
                        if (format.charAt(iFormat) == "'" && !lookAhead("'"))
                            literal = false;
                        else
                            output += format.charAt(iFormat);
                    else
                        switch (format.charAt(iFormat)) {
                            case 'd':
                                output += formatNumber('d', date.getDate(), 2);
                                break;
                            case 'D':
                                output += formatName('D', date.getDay(), dayNamesShort, dayNames);
                                break;
                            case 'o':
                                output += formatNumber('o',
                                    Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                                break;
                            case 'm':
                                output += formatNumber('m', date.getMonth() + 1, 2);
                                break;
                            case 'M':
                                output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
                                break;
                            case 'y':
                                output += (lookAhead('y') ? date.getFullYear() :
                                    (date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);
                                break;
                            case '@':
                                output += date.getTime();
                                break;
                            case '!':
                                output += date.getTime() * 10000 + this._ticksTo1970;
                                break;
                            case "'":
                                if (lookAhead("'"))
                                    output += "'";
                                else
                                    literal = true;
                                break;
                            default:
                                output += format.charAt(iFormat);
                        }
                }
            return output;
        },

        /* Extract all possible characters from the date format. */
        _possibleChars: function (format) {
            var chars = '';
            var literal = false;
            // Check whether a format character is doubled
            var lookAhead = function(match) {
                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
                if (matches)
                    iFormat++;
                return matches;
            };
            for (var iFormat = 0; iFormat < format.length; iFormat++)
                if (literal)
                    if (format.charAt(iFormat) == "'" && !lookAhead("'"))
                        literal = false;
                    else
                        chars += format.charAt(iFormat);
                else
                    switch (format.charAt(iFormat)) {
                        case 'd': case 'm': case 'y': case '@':
                            chars += '0123456789';
                            break;
                        case 'D': case 'M':
                            return null; // Accept anything
                        case "'":
                            if (lookAhead("'"))
                                chars += "'";
                            else
                                literal = true;
                            break;
                        default:
                            chars += format.charAt(iFormat);
                    }
            return chars;
        },

        /* Get a setting value, defaulting if necessary. */
        _get: function(inst, name) {
            return inst.settings[name] !== undefined ?
                inst.settings[name] : this._defaults[name];
        },

        /* Parse existing date and initialise date picker. */
        _setDateFromField: function(inst, noDefault) {
            if (inst.input.val() == inst.lastVal) {
                return;
            }
            var dateFormat = this._get(inst, 'dateFormat');
            var dates = inst.lastVal = inst.input ? inst.input.val() : null;
            var date, defaultDate;
            date = defaultDate = this._getDefaultDate(inst);
            var settings = this._getFormatConfig(inst);
            try {
                date = this.parseDate(dateFormat, dates, settings) || defaultDate;
            } catch (event) {
                this.log(event);
                dates = (noDefault ? '' : dates);
            }

            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();

            inst.currentDay = (dates ? date.getDate() : 0);
            inst.currentMonth = (dates ? date.getMonth() : 0);
            inst.currentYear = (dates ? date.getFullYear() : 0);

            inst._hour = (dates ? date.getHours() : 0);
            inst._minute = (dates ? date.getMinutes() : 0);
            inst._second = (dates ? date.getSeconds() : 0);
            inst._millisec = (dates ? date.getMilliseconds() : 0);

            this._adjustInstDate(inst);
        },

        /* Retrieve the default date shown on opening. */
        _getDefaultDate: function(inst) {
            return this._restrictMinMax(inst,
                this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
        },

        /* A date may be specified as an exact value or a relative one. */
        _determineDate: function(inst, date, defaultDate) {
            var offsetNumeric = function(offset) {
                var date = new Date();
                date.setDate(date.getDate() + offset);
                return date;
            };
            var offsetString = function(offset) {
                try {
                    return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
                        offset, $.datepicker._getFormatConfig(inst));
                }
                catch (e) {
                    // Ignore
                }
                var date = (offset.toLowerCase().match(/^c/) ?
                    $.datepicker._getDate(inst) : null) || new Date();
                var year = date.getFullYear();
                var month = date.getMonth();
                var day = date.getDate();
                var pattern = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g;
                var matches = pattern.exec(offset);
                while (matches) {
                    switch (matches[2] || 'd') {
                        case 'd' : case 'D' :
                            day += parseInt(matches[1],10); break;
                        case 'w' : case 'W' :
                            day += parseInt(matches[1],10) * 7; break;
                        case 'm' : case 'M' :
                            month += parseInt(matches[1],10);
                            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                            break;
                        case 'y': case 'Y' :
                            year += parseInt(matches[1],10);
                            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                            break;
                    }
                    matches = pattern.exec(offset);
                }
                return new Date(year, month, day);
            };
            var newDate = (date == null || date === '' ? defaultDate : (typeof date == 'string' ? offsetString(date) :
                (typeof date == 'number' ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
            newDate = (newDate && newDate.toString() == 'Invalid Date' ? defaultDate : newDate);
            //this._clearTime(inst, newDate);
            return this._daylightSavingAdjust(newDate);
        },

        _clearTime: function(inst, date){
            if(!inst || !date){
                return;
            }
            date.setHours(0);
            date.setMinutes(0);
            date.setSeconds(0);
            date.setMilliseconds(0);
        },

        /* Handle switch to/from daylight saving.
           Hours may be non-zero on daylight saving cut-over:
           > 12 when midnight changeover, but then cannot generate
           midnight datetime, so jump to 1AM, otherwise reset.
           @param  date  (Date) the date to check
           @return  (Date) the corrected date */
        _daylightSavingAdjust: function(date) {
            return date;
        },

        /* Set the date(s) directly. */
        _setDate: function(inst, date, noChange) {
            var origMonth = inst.selectedMonth,
                origYear = inst.selectedYear,
                nowDate = new Date(),
                newDate = this._restrictMinMax(inst, this._determineDate(inst, date, nowDate));

            inst.selectedDay = (date ? date.getDate() : nowDate.getDate());
            inst.selectedMonth = inst.drawMonth = (date ? date.getMonth() : nowDate.getMonth());
            inst.selectedYear = inst.drawYear = (date ? date.getFullYear() : nowDate.getFullYear());

            inst.currentDay = (date ? date.getDate() : 0);
            inst.currentMonth = (date ? date.getMonth() : 0);
            inst.currentYear = (date ? date.getFullYear() : 0);

            inst._hour = (date ? date.getHours() : 0);
            inst._minute = (date ? date.getMinutes() : 0);
            inst._second = (date ? date.getSeconds() : 0);
            inst._millisec = (date ? date.getMilliseconds() : 0);

            if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) && !noChange)
                this._notifyChange(inst);
            this._adjustInstDate(inst);
        },

        /* Retrieve the date(s) directly. */
        _getDate: function(inst, onlyByInst) {
            var onlyByInst = !!onlyByInst,
                startDate = inst.currentYear && (onlyByInst || (inst.input && inst.input.val() !== ''))?
                        this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)) : null;

            if(startDate){
                startDate.setHours(inst._hour);
                startDate.setMinutes(inst._minute);
                startDate.setSeconds(inst._second);
                startDate.setMilliseconds(inst._millisec);
            }

            return startDate;
        },

        /* Generate the HTML for the current state of the date picker. */
        _generateHTML: function(inst) {
            var today = new Date();
            today = this._daylightSavingAdjust(
                new Date(today.getFullYear(), today.getMonth(), today.getDate())); // clear time
            var isRTL = this._get(inst, 'isRTL');
            var showButtonPanel = this._get(inst, 'showButtonPanel');
            var hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext');
            var navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat');
            var numMonths = this._getNumberOfMonths(inst);
            var showCurrentAtPos = this._get(inst, 'showCurrentAtPos');
            var stepMonths = this._get(inst, 'stepMonths');
            var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);
            var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
                new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
            var minDate = this._getMinMaxDate(inst, 'min');
            var maxDate = this._getMinMaxDate(inst, 'max');
            var drawMonth = inst.drawMonth - showCurrentAtPos;
            var drawYear = inst.drawYear;
            if (drawMonth < 0) {
                drawMonth += 12;
                drawYear--;
            }
            if (maxDate) {
                var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
                    maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
                maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
                while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                    drawMonth--;
                    if (drawMonth < 0) {
                        drawMonth = 11;
                        drawYear--;
                    }
                }
            }
            inst.drawMonth = drawMonth;
            inst.drawYear = drawYear;
            var prevText = this._get(inst, 'prevText');
            prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
                this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
                this._getFormatConfig(inst)));
            var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
                '<a class="ui-datepicker-prev ui-corner-all" onclick="' + getCaller(inst) +
                '.datepicker._adjustDate(\'#' + inst.id + '\', -' + stepMonths + ', \'M\');"' +
                ' title="' + prevText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>' :
                (hideIfNoPrevNext ? '' : '<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+ prevText +'"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>'));
            var nextText = this._get(inst, 'nextText');
            nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
                this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
                this._getFormatConfig(inst)));
            var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
                '<a class="ui-datepicker-next ui-corner-all" onclick="' + getCaller(inst) +
                '.datepicker._adjustDate(\'#' + inst.id + '\', +' + stepMonths + ', \'M\');"' +
                ' title="' + nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>' :
                (hideIfNoPrevNext ? '' : '<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+ nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>'));
            var currentText = this._get(inst, 'currentText');
            var gotoDate = (this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today);
            currentText = (!navigationAsDateFormat ? currentText :
                this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
            var controls = (!inst.inline ? '<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" onclick="' + getCaller(inst) +
                '.datepicker._finishDatepicker();">' + this._get(inst, 'closeText') + '</button>' : '');
            var buttonPanel = (showButtonPanel) ? '<div class="ui-datepicker-buttonpane ui-widget-content">' + (isRTL ? controls : '') +
                (this._isInRange(inst, gotoDate) ? '<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" onclick="' + getCaller(inst) +
                '.datepicker._gotoToday(\'#' + inst.id + '\');"' +
                '>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
            var firstDay = parseInt(this._get(inst, 'firstDay'),10);
            firstDay = (isNaN(firstDay) ? 0 : firstDay);
            var showWeek = this._get(inst, 'showWeek');
            var dayNames = this._get(inst, 'dayNames');
            var dayNamesShort = this._get(inst, 'dayNamesShort');
            var dayNamesMin = this._get(inst, 'dayNamesMin');
            var monthNames = this._get(inst, 'monthNames');
            var monthNamesShort = this._get(inst, 'monthNamesShort');
            var beforeShowDay = this._get(inst, 'beforeShowDay');
            var showOtherMonths = this._get(inst, 'showOtherMonths');
            var selectOtherMonths = this._get(inst, 'selectOtherMonths');
            var calculateWeek = this._get(inst, 'calculateWeek') || this.iso8601Week;
            var defaultDate = this._getDefaultDate(inst);
            var html = '';
            for (var row = 0; row < numMonths[0]; row++) {
                var group = '';
                this.maxRows = 4;
                for (var col = 0; col < numMonths[1]; col++) {
                    this.maxRows = 4;
                    var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                    var cornerClass = ' ui-corner-all';
                    var calender = '';
                    if (isMultiMonth) {
                        calender += '<div class="ui-datepicker-group';
                        if (numMonths[1] > 1)
                            switch (col) {
                                case 0: calender += ' ui-datepicker-group-first';
                                    cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left'); break;
                                case numMonths[1]-1: calender += ' ui-datepicker-group-last';
                                    cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right'); break;
                                default: calender += ' ui-datepicker-group-middle'; cornerClass = ''; break;
                            }
                        calender += '">';
                    }
                    calender += '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '">' +
                        (/all|left/.test(cornerClass) && row == 0 ? (isRTL ? next : prev) : '') +
                        (/all|right/.test(cornerClass) && row == 0 ? (isRTL ? prev : next) : '') +
                        this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
                        row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
                        '</div><table class="ui-datepicker-calendar"><thead>' +
                        '<tr>';
                    var thead = (showWeek ? '<th class="ui-datepicker-week-col">' + this._get(inst, 'weekHeader') + '</th>' : '');
                    for (var dow = 0; dow < 7; dow++) { // days of the week
                        var day = (dow + firstDay) % 7;
                        thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ? ' class="ui-datepicker-week-end"' : '') + '>' +
                            '<span title="' + dayNames[day] + '">' + dayNamesMin[day] + '</span></th>';
                    }
                    calender += thead + '</tr></thead><tbody>';
                    var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                    if (drawYear == inst.selectedYear && drawMonth == inst.selectedMonth)
                        inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                    var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                    var curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
                    var numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
                    this.maxRows = numRows;
                    var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                    for (var dRow = 0; dRow < numRows; dRow++) { // create date picker rows
                        calender += '<tr>';
                        var tbody = (!showWeek ? '' : '<td class="ui-datepicker-week-col">' +
                            this._get(inst, 'calculateWeek')(printDate) + '</td>');
                        for (var dow = 0; dow < 7; dow++) { // create date picker days
                            var daySettings = (beforeShowDay ?
                                beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, '']);
                            var otherMonth = (printDate.getMonth() != drawMonth);
                            var unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
                                (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
                            tbody += '<td class="' +
                                ((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + // highlight weekends
                                (otherMonth ? ' ui-datepicker-other-month' : '') + // highlight days from other months
                                ((printDate.getTime() == selectedDate.getTime() && drawMonth == inst.selectedMonth) || // user pressed key
                                (defaultDate.getTime() == printDate.getTime() && defaultDate.getTime() == selectedDate.getTime()) ?
                                // or defaultDate is current printedDate and defaultDate is selectedDate
                                ' ' + this._dayOverClass : '') + // highlight selected day
                                (unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled': '') +  // highlight unselectable days
                                (otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + // highlight custom dates
                                (printDate.getTime() == currentDate.getTime() ? ' ' + this._currentClass : '') + // highlight selected day
                                (printDate.getTime() == today.getTime() ? ' ui-datepicker-today' : '')) + '"' + // highlight today (if different)
                                ((!otherMonth || showOtherMonths) && daySettings[2] ? ' title="' + daySettings[2] + '"' : '') + // cell title
                                (unselectable ? '' : ' onclick="' + getCaller(inst) + '.datepicker._selectDay(\'#' +
                                inst.id + '\',' + printDate.getMonth() + ',' + printDate.getFullYear() + ', this);return false;"') + '>' + // actions
                                (otherMonth && !showOtherMonths ? '&#xa0;' : // display for other months
                                (unselectable ? '<span class="ui-state-default">' + printDate.getDate() + '</span>' : '<a class="ui-state-default' +
                                (printDate.getTime() == today.getTime() ? ' ui-state-highlight' : '') +
                                (printDate.getTime() == currentDate.getTime() ? ' ui-state-active' : '') + // highlight selected day
                                (otherMonth ? ' ui-priority-secondary' : '') + // distinguish dates from other months
                                '" href="#">' + printDate.getDate() + '</a>')) + '</td>'; // display selectable date
                            printDate.setDate(printDate.getDate() + 1);
                            printDate = this._daylightSavingAdjust(printDate);
                        }
                        calender += tbody + '</tr>';
                    }
                    drawMonth++;
                    if (drawMonth > 11) {
                        drawMonth = 0;
                        drawYear++;
                    }
                    calender += '</tbody></table>' + (isMultiMonth ? '</div>' +
                                ((numMonths[0] > 0 && col == numMonths[1]-1) ? '<div class="ui-datepicker-row-break"></div>' : '') : '');
                    group += calender;
                }
                html += group;
            }
            html += buttonPanel + ($.browser.msie && parseInt($.browser.version,10) < 7 && !inst.inline ?
                '<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>' : '');
            inst._keyEvent = false;
            return html;
        },

        /* Generate the month and year header. */
        _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
                secondary, monthNames, monthNamesShort) {
            var changeMonth = this._get(inst, 'changeMonth');
            var changeYear = this._get(inst, 'changeYear');
            var showMonthAfterYear = this._get(inst, 'showMonthAfterYear');
            var html = '<div class="ui-datepicker-title">';
            var monthHtml = '';
            // month selection
            if (secondary || !changeMonth)
                monthHtml += '<span class="ui-datepicker-month">' + monthNames[drawMonth] + '</span>';
            else {
                var inMinYear = (minDate && minDate.getFullYear() == drawYear);
                var inMaxYear = (maxDate && maxDate.getFullYear() == drawYear);
                monthHtml += '<select class="ui-datepicker-month" ' +
                    'onchange="' + getCaller(inst) + '.datepicker._selectMonthYear(\'#' + inst.id + '\', this, \'M\');" ' +
                     '>';
                for (var month = 0; month < 12; month++) {
                    if ((!inMinYear || month >= minDate.getMonth()) &&
                            (!inMaxYear || month <= maxDate.getMonth()))
                        monthHtml += '<option value="' + month + '"' +
                            (month == drawMonth ? ' selected="selected"' : '') +
                            '>' + monthNamesShort[month] + '</option>';
                }
                monthHtml += '</select>';
            }
            if (!showMonthAfterYear)
                html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
            // year selection
            if ( !inst.yearshtml ) {
                inst.yearshtml = '';
                if (secondary || !changeYear)
                    html += '<span class="ui-datepicker-year">' + drawYear + '</span>';
                else {
                    // determine range of years to display
                    var years = this._get(inst, 'yearRange').split(':');
                    var thisYear = new Date().getFullYear();
                    var determineYear = function(value) {
                        var year = (value.match(/c[+-].*/) ? drawYear + parseInt(value.substring(1), 10) :
                            (value.match(/[+-].*/) ? thisYear + parseInt(value, 10) :
                            parseInt(value, 10)));
                        return (isNaN(year) ? thisYear : year);
                    };
                    var year = determineYear(years[0]);
                    var endYear = Math.max(year, determineYear(years[1] || ''));
                    year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
                    endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
                    inst.yearshtml += '<select class="ui-datepicker-year" ' +
                        'onchange="' + getCaller(inst) + '.datepicker._selectMonthYear(\'#' + inst.id + '\', this, \'Y\');" ' +
                        '>';
                    for (; year <= endYear; year++) {
                        inst.yearshtml += '<option value="' + year + '"' +
                            (year == drawYear ? ' selected="selected"' : '') +
                            '>' + year + '</option>';
                    }
                    inst.yearshtml += '</select>';

                    html += inst.yearshtml;
                    inst.yearshtml = null;
                }
            }
            html += this._get(inst, 'yearSuffix');
            if (showMonthAfterYear)
                html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
            html += '</div>'; // Close datepicker_header
            return html;
        },

        /* Adjust one of the date sub-fields. */
        _adjustInstDate: function(inst, offset, period) {
            var year = inst.selectedYear + (period == 'Y' ? offset : 0),
                month = inst.selectedMonth + (period == 'M' ? offset : 0),
                day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period == 'D' ? offset : 0),
                origMonth = inst.selectedMonth,
                origYear = inst.selectedYear,
                date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();

            if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear))
                this._notifyChange(inst);

            /*
            if (period == 'M' || period == 'Y')
                this._notifyChange(inst);
                */
        },

        /* Ensure a date is within any min/max bounds. */
        _restrictMinMax: function(inst, date) {
            if(date == null){
                return null;
            }
            var minDate = this._getMinMaxDate(inst, 'min');
            var maxDate = this._getMinMaxDate(inst, 'max');
            var newDate = (minDate && date < minDate ? minDate : date);
            newDate = (maxDate && newDate > maxDate ? maxDate : newDate);
            return newDate;
        },

        /* Notify change of month/year. */
        _notifyChange: function(inst) {
            var onChange = this._get(inst, 'onChangeMonthYear');
            if (onChange)
                onChange.apply((inst.input ? inst.input[0] : null),
                    [inst.selectedYear, inst.selectedMonth + 1, inst]);
        },

        /* Determine the number of months to show. */
        _getNumberOfMonths: function(inst) {
            var numMonths = this._get(inst, 'numberOfMonths');
            return (numMonths == null ? [1, 1] : (typeof numMonths == 'number' ? [1, numMonths] : numMonths));
        },

        /* Determine the current maximum date - ensure no time components are set. */
        _getMinMaxDate: function(inst, minMax) {
            return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
        },

        /* Find the number of days in a given month.*/
        _getDaysInMonth: function(year, month) {
            return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
        },

        /* Find the day of the week of the first of a month. */
        _getFirstDayOfMonth: function(year, month) {
            return new Date(year, month, 1).getDay();
        },

        /* Determines if we should allow a "next/prev" month display change. */
        _canAdjustMonth: function(inst, offset, curYear, curMonth) {
            var numMonths = this._getNumberOfMonths(inst);
            var date = this._daylightSavingAdjust(new Date(curYear,
                curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
            if (offset < 0)
                date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
            return this._isInRange(inst, date);
        },

        /* Is the given date in the accepted range? */
        _isInRange: function(inst, date) {
            var minDate = this._getMinMaxDate(inst, 'min');
            var maxDate = this._getMinMaxDate(inst, 'max');
            return ((!minDate || date.getTime() >= minDate.getTime()) &&
                (!maxDate || date.getTime() <= maxDate.getTime()));
        },

        /* Provide the configuration settings for formatting/parsing. */
        _getFormatConfig: function(inst) {
            var shortYearCutoff = this._get(inst, 'shortYearCutoff');
            shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
                new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
            return {shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get(inst, 'dayNamesShort'), dayNames: this._get(inst, 'dayNames'),
                monthNamesShort: this._get(inst, 'monthNamesShort'), monthNames: this._get(inst, 'monthNames')};
        },

        /* Format the given date for display. */
        _formatDate: function(inst, day, month, year) {
            if (!day) {
                inst.currentDay = inst.selectedDay;
                inst.currentMonth = inst.selectedMonth;
                inst.currentYear = inst.selectedYear;
            }
            var date = (day ? (typeof day == 'object' ? day :
                this._daylightSavingAdjust(new Date(year, month, day))) :
                this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
            return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
        }
    });

    /*
     * Bind hover events for datepicker elements.
     * Done via delegate so the binding only occurs once in the lifetime of the parent div.
     * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
     */
    function bindHover(dpDiv) {
        var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a',
            tabListStr = '.ui_tpicker_hour a.ui-slider-handle,.ui_tpicker_minute a.ui-slider-handle,.ui_tpicker_second a.ui-slider-handle,.ui-datepicker-current,.ui-datepicker-close',
            tabList = tabListStr.split(',');

         dpDiv.bind('mouseout', function(event) {
                var elem = $( event.target ).closest( selector );
                if ( !elem.length ) {
                    return;
                }
                elem.removeClass( "ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover" );
            })
            .bind('mouseover', function(event) {
                var elem = $( event.target ).closest( selector );
                if ($.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0]) ||
                        !elem.length ) {
                    return;
                }
                elem.parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
                elem.addClass('ui-state-hover');
                if (elem.hasClass('ui-datepicker-prev')) elem.addClass('ui-datepicker-prev-hover');
                if (elem.hasClass('ui-datepicker-next')) elem.addClass('ui-datepicker-next-hover');
            })
            .bind('keydown', function(event){
                var elem = $( event.target ),
                    doc = event.target.ownerDocument,
                    keyCode = $.ui.keyCode;

                switch (event.keyCode) {
                    case keyCode.TAB:
                        if($(elem).is(tabListStr)){
                            var found = false,
                                next;
                            for(var i = 0, length = tabList.length; i < length; i++){
                                if(found && $(tabList[i], doc).is(":visible")){
                                    next = $(tabList[i], doc);
                                    break;
                                }
                                if($(elem).is(tabList[i])){
                                    found = true;
                                }
                            }

                            if(next){
                                next.focus();
                            }else{
                                instActive.input.trigger('focus', true);
                            }

                            return false;
                        }
                        return true;
                    case keyCode.ENTER:
                        if($(elem).is('.ui-slider-handle')){
                            $.datepicker._finishDatepicker();
                        }
                        return true;
                    case keyCode.ESCAPE:
                        instActive.input.trigger('focus', true);
                        $.datepicker._hideDatepicker();
                        return true;
                }
            }).bind('click', function(e){
                e.stopPropagation();
            });

        dpDiv.delegate('.ui-datepicker-current,.ui-datepicker-close', 'focus', function(e){
            var elem = $( e.target );
            elem.addClass('ui-state-hover');
        });
        dpDiv.delegate('.ui-datepicker-current,.ui-datepicker-close', 'blur', function(e){
            var elem = $( e.target );
            elem.removeClass('ui-state-hover');
        });

        return dpDiv;
    }

    /* jQuery extend now ignores nulls! */
    function extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props)
            if (props[name] == null || props[name] == undefined)
                target[name] = props[name];
        return target;
    };

    function getCaller(inst){
        var inIframe = $.datepicker._get(inst, "inIframe"),
            iframeLevel = $.datepicker._get(inst, "iframeLevel"),
            prefix = "";

        if(inIframe){
            prefix = $.wafIframe.getIframeNames(iframeLevel).join(".");
            if(prefix){
                prefix += ".";
            }
        }
        return prefix + 'DP_jQuery_' + dpuuid;
    }

    /* Determine whether an object is an array. */
    function isArray(a) {
        return (a && (($.browser.safari && typeof a == 'object' && a.length) ||
            (a.constructor && a.constructor.toString().match(/\Array\(\)/))));
    };

    /* Invoke the datepicker functionality.
       @param  options  string - a command, optionally followed by additional parameters or
                        Object - settings for attaching new datepicker functionality
       @return  jQuery object */
    $.fn.datepicker = function(options){

        /* Verify an empty collection wasn't passed - Fixes #6976 */
        if ( !this.length ) {
            return this;
        }

        /* Initialise the date picker. */
        if (!$.datepicker.initialized) {
            //$(document).mousedown($.datepicker._checkExternalClick);
            $.datepicker.dpDiv.appendTo("body");
            $.datepicker.initialized = true;
        }

        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options == 'string' && (options == 'isDisabled' || options == 'getDate' || options == 'getValue' || options == 'widget'))
            return $.datepicker['_' + options + 'Datepicker'].
                apply($.datepicker, [this[0]].concat(otherArgs));
        if (options == 'option' && arguments.length == 2 && typeof arguments[1] == 'string')
            return $.datepicker['_' + options + 'Datepicker'].
                apply($.datepicker, [this[0]].concat(otherArgs));
        return this.each(function() {
            typeof options == 'string' ?
                $.datepicker['_' + options + 'Datepicker'].
                    apply($.datepicker, [this].concat(otherArgs)) :
                $.datepicker._attachDatepicker(this, options);
        });
    };

    //add i18n

    $.datepicker = new Datepicker(); // singleton instance
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = "1.8.16";          
//    $.datepicker.setDefaults($.wafDatepicker.resource);
    // Workaround for #4055
    // Add another global to avoid noConflict issues with inline event handlers
    window['DP_jQuery_' + dpuuid] = $;

    //for waf2
    //$.fn.wafDatePicker = $.fn.datepicker;
    $.wafDatePicker = $.datepicker;
    $.extend($.wafDatePicker, {
        createDatePickerDOM: function(opts) {
             var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated")))  {
                    return [$('<input id="' + opts.id + '" name="' + opts.name + '_el" type="text" class="hasDatepicker">'),
                    $('<input id="' + opts.id + '_el" name="' + opts.name + '" type="hidden">'),
                    $('<label class="viewStatus" id="' + opts.id + '_view"></label>')];
                }  else {
                    return obj;
                }
        },
        initDatePicker: function(opts, el) {
            el=$.isArray(el)?el[0]:el;
            el.wafDatePicker(opts);
        },
        removeDatePicker: function(opts) {
            var el = $("#" + opts.id),
                subel = $("#" + opts.id + "_el"),
                view = $("#" + opts.id + "_view");

            if(el.length) {
                el.wafDatePicker("destroy");
                el.remove();
            }
            if(subel.length) {
                subel.remove();
            }
            if(view.length) {
                view.remove();
            }
        },
        modifyDatePicker: function(opts) {
            var option = $.extend(true, {}, opts);
            _value = option.value, el = $("#" + option.id);
            delete option.value;
            el.wafDatePicker("option", option);
            if(_value != null) {
                el.wafDatePicker("setValue", _value);
            }
        }
    });
    $(function() {
        if($.registerComponent) $.registerComponent("datePicker", {
            createDOMFun: $.wafDatePicker.createDatePickerDOM,
            initFun: $.wafDatePicker.initDatePicker,
            deleteFun: $.wafDatePicker.removeDatePicker,
            modifyFun: $.wafDatePicker.modifyDatePicker,
            lazyInit:true
        });
    });
    })(jQuery);

/*
 * jQuery UI Effects 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/
 */
;jQuery.effects || (function($, undefined) {

$.effects = {};



/******************************************************************************/
/****************************** COLOR ANIMATIONS ******************************/
/******************************************************************************/

// override the animation for color styles
$.each(['backgroundColor', 'borderBottomColor', 'borderLeftColor',
	'borderRightColor', 'borderTopColor', 'borderColor', 'color', 'outlineColor'],
function(i, attr) {
	$.fx.step[attr] = function(fx) {
		if (!fx.colorInit) {
			fx.start = getColor(fx.elem, attr);
			fx.end = getRGB(fx.end);
			fx.colorInit = true;
		}

		fx.elem.style[attr] = 'rgb(' +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[0] - fx.start[0])) + fx.start[0], 10), 255), 0) + ',' +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[1] - fx.start[1])) + fx.start[1], 10), 255), 0) + ',' +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[2] - fx.start[2])) + fx.start[2], 10), 255), 0) + ')';
	};
});

// Color Conversion functions from highlightFade
// By Blair Mitchelmore
// http://jquery.offput.ca/highlightFade/

// Parse strings looking for color tuples [255,255,255]
function getRGB(color) {
		var result;

		// Check if we're already dealing with an array of colors
		if ( color && color.constructor == Array && color.length == 3 )
				return color;

		// Look for rgb(num,num,num)
		if (result = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(color))
				return [parseInt(result[1],10), parseInt(result[2],10), parseInt(result[3],10)];

		// Look for rgb(num%,num%,num%)
		if (result = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(color))
				return [parseFloat(result[1])*2.55, parseFloat(result[2])*2.55, parseFloat(result[3])*2.55];

		// Look for #a0b1c2
		if (result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(color))
				return [parseInt(result[1],16), parseInt(result[2],16), parseInt(result[3],16)];

		// Look for #fff
		if (result = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(color))
				return [parseInt(result[1]+result[1],16), parseInt(result[2]+result[2],16), parseInt(result[3]+result[3],16)];

		// Look for rgba(0, 0, 0, 0) == transparent in Safari 3
		if (result = /rgba\(0, 0, 0, 0\)/.exec(color))
				return colors['transparent'];

		// Otherwise, we're most likely dealing with a named color
		return colors[$.trim(color).toLowerCase()];
}

function getColor(elem, attr) {
		var color;

		do {
				color = $.curCSS(elem, attr);

				// Keep going until we find an element that has color, or we hit the body
				if ( color != '' && color != 'transparent' || $.nodeName(elem, "body") )
						break;

				attr = "backgroundColor";
		} while ( elem = elem.parentNode );

		return getRGB(color);
};

// Some named colors to work with
// From Interface by Stefan Petre
// http://interface.eyecon.ro/

var colors = {
	aqua:[0,255,255],
	azure:[240,255,255],
	beige:[245,245,220],
	black:[0,0,0],
	blue:[0,0,255],
	brown:[165,42,42],
	cyan:[0,255,255],
	darkblue:[0,0,139],
	darkcyan:[0,139,139],
	darkgrey:[169,169,169],
	darkgreen:[0,100,0],
	darkkhaki:[189,183,107],
	darkmagenta:[139,0,139],
	darkolivegreen:[85,107,47],
	darkorange:[255,140,0],
	darkorchid:[153,50,204],
	darkred:[139,0,0],
	darksalmon:[233,150,122],
	darkviolet:[148,0,211],
	fuchsia:[255,0,255],
	gold:[255,215,0],
	green:[0,128,0],
	indigo:[75,0,130],
	khaki:[240,230,140],
	lightblue:[173,216,230],
	lightcyan:[224,255,255],
	lightgreen:[144,238,144],
	lightgrey:[211,211,211],
	lightpink:[255,182,193],
	lightyellow:[255,255,224],
	lime:[0,255,0],
	magenta:[255,0,255],
	maroon:[128,0,0],
	navy:[0,0,128],
	olive:[128,128,0],
	orange:[255,165,0],
	pink:[255,192,203],
	purple:[128,0,128],
	violet:[128,0,128],
	red:[255,0,0],
	silver:[192,192,192],
	white:[255,255,255],
	yellow:[255,255,0],
	transparent: [255,255,255]
};



/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/

var classAnimationActions = ['add', 'remove', 'toggle'],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

function getElementStyles() {
	var style = document.defaultView
			? document.defaultView.getComputedStyle(this, null)
			: this.currentStyle,
		newStyle = {},
		key,
		camelCase;

	// webkit enumerates style porperties
	if (style && style.length && style[0] && style[style[0]]) {
		var len = style.length;
		while (len--) {
			key = style[len];
			if (typeof style[key] == 'string') {
				camelCase = key.replace(/\-(\w)/g, function(all, letter){
					return letter.toUpperCase();
				});
				newStyle[camelCase] = style[key];
			}
		}
	} else {
		for (key in style) {
			if (typeof style[key] === 'string') {
				newStyle[key] = style[key];
			}
		}
	}
	
	return newStyle;
}

function filterStyles(styles) {
	var name, value;
	for (name in styles) {
		value = styles[name];
		if (
			// ignore null and undefined values
			value == null ||
			// ignore functions (when does this occur?)
			$.isFunction(value) ||
			// shorthand styles that need to be expanded
			name in shorthandStyles ||
			// ignore scrollbars (break in IE)
			(/scrollbar/).test(name) ||

			// only colors or values that can be converted to numbers
			(!(/color/i).test(name) && isNaN(parseFloat(value)))
		) {
			delete styles[name];
		}
	}
	
	return styles;
}

function styleDifference(oldStyle, newStyle) {
	var diff = { _: 0 }, // http://dev.jquery.com/ticket/5459
		name;

	for (name in newStyle) {
		if (oldStyle[name] != newStyle[name]) {
			diff[name] = newStyle[name];
		}
	}

	return diff;
}

$.effects.animateClass = function(value, duration, easing, callback) {
	if ($.isFunction(easing)) {
		callback = easing;
		easing = null;
	}

	return this.queue(function() {
		var that = $(this),
			originalStyleAttr = that.attr('style') || ' ',
			originalStyle = filterStyles(getElementStyles.call(this)),
			newStyle,
			className = that.attr('class');

		$.each(classAnimationActions, function(i, action) {
			if (value[action]) {
				that[action + 'Class'](value[action]);
			}
		});
		newStyle = filterStyles(getElementStyles.call(this));
		that.attr('class', className);

		that.animate(styleDifference(originalStyle, newStyle), {
			queue: false,
			duration: duration,
			easing: easing,
			complete: function() {
				$.each(classAnimationActions, function(i, action) {
					if (value[action]) { that[action + 'Class'](value[action]); }
				});
				// work around bug in IE by clearing the cssText before setting it
				if (typeof that.attr('style') == 'object') {
					that.attr('style').cssText = '';
					that.attr('style').cssText = originalStyleAttr;
				} else {
					that.attr('style', originalStyleAttr);
				}
				if (callback) { callback.apply(this, arguments); }
				$.dequeue( this );
			}
		});
	});
};

$.fn.extend({
	_addClass: $.fn.addClass,
	addClass: function(classNames, speed, easing, callback) {
		return speed ? $.effects.animateClass.apply(this, [{ add: classNames },speed,easing,callback]) : this._addClass(classNames);
	},

	_removeClass: $.fn.removeClass,
	removeClass: function(classNames,speed,easing,callback) {
		return speed ? $.effects.animateClass.apply(this, [{ remove: classNames },speed,easing,callback]) : this._removeClass(classNames);
	},

	_toggleClass: $.fn.toggleClass,
	toggleClass: function(classNames, force, speed, easing, callback) {
		if ( typeof force == "boolean" || force === undefined ) {
			if ( !speed ) {
				// without speed parameter;
				return this._toggleClass(classNames, force);
			} else {
				return $.effects.animateClass.apply(this, [(force?{add:classNames}:{remove:classNames}),speed,easing,callback]);
			}
		} else {
			// without switch parameter;
			return $.effects.animateClass.apply(this, [{ toggle: classNames },force,speed,easing]);
		}
	},

	switchClass: function(remove,add,speed,easing,callback) {
		return $.effects.animateClass.apply(this, [{ add: add, remove: remove },speed,easing,callback]);
	}
});



/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

$.extend($.effects, {
	version: "1.8.16",

	// Saves a set of properties in a data storage
	save: function(element, set) {
		for(var i=0; i < set.length; i++) {
			if(set[i] !== null) element.data("ec.storage."+set[i], element[0].style[set[i]]);
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function(element, set) {
		for(var i=0; i < set.length; i++) {
			if(set[i] !== null) element.css(set[i], element.data("ec.storage."+set[i]));
		}
	},

	setMode: function(el, mode) {
		if (mode == 'toggle') mode = el.is(':hidden') ? 'show' : 'hide'; // Set for toggle
		return mode;
	},

	getBaseline: function(origin, original) { // Translates a [top,left] array into a baseline value
		// this should be a little more flexible in the future to handle a string & hash
		var y, x;
		switch (origin[0]) {
			case 'top': y = 0; break;
			case 'middle': y = 0.5; break;
			case 'bottom': y = 1; break;
			default: y = origin[0] / original.height;
		};
		switch (origin[1]) {
			case 'left': x = 0; break;
			case 'center': x = 0.5; break;
			case 'right': x = 1; break;
			default: x = origin[1] / original.width;
		};
		return {x: x, y: y};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function(element) {

		// if the element is already wrapped, return it
		if (element.parent().is('.ui-effects-wrapper')) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				'float': element.css('float')
			},
			wrapper = $('<div></div>')
				.addClass('ui-effects-wrapper')
				.css({
					fontSize: '100%',
					background: 'transparent',
					border: 'none',
					margin: 0,
					padding: 0
				}),
			active = document.activeElement;

		element.wrap(wrapper);

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}
		
		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually loose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if (element.css('position') == 'static') {
			wrapper.css({ position: 'relative' });
			element.css({ position: 'relative' });
		} else {
			$.extend(props, {
				position: element.css('position'),
				zIndex: element.css('z-index')
			});
			$.each(['top', 'left', 'bottom', 'right'], function(i, pos) {
				props[pos] = element.css(pos);
				if (isNaN(parseInt(props[pos], 10))) {
					props[pos] = 'auto';
				}
			});
			element.css({position: 'relative', top: 0, left: 0, right: 'auto', bottom: 'auto' });
		}

		return wrapper.css(props).show();
	},

	removeWrapper: function(element) {
		var parent,
			active = document.activeElement;
		
		if (element.parent().is('.ui-effects-wrapper')) {
			parent = element.parent().replaceWith(element);
			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
			return parent;
		}
			
		return element;
	},

	setTransition: function(element, list, factor, value) {
		value = value || {};
		$.each(list, function(i, x){
			unit = element.cssUnit(x);
			if (unit[0] > 0) value[x] = unit[0] * factor + unit[1];
		});
		return value;
	}
});


function _normalizeArguments(effect, options, speed, callback) {
	// shift params for method overloading
	if (typeof effect == 'object') {
		callback = options;
		speed = null;
		options = effect;
		effect = options.effect;
	}
	if ($.isFunction(options)) {
		callback = options;
		speed = null;
		options = {};
	}
        if (typeof options == 'number' || $.fx.speeds[options]) {
		callback = speed;
		speed = options;
		options = {};
	}
	if ($.isFunction(speed)) {
		callback = speed;
		speed = null;
	}

	options = options || {};

	speed = speed || options.duration;
	speed = $.fx.off ? 0 : typeof speed == 'number'
		? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;

	callback = callback || options.complete;

	return [effect, options, speed, callback];
}

function standardSpeed( speed ) {
	// valid standard speeds
	if ( !speed || typeof speed === "number" || $.fx.speeds[ speed ] ) {
		return true;
	}
	
	// invalid strings - treat as "normal" speed
	if ( typeof speed === "string" && !$.effects[ speed ] ) {
		return true;
	}
	
	return false;
}

$.fn.extend({
	effect: function(effect, options, speed, callback) {
		var args = _normalizeArguments.apply(this, arguments),
			// TODO: make effects take actual parameters instead of a hash
			args2 = {
				options: args[1],
				duration: args[2],
				callback: args[3]
			},
			mode = args2.options.mode,
			effectMethod = $.effects[effect];
		
		if ( $.fx.off || !effectMethod ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args2.duration, args2.callback );
			} else {
				return this.each(function() {
					if ( args2.callback ) {
						args2.callback.call( this );
					}
				});
			}
		}
		
		return effectMethod.call(this, args2);
	},

	_show: $.fn.show,
	show: function(speed) {
		if ( standardSpeed( speed ) ) {
			return this._show.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = 'show';
			return this.effect.apply(this, args);
		}
	},

	_hide: $.fn.hide,
	hide: function(speed) {
		if ( standardSpeed( speed ) ) {
			return this._hide.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = 'hide';
			return this.effect.apply(this, args);
		}
	},

	// jQuery core overloads toggle and creates _toggle
	__toggle: $.fn.toggle,
	toggle: function(speed) {
		if ( standardSpeed( speed ) || typeof speed === "boolean" || $.isFunction( speed ) ) {
			return this.__toggle.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = 'toggle';
			return this.effect.apply(this, args);
		}
	},

	// helper functions
	cssUnit: function(key) {
		var style = this.css(key), val = [];
		$.each( ['em','px','%','pt'], function(i, unit){
			if(style.indexOf(unit) > 0)
				val = [parseFloat(style), unit];
		});
		return val;
	}
});



/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

/*
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
 *
 * Uses the built in easing capabilities added In jQuery 1.1
 * to offer multiple easing options
 *
 * TERMS OF USE - jQuery Easing
 *
 * Open source under the BSD License.
 *
 * Copyright 2008 George McGinley Smith
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

// t: current time, b: begInnIng value, c: change In value, d: duration
$.easing.jswing = $.easing.swing;

$.extend($.easing,
{
	def: 'easeOutQuad',
	swing: function (x, t, b, c, d) {
		//alert($.easing.default);
		return $.easing[$.easing.def](x, t, b, c, d);
	},
	easeInQuad: function (x, t, b, c, d) {
		return c*(t/=d)*t + b;
	},
	easeOutQuad: function (x, t, b, c, d) {
		return -c *(t/=d)*(t-2) + b;
	},
	easeInOutQuad: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t + b;
		return -c/2 * ((--t)*(t-2) - 1) + b;
	},
	easeInCubic: function (x, t, b, c, d) {
		return c*(t/=d)*t*t + b;
	},
	easeOutCubic: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t + 1) + b;
	},
	easeInOutCubic: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t + b;
		return c/2*((t-=2)*t*t + 2) + b;
	},
	easeInQuart: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t + b;
	},
	easeOutQuart: function (x, t, b, c, d) {
		return -c * ((t=t/d-1)*t*t*t - 1) + b;
	},
	easeInOutQuart: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2)*t*t*t - 2) + b;
	},
	easeInQuint: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t*t + b;
	},
	easeOutQuint: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t*t*t + 1) + b;
	},
	easeInOutQuint: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2)*t*t*t*t + 2) + b;
	},
	easeInSine: function (x, t, b, c, d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},
	easeOutSine: function (x, t, b, c, d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},
	easeInOutSine: function (x, t, b, c, d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},
	easeInExpo: function (x, t, b, c, d) {
		return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	},
	easeOutExpo: function (x, t, b, c, d) {
		return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	},
	easeInOutExpo: function (x, t, b, c, d) {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	},
	easeInCirc: function (x, t, b, c, d) {
		return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	},
	easeOutCirc: function (x, t, b, c, d) {
		return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	},
	easeInOutCirc: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	},
	easeInElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	},
	easeOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
	},
	easeInOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	},
	easeInBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*(t/=d)*t*((s+1)*t - s) + b;
	},
	easeOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	},
	easeInOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
		return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	},
	easeInBounce: function (x, t, b, c, d) {
		return c - $.easing.easeOutBounce (x, d-t, 0, c, d) + b;
	},
	easeOutBounce: function (x, t, b, c, d) {
		if ((t/=d) < (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t < (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t < (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}
	},
	easeInOutBounce: function (x, t, b, c, d) {
		if (t < d/2) return $.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
		return $.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
	}
});

/*
 *
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright 2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

})(jQuery);

/*
 * jQuery UI Effects Blind 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Blind
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.blind = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
		var direction = o.options.direction || 'vertical'; // Default direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		var wrapper = $.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
		var ref = (direction == 'vertical') ? 'height' : 'width';
		var distance = (direction == 'vertical') ? wrapper.height() : wrapper.width();
		if(mode == 'show') wrapper.css(ref, 0); // Shift

		// Animation
		var animation = {};
		animation[ref] = mode == 'show' ? distance : 0;

		// Animate
		wrapper.animate(animation, o.duration, o.options.easing, function() {
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(el[0], arguments); // Callback
			el.dequeue();
		});

	});

};

})(jQuery);

/*
 * jQuery UI Effects Bounce 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Bounce
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.bounce = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
		var direction = o.options.direction || 'up'; // Default direction
		var distance = o.options.distance || 20; // Default distance
		var times = o.options.times || 5; // Default # of times
		var speed = o.duration || 250; // Default speed per bounce
		if (/show|hide/.test(mode)) props.push('opacity'); // Avoid touching opacity to prevent clearType and PNG issues in IE

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		$.effects.createWrapper(el); // Create Wrapper
		var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
		var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';
		var distance = o.options.distance || (ref == 'top' ? el.outerHeight({margin:true}) / 3 : el.outerWidth({margin:true}) / 3);
		if (mode == 'show') el.css('opacity', 0).css(ref, motion == 'pos' ? -distance : distance); // Shift
		if (mode == 'hide') distance = distance / (times * 2);
		if (mode != 'hide') times--;

		// Animate
		if (mode == 'show') { // Show Bounce
			var animation = {opacity: 1};
			animation[ref] = (motion == 'pos' ? '+=' : '-=') + distance;
			el.animate(animation, speed / 2, o.options.easing);
			distance = distance / 2;
			times--;
		};
		for (var i = 0; i < times; i++) { // Bounces
			var animation1 = {}, animation2 = {};
			animation1[ref] = (motion == 'pos' ? '-=' : '+=') + distance;
			animation2[ref] = (motion == 'pos' ? '+=' : '-=') + distance;
			el.animate(animation1, speed / 2, o.options.easing).animate(animation2, speed / 2, o.options.easing);
			distance = (mode == 'hide') ? distance * 2 : distance / 2;
		};
		if (mode == 'hide') { // Last Bounce
			var animation = {opacity: 0};
			animation[ref] = (motion == 'pos' ? '-=' : '+=')  + distance;
			el.animate(animation, speed / 2, o.options.easing, function(){
				el.hide(); // Hide
				$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
				if(o.callback) o.callback.apply(this, arguments); // Callback
			});
		} else {
			var animation1 = {}, animation2 = {};
			animation1[ref] = (motion == 'pos' ? '-=' : '+=') + distance;
			animation2[ref] = (motion == 'pos' ? '+=' : '-=') + distance;
			el.animate(animation1, speed / 2, o.options.easing).animate(animation2, speed / 2, o.options.easing, function(){
				$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
				if(o.callback) o.callback.apply(this, arguments); // Callback
			});
		};
		el.queue('fx', function() { el.dequeue(); });
		el.dequeue();
	});

};

})(jQuery);

/*
 * jQuery UI Effects Clip 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Clip
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.clip = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right','height','width'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
		var direction = o.options.direction || 'vertical'; // Default direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		var wrapper = $.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
		var animate = el[0].tagName == 'IMG' ? wrapper : el;
		var ref = {
			size: (direction == 'vertical') ? 'height' : 'width',
			position: (direction == 'vertical') ? 'top' : 'left'
		};
		var distance = (direction == 'vertical') ? animate.height() : animate.width();
		if(mode == 'show') { animate.css(ref.size, 0); animate.css(ref.position, distance / 2); } // Shift

		// Animation
		var animation = {};
		animation[ref.size] = mode == 'show' ? distance : 0;
		animation[ref.position] = mode == 'show' ? 0 : distance / 2;

		// Animate
		animate.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(el[0], arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);

/*
 * jQuery UI Effects Drop 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Drop
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.drop = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right','opacity'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
		var direction = o.options.direction || 'left'; // Default Direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		$.effects.createWrapper(el); // Create Wrapper
		var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
		var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';
		var distance = o.options.distance || (ref == 'top' ? el.outerHeight({margin:true}) / 2 : el.outerWidth({margin:true}) / 2);
		if (mode == 'show') el.css('opacity', 0).css(ref, motion == 'pos' ? -distance : distance); // Shift

		// Animation
		var animation = {opacity: mode == 'show' ? 1 : 0};
		animation[ref] = (mode == 'show' ? (motion == 'pos' ? '+=' : '-=') : (motion == 'pos' ? '-=' : '+=')) + distance;

		// Animate
		el.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);

/*
 * jQuery UI Effects Explode 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Explode
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.explode = function(o) {

	return this.queue(function() {

	var rows = o.options.pieces ? Math.round(Math.sqrt(o.options.pieces)) : 3;
	var cells = o.options.pieces ? Math.round(Math.sqrt(o.options.pieces)) : 3;

	o.options.mode = o.options.mode == 'toggle' ? ($(this).is(':visible') ? 'hide' : 'show') : o.options.mode;
	var el = $(this).show().css('visibility', 'hidden');
	var offset = el.offset();

	//Substract the margins - not fixing the problem yet.
	offset.top -= parseInt(el.css("marginTop"),10) || 0;
	offset.left -= parseInt(el.css("marginLeft"),10) || 0;

	var width = el.outerWidth(true);
	var height = el.outerHeight(true);

	for(var i=0;i<rows;i++) { // =
		for(var j=0;j<cells;j++) { // ||
			el
				.clone()
				.appendTo('body')
				.wrap('<div></div>')
				.css({
					position: 'absolute',
					visibility: 'visible',
					left: -j*(width/cells),
					top: -i*(height/rows)
				})
				.parent()
				.addClass('ui-effects-explode')
				.css({
					position: 'absolute',
					overflow: 'hidden',
					width: width/cells,
					height: height/rows,
					left: offset.left + j*(width/cells) + (o.options.mode == 'show' ? (j-Math.floor(cells/2))*(width/cells) : 0),
					top: offset.top + i*(height/rows) + (o.options.mode == 'show' ? (i-Math.floor(rows/2))*(height/rows) : 0),
					opacity: o.options.mode == 'show' ? 0 : 1
				}).animate({
					left: offset.left + j*(width/cells) + (o.options.mode == 'show' ? 0 : (j-Math.floor(cells/2))*(width/cells)),
					top: offset.top + i*(height/rows) + (o.options.mode == 'show' ? 0 : (i-Math.floor(rows/2))*(height/rows)),
					opacity: o.options.mode == 'show' ? 1 : 0
				}, o.duration || 500);
		}
	}

	// Set a timeout, to call the callback approx. when the other animations have finished
	setTimeout(function() {

		o.options.mode == 'show' ? el.css({ visibility: 'visible' }) : el.css({ visibility: 'visible' }).hide();
				if(o.callback) o.callback.apply(el[0]); // Callback
				el.dequeue();

				$('div.ui-effects-explode').remove();

	}, o.duration || 500);


	});

};

})(jQuery);

/*
 * jQuery UI Effects Fade 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fade
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.fade = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || 'hide');

		elem.animate({ opacity: mode }, {
			queue: false,
			duration: o.duration,
			easing: o.options.easing,
			complete: function() {
				(o.callback && o.callback.apply(this, arguments));
				elem.dequeue();
			}
		});
	});
};

})(jQuery);

/*
 * jQuery UI Effects Fold 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fold
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.fold = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
		var size = o.options.size || 15; // Default fold size
		var horizFirst = !(!o.options.horizFirst); // Ensure a boolean value
		var duration = o.duration ? o.duration / 2 : $.fx.speeds._default / 2;

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		var wrapper = $.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
		var widthFirst = ((mode == 'show') != horizFirst);
		var ref = widthFirst ? ['width', 'height'] : ['height', 'width'];
		var distance = widthFirst ? [wrapper.width(), wrapper.height()] : [wrapper.height(), wrapper.width()];
		var percent = /([0-9]+)%/.exec(size);
		if(percent) size = parseInt(percent[1],10) / 100 * distance[mode == 'hide' ? 0 : 1];
		if(mode == 'show') wrapper.css(horizFirst ? {height: 0, width: size} : {height: size, width: 0}); // Shift

		// Animation
		var animation1 = {}, animation2 = {};
		animation1[ref[0]] = mode == 'show' ? distance[0] : size;
		animation2[ref[1]] = mode == 'show' ? distance[1] : 0;

		// Animate
		wrapper.animate(animation1, duration, o.options.easing)
		.animate(animation2, duration, o.options.easing, function() {
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(el[0], arguments); // Callback
			el.dequeue();
		});

	});

};

})(jQuery);

/*
 * jQuery UI Effects Highlight 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Highlight
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.highlight = function(o) {
	return this.queue(function() {
		var elem = $(this),
			props = ['backgroundImage', 'backgroundColor', 'opacity'],
			mode = $.effects.setMode(elem, o.options.mode || 'show'),
			animation = {
				backgroundColor: elem.css('backgroundColor')
			};

		if (mode == 'hide') {
			animation.opacity = 0;
		}

		$.effects.save(elem, props);
		elem
			.show()
			.css({
				backgroundImage: 'none',
				backgroundColor: o.options.color || '#ffff99'
			})
			.animate(animation, {
				queue: false,
				duration: o.duration,
				easing: o.options.easing,
				complete: function() {
					(mode == 'hide' && elem.hide());
					$.effects.restore(elem, props);
					(mode == 'show' && !$.support.opacity && this.style.removeAttribute('filter'));
					(o.callback && o.callback.apply(this, arguments));
					elem.dequeue();
				}
			});
	});
};

})(jQuery);

/*
 * jQuery UI Effects Pulsate 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Pulsate
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.pulsate = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || 'show');
			times = ((o.options.times || 5) * 2) - 1;
			duration = o.duration ? o.duration / 2 : $.fx.speeds._default / 2,
			isVisible = elem.is(':visible'),
			animateTo = 0;

		if (!isVisible) {
			elem.css('opacity', 0).show();
			animateTo = 1;
		}

		if ((mode == 'hide' && isVisible) || (mode == 'show' && !isVisible)) {
			times--;
		}

		for (var i = 0; i < times; i++) {
			elem.animate({ opacity: animateTo }, duration, o.options.easing);
			animateTo = (animateTo + 1) % 2;
		}

		elem.animate({ opacity: animateTo }, duration, o.options.easing, function() {
			if (animateTo == 0) {
				elem.hide();
			}
			(o.callback && o.callback.apply(this, arguments));
		});

		elem
			.queue('fx', function() { elem.dequeue(); })
			.dequeue();
	});
};

})(jQuery);

/*
 * jQuery UI Effects Scale 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Scale
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.puff = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || 'hide'),
			percent = parseInt(o.options.percent, 10) || 150,
			factor = percent / 100,
			original = { height: elem.height(), width: elem.width() };

		$.extend(o.options, {
			fade: true,
			mode: mode,
			percent: mode == 'hide' ? percent : 100,
			from: mode == 'hide'
				? original
				: {
					height: original.height * factor,
					width: original.width * factor
				}
		});

		elem.effect('scale', o.options, o.duration, o.callback);
		elem.dequeue();
	});
};

$.effects.scale = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this);

		// Set options
		var options = $.extend(true, {}, o.options);
		var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
		var percent = parseInt(o.options.percent,10) || (parseInt(o.options.percent,10) == 0 ? 0 : (mode == 'hide' ? 0 : 100)); // Set default scaling percent
		var direction = o.options.direction || 'both'; // Set default axis
		var origin = o.options.origin; // The origin of the scaling
		if (mode != 'effect') { // Set default origin and restore for show/hide
			options.origin = origin || ['middle','center'];
			options.restore = true;
		}
		var original = {height: el.height(), width: el.width()}; // Save original
		el.from = o.options.from || (mode == 'show' ? {height: 0, width: 0} : original); // Default from state

		// Adjust
		var factor = { // Set scaling factor
			y: direction != 'horizontal' ? (percent / 100) : 1,
			x: direction != 'vertical' ? (percent / 100) : 1
		};
		el.to = {height: original.height * factor.y, width: original.width * factor.x}; // Set to state

		if (o.options.fade) { // Fade option to support puff
			if (mode == 'show') {el.from.opacity = 0; el.to.opacity = 1;};
			if (mode == 'hide') {el.from.opacity = 1; el.to.opacity = 0;};
		};

		// Animation
		options.from = el.from; options.to = el.to; options.mode = mode;

		// Animate
		el.effect('size', options, o.duration, o.callback);
		el.dequeue();
	});

};

$.effects.size = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right','width','height','overflow','opacity'];
		var props1 = ['position','top','bottom','left','right','overflow','opacity']; // Always restore
		var props2 = ['width','height','overflow']; // Copy for children
		var cProps = ['fontSize'];
		var vProps = ['borderTopWidth', 'borderBottomWidth', 'paddingTop', 'paddingBottom'];
		var hProps = ['borderLeftWidth', 'borderRightWidth', 'paddingLeft', 'paddingRight'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
		var restore = o.options.restore || false; // Default restore
		var scale = o.options.scale || 'both'; // Default scale mode
		var origin = o.options.origin; // The origin of the sizing
		var original = {height: el.height(), width: el.width()}; // Save original
		el.from = o.options.from || original; // Default from state
		el.to = o.options.to || original; // Default to state
		// Adjust
		if (origin) { // Calculate baseline shifts
			var baseline = $.effects.getBaseline(origin, original);
			el.from.top = (original.height - el.from.height) * baseline.y;
			el.from.left = (original.width - el.from.width) * baseline.x;
			el.to.top = (original.height - el.to.height) * baseline.y;
			el.to.left = (original.width - el.to.width) * baseline.x;
		};
		var factor = { // Set scaling factor
			from: {y: el.from.height / original.height, x: el.from.width / original.width},
			to: {y: el.to.height / original.height, x: el.to.width / original.width}
		};
		if (scale == 'box' || scale == 'both') { // Scale the css box
			if (factor.from.y != factor.to.y) { // Vertical props scaling
				props = props.concat(vProps);
				el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
				el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
			};
			if (factor.from.x != factor.to.x) { // Horizontal props scaling
				props = props.concat(hProps);
				el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
				el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
			};
		};
		if (scale == 'content' || scale == 'both') { // Scale the content
			if (factor.from.y != factor.to.y) { // Vertical props scaling
				props = props.concat(cProps);
				el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
				el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
			};
		};
		$.effects.save(el, restore ? props : props1); el.show(); // Save & Show
		$.effects.createWrapper(el); // Create Wrapper
		el.css('overflow','hidden').css(el.from); // Shift

		// Animate
		if (scale == 'content' || scale == 'both') { // Scale the children
			vProps = vProps.concat(['marginTop','marginBottom']).concat(cProps); // Add margins/font-size
			hProps = hProps.concat(['marginLeft','marginRight']); // Add margins
			props2 = props.concat(vProps).concat(hProps); // Concat
			el.find("*[width]").each(function(){
				child = $(this);
				if (restore) $.effects.save(child, props2);
				var c_original = {height: child.height(), width: child.width()}; // Save original
				child.from = {height: c_original.height * factor.from.y, width: c_original.width * factor.from.x};
				child.to = {height: c_original.height * factor.to.y, width: c_original.width * factor.to.x};
				if (factor.from.y != factor.to.y) { // Vertical props scaling
					child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
					child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
				};
				if (factor.from.x != factor.to.x) { // Horizontal props scaling
					child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
					child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
				};
				child.css(child.from); // Shift children
				child.animate(child.to, o.duration, o.options.easing, function(){
					if (restore) $.effects.restore(child, props2); // Restore children
				}); // Animate children
			});
		};

		// Animate
		el.animate(el.to, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if (el.to.opacity === 0) {
				el.css('opacity', el.from.opacity);
			}
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, restore ? props : props1); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);

/*
 * jQuery UI Effects Shake 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Shake
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.shake = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
		var direction = o.options.direction || 'left'; // Default direction
		var distance = o.options.distance || 20; // Default distance
		var times = o.options.times || 3; // Default # of times
		var speed = o.duration || o.options.duration || 140; // Default speed per shake

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		$.effects.createWrapper(el); // Create Wrapper
		var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
		var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';

		// Animation
		var animation = {}, animation1 = {}, animation2 = {};
		animation[ref] = (motion == 'pos' ? '-=' : '+=')  + distance;
		animation1[ref] = (motion == 'pos' ? '+=' : '-=')  + distance * 2;
		animation2[ref] = (motion == 'pos' ? '-=' : '+=')  + distance * 2;

		// Animate
		el.animate(animation, speed, o.options.easing);
		for (var i = 1; i < times; i++) { // Shakes
			el.animate(animation1, speed, o.options.easing).animate(animation2, speed, o.options.easing);
		};
		el.animate(animation1, speed, o.options.easing).
		animate(animation, speed / 2, o.options.easing, function(){ // Last shake
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
		});
		el.queue('fx', function() { el.dequeue(); });
		el.dequeue();
	});

};

})(jQuery);

/*
 * jQuery UI Effects Slide 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Slide
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.slide = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'show'); // Set Mode
		var direction = o.options.direction || 'left'; // Default Direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		$.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
		var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
		var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';
		var distance = o.options.distance || (ref == 'top' ? el.outerHeight({margin:true}) : el.outerWidth({margin:true}));
		if (mode == 'show') el.css(ref, motion == 'pos' ? (isNaN(distance) ? "-" + distance : -distance) : distance); // Shift

		// Animation
		var animation = {};
		animation[ref] = (mode == 'show' ? (motion == 'pos' ? '+=' : '-=') : (motion == 'pos' ? '-=' : '+=')) + distance;

		// Animate
		el.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);

/*
 * jQuery UI Effects Transfer 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Transfer
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.transfer = function(o) {
	return this.queue(function() {
		var elem = $(this),
			target = $(o.options.to),
			endPosition = target.offset(),
			animation = {
				top: endPosition.top,
				left: endPosition.left,
				height: target.innerHeight(),
				width: target.innerWidth()
			},
			startPosition = elem.offset(),
			transfer = $('<div class="ui-effects-transfer"></div>')
				.appendTo(document.body)
				.addClass(o.options.className)
				.css({
					top: startPosition.top,
					left: startPosition.left,
					height: elem.innerHeight(),
					width: elem.innerWidth(),
					position: 'absolute'
				})
				.animate(animation, o.duration, o.options.easing, function() {
					transfer.remove();
					(o.callback && o.callback.apply(elem[0], arguments));
					elem.dequeue();
				});
	});
};

})(jQuery);

/**
* jQuery AOP - jQuery plugin to add features of aspect-oriented programming (AOP) to jQuery.
* http://jquery-aop.googlecode.com/
*
* Licensed under the MIT license:
* http://www.opensource.org/licenses/mit-license.php
*
* Version: 1.3
*
* Cross-frame type detection based on Daniel Steigerwald's code (http://daniel.steigerwald.cz)
* http://gist.github.com/204554
*
*/

(function() {

	var _after			= 1;
	var _afterThrow		= 2;
	var _afterFinally	= 3;
	var _before			= 4;
	var _around			= 5;
	var _intro			= 6;
	var _regexEnabled = true;
	var _arguments = 'arguments';
	var _undef = 'undefined';

	var getType = (function() {
	 
		var toString = Object.prototype.toString,
			toStrings = {},
			nodeTypes = { 1: 'element', 3: 'textnode', 9: 'document', 11: 'fragment' },
			types = 'Arguments Array Boolean Date Document Element Error Fragment Function NodeList Null Number Object RegExp String TextNode Undefined Window'.split(' ');
	 
		for (var i = types.length; i--; ) {
			var type = types[i], constructor = window[type];
			if (constructor) {
				try { toStrings[toString.call(new constructor)] = type.toLowerCase(); }
				catch (e) { }
			}
		}
	 
		return function(item) {
			return item == null && (item === undefined ? _undef : 'null') ||
				item.nodeType && nodeTypes[item.nodeType] ||
				typeof item.length == 'number' && (
					item.callee && _arguments ||
					item.alert && 'window' ||
					item.item && 'nodelist') ||
				toStrings[toString.call(item)];
		};
	 
	})();

	var isFunc = function(obj) { return getType(obj) == 'function'; };

	/**
	 * Private weaving function.
	 */
	var weaveOne = function(source, method, advice) {

		var old = source[method];

		// Work-around IE6/7 behavior on some native method that return object instances
		if (advice.type != _intro && !isFunc(old)) {
			var oldObject = old;
			old = function() {
				var code = arguments.length > 0 ? _arguments + '[0]' : '';

				for (var i=1;i<arguments.length;i++) {
					code += ',' + _arguments + '[' + i + ']';
				}

				return eval('oldObject(' + code + ');');
			};
		}

		var aspect;
		if (advice.type == _after || advice.type == _afterThrow || advice.type == _afterFinally)
			aspect = function() {
				var returnValue, exceptionThrown = null;

				try {
					returnValue = old.apply(this, arguments);
				} catch (e) {
					exceptionThrown = e;
				}

				if (advice.type == _after)
					if (exceptionThrown == null)
						returnValue = advice.value.apply(this, [returnValue, method]);
					else
						throw exceptionThrown;
				else if (advice.type == _afterThrow && exceptionThrown != null)
					returnValue = advice.value.apply(this, [exceptionThrown, method]);
				else if (advice.type == _afterFinally)
					returnValue = advice.value.apply(this, [returnValue, exceptionThrown, method]);

				return returnValue;
			};
		else if (advice.type == _before)
			aspect = function() {
				advice.value.apply(this, [arguments, method]);
				return old.apply(this, arguments);
			};
		else if (advice.type == _intro)
			aspect = function() {
				return advice.value.apply(this, arguments);
			};
		else if (advice.type == _around) {
			aspect = function() {
				var invocation = { object: this, args: Array.prototype.slice.call(arguments) };
				return advice.value.apply(invocation.object, [{ arguments: invocation.args, method: method, proceed : 
					function() {
						return old.apply(invocation.object, invocation.args);
					}
				}] );
			};
		}

		aspect.unweave = function() { 
			source[method] = old;
			pointcut = source = aspect = old = null;
		};

		source[method] = aspect;

		return aspect;

	};

	/**
	 * Private method search
	 */
	var search = function(source, pointcut, advice) {
		
		var methods = [];

		for (var method in source) {

			var item = null;

			// Ignore exceptions during method retrival
			try {
				item = source[method];
			}
			catch (e) { }

			if (item != null && method.match(pointcut.method) && isFunc(item))
				methods[methods.length] = { source: source, method: method, advice: advice };

		}

		return methods;
	};

	/**
	 * Private weaver and pointcut parser.
	 */
	var weave = function(pointcut, advice) {

		var source = typeof(pointcut.target.prototype) != _undef ? pointcut.target.prototype : pointcut.target;
		var advices = [];

		// If it's not an introduction and no method was found, try with regex...
		if (advice.type != _intro && typeof(source[pointcut.method]) == _undef) {

			// First try directly on target
			var methods = search(pointcut.target, pointcut, advice);

			// No method found, re-try directly on prototype
			if (methods.length == 0)
				methods = search(source, pointcut, advice);

			for (var i in methods)
				advices[advices.length] = weaveOne(methods[i].source, methods[i].method, methods[i].advice);

		} 
		else
		{
			// Return as an array of one element
			advices[0] = weaveOne(source, pointcut.method, advice);
		}

		return _regexEnabled ? advices : advices[0];

	};

	jQuery.aop = 
	{
		/**
		 * Creates an advice after the defined point-cut. The advice will be executed after the point-cut method 
		 * has completed execution successfully, and will receive one parameter with the result of the execution.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.after( {target: window, method: 'MyGlobalMethod'}, function(result) { 
		 *                alert('Returned: ' + result); 
		 *                return result;
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.after( {target: String, method: 'indexOf'}, function(index) { 
		 *                alert('Result found at: ' + index + ' on:' + this); 
		 *                return index;
		 *          } );
		 * @result Array<Function>
		 *
		 * @name after
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called after the execution of the point-cut. It receives one parameter
		 *                        with the result of the point-cut's execution. The function can choose to return this same value or a different one.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		after : function(pointcut, advice)
		{
			return weave( pointcut, { type: _after, value: advice } );
		},

		/**
		 * Creates an advice after the defined point-cut only for unhandled exceptions. The advice will be executed 
		 * after the point-cut method only if the execution failed and an exception has been thrown. It will receive one 
		 * parameter with the exception thrown by the point-cut method.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.afterThrow( {target: String, method: 'indexOf'}, function(exception) { 
		 *                alert('Unhandled exception: ' + exception); 
		 *                return -1;
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.afterThrow( {target: calculator, method: 'Calculate'}, function(exception) { 
		 *                console.log('Unhandled exception: ' + exception);
		 *                throw exception;
		 *          } );
		 * @result Array<Function>
		 *
		 * @name afterThrow
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called after the execution of the point-cut. It receives one parameter
		 *                        with the exception thrown by the point-cut method.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		afterThrow : function(pointcut, advice)
		{
			return weave( pointcut, { type: _afterThrow, value: advice } );
		},

		/**
		 * Creates an advice after the defined point-cut. The advice will be executed after the point-cut method 
		 * regardless of its success or failure, and it will receive two parameters: one with the 
		 * result of a successful execution or null, and another one with the exception thrown or null.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.afterFinally( {target: window, method: 'MyGlobalMethod'}, function(result, exception) {
		 *                if (exception == null)
		 *                    return 'Returned: ' + result;
		 *                else
		 *                    return 'Unhandled exception: ' + exception;
		 *          } );
		 * @result Array<Function>
		 *
		 * @name afterFinally
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called after the execution of the point-cut regardless of its success or failure.
		 *                        It receives two parameters, the first one with the result of a successful execution or null, and the second one with the 
		 *                        exception or null.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		afterFinally : function(pointcut, advice)
		{
			return weave( pointcut, { type: _afterFinally, value: advice } );
		},


		/**
		 * Creates an advice before the defined point-cut. The advice will be executed before the point-cut method 
		 * but cannot modify the behavior of the method, or prevent its execution.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.before( {target: window, method: 'MyGlobalMethod'}, function() { 
		 *                alert('About to execute MyGlobalMethod'); 
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.before( {target: String, method: 'indexOf'}, function(index) {
		 *                alert('About to execute String.indexOf on: ' + this);
		 *          } );
		 * @result Array<Function>
		 *
		 * @name before
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called before the execution of the point-cut.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		before : function(pointcut, advice)
		{
			return weave( pointcut, { type: _before, value: advice } );
		},


		/**
		 * Creates an advice 'around' the defined point-cut. This type of advice can control the point-cut method execution by calling
		 * the functions '.proceed()' on the 'invocation' object, and also, can modify the arguments collection before sending them to the function call.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.around( {target: window, method: 'MyGlobalMethod'}, function(invocation) {
		 *                alert('# of Arguments: ' + invocation.arguments.length); 
		 *                return invocation.proceed(); 
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.around( {target: String, method: 'indexOf'}, function(invocation) { 
		 *                alert('Searching: ' + invocation.arguments[0] + ' on: ' + this); 
		 *                return invocation.proceed(); 
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.around( {target: window, method: /Get(\d+)/}, function(invocation) {
		 *                alert('Executing ' + invocation.method); 
		 *                return invocation.proceed(); 
		 *          } );
		 * @desc Matches all global methods starting with 'Get' and followed by a number.
		 * @result Array<Function>
		 *
		 *
		 * @name around
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called around the execution of the point-cut. This advice will be called with one
		 *                        argument containing one function '.proceed()', the collection of arguments '.arguments', and the matched method name '.method'.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		around : function(pointcut, advice)
		{
			return weave( pointcut, { type: _around, value: advice } );
		},

		/**
		 * Creates an introduction on the defined point-cut. This type of advice replaces any existing methods with the same
		 * name. To restore them, just unweave it.
		 * This function returns an array with only one weaved aspect (Function).
		 *
		 * @example jQuery.aop.introduction( {target: window, method: 'MyGlobalMethod'}, function(result) {
		 *                alert('Returned: ' + result);
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.introduction( {target: String, method: 'log'}, function() {
		 *                alert('Console: ' + this);
		 *          } );
		 * @result Array<Function>
		 *
		 * @name introduction
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved.
		 * @param Function advice Function containing the code that will be executed on the point-cut. 
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		introduction : function(pointcut, advice)
		{
			return weave( pointcut, { type: _intro, value: advice } );
		},
		
		/**
		 * Configures global options.
		 *
		 * @name setup
		 * @param Map settings Configuration options.
		 * @option Boolean regexMatch Enables/disables regex matching of method names.
		 *
		 * @example jQuery.aop.setup( { regexMatch: false } );
		 * @desc Disable regex matching.
		 *
		 * @type Void
		 * @cat Plugins/General
		 */
		setup: function(settings)
		{
			_regexEnabled = settings.regexMatch;
		}
	};

})();

/*!
 * jQuery Form Plugin
 * version: 2.92 (22-NOV-2011)
 * @requires jQuery v1.3.2 or later
 *
 * Examples and documentation at: http://malsup.com/jquery/form/
 * Dual licensed under the MIT and GPL licenses:
 *	http://www.opensource.org/licenses/mit-license.php
 *	http://www.gnu.org/licenses/gpl.html
 */
;(function($) {

/*
	Usage Note:
	-----------
	Do not use both ajaxSubmit and ajaxForm on the same form.  These
	functions are intended to be exclusive.  Use ajaxSubmit if you want
	to bind your own submit handler to the form.  For example,

	$(document).ready(function() {
		$('#myForm').bind('submit', function(e) {
			e.preventDefault(); // <-- important
			$(this).ajaxSubmit({
				target: '#output'
			});
		});
	});

	Use ajaxForm when you want the plugin to manage all the event binding
	for you.  For example,

	$(document).ready(function() {
		$('#myForm').ajaxForm({
			target: '#output'
		});
	});

	When using ajaxForm, the ajaxSubmit function will be invoked for you
	at the appropriate time.
*/

/**
 * ajaxSubmit() provides a mechanism for immediately submitting
 * an HTML form using AJAX.
 */
$.fn.ajaxSubmit = function(options) {
	// fast fail if nothing selected (http://dev.jquery.com/ticket/2752)
	if (!this.length) {
		log('ajaxSubmit: skipping submit process - no element selected');
		return this;
	}
	
	var method, action, url, $form = this;

	if (typeof options == 'function') {
		options = { success: options };
	}

	method = this.attr('method');
	action = this.attr('action');
	url = (typeof action === 'string') ? $.trim(action) : '';
	url = url || window.location.href || '';
	if (url) {
		// clean url (don't include hash vaue)
		url = (url.match(/^([^#]+)/)||[])[1];
	}

	options = $.extend(true, {
		url:  url,
		success: $.ajaxSettings.success,
		type: method || 'GET',
		iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'
	}, options);

	// hook for manipulating the form data before it is extracted;
	// convenient for use with rich editors like tinyMCE or FCKEditor
	var veto = {};
	this.trigger('form-pre-serialize', [this, options, veto]);
	if (veto.veto) {
		log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');
		return this;
	}

	// provide opportunity to alter form data before it is serialized
	if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
		log('ajaxSubmit: submit aborted via beforeSerialize callback');
		return this;
	}

	var traditional = options.traditional;
	if ( traditional === undefined ) {
		traditional = $.ajaxSettings.traditional;
	}
	
	var qx,n,v,a = this.formToArray(options.semantic);
	if (options.data) {
		options.extraData = options.data;
		qx = $.param(options.data, traditional);
	}

	// give pre-submit callback an opportunity to abort the submit
	if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
		log('ajaxSubmit: submit aborted via beforeSubmit callback');
		return this;
	}

	// fire vetoable 'validate' event
	this.trigger('form-submit-validate', [a, this, options, veto]);
	if (veto.veto) {
		log('ajaxSubmit: submit vetoed via form-submit-validate trigger');
		return this;
	}

	var q = $.param(a, traditional);
	if (qx) {
		q = ( q ? (q + '&' + qx) : qx );
	}	
	if (options.type.toUpperCase() == 'GET') {
		options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;
		options.data = null;  // data is null for 'get'
	}
	else {
		options.data = q; // data is the query string for 'post'
	}

	var callbacks = [];
	if (options.resetForm) {
		callbacks.push(function() { $form.resetForm(); });
	}
	if (options.clearForm) {
		callbacks.push(function() { $form.clearForm(options.includeHidden); });
	}

	// perform a load on the target only if dataType is not provided
	if (!options.dataType && options.target) {
		var oldSuccess = options.success || function(){};
		callbacks.push(function(data) {
			var fn = options.replaceTarget ? 'replaceWith' : 'html';
			$(options.target)[fn](data).each(oldSuccess, arguments);
		});
	}
	else if (options.success) {
		callbacks.push(options.success);
	}

	options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg
		var context = options.context || options;	// jQuery 1.4+ supports scope context 
		for (var i=0, max=callbacks.length; i < max; i++) {
			callbacks[i].apply(context, [data, status, xhr || $form, $form]);
		}
	};

	// are there files to upload?
	var fileInputs = $('input:file:enabled[value]', this); // [value] (issue #113)
	var hasFileInputs = fileInputs.length > 0;
	var mp = 'multipart/form-data';
	var multipart = ($form.attr('enctype') == mp || $form.attr('encoding') == mp);

	var fileAPI = !!(hasFileInputs && fileInputs.get(0).files && window.FormData);
	log("fileAPI :" + fileAPI);
	var shouldUseFrame = (hasFileInputs || multipart) && !fileAPI;

	// options.iframe allows user to force iframe mode
	// 06-NOV-09: now defaulting to iframe mode if file input is detected
	if (options.iframe !== false && (options.iframe || shouldUseFrame)) {
		// hack to fix Safari hang (thanks to Tim Molendijk for this)
		// see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
		if (options.closeKeepAlive) {
			$.get(options.closeKeepAlive, function() {
				fileUploadIframe(a);
			});
		}
  		else {
			fileUploadIframe(a);
  		}
	}
	else if ((hasFileInputs || multipart) && fileAPI) {
		options.progress = options.progress || $.noop;
		fileUploadXhr(a);
	}
	else {
		$.ajax(options);
	}

	 // fire 'notify' event
	 this.trigger('form-submit-notify', [this, options]);
	 return this;

	 // XMLHttpRequest Level 2 file uploads (big hat tip to francois2metz)
	function fileUploadXhr(a) {
		var formdata = new FormData();

		for (var i=0; i < a.length; i++) {
			if (a[i].type == 'file')
				continue;
			formdata.append(a[i].name, a[i].value);
		}

		$form.find('input:file:enabled').each(function(){
			var name = $(this).attr('name'), files = this.files;
			if (name) {
				for (var i=0; i < files.length; i++)
					formdata.append(name, files[i]);
			}
		});

		options.data = null;
		var _beforeSend = options.beforeSend;
		options.beforeSend = function(xhr, options) {
			options.data = formdata;
			if (xhr.upload) { // unfortunately, jQuery doesn't expose this prop (http://bugs.jquery.com/ticket/10190)
				xhr.upload.onprogress = function(event) {
					options.progress(event.position, event.total);
				}
			}
			if (_beforeSend)
				_beforeSend.call(options, xhr, options);
		}
		$.ajax(options);
	}

	// private function for handling file uploads (hat tip to YAHOO!)
	function fileUploadIframe(a) {
		var form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;
		var useProp = !!$.fn.prop;

		if (a) {
			if ( useProp ) {
				// ensure that every serialized input is still enabled
				for (i=0; i < a.length; i++) {
					el = $(form[a[i].name]);
					el.prop('disabled', false);
				}
			} else {
				for (i=0; i < a.length; i++) {
					el = $(form[a[i].name]);
					el.removeAttr('disabled');
				}
			};
		}

		if ($(':input[name=submit],:input[id=submit]', form).length) {
			// if there is an input with a name or id of 'submit' then we won't be
			// able to invoke the submit fn on the form (at least not x-browser)
			alert('Error: Form elements must not have name or id of "submit".');
			return;
		}
		
		s = $.extend(true, {}, $.ajaxSettings, options);
		s.context = s.context || s;
		id = 'jqFormIO' + (new Date().getTime());
		if (s.iframeTarget) {
			$io = $(s.iframeTarget);
			n = $io.attr('name');
			if (n == null)
			 	$io.attr('name', id);
			else
				id = n;
		}
		else {
			$io = $('<iframe name="' + id + '" src="'+ s.iframeSrc +'" />');
			$io.css({ position: 'absolute', top: '-1000px', left: '-1000px' });
		}
		io = $io[0];


		xhr = { // mock object
			aborted: 0,
			responseText: null,
			responseXML: null,
			status: 0,
			statusText: 'n/a',
			getAllResponseHeaders: function() {},
			getResponseHeader: function() {},
			setRequestHeader: function() {},
			abort: function(status) {
				var e = (status === 'timeout' ? 'timeout' : 'aborted');
				log('aborting upload... ' + e);
				this.aborted = 1;
				$io.attr('src', s.iframeSrc); // abort op in progress
				xhr.error = e;
				s.error && s.error.call(s.context, xhr, e, status);
				g && $.event.trigger("ajaxError", [xhr, s, e]);
				s.complete && s.complete.call(s.context, xhr, e);
			}
		};

		g = s.global;
		// trigger ajax global events so that activity/block indicators work like normal
		if (g && ! $.active++) {
			$.event.trigger("ajaxStart");
		}
		if (g) {
			$.event.trigger("ajaxSend", [xhr, s]);
		}

		if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
			if (s.global) {
				$.active--;
			}
			return;
		}
		if (xhr.aborted) {
			return;
		}

		// add submitting element to data if we know it
		sub = form.clk;
		if (sub) {
			n = sub.name;
			if (n && !sub.disabled) {
				s.extraData = s.extraData || {};
				s.extraData[n] = sub.value;
				if (sub.type == "image") {
					s.extraData[n+'.x'] = form.clk_x;
					s.extraData[n+'.y'] = form.clk_y;
				}
			}
		}
		
		var CLIENT_TIMEOUT_ABORT = 1;
		var SERVER_ABORT = 2;

		function getDoc(frame) {
			var doc = frame.contentWindow ? frame.contentWindow.document : frame.contentDocument ? frame.contentDocument : frame.document;
			return doc;
		}
		
		// Rails CSRF hack (thanks to Yvan BARTH?LEMY)
		var csrf_token = $('meta[name=csrf-token]').attr('content');
		var csrf_param = $('meta[name=csrf-param]').attr('content');
		if (csrf_param && csrf_token) {
			s.extraData = s.extraData || {};
			s.extraData[csrf_param] = csrf_token;
		}

		// take a breath so that pending repaints get some cpu time before the upload starts
		function doSubmit() {
			// make sure form attrs are set
			var t = $form.attr('target'), a = $form.attr('action');

			// update form attrs in IE friendly way
			form.setAttribute('target',id);
			if (!method) {
				form.setAttribute('method', 'POST');
			}
			if (a != s.url) {
				s.url=s.url + "&conversationid=" + waf.getConversationID();
				form.setAttribute('action', s.url);
			}

			// ie borks in some cases when setting encoding
			if (! s.skipEncodingOverride && (!method || /post/i.test(method))) {
				$form.attr({
					encoding: 'multipart/form-data',
					enctype:  'multipart/form-data'
				});
			}

			// support timout
			if (s.timeout) {
				timeoutHandle = setTimeout(function() { timedOut = true; cb(CLIENT_TIMEOUT_ABORT); }, s.timeout);
			}
			
			// look for server aborts
			function checkState() {
				try {
					var state = getDoc(io).readyState;
					log('state = ' + state);
					if (state.toLowerCase() == 'uninitialized')
						setTimeout(checkState,50);
				}
				catch(e) {
					log('Server abort: ' , e, ' (', e.name, ')');
					cb(SERVER_ABORT);
					timeoutHandle && clearTimeout(timeoutHandle);
					timeoutHandle = undefined;
				}
			}

			// add "extra" data to form if provided in options
			var extraInputs = [];
			try {
				if (s.extraData) {
					for (var n in s.extraData) {
						extraInputs.push(
							$('<input type="hidden" name="'+n+'">').attr('value',s.extraData[n])
								.appendTo(form)[0]);
					}
				}

				if (!s.iframeTarget) {
					// add iframe to doc and submit the form
					$io.appendTo('body');
					io.attachEvent ? io.attachEvent('onload', cb) : io.addEventListener('load', cb, false);
				}
				setTimeout(checkState,15);
				form.submit();
			}
			finally {
				// reset attrs and remove "extra" input elements
				form.setAttribute('action',a);
				if(t) {
					form.setAttribute('target', t);
				} else {
					$form.removeAttr('target');
				}
				$(extraInputs).remove();
			}
		}

		if (s.forceSync) {
			doSubmit();
		}
		else {
			setTimeout(doSubmit, 10); // this lets dom updates render
		}

		var data, doc, domCheckCount = 50, callbackProcessed;

		function cb(e) {
			if (xhr.aborted || callbackProcessed) {
				return;
			}
			try {
				doc = getDoc(io);
			}
			catch(ex) {
				log('cannot access response document: ', ex);
				e = SERVER_ABORT;
			}
			if (e === CLIENT_TIMEOUT_ABORT && xhr) {
				xhr.abort('timeout');
				return;
			}
			else if (e == SERVER_ABORT && xhr) {
				xhr.abort('server abort');
				return;
			}

			if (!doc || doc.location.href == s.iframeSrc) {
				// response not received yet
				if (!timedOut)
					return;
			}
			io.detachEvent ? io.detachEvent('onload', cb) : io.removeEventListener('load', cb, false);

			var status = 'success', errMsg;
			try {
				if (timedOut) {
					throw 'timeout';
				}

				var isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);
				log('isXml='+isXml);
				if (!isXml && window.opera && (doc.body == null || doc.body.innerHTML == '')) {
					if (--domCheckCount) {
						// in some browsers (Opera) the iframe DOM is not always traversable when
						// the onload callback fires, so we loop a bit to accommodate
						log('requeing onLoad callback, DOM not available');
						setTimeout(cb, 250);
						return;
					}
					// let this fall through because server response could be an empty document
					//log('Could not access iframe DOM after mutiple tries.');
					//throw 'DOMException: not available';
				}

				//log('response detected');
				var docRoot = doc.body ? doc.body : doc.documentElement;
				xhr.responseText = docRoot ? docRoot.innerHTML : null;
				xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
				if (isXml)
					s.dataType = 'xml';
				xhr.getResponseHeader = function(header){
					var headers = {'content-type': s.dataType};
					return headers[header];
				};
				// support for XHR 'status' & 'statusText' emulation :
				if (docRoot) {
					xhr.status = Number( docRoot.getAttribute('status') ) || xhr.status;
					xhr.statusText = docRoot.getAttribute('statusText') || xhr.statusText;
				}

				var dt = (s.dataType || '').toLowerCase();
				var scr = /(json|script|text)/.test(dt);
				if (scr || s.textarea) {
					// see if user embedded response in textarea
					var ta = doc.getElementsByTagName('textarea')[0];
					if (ta) {
						xhr.responseText = ta.value;
						// support for XHR 'status' & 'statusText' emulation :
						xhr.status = Number( ta.getAttribute('status') ) || xhr.status;
						xhr.statusText = ta.getAttribute('statusText') || xhr.statusText;
					}
					else if (scr) {
						// account for browsers injecting pre around json response
						var pre = doc.getElementsByTagName('pre')[0];
						var b =  doc.getElementsByTagName('body')[0];
						if (pre) {
							xhr.responseText = pre.textContent ? pre.textContent : pre.innerText;
						}
						else if (b) {
							xhr.responseText = b.textContent ? b.textContent : "<title>" + doc.getElementsByTagName('title')[0].innerText.toLowerCase() + "</title>" + doc.getElementsByTagName('body')[0].outerHTML;
						}
					}
				}
				else if (dt == 'xml' && !xhr.responseXML && xhr.responseText != null) {
					xhr.responseXML = toXml(xhr.responseText);
				}

				try {
					data = httpData(xhr, dt, s);
				}
				catch (e) {
					status = 'parsererror';
					xhr.error = errMsg = (e || status);
				}
			}
			catch (e) {
				log('error caught: ',e);
				status = 'error';
				xhr.error = errMsg = (e || status);
			}

			if (xhr.aborted) {
				log('upload aborted');
				status = null;
			}

			if (xhr.status) { // we've set xhr.status
				status = (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) ? 'success' : 'error';
			}

			// ordering of these callbacks/triggers is odd, but that's how $.ajax does it
			if (status === 'success') {
				s.success && s.success.call(s.context, data, 'success', xhr);
				g && $.event.trigger("ajaxSuccess", [xhr, s]);
			}
			else if (status) {
				if (errMsg == undefined)
					errMsg = xhr.statusText;
				s.error && s.error.call(s.context, xhr, status, errMsg);
				g && $.event.trigger("ajaxError", [xhr, s, errMsg]);
			}

			g && $.event.trigger("ajaxComplete", [xhr, s]);

			if (g && ! --$.active) {
				$.event.trigger("ajaxStop");
			}

			s.complete && s.complete.call(s.context, xhr, status);

			callbackProcessed = true;
			if (s.timeout)
				clearTimeout(timeoutHandle);

			// clean up
			setTimeout(function() {
				if (!s.iframeTarget)
					$io.remove();
				xhr.responseXML = null;
			}, 100);
		}

		var toXml = $.parseXML || function(s, doc) { // use parseXML if available (jQuery 1.5+)
			if (window.ActiveXObject) {
				doc = new ActiveXObject('Microsoft.XMLDOM');
				doc.async = 'false';
				doc.loadXML(s);
			}
			else {
				doc = (new DOMParser()).parseFromString(s, 'text/xml');
			}
			return (doc && doc.documentElement && doc.documentElement.nodeName != 'parsererror') ? doc : null;
		};
		var parseJSON = $.parseJSON || function(s) {
			return window['eval']('(' + s + ')');
		};

		var httpData = function( xhr, type, s ) { // mostly lifted from jq1.4.4

			var ct = xhr.getResponseHeader('content-type') || '',
				xml = type === 'xml' || !type && ct.indexOf('xml') >= 0,
				data = xml ? xhr.responseXML : xhr.responseText;

			if (xml && data.documentElement.nodeName === 'parsererror') {
				$.error && $.error('parsererror');
			}
			if (s && s.dataFilter) {
				data = s.dataFilter(data, type);
			}
			if (typeof data === 'string') {
				if (type === 'json' || !type && ct.indexOf('json') >= 0) {
					data = parseJSON(data);
				} else if (type === "script" || !type && ct.indexOf("javascript") >= 0) {
					$.globalEval(data);
				}
			}
			return data;
		};
	}
};

/**
 * ajaxForm() provides a mechanism for fully automating form submission.
 *
 * The advantages of using this method instead of ajaxSubmit() are:
 *
 * 1: This method will include coordinates for <input type="image" /> elements (if the element
 *	is used to submit the form).
 * 2. This method will include the submit element's name/value data (for the element that was
 *	used to submit the form).
 * 3. This method binds the submit() method to the form for you.
 *
 * The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely
 * passes the options argument along after properly binding events for submit elements and
 * the form itself.
 */
$.fn.ajaxForm = function(options) {
	// in jQuery 1.3+ we can fix mistakes with the ready state
	if (this.length === 0) {
		var o = { s: this.selector, c: this.context };
		if (!$.isReady && o.s) {
			log('DOM not ready, queuing ajaxForm');
			$(function() {
				$(o.s,o.c).ajaxForm(options);
			});
			return this;
		}
		// is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()
		log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));
		return this;
	}

	return this.ajaxFormUnbind().bind('submit.form-plugin', function(e) {
		if (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed
			e.preventDefault();
			$(this).ajaxSubmit(options);
		}
	}).bind('click.form-plugin', function(e) {
		var target = e.target;
		var $el = $(target);
		if (!($el.is(":submit,input:image"))) {
			// is this a child element of the submit el?  (ex: a span within a button)
			var t = $el.closest(':submit');
			if (t.length == 0) {
				return;
			}
			target = t[0];
		}
		var form = this;
		form.clk = target;
		if (target.type == 'image') {
			if (e.offsetX != undefined) {
				form.clk_x = e.offsetX;
				form.clk_y = e.offsetY;
			} else if (typeof $.fn.offset == 'function') { // try to use dimensions plugin
				var offset = $el.offset();
				form.clk_x = e.pageX - offset.left;
				form.clk_y = e.pageY - offset.top;
			} else {
				form.clk_x = e.pageX - target.offsetLeft;
				form.clk_y = e.pageY - target.offsetTop;
			}
		}
		// clear form vars
		setTimeout(function() { form.clk = form.clk_x = form.clk_y = null; }, 100);
	});
};

// ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm
$.fn.ajaxFormUnbind = function() {
	return this.unbind('submit.form-plugin click.form-plugin');
};

/**
 * formToArray() gathers form element data into an array of objects that can
 * be passed to any of the following ajax functions: $.get, $.post, or load.
 * Each object in the array has both a 'name' and 'value' property.  An example of
 * an array for a simple login form might be:
 *
 * [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]
 *
 * It is this array that is passed to pre-submit callback functions provided to the
 * ajaxSubmit() and ajaxForm() methods.
 */
$.fn.formToArray = function(semantic) {
	var a = [];
	if (this.length === 0) {
		return a;
	}

	var form = this[0];
	var els = semantic ? form.getElementsByTagName('*') : form.elements;
	if (!els) {
		return a;
	}

	var i,j,n,v,el,max,jmax;
	for(i=0, max=els.length; i < max; i++) {
		el = els[i];
		n = el.name;
		if (!n) {
			continue;
		}

		if (semantic && form.clk && el.type == "image") {
			// handle image inputs on the fly when semantic == true
			if(!el.disabled && form.clk == el) {
				a.push({name: n, value: $(el).val(), type: el.type });
				a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
			}
			continue;
		}

		v = $.fieldValue(el, true);
		if (v && v.constructor == Array) {
			for(j=0, jmax=v.length; j < jmax; j++) {
				a.push({name: n, value: v[j]});
			}
		}
		else if (v !== null && typeof v != 'undefined') {
			a.push({name: n, value: v, type: el.type});
		}
	}

	if (!semantic && form.clk) {
		// input type=='image' are not found in elements array! handle it here
		var $input = $(form.clk), input = $input[0];
		n = input.name;
		if (n && !input.disabled && input.type == 'image') {
			a.push({name: n, value: $input.val()});
			a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
		}
	}
	return a;
};

/**
 * Serializes form data into a 'submittable' string. This method will return a string
 * in the format: name1=value1&amp;name2=value2
 */
$.fn.formSerialize = function(semantic) {
	//hand off to jQuery.param for proper encoding
	return $.param(this.formToArray(semantic));
};

/**
 * Serializes all field elements in the jQuery object into a query string.
 * This method will return a string in the format: name1=value1&amp;name2=value2
 */
$.fn.fieldSerialize = function(successful) {
	var a = [];
	this.each(function() {
		var n = this.name;
		if (!n) {
			return;
		}
		var v = $.fieldValue(this, successful);
		if (v && v.constructor == Array) {
			for (var i=0,max=v.length; i < max; i++) {
				a.push({name: n, value: v[i]});
			}
		}
		else if (v !== null && typeof v != 'undefined') {
			a.push({name: this.name, value: v});
		}
	});
	//hand off to jQuery.param for proper encoding
	return $.param(a);
};

/**
 * Returns the value(s) of the element in the matched set.  For example, consider the following form:
 *
 *  <form><fieldset>
 *	  <input name="A" type="text" />
 *	  <input name="A" type="text" />
 *	  <input name="B" type="checkbox" value="B1" />
 *	  <input name="B" type="checkbox" value="B2"/>
 *	  <input name="C" type="radio" value="C1" />
 *	  <input name="C" type="radio" value="C2" />
 *  </fieldset></form>
 *
 *  var v = $(':text').fieldValue();
 *  // if no values are entered into the text inputs
 *  v == ['','']
 *  // if values entered into the text inputs are 'foo' and 'bar'
 *  v == ['foo','bar']
 *
 *  var v = $(':checkbox').fieldValue();
 *  // if neither checkbox is checked
 *  v === undefined
 *  // if both checkboxes are checked
 *  v == ['B1', 'B2']
 *
 *  var v = $(':radio').fieldValue();
 *  // if neither radio is checked
 *  v === undefined
 *  // if first radio is checked
 *  v == ['C1']
 *
 * The successful argument controls whether or not the field element must be 'successful'
 * (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).
 * The default value of the successful argument is true.  If this value is false the value(s)
 * for each element is returned.
 *
 * Note: This method *always* returns an array.  If no valid value can be determined the
 *	array will be empty, otherwise it will contain one or more values.
 */
$.fn.fieldValue = function(successful) {
	for (var val=[], i=0, max=this.length; i < max; i++) {
		var el = this[i];
		var v = $.fieldValue(el, successful);
		if (v === null || typeof v == 'undefined' || (v.constructor == Array && !v.length)) {
			continue;
		}
		v.constructor == Array ? $.merge(val, v) : val.push(v);
	}
	return val;
};

/**
 * Returns the value of the field element.
 */
$.fieldValue = function(el, successful) {
	var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
	if (successful === undefined) {
		successful = true;
	}

	if (successful && (!n || el.disabled || t == 'reset' || t == 'button' ||
		(t == 'checkbox' || t == 'radio') && !el.checked ||
		(t == 'submit' || t == 'image') && el.form && el.form.clk != el ||
		tag == 'select' && el.selectedIndex == -1)) {
			return null;
	}

	if (tag == 'select') {
		var index = el.selectedIndex;
		if (index < 0) {
			return null;
		}
		var a = [], ops = el.options;
		var one = (t == 'select-one');
		var max = (one ? index+1 : ops.length);
		for(var i=(one ? index : 0); i < max; i++) {
			var op = ops[i];
			if (op.selected) {
				var v = op.value;
				if (!v) { // extra pain for IE...
					v = (op.attributes && op.attributes['value'] && !(op.attributes['value'].specified)) ? op.text : op.value;
				}
				if (one) {
					return v;
				}
				a.push(v);
			}
		}
		return a;
	}
	return $(el).val();
};

/**
 * Clears the form data.  Takes the following actions on the form's input fields:
 *  - input text fields will have their 'value' property set to the empty string
 *  - select elements will have their 'selectedIndex' property set to -1
 *  - checkbox and radio inputs will have their 'checked' property set to false
 *  - inputs of type submit, button, reset, and hidden will *not* be effected
 *  - button elements will *not* be effected
 */
$.fn.clearForm = function(includeHidden) {
	return this.each(function() {
		$('input,select,textarea', this).clearFields(includeHidden);
	});
};

/**
 * Clears the selected form elements.
 */
$.fn.clearFields = $.fn.clearInputs = function(includeHidden) {
	var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; // 'hidden' is not in this list
	return this.each(function() {
		var t = this.type, tag = this.tagName.toLowerCase();
		if (re.test(t) || tag == 'textarea' || (includeHidden && /hidden/.test(t)) ) {
			this.value = '';
		}
		else if (t == 'checkbox' || t == 'radio') {
			this.checked = false;
		}
		else if (tag == 'select') {
			this.selectedIndex = -1;
		}
	});
};

/**
 * Resets the form data.  Causes all form elements to be reset to their original value.
 */
$.fn.resetForm = function() {
	return this.each(function() {
		// guard against an input with the name of 'reset'
		// note that IE reports the reset function as an 'object'
		if (typeof this.reset == 'function' || (typeof this.reset == 'object' && !this.reset.nodeType)) {
			this.reset();
		}
	});
};

/**
 * Enables or disables any matching elements.
 */
$.fn.enable = function(b) {
	if (b === undefined) {
		b = true;
	}
	return this.each(function() {
		this.disabled = !b;
	});
};

/**
 * Checks/unchecks any matching checkboxes or radio buttons and
 * selects/deselects and matching option elements.
 */
$.fn.selected = function(select) {
	if (select === undefined) {
		select = true;
	}
	return this.each(function() {
		var t = this.type;
		if (t == 'checkbox' || t == 'radio') {
			this.checked = select;
		}
		else if (this.tagName.toLowerCase() == 'option') {
			var $sel = $(this).parent('select');
			if (select && $sel[0] && $sel[0].type == 'select-one') {
				// deselect all other options
				$sel.find('option').selected(false);
			}
			this.selected = select;
		}
	});
};

// expose debug var
$.fn.ajaxSubmit.debug = false;

// helper fn for console logging
function log() {
	if (!$.fn.ajaxSubmit.debug) 
		return;
	var msg = '[jquery.form] ' + Array.prototype.join.call(arguments,'');
	if (window.console && window.console.log) {
		window.console.log(msg);
	}
	else if (window.opera && window.opera.postError) {
		window.opera.postError(msg);
	}
};

})(jQuery);

$.widget("ui.wafctrl", {
    options: {
        hidden: false,
        displayField: null,
        operateState: null,
        viewDisplayType: null
    },
    _create: function(){        
        this.options.displayField = this.options.displayField || "#" + this.element.attr('id') + '_view';
    },
    _setOptions: function(options) {
        var self = this;
        $.each(options, function(key, value) {
            self._setOption(key, value);
        });

        this._operateState();
        return this;
    },
    _operateState: function() {
        var isView = waf.wafutil.isViewOperateState(this.options),
            displayType = waf.wafutil.getViewDisplayType(this.options);
        this._displayTypeCancel();
        if(isView) {
            this["_" + displayType + "DisplayTypeOK"]();
        }
    },
    _displayTypeCancel: function() {
        this._wordonlyDisplayTypeCancel();
        this._disableDisplayTypeCancel();
    },
    _wordonlyDisplayTypeCancel: function() {
        var isHidden = this.options.hidden,
            view = $(this.options.displayField);
        this.widget()[isHidden ? 'hide' : 'show']();
        view.hide();
    },
    _wordonlyDisplayTypeOK: function() {
        var isHidden = this.options.hidden,
            view = $(this.options.displayField);
        this.widget().hide();
        view[isHidden ? 'hide' : 'show']();
    },
    _disableDisplayTypeCancel: function() {
        this._viewDisable(this.options.disabled);
    },
    _disableDisplayTypeOK: function() {
        this._viewDisable(true);
    },
    _viewDisable: function(isDisable) {
        this.widget()[ isDisable ? "addClass" : "removeClass"]
                (this.widgetBaseClass + "-disabled" + " " + "ui-state-disabled" )
                .attr( "aria-disabled", isDisable );
    },
    _setDisplayValue: function(value, isHtml) {
        isHtml = !! isHtml;
        $(this.options.displayField)[isHtml ? 'html' : 'text'](value);
    },
    _getTemplateEngine:function(engine){
        return $.wafutil.getTemplateEngine(engine);
    },
    _callWidgetFunction:function(methodName){
        var instance = $(this.element).data(this.widgetName);
        if(instance[methodName] && $.isFunction(instance[methodName])){
            instance[methodName].call(this,arguments);
        }
    }
});
/**
* WAF
* @author JASON LIU
* @class WAF
* @constructor
*/
waf.defineClass("waf.framework.Waf_LocaleStr_l1",null,{
	ERROR_MSGBOX_TITLE:"System error",
	ERROR_MSGBOX_SUMMARY:"System error,please contact administrator!",
	ERROR_MSGBOX_DETAILMSG:"Details",
	AJAX_ASYNC_BLOCK_INFO:"please wait..."
});
waf.defineClass("waf.framework.Waf_LocaleStr_l2",null,{
	ERROR_MSGBOX_TITLE:"",
	ERROR_MSGBOX_DETAILMSG:"",
	ERROR_MSGBOX_SUMMARY:",!",
	AJAX_ASYNC_BLOCK_INFO:"..."
});
waf.defineClass("waf.framework.Waf_LocaleStr_l3",null,{
	ERROR_MSGBOX_TITLE:"",
	ERROR_MSGBOX_DETAILMSG:"",
	ERROR_MSGBOX_SUMMARY:",!",
	AJAX_ASYNC_BLOCK_INFO:"..."
});

// moment.js
// version : 1.7.0
// author : Tim Wood
// license : MIT
// momentjs.com

(function (Date, undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "1.7.0",
        round = Math.round, i,
        // internal storage for language config files
        languages = {},
        currentLanguage = 'en',

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // Parameters to check for on the lang config.  This list of properties
        // will be inherited from English if not provided in a language
        // definition.  monthsParse is also a lang config property, but it
        // cannot be inherited and as such cannot be enumerated here.
        langConfigProperties = 'months|monthsShort|weekdays|weekdaysShort|weekdaysMin|longDateFormat|calendar|relativeTime|ordinal|meridiem'.split('|'),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|YYYY|YY|a|A|hh?|HH?|mm?|ss?|SS?S?|zz?|ZZ?)/g,
        localFormattingTokens = /(LT|LL?L?L?)/g,
        formattingRemoveEscapes = /(^\[)|(\\)|\]$/g,

        // parsing tokens
        parseMultipleFormatChunker = /([0-9a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+)/gi,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenWord = /[0-9a-z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+/i, // any word characters or numbers
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO seperator)

        // preliminary iso regex 
        // 0000-00-00 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000
        isoRegex = /^\s*\d{4}-\d\d-\d\d(T(\d\d(:\d\d(:\d\d(\.\d\d?\d?)?)?)?)?([\+\-]\d\d:?\d\d)?)?/,
        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.S', /T\d\d:\d\d:\d\d\.\d{1,3}/],
            ['HH:mm:ss', /T\d\d:\d\d:\d\d/],
            ['HH:mm', /T\d\d:\d\d/],
            ['HH', /T\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Month|Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        // format function strings
        formatFunctions = {},

        /*
         * moment.fn.format uses new Function() to create an inlined formatting function.
         * Results are a 3x speed boost
         * http://jsperf.com/momentjs-cached-format-functions
         *
         * These strings are appended into a function using replaceFormatTokens and makeFormatFunction
         */
        formatFunctionStrings = {
            // a = placeholder
            // b = placeholder
            // t = the current moment being formatted
            // v = getValueAtKey function
            // o = language.ordinal function
            // p = leftZeroFill function
            // m = language.meridiem value or function
            M    : '(a=t.month()+1)',
            MMM  : 'v("monthsShort",t.month())',
            MMMM : 'v("months",t.month())',
            D    : '(a=t.date())',
            DDD  : '(a=new Date(t.year(),t.month(),t.date()),b=new Date(t.year(),0,1),a=~~(((a-b)/864e5)+1.5))',
            d    : '(a=t.day())',
            dd   : 'v("weekdaysMin",t.day())',
            ddd  : 'v("weekdaysShort",t.day())',
            dddd : 'v("weekdays",t.day())',
            w    : '(a=new Date(t.year(),t.month(),t.date()-t.day()+5),b=new Date(a.getFullYear(),0,4),a=~~((a-b)/864e5/7+1.5))',
            YY   : 'p(t.year()%100,2)',
            YYYY : 'p(t.year(),4)',
            a    : 'm(t.hours(),t.minutes(),!0)',
            A    : 'm(t.hours(),t.minutes(),!1)',
            H    : 't.hours()',
            h    : 't.hours()%12||12',
            m    : 't.minutes()',
            s    : 't.seconds()',
            S    : '~~(t.milliseconds()/100)',
            SS   : 'p(~~(t.milliseconds()/10),2)',
            SSS  : 'p(t.milliseconds(),3)',
            Z    : '((a=-t.zone())<0?((a=-a),"-"):"+")+p(~~(a/60),2)+":"+p(~~a%60,2)',
            ZZ   : '((a=-t.zone())<0?((a=-a),"-"):"+")+p(~~(10*a/6),4)'
        },

        ordinalizeTokens = 'DDD w M D d'.split(' '),
        paddedTokens = 'M D H h m s w'.split(' ');

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatFunctionStrings[i + 'o'] = formatFunctionStrings[i] + '+o(a)';
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatFunctionStrings[i + i] = 'p(' + formatFunctionStrings[i] + ',2)';
    }
    formatFunctionStrings.DDDD = 'p(' + formatFunctionStrings.DDD + ',3)';


    /************************************
        Constructors
    ************************************/


    // Moment prototype object
    function Moment(date, isUTC, lang) {
        this._d = date;
        this._isUTC = !!isUTC;
        this._a = date._a || null;
        date._a = null;
        this._lang = lang || false;
    }

    // Duration Constructor
    function Duration(duration) {
        var data = this._data = {},
            years = duration.years || duration.y || 0,
            months = duration.months || duration.M || 0, 
            weeks = duration.weeks || duration.w || 0,
            days = duration.days || duration.d || 0,
            hours = duration.hours || duration.h || 0,
            minutes = duration.minutes || duration.m || 0,
            seconds = duration.seconds || duration.s || 0,
            milliseconds = duration.milliseconds || duration.ms || 0;

        // representation for dateAddRemove
        this._milliseconds = milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = months +
            years * 12;
            
        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;
        seconds += absRound(milliseconds / 1000);

        data.seconds = seconds % 60;
        minutes += absRound(seconds / 60);

        data.minutes = minutes % 60;
        hours += absRound(minutes / 60);

        data.hours = hours % 24;
        days += absRound(hours / 24);

        days += weeks * 7;
        data.days = days % 30;
        
        months += absRound(days / 30);

        data.months = months % 12;
        years += absRound(months / 12);

        data.years = years;

        this._lang = false;
    }


    /************************************
        Helpers
    ************************************/


    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength) {
        var output = number + '';
        while (output.length < targetLength) {
            output = '0' + output;
        }
        return output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding) {
        var ms = duration._milliseconds,
            d = duration._days,
            M = duration._months,
            currentDate;

        if (ms) {
            mom._d.setTime(+mom + ms * isAdding);
        }
        if (d) {
            mom.date(mom.date() + d * isAdding);
        }
        if (M) {
            currentDate = mom.date();
            mom.date(1)
                .month(mom.month() + M * isAdding)
                .date(Math.min(currentDate, mom.daysInMonth()));
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (~~array1[i] !== ~~array2[i]) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromArray(input, asUTC) {
        var i, date;
        for (i = 1; i < 7; i++) {
            input[i] = (input[i] == null) ? (i === 2 ? 1 : 0) : input[i];
        }
        // we store whether we used utc or not in the input array
        input[7] = asUTC;
        date = new Date(0);
        if (asUTC) {
            date.setUTCFullYear(input[0], input[1], input[2]);
            date.setUTCHours(input[3], input[4], input[5], input[6]);
        } else {
            date.setFullYear(input[0], input[1], input[2]);
            date.setHours(input[3], input[4], input[5], input[6]);
        }
        date._a = input;
        return date;
    }

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        var i, m,
            parse = [];

        if (!values && hasModule) {
            values = require('./lang/' + key);
        }
        
        for (i = 0; i < langConfigProperties.length; i++) {
            // If a language definition does not provide a value, inherit
            // from English
            values[langConfigProperties[i]] = values[langConfigProperties[i]] ||
              languages.en[langConfigProperties[i]];
        }

        for (i = 0; i < 12; i++) {
            m = moment([2000, i]);
            parse[i] = new RegExp('^' + (values.months[i] || values.months(m, '')) + 
                '|^' + (values.monthsShort[i] || values.monthsShort(m, '')).replace('.', ''), 'i');
        }
        values.monthsParse = values.monthsParse || parse;

        languages[key] = values;
        
        return values;
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.  If you pass in a moment or duration instance, it
    // will decide the language based on that, or default to the global
    // language.
    function getLangDefinition(m) {
        var langKey = (typeof m === 'string') && m ||
                      m && m._lang ||
                      null;

        return langKey ? (languages[langKey] || loadLang(langKey)) : moment;
    }


    /************************************
        Formatting
    ************************************/


    // helper for building inline formatting functions
    function replaceFormatTokens(token) {
        return formatFunctionStrings[token] ? 
            ("'+(" + formatFunctionStrings[token] + ")+'") :
            token.replace(formattingRemoveEscapes, "").replace(/\\?'/g, "\\'");
    }

    // helper for recursing long date formatting tokens
    function replaceLongDateFormatTokens(input) {
        return getLangDefinition().longDateFormat[input] || input;
    }

    function makeFormatFunction(format) {
        var output = "var a,b;return '" +
            format.replace(formattingTokens, replaceFormatTokens) + "';",
            Fn = Function; // get around jshint
        // t = the current moment being formatted
        // v = getValueAtKey function
        // o = language.ordinal function
        // p = leftZeroFill function
        // m = language.meridiem value or function
        return new Fn('t', 'v', 'o', 'p', 'm', output);
    }

    function makeOrGetFormatFunction(format) {
        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }
        return formatFunctions[format];
    }

    // format date using native date object
    function formatMoment(m, format) {
        var lang = getLangDefinition(m);

        function getValueFromArray(key, index) {
            return lang[key].call ? lang[key](m, format) : lang[key][index];
        }

        while (localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        }

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m, getValueFromArray, lang.ordinal, leftZeroFill, lang.meridiem);
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token) {
        switch (token) {
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
            return parseTokenFourDigits;
        case 'S':
        case 'SS':
        case 'SSS':
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
        case 'a':
        case 'A':
            return parseTokenWord;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
            return parseTokenOneOrTwoDigits;
        default :
            return new RegExp(token.replace('\\', ''));
        }
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, datePartArray, config) {
        var a;
        //console.log('addTime', format, input);
        switch (token) {
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            datePartArray[1] = (input == null) ? 0 : ~~input - 1;
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            for (a = 0; a < 12; a++) {
                if (getLangDefinition().monthsParse[a].test(input)) {
                    datePartArray[1] = a;
                    break;
                }
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DDDD
        case 'DD' : // fall through to DDDD
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                datePartArray[2] = ~~input;
            }
            break;
        // YEAR
        case 'YY' :
            input = ~~input;
            datePartArray[0] = input + (input > 70 ? 1900 : 2000);
            break;
        case 'YYYY' :
            datePartArray[0] = ~~Math.abs(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config.isPm = ((input + '').toLowerCase() === 'pm');
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[3] = ~~input;
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[4] = ~~input;
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[5] = ~~input;
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
            datePartArray[6] = ~~ (('0.' + input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config.isUTC = true;
            a = (input + '').match(parseTimezoneChunker);
            if (a && a[1]) {
                config.tzh = ~~a[1];
            }
            if (a && a[2]) {
                config.tzm = ~~a[2];
            }
            // reverse offsets
            if (a && a[0] === '+') {
                config.tzh = -config.tzh;
                config.tzm = -config.tzm;
            }
            break;
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(string, format) {
        var datePartArray = [0, 0, 1, 0, 0, 0, 0],
            config = {
                tzh : 0, // timezone hour offset
                tzm : 0  // timezone minute offset
            },
            tokens = format.match(formattingTokens),
            i, parsedInput;

        for (i = 0; i < tokens.length; i++) {
            parsedInput = (getParseRegexForToken(tokens[i]).exec(string) || [])[0];
            string = string.replace(getParseRegexForToken(tokens[i]), '');
            addTimeToArrayFromToken(tokens[i], parsedInput, datePartArray, config);
        }
        // handle am pm
        if (config.isPm && datePartArray[3] < 12) {
            datePartArray[3] += 12;
        }
        // if is 12 am, change hours to 0
        if (config.isPm === false && datePartArray[3] === 12) {
            datePartArray[3] = 0;
        }
        // handle timezone
        datePartArray[3] += config.tzh;
        datePartArray[4] += config.tzm;
        // return
        return dateFromArray(datePartArray, config.isUTC);
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(string, formats) {
        var output,
            inputParts = string.match(parseMultipleFormatChunker) || [],
            formattedInputParts,
            scoreToBeat = 99,
            i,
            currentDate,
            currentScore;
        for (i = 0; i < formats.length; i++) {
            currentDate = makeDateFromStringAndFormat(string, formats[i]);
            formattedInputParts = formatMoment(new Moment(currentDate), formats[i]).match(parseMultipleFormatChunker) || [];
            currentScore = compareArrays(inputParts, formattedInputParts);
            if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                output = currentDate;
            }
        }
        return output;
    }

    // date from iso format
    function makeDateFromString(string) {
        var format = 'YYYY-MM-DDT',
            i;
        if (isoRegex.exec(string)) {
            for (i = 0; i < 4; i++) {
                if (isoTimes[i][1].exec(string)) {
                    format += isoTimes[i][0];
                    break;
                }
            }
            return parseTokenTimezone.exec(string) ? 
                makeDateFromStringAndFormat(string, format + ' Z') :
                makeDateFromStringAndFormat(string, format);
        }
        return new Date(string);
    }


    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        var rt = lang.relativeTime[string];
        return (typeof rt === 'function') ?
            rt(number || 1, !!withoutSuffix, string, isFuture) :
            rt.replace(/%d/i, number || 1);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Top Level Functions
    ************************************/


    moment = function (input, format) {
        if (input === null || input === '') {
            return null;
        }
        var date,
            matched;
        // parse Moment object
        if (moment.isMoment(input)) {
            return new Moment(new Date(+input._d), input._isUTC, input._lang);
        // parse string and format
        } else if (format) {
            if (isArray(format)) {
                date = makeDateFromStringAndArray(input, format);
            } else {
                date = makeDateFromStringAndFormat(input, format);
            }
        // evaluate it as a JSON-encoded date
        } else {
            matched = aspNetJsonRegex.exec(input);
            date = input === undefined ? new Date() :
                matched ? new Date(+matched[1]) :
                input instanceof Date ? input :
                isArray(input) ? dateFromArray(input) :
                typeof input === 'string' ? makeDateFromString(input) :
                new Date(input);
        }

        return new Moment(date);
    };

    // creating with utc
    moment.utc = function (input, format) {
        if (isArray(input)) {
            return new Moment(dateFromArray(input, true), true);
        }
        // if we don't have a timezone, we need to add one to trigger parsing into utc
        if (typeof input === 'string' && !parseTokenTimezone.exec(input)) {
            input += ' +0000';
            if (format) {
                format += ' Z';
            }
        }
        return moment(input, format).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var isDuration = moment.isDuration(input),
            isNumber = (typeof input === 'number'),
            duration = (isDuration ? input._data : (isNumber ? {} : input)),
            ret;

        if (isNumber) {
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        }

        ret = new Duration(duration);

        if (isDuration) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // humanizeDuration
    // This method is deprecated in favor of the new Duration object.  Please
    // see the moment.duration method.
    moment.humanizeDuration = function (num, type, withSuffix) {
        return moment.duration(num, type === true ? null : type).humanize(type === true ? true : withSuffix);
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var i;

        if (!key) {
            return currentLanguage;
        }
        if (values || !languages[key]) {
            loadLang(key, values);
        }
        if (languages[key]) {
            // deprecated, to get the language definition variables, use the
            // moment.fn.lang method or the getLangDefinition function.
            for (i = 0; i < langConfigProperties.length; i++) {
                moment[langConfigProperties[i]] = languages[key][langConfigProperties[i]];
            }
            moment.monthsParse = languages[key].monthsParse;
            currentLanguage = key;
        }
    };

    // returns language data
    moment.langData = getLangDefinition;

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment;
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        ordinal : function (number) {
            var b = number % 10;
            return (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        }
    });


    /************************************
        Moment Prototype
    ************************************/


    moment.fn = Moment.prototype = {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d;
        },

        unix : function () {
            return Math.floor(+this._d / 1000);
        },

        toString : function () {
            return this._d.toString();
        },

        toDate : function () {
            return this._d;
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds(),
                !!this._isUTC
            ];
        },

        isValid : function () {
            if (this._a) {
                return !compareArrays(this._a, (this._a[7] ? moment.utc(this) : this).toArray());
            }
            return !isNaN(this._d.getTime());
        },

        utc : function () {
            this._isUTC = true;
            return this;
        },

        local : function () {
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            return formatMoment(this, inputString ? inputString : moment.defaultFormat);
        },

        add : function (input, val) {
            var dur = val ? moment.duration(+val, input) : moment.duration(input);
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur = val ? moment.duration(+val, input) : moment.duration(input);
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, val, asFloat) {
            var inputMoment = this._isUTC ? moment(input).utc() : moment(input).local(),
                zoneDiff = (this.zone() - inputMoment.zone()) * 6e4,
                diff = this._d - inputMoment._d - zoneDiff,
                year = this.year() - inputMoment.year(),
                month = this.month() - inputMoment.month(),
                date = this.date() - inputMoment.date(),
                output;
            if (val === 'months') {
                output = year * 12 + month + date / 30;
            } else if (val === 'years') {
                output = year + (month + date / 30) / 12;
            } else {
                output = val === 'seconds' ? diff / 1e3 : // 1000
                    val === 'minutes' ? diff / 6e4 : // 1000 * 60
                    val === 'hours' ? diff / 36e5 : // 1000 * 60 * 60
                    val === 'days' ? diff / 864e5 : // 1000 * 60 * 60 * 24
                    val === 'weeks' ? diff / 6048e5 : // 1000 * 60 * 60 * 24 * 7
                    diff;
            }
            return asFloat ? output : round(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this._lang).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            var diff = this.diff(moment().sod(), 'days', true),
                calendar = this.lang().calendar,
                allElse = calendar.sameElse,
                format = diff < -6 ? allElse :
                diff < -1 ? calendar.lastWeek :
                diff < 0 ? calendar.lastDay :
                diff < 1 ? calendar.sameDay :
                diff < 2 ? calendar.nextDay :
                diff < 7 ? calendar.nextWeek : allElse;
            return this.format(typeof format === 'function' ? format.apply(this) : format);
        },

        isLeapYear : function () {
            var year = this.year();
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
        },

        isDST : function () {
            return (this.zone() < moment([this.year()]).zone() || 
                this.zone() < moment([this.year(), 5]).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            return input == null ? day :
                this.add({ d : input - day });
        },

        startOf: function (val) {
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (val.replace(/s$/, '')) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'month':
                this.date(1);
                /* falls through */
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }
            return this;
        },

        endOf: function (val) {
            return this.startOf(val).add(val.replace(/s?$/, 's'), 1).subtract('ms', 1);
        },
        
        sod: function () {
            return this.clone().startOf('day');
        },

        eod: function () {
            // end of day = start of day plus 1 day, minus 1 millisecond
            return this.clone().endOf('day');
        },

        zone : function () {
            return this._isUTC ? 0 : this._d.getTimezoneOffset();
        },

        daysInMonth : function () {
            return moment.utc([this.year(), this.month() + 1, 0]).date();
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (lang) {
            if (lang === undefined) {
                return getLangDefinition(this);
            } else {
                this._lang = lang;
                return this;
            }
        }
    };

    // helper for adding shortcuts
    function makeGetterAndSetter(name, key) {
        moment.fn[name] = function (input) {
            var utc = this._isUTC ? 'UTC' : '';
            if (input != null) {
                this._d['set' + utc + key](input);
                return this;
            } else {
                return this._d['get' + utc + key]();
            }
        };
    }

    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase(), proxyGettersAndSetters[i]);
    }

    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
    makeGetterAndSetter('year', 'FullYear');


    /************************************
        Duration Prototype
    ************************************/


    moment.duration.fn = Duration.prototype = {
        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              this._months * 2592e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                rel = this.lang().relativeTime,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = (difference <= 0 ? rel.past : rel.future).replace(/%s/i, output);
            }

            return output;
        },

        lang : moment.fn.lang
    };

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);


    /************************************
        Exposing Moment
    ************************************/


    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
    }
    /*global ender:false */
    if (typeof ender === 'undefined') {
        // here, `this` means `window` in the browser, or `global` on the server
        // add `moment` as a global object via a string identifier,
        // for Closure Compiler "advanced" mode
        this['moment'] = moment;
    }
    /*global define:false */
    if (typeof define === "function" && define.amd) {
        define("moment", [], function () {
            return moment;
        });
    }
}).call(this, Date);

/*
 * jLinq - 3.0.1
 * Hugo Bonacci - hugoware.com
 * http://creativecommons.org/licenses/by/3.0/
 */

var jLinq;
var jlinq;
var jl;
(function() {

    //jLinq functionality
    var framework = {
    
        //command types for extensions
        command:{
        
            //queues a comparison to filter records
            query:0,
            
            //executes all queued commands and filters the records
            select:1,
            
            //performs an immediate action to the query
            action:2
        },
        
        //common expressions
        exp:{
            //gets each part of a dot notation path
            get_path:/\./g,
            
            //escapes string so it can be used in a regular expression
            escape_regex:/[\-\[\]\{\}\(\)\*\+\?\.\,\\\^\$\|\#\s]/g
        },
        
        //common javascript types
        type:{
            nothing:-1,
            undefined:0,
            string:1,
            number:2,
            array:3,
            regex:4,
            bool:5,
            method:6,
            datetime:7,
            object:99
        },
        
        //contains jLinq commands and functions
        library:{
        
            //the current commands in jLinq
            commands:{},
            
            //the type comparisons for jLinq
            types:{},
        
            //includes a comparison to identify types
            addType:function(type, compare) {
                framework.library.types[type] = compare;
            },
        
            //adds a command to the jLinq library
            extend:function(commands) {
            
                //convert to an array if not already
                if (!framework.util.isType(framework.type.array, commands)) {
                    commands = [commands];
                }
                
                //append each method
                framework.util.each(commands, function(command) {
                    framework.library.commands[command.name] = command;
                });
            
            },
            
            //starts a new jLinq query
            query:function(collection, params) {
            
                //make sure something is there
                if (!framework.util.isType(framework.type.array, collection)) {
                    throw "jLinq can only query arrays of objects.";
                }
                
                //clone the array to prevent changing objects - by default
                //this is off
                collection = params.clone || (params.clone == null && jLinq.alwaysClone)
                    ? framework.util.clone(collection) 
                    : collection;
            
                //holds the state of the current query
                var self = {
                
                    //the public instance of the query
                    instance:{
                    
                        //should this query ignore case
                        ignoreCase:jLinq.ignoreCase,
                        
                        //should the next command be evaluated as not
                        not:false,
                        
                        //the action that was last invoked
                        lastCommand:null,
                        
                        //the name of the last field queried
                        lastField:null,
                    
                        //the current records available
                        records:collection,
                    
                        //records that have been filtered out
                        removed:[],
                        
                        //tells a query to start a new function
                        or:function() { self.startNewCommandSet(); },
                        
                        //the query creator object
                        query:{}
                        
                    },
                    
                    //determines if the arguments provided meet the
                    //requirements to be a repeated command
                    canRepeatCommand:function(args) {
                        return self.instance.lastCommand != null &&
                            args.length == (self.instance.lastCommand.method.length + 1) &&
                            framework.util.isType(framework.type.string, args[0])
                    },

                    //commands waiting to execute
                    commands:[[]],
                    
                    //executes the current query and updated the records
                    execute:function() {
                        var results = [];
                        
                        //get the current state of the query
                        var state = self.instance;
                        
                        //start checking each record
                        framework.util.each(self.instance.records, function(record) {
                            
                            //update the state
                            state.record = record;

                            //perform the evaluation
                            if (self.evaluate(state)) { 
                                results.push(record); 
                            }
                            else {
                                self.instance.removed.push(record);
                            }
                        });
                        
                        //update the matching records
                        self.instance.records = results;
                    },
                    
                    //tries to find a value from the path name
                    findValue:framework.util.findValue,
                    
                    //evaluates each queued command for matched
                    evaluate:function(state) {
                        
                        //check each of the command sets
                        for (var command = 0, l = self.commands.length; command < l; command++) {
                        
                            //each set represents an 'or' set - if any
                            //match then return this worked
                            var set = self.commands[command];
                            if (self.evaluateSet(set, state)) { return true; }
                            
                        };
                        
                        //since nothing evaluated, return it failed
                        return false;
                        
                    },
                    
                    //evaluates a single set of commands
                    evaluateSet:function(set, state) {
                    
                        //check each command in this set
                        for (var item in set) {
                            if (!set.hasOwnProperty(item)) continue;
                            //get the details to use
                            var command = set[item];
                            state.value = self.findValue(state.record, command.path);
                            state.compare = function(types) { return framework.util.compare(state.value, types, state); };
                            state.when = function(types) { return framework.util.when(state.value, types, state); };
                                
                            //evaluate the command
                            try {
                                var result = command.method.apply(state, command.args);
                                if (command.not) { result = !result; }
                                if (!result) { return false; }
                            }
                            //errors and exceptions just result in a failed
                            //to evaluate as true
                            catch (e) {
                                return false;
                            }
                            
                        }
                        
                        //if nothing failed then return it worked
                        return true;
                        
                    },
                    
                    //repeats the previous command with new
                    //arguments
                    repeat:function(arguments) {
                    
                        //check if there is anything to repeat
                        if (!self.instance.lastCommand || arguments == null) { return; }
                        
                        //get the array of arguments to work with
                        arguments = framework.util.toArray(arguments);
                            
                        //check if there is a field name has changed, and
                        //if so, update the arguments to match
                        if (self.canRepeatCommand(arguments)) {
                            self.instance.lastField = arguments[0];
                            arguments = framework.util.select(arguments, null, 1, null);
                        }
                        
                        //invoke the command now
                        self.queue(self.instance.lastCommand, arguments);
                    },
                    
                    //saves a command to evaluate later
                    queue:function(command, args) {
                        self.instance.lastCommand = command;
                        
                        //the base detail for the command
                        var detail = {
                            name:command.name,
                            method:command.method,
                            field:self.instance.lastField,
                            count:command.method.length,
                            args:args,
                            not:self.not
                        };
                        
                        //check to see if there is an extra argument which should
                        //be the field name argument
                        if (detail.args.length > command.method.length) {
                        
                            //if so, grab the name and update the arguments
                            detail.field = detail.args[0];
                            detail.args = framework.util.remaining(detail.args, 1);
                            self.instance.lastField = detail.field;
                        }
                        
                        //get the full path for the field name
                        detail.path = detail.field;
                        
                        //queue the command to the current set
                        self.commands[self.commands.length-1].push(detail);

                        //then reset the not state
                        self.not = false;
                    
                    },
                    
                    //creates a new set of methods that should be evaluated
                    startNewCommandSet:function() {
                        self.commands.push([]);
                    },
                    
                    //marks a command to evaluate as NOT
                    setNot:function() {
                        self.not = !self.not;
                    }
                    
                };
                
                //append each of the functions
                framework.util.each(framework.library.commands, function(command) {
                
                    //Query methods queue up and are not evaluated until
                    //a selection or action command is called
                    if (command.type == framework.command.query) {
                        
                        //the default action to perform
                        var action = function() {
                            self.queue(command, arguments);
                            return self.instance.query;
                        };
                        
                        //create the default action
                        self.instance.query[command.name] = action;
                        
                        //orCommand
                        var name = framework.util.operatorName(command.name);
                        self.instance.query["or"+name] = function() {
                            self.startNewCommandSet();
                            return action.apply(null, arguments);
                        };
                        
                        //orNotCommand
                        self.instance.query["orNot"+name] = function() {
                            self.startNewCommandSet();
                            self.setNot();
                            return action.apply(null, arguments);
                        };
                        
                        //andCommand
                        self.instance.query["and"+name] = function() {
                            return action.apply(null, arguments);
                        };
                        
                        //andNotCommand
                        self.instance.query["andNot"+name] = function() {
                            self.setNot();
                            return action.apply(null, arguments);
                        };
                        
                        //notCommand
                        self.instance.query["not"+name] = function() {
                            self.setNot();
                            return action.apply(null, arguments);
                        };
                        
                    }
                    
                    //Selections commands flush the queue of commands
                    //before they are executed. A selection command
                    //must return something (even if it is the current query)
                    else if (command.type == framework.command.select) {
                        self.instance.query[command.name] = function() {
                        
                            //apply the current changes
                            self.execute();
                            
                            //get the current state of the query
                            var state = self.instance;
                            state.compare = function(value, types) { return framework.util.compare(value, types, state); };
                            state.when = function(value, types) { return framework.util.when(value, types, state); };
                            
                            //perform the work
                            return command.method.apply(state, arguments);
                        };
                    }
                    
                    //actions evaluate immediately then return control to
                    //the query 
                    else if (command.type == framework.command.action) {
                        self.instance.query[command.name] = function() {
                        
                            //get the current state of the query
                            var state = self.instance;
                            state.compare = function(value, types) { return framework.util.compare(value, types, state); };
                            state.when = function(value, types) { return framework.util.when(value, types, state); };
                        
                            //perform the work
                            command.method.apply(state, arguments);
                            return self.instance.query;
                        };
                    }
                
                });
                
                //causes the next command to be an 'or'
                self.instance.query.or = function() {
                    self.startNewCommandSet();
                    self.repeat(arguments);
                    return self.instance.query;
                };
                
                //causes the next command to be an 'and' (which is default)
                self.instance.query.and = function() { 
                    self.repeat(arguments); 
                    return self.instance.query;
                };
                
                //causes the next command to be a 'not'
                self.instance.query.not = function() { 
                    self.setNot();
                    self.repeat(arguments); 
                    return self.instance.query;
                };
                
                //causes the next command to be a 'not'
                self.instance.query.andNot = function() { 
                    self.setNot();
                    self.repeat(arguments); 
                    return self.instance.query;
                };
                
                //causes the next command to be a 'not' and 'or'
                self.instance.query.orNot = function() { 
                    self.startNewCommandSet();
                    self.setNot();
                    self.repeat(arguments); 
                    return self.instance.query;
                };
                
                //return the query information
                return self.instance.query;
            
            }
            
        },
        
        //variety of helper methods
        util:{
        
            //removes trailing and leading spaces from a value
            trim:function(value) {
                
                //get the string value
                value = value == null ? "" : value;
                value = value.toString();
                
                //trim the spaces
                return value.replace(/^\s*|\s*$/g, "");
            
            },
        
            //clones each item in an array
            cloneArray:function(array) {
                var result = [];
                framework.util.each(array, function(item) {
                    result.push(framework.util.clone(item));
                });
                return result;
            },
        
            //creates a copy of an object
            clone:function(obj) {
            
                //for arrays, copy each item
                if (framework.util.isType(framework.type.array, obj)) { 
                    return framework.util.cloneArray(obj);
                }
                //for object check each value
                else if (framework.util.isType(framework.type.object, obj)) {
                    var clone = {};
                    for(var item in obj) {
                        if (obj.hasOwnProperty(item)) clone[item] = framework.util.clone(obj[item]);
                    }
                    return clone;
                }
                //all other types just return the value
                else {
                    return obj;
                }
            },
        
            //creates an invocation handler for a field
            //name instead of grabbing values
            invoke:function(obj, args) {
                //copy the array to avoid breaking any other calls
                args = args.concat();
                
                //start by getting the path
                var path = args[0];
                
                //find the method and extract the arguments
                var method = framework.util.findValue(obj, path);
                args = framework.util.select(args, null, 1, null);
                
                //if we are invoking a method that hangs off
                //another object then we need to find the value
                path = path.replace(/\..*$/, "");
                var parent = framework.util.findValue(obj, path);
                obj = parent === method ? obj : parent;
                
                //return the result of the call
                try {
                    var result = method.apply(obj, args);
                    return result;
                }
                catch (e) {
                    return null;
                }
                
            },
        
            //gets a path from a field name
            getPath:function(path) {
                return framework.util.toString(path).split(framework.exp.get_path);
            },
        
            //searches an object to find a value
            findValue:function(obj, path) {
            
                //start by checking if this is actualy an attempt to 
                //invoke a value on this property
                if (framework.util.isType(framework.type.array, path)) {
                    return framework.util.invoke(obj, path);
                    
                }
                //if this referring to a field
                else if (framework.util.isType(framework.type.string, path)) {

                    //get each part of the path
                    path = framework.util.getPath(path);

                    //search for the record
                    var index = 0;
                    while(obj != null && index < path.length) {
                        obj = obj[path[index++]];
                    }
                    
                    //return the final found object
                    return obj;
                    
                }
                //nothing that can be read, just return the value
                else {
                    return obj;
                }
                
            },
        
            //returns the value at the provided index
            elementAt:function(collection, index) {
                return collection && collection.length > 0 && index < collection.length && index >= 0 
                    ? collection[index]
                    : null;
            },
        
            //makes a string save for regular expression searching
            regexEscape:function(val) {
                return (val ? val : "").toString().replace(framework.exp.escape_regex, "\\$&");
            },
            
            //matches expressions to a value
            regexMatch:function(expression, source, ignoreCase) {
            
                //get the string value if needed
                if (framework.util.isType(framework.type.regex, expression)) {
                    expression = expression.source;
                }
            
                //create the actual expression and match
                expression = new RegExp(framework.util.toString(expression), ignoreCase ? "gi" : "g");
                return framework.util.toString(source).match(expression) != null;
            },
        
            //converts a command to an operator name
            operatorName:function(name) {
                return name.replace(/^\w/, function(match) { return match.toUpperCase(); });
            },
        
            //changes a value based on the type
            compare:function(value, types, state) {
                var result = framework.util.when(value, types, state);
                return result == true ? result : false;
            },
            
            //performs the correct action depending on the type
            when:function(value, types, state) {

                //get the kind of object this is
                var kind = framework.util.getType(value);
                
                //check each of the types
                for (var item in types) {
                    if (!types.hasOwnProperty(item)) continue;
                    var type = framework.type[item];
                    if (type == kind) { 
                        return types[item].apply(state, [value]); 
                    }
                }
                
                //if there is a fallback comparison
                if (types.other) { return types.other.apply(state, [value]); }
                
                //no matches were found
                return null;
            },
        
            //performs an action on each item in a collection
            each:function(collection, action) {
                var index = 0;
                for(var item in collection){
                    if (collection.hasOwnProperty(item)) action(collection[item], index++);
                }
            },
            
            //performs an action to each item in a collection and then returns the items
            grab:function(collection, action) {
                var list = [];
                framework.util.each(collection, function(item) {
                    list.push(action(item));
                });
                return list;
            },
            
            //performs an action on each item in a collection
            until:function(collection, action) {
                for(var item = 0, l = collection.length; item < l; item++) {
                    var result = action(collection[item], item + 1);
                    if (result === true) { return true; }
                }
                return false;
            },
        
            //checks if the types match
            isType:function(type, value) {
                return framework.util.getType(value) == type;
            },
            
            //finds the type for an object
            getType:function(obj) {
            
                //check if this even has a value
                if (obj == null) { return framework.type.nothing; }
                
                //check each type except object
                for (var item in framework.library.types) {
                    if (framework.library.types[item](obj)) { return item; }
                }
                
                //no matching type was found
                return framework.type.object;
            },
            
            //grabs remaining elements from and array
            remaining:function(array, at) {
                var results = [];
                for(; at < array.length; at++) results.push(array[at]);
                return results;
            },
            
            //append items onto a target object
            apply:function(target, source) {
                for(var item in source) {
                    if (source.hasOwnProperty(item)) target[item] = source[item];
                }
                return target;
            },
            
            //performs sorting on a collection of records
            reorder:function(collection, fields, ignoreCase) {

                //reverses the fields so that they are organized
                //in the correct order
                return framework.util._performSort(collection, fields, ignoreCase);
            },
            
            //handles actual work of reordering (call reorder)
            _performSort:function(collection, fields, ignoreCase) {
            
                //get the next field to use
                var field = fields.splice(0, 1);
                if (field.length == 0) { return collection; }
                field = field[0];
                
                //get the name of the field and descending or not
                var invoked = framework.util.isType(framework.type.array, field);
                var name = (invoked ? field[0] : field);
                var desc = name.match(/^\-/);
                name = desc ? name.substr(1) : name;
                
                //updat the name if needed
                if (desc) { 
                    if (invoked) { field[0] = name; } else { field = name; }
                }
                
                //IE sorting bug resolved (Thanks @rizil)
                //http://webcache.googleusercontent.com/search?q=cache:www.zachleat.com/web/2010/02/24/array-sort/+zach+array+sort
                
                //create the sorting method for this field
                var sort = function(val1, val2) {
                
                    //find the values to compare
                    var a = framework.util.findValue(val1, field);
                    var b = framework.util.findValue(val2, field);
                    
                    //default to something when null
                    if (a == null && b == null) { a = 0; b = 0; }
                    else if (a == null && b != null) { a = 0; b = 1; }
                    else if (a != null && b == null) { a = 1; b = 0; }
                    
                    //check for string values
                    else if (ignoreCase && 
                        framework.util.isType(framework.type.string, a) && 
                        framework.util.isType(framework.type.string, b)) {
                        a = a.toLowerCase();
                        b = b.toLowerCase();
                    }
                    //if there is a length attribute use it instead
                    else if (a.length && b.length) {
                        a = a.length;
                        b = b.length;
                    }
                    
                    //perform the sorting
                    var result = (a < b) ? -1 : (a > b) ? 1 : 0;
                    return desc ? -result : result;
                
                };
                
                //then perform the sorting
                collection.sort(sort);
                
                //check for sub groups if required
                if (fields.length > 0) {
                
                    //create the container for the results
                    var sorted = [];
                    var groups = framework.util.group(collection, field, ignoreCase);
                    framework.util.each(groups, function(group) {
                        var listing = fields.slice();
                        var records = framework.util._performSort(group, listing, ignoreCase);
                        sorted = sorted.concat(records);
                    });
                    
                    //update the main collection
                    collection = sorted;
                }
                
                //the final results
                return collection;
            },
            
            //returns groups of unique field values
            group:function(records, field, ignoreCase) {
            
                //create a container to track group names
                var groups = {};
                for(var item = 0, l = records.length; item < l; item++) {
                    //get the values
                    var record = records[item];
                    var alias = framework.util.toString(framework.util.findValue(record, field));
                    alias = ignoreCase ? alias.toUpperCase() : alias;

                    //check for existing values
                    if (!groups[alias]) { 
                        groups[alias] = [record]; 
                    }
                    else {
                        groups[alias].push(record);
                    }
                    
                }
                
                //return the matches
                return groups;
            
            },
            
            //compares two values for equality
            equals:function(val1, val2, ignoreCase) {
                return framework.util.when(val1, {
                    string:function() {
                        return framework.util.regexMatch(
                            "^"+framework.util.regexEscape(val2)+"$", 
                            val1, 
                            ignoreCase); 
                    },
                    other:function() { return (val1 == null && val2 == null) || (val1 === val2); }
                });
            },
            
            //converts an object to an array of elements
            toArray:function(obj) {
                var items = [];
                if (obj.length) {
                    for (var i = 0; i < obj.length; i++) { items.push(obj[i]); }
                }
                else {
                    for (var item in obj) {
                        if (obj.hasOwnProperty(item)) items.push(obj[item]);
                    }
                }
                return items;
            },
            
            //converts a value into a string
            toString:function(val) {
                return val == null ? "" : val.toString();
            },
            
            //grabs a range of records from a collection
            skipTake:function(collection, action, skip, take) {
            
                //set the defaults
                skip = skip == null ? 0 : skip;
                take = take == null ? collection.length : take;
                
                //check if this will return any records
                if (skip >= collection.length || 
                    take == 0) {
                    return []; 
                }
            
                //return the results
                return framework.util.select(collection, action, skip, skip + take);
            },
            
            //grabs a range and format for records
            select:function(collection, action, start, end) {

                //grab the records if there is a range
                start = start == null ? 0 : start;
                end = end == null ? collection.length : end;
                
                //slice the records
                var results = collection.slice(start, end);
                
                //check if this is a mapping method
                if (jLinq.util.isType(jLinq.type.object, action)) {
                    var map = action;
                    action = function(rec) {
                        
                        //map existing values or defaults
                        // TODO: tests do not cover this method!
                        var create = {};
                        for (var item in map) {
                            if (!map.hasOwnProperty(item)) continue;
                            create[item] = rec[item]
                                ? rec[item]
                                : map[item];
                        }
                        
                        //return the created record
                        return create;
                    
                    };
                };
                
                //if there is a selection method, use it
                if (jLinq.util.isType(jLinq.type.method, action)) {
                    for (var i = 0; i < results.length; i++) {
                        var record = results[i];
                        results[i] = action.apply(record, [record]);
                    }
                }
                
                //return the final set of records
                return results;
            }
            
        }
    
    };
    
    //default types
    framework.library.addType(framework.type.nothing, function(value) { return value == null; });
    framework.library.addType(framework.type.array, function(value) { return value instanceof Array; });
    framework.library.addType(framework.type.string, function(value) { return value.substr && value.toLowerCase; });
    framework.library.addType(framework.type.number, function(value) { return value.toFixed && value.toExponential; });
    framework.library.addType(framework.type.regex, function(value) { return value instanceof RegExp; });
    framework.library.addType(framework.type.bool, function(value) { return value == true || value == false; });
    framework.library.addType(framework.type.method, function(value) { return value instanceof Function; });
    framework.library.addType(framework.type.datetime, function(value) { return value instanceof Date; });
    
    //add the default methods
    framework.library.extend([
    
        //sets a query to ignore case
        { name:"ignoreCase", type:framework.command.action, 
            method:function() {
                this.ignoreCase = true;
            }},
            
        //reverses the current set of records
        { name:"reverse", type:framework.command.action, 
            method:function() {
                this.records.reverse();
            }},
            
        //sets a query to evaluate case
        { name:"useCase", type:framework.command.action, 
            method:function() {
                this.ignoreCase = false;
            }},
            
        //performs an action for each record
        { name:"each", type:framework.command.action,
            method:function(action) {
                jLinq.util.each(this.records, function(record) { action(record); });
            }},
            
        //attaches a value or result of a method to each record
        { name:"attach", type:framework.command.action,
            method:function(field, action) {
                this.when(action, {
                    method:function() { jLinq.util.each(this.records, function(record) { record[field] = action(record); }); },
                    other:function() { jLinq.util.each(this.records, function(record) { record[field] = action; }); }
                });
            }},
            
        //joins two sets of records by the key information provided
        { name:"join", type:framework.command.action,
            method:function(source, alias, pk, fk) {
                jLinq.util.each(this.records, function(record) {
                    record[alias] = jLinq.from(source).equals(fk, record[pk]).select();
                });
            }},
            
        //joins a second array but uses only the first matched record. Allows for a default for a fallback value
        { name:"assign", type:framework.command.action,
            method:function(source, alias, pk, fk, fallback) {
                jLinq.util.each(this.records, function(record) {
                    record[alias] = jLinq.from(source).equals(fk, record[pk]).first(fallback);
                });
            }},
            
        //joins two sets of records by the key information provided
        { name:"sort", type:framework.command.action,
            method:function() {
                var args = jLinq.util.toArray(arguments);
                this.records = jLinq.util.reorder(this.records, args, this.ignoreCase);
            }},
    
        //are the two values the same
        { name:"equals", type:framework.command.query, 
            method:function(value) {
                return jLinq.util.equals(this.value, value, this.ignoreCase);
            }},
            
        //does this start with a value
        { name:"starts", type:framework.command.query, 
            method:function(value) {
                return this.compare({
                    array:function() { return jLinq.util.equals(this.value[0], value, this.ignoreCase); },
                    other:function() { return jLinq.util.regexMatch(("^"+jLinq.util.regexEscape(value)), this.value, this.ignoreCase); }
                });
            }},
            
        //does this start with a value
        { name:"ends", type:framework.command.query, 
            method:function(value) {
                return this.compare({
                    array:function() { return jLinq.util.equals(this.value[this.value.length - 1], value, this.ignoreCase); },
                    other:function() { return jLinq.util.regexMatch((jLinq.util.regexEscape(value)+"$"), this.value, this.ignoreCase); }
                });
            }},
            
        //does this start with a value
        { name:"contains", type:framework.command.query, 
            method:function(value) {
                return this.compare({
                    array:function() { 
                        var ignoreCase = this.ignoreCase;
                        return jLinq.util.until(this.value, function(item) { return jLinq.util.equals(item, value, ignoreCase); }); 
                    },
                    other:function() { return jLinq.util.regexMatch(jLinq.util.regexEscape(value), this.value, this.ignoreCase); }
                });
            }},
            
        //does this start with a value
        { name:"match", type:framework.command.query, 
            method:function(value) {
                return this.compare({
                    array:function() { 
                        var ignoreCase = this.ignoreCase;
                        return jLinq.util.until(this.value, function(item) { return jLinq.util.regexMatch(value, item, ignoreCase); }); 
                    },
                    other:function() { return jLinq.util.regexMatch(value, this.value, this.ignoreCase); }
                });
            }},
            
        //checks if the value matches the type provided
        { name:"type", type:framework.command.query, 
            method:function(type) {
                return jLinq.util.isType(type, this.value);
            }},
            
        //is the value greater than the argument
        { name:"greater", type:framework.command.query, 
            method:function(value) {
                return this.compare({
                    array:function() { return this.value.length > value; },
                    string:function() { return this.value.length > value; },
                    other:function() { return this.value > value; }
                });
            }},
            
        //is the value greater than or equal to the argument
        { name:"greaterEquals", type:framework.command.query, 
            method:function(value) {
                return this.compare({
                    array:function() { return this.value.length >= value; },
                    string:function() { return this.value.length >= value; },
                    other:function() { return this.value >= value; }
                });
            }},
            
        //is the value less than the argument
        { name:"less", type:framework.command.query, 
            method:function(value) {
                return this.compare({
                    array:function() { return this.value.length < value; },
                    string:function() { return this.value.length < value; },
                    other:function() { return this.value < value; }
                });
            }},
            
        //is the value less than or equal to the argument
        { name:"lessEquals", type:framework.command.query, 
            method:function(value) {
                return this.compare({
                    array:function() { return this.value.length <= value; },
                    string:function() { return this.value.length <= value; },
                    other:function() { return this.value <= value; }
                });
            }},
            
        //is the value between the values provided
        { name:"between", type:framework.command.query, 
            method:function(low, high) {
                return this.compare({
                    array:function() { return this.value.length > low && this.value.length < high; },
                    string:function() { return this.value.length > low && this.value.length < high; },
                    other:function() { return this.value > low && this.value < high; }
                });
            }},
            
        //is the value between or equal to the values provided
        { name:"betweenEquals", type:framework.command.query, 
            method:function(low, high) {
                return this.compare({
                    array:function() { return this.value.length >= low && this.value.length <= high; },
                    string:function() { return this.value.length >= low && this.value.length <= high; },
                    other:function() { return this.value >= low && this.value <= high; }
                });
            }},
            
        //returns if a value is null or contains nothing
        { name:"empty", type:framework.command.query, 
            method:function() {
                return this.compare({
                    array:function() { return this.value.length == 0; },
                    string:function() { return jLinq.util.trim(this.value).length == 0; },
                    other:function() { return this.value == null; }
                });
            }},
            
        //returns if a value is true or exists
        { name:"is", type:framework.command.query, 
            method:function() {
                return this.compare({
                    bool:function() { return this.value === true; },
                    other:function() { return this.value != null; }
                });
            }},
        
        //gets the smallest value from the collection
        { name:"min", type:framework.command.select,
            method:function(field) {
                var matches = jLinq.util.reorder(this.records, [field], this.ignoreCase);
                return jLinq.util.elementAt(matches, 0);
            }},
            
        //gets the largest value from the collection
        { name:"max", type:framework.command.select,
            method:function(field) {
                var matches = jLinq.util.reorder(this.records, [field], this.ignoreCase);
                return jLinq.util.elementAt(matches, matches.length - 1);
            }},
            
        //returns the sum of the values of the field
        { name:"sum", type:framework.command.select,
            method:function(field) {
                var sum; 
                jLinq.util.each(this.records, function(record) {
                    var value = jLinq.util.findValue(record, field);
                    sum = sum == null ? value : (sum + value);
                });
                return sum;
            }},
            
        //returns the sum of the values of the field
        { name:"average", type:framework.command.select,
            method:function(field) {
                var sum; 
                jLinq.util.each(this.records, function(record) {
                    var value = jLinq.util.findValue(record, field);
                    sum = sum == null ? value : (sum + value);
                });
                return sum / this.records.length;
            }},
                
        //skips the requested number of records
        { name:"skip", type:framework.command.select,
            method:function(skip, selection) {
                this.records = this.when(selection, {
                    method:function() { return jLinq.util.skipTake(this.records, selection, skip, null); },
                    object:function() { return jLinq.util.skipTake(this.records, selection, skip, null); },
                    other:function() { return jLinq.util.skipTake(this.records, null, skip, null); }
                });
                return this.query;
            }},
            
        //takes the requested number of records
        { name:"take", type:framework.command.select,
            method:function(take, selection) {
                return this.when(selection, {
                    method:function() { return jLinq.util.skipTake(this.records, selection, null, take); },
                    object:function() { return jLinq.util.skipTake(this.records, selection, null, take); },
                    other:function() { return jLinq.util.skipTake(this.records, null, null, take); }
                });
            }},
            
        //skips and takes records
        { name:"skipTake", type:framework.command.select,
            method:function(skip, take, selection) {
                return this.when(selection, {
                    method:function() { return jLinq.util.skipTake(this.records, selection, skip, take); },
                    object:function() { return jLinq.util.skipTake(this.records, selection, skip, take); },
                    other:function() { return jLinq.util.skipTake(this.records, null, skip, take); }
                });
            }},
            
        //selects the remaining records
        { name:"select", type:framework.command.select,
            method:function(selection) {
                return this.when(selection, {
                    method:function() { return jLinq.util.select(this.records, selection); },
                    object:function() { return jLinq.util.select(this.records, selection); },
                    other:function() { return this.records; }
                });
            }},
            
        //selects all of the distinct values for a field
        { name:"distinct", type:framework.command.select,
            method:function(field) {
                var groups = jLinq.util.group(this.records, field, this.ignoreCase);
                return jLinq.util.grab(groups, function(record) {
                    return jLinq.util.findValue(record[0], field);
                });
            }},
            
        //groups the values of a field by unique values
        { name:"group", type:framework.command.select,
            method:function(field) {
                return jLinq.util.group(this.records, field, this.ignoreCase);
            }},
            
        //selects records into a new format
        { name:"define", type:framework.command.select,
            method:function(selection) {
                var results = this.when(selection, {
                    method:function() { return jLinq.util.select(this.records, selection); },
                    object:function() { return jLinq.util.select(this.records, selection); },
                    other:function() { return this.records; }
                });
                return jLinq.from(results);
            }},
            
        //returns if a collection contains any records
        { name:"any", type:framework.command.select,
            method:function() {
                return this.records.length > 0;
            }},
            
        //returns if no records matched this query
        { name:"none", type:framework.command.select,
            method:function() {
                return this.records.length == 0;
            }},
            
        //returns if all records matched the query
        { name:"all", type:framework.command.select,
            method:function() {
                return this.removed.length == 0;
            }},
                
        //returns the first record found or the fallback value if nothing was found
        { name:"first", type:framework.command.select,
            method:function(fallback) {
                var record = jLinq.util.elementAt(this.records, 0);
                return record == null ? fallback : record;
            }},
            
        //returns the last record found or the fallback value if nothing was found
        { name:"last", type:framework.command.select,
            method:function(fallback) {
                var record = jLinq.util.elementAt(this.records, this.records.length - 1);
                return record == null ? fallback : record;
            }},
            
        //returns the record at the provided index or the fallback value if nothing was found
        { name:"at", type:framework.command.select,
            method:function(index, fallback) {
                var record = jLinq.util.elementAt(this.records, index);
                return record == null ? fallback : record;
            }},
                    
        //returns the remaining count of records
        { name:"count", type:framework.command.select,
            method:function() {
                return this.records.length;
            }},
            
        //selects the remaining records
        { name:"removed", type:framework.command.select,
            method:function(selection) {
                return this.when(selection, {
                    method:function() { return jLinq.util.select(this.removed, selection); },
                    object:function() { return jLinq.util.select(this.removed, selection); },
                    other:function() { return this.removed; }
                });
            }},
            
        //performs a manual comparison of records
        { name:"where", type:framework.command.select, 
            method:function(compare) {
                
                //filter the selection
                var state = this;
                var matches = [];
                jLinq.util.each(this.records, function(record) {
                    if (compare.apply(state, [record]) === true) { matches.push(record); }
                });
                
                //create a new query with matching arguments
                var query = jLinq.from(matches);
                if (!this.ignoreCase) { query.useCase(); }
                return query;
            }}
            
        ]);
    
    //set the public object
    jLinq = {
    
        //determines if new queries should always be
        //cloned to prevent accidental changes to objects
        alwaysClone:false,
        
        //sets the default for jLinq query case checking
        ignoreCase:true,
    
        //command types (select, query, action)
        command:framework.command,
        
        //types of object and values
        type:framework.type,
        
        //allows command to be added to the library
        extend:function() { framework.library.extend.apply(null, arguments); },
        
        //core function to start and entirely new query
        query:function(collection, params) { 
            return library.framework.query(collection, params); 
        },
        
        //starts a new query with the array provided
        from:function(collection) { 
            return framework.library.query(collection, { clone:false });
        },
        
        //returns a list of commands in the library
        getCommands:function() {
            return framework.util.grab(framework.library.commands, function(command) {
                return {
                    name:command.name,
                    typeId:command.type,
                    type:command.type == framework.command.select ? "select"
                        : command.type == framework.command.query ? "query"
                        : command.type == framework.command.action ? "action"
                        : "unknown"
                };
            });
        },
        
        //helper functions for jLinq
        util:{
        
            //removes leading and trailing spaces
            trim:framework.util.trim,
        
            //loops and finds a value in an object from a path
            findValue:framework.util.findValue,
        
            //gets an element at the specified index (if any)
            elementAt:framework.util.elementAt,
        
            //returns a regex safe version of a string
            regexEscape:framework.util.regexEscape,
            
            //compares an expression to another string
            regexMatch:framework.util.regexMatch,
        
            //compares equality of two objects
            equals:framework.util.equals,
            
            //gets groups for a collection
            group:framework.util.group,
            
            //updates the order of a collection
            reorder:framework.util.reorder,
            
            //performs a function when a value matches a type
            when:framework.util.when,
            
            //converts an object to an array of values
            toArray:framework.util.toArray,
            
            //loops for each record in a set
            each:framework.util.each,
            
            //grabs a collection of items
            grab:framework.util.grab,
            
            //loops records until one returns true or the end is reached
            until:framework.util.until,
            
            //returns if an object is the provided type
            isType:framework.util.isType,
            
            //determines the matching type for a value
            getType:framework.util.getType,
            
            //applies each source property to the target
            apply:framework.util.apply,
            
            //uses the action to select items from a collection
            select:framework.util.select,
            
            //grabs records for a specific range
            skipTake:framework.util.skipTake
            
        }
    };
    
    //set the other aliases
    jlinq = jLinq;
    jl = jLinq;
})();

if (typeof define === "function" && define.amd && define.amd.jQuery) {
        define("jLinq", [], function () {
            return jLinq;
        });
}  
/* 
 * MapMap 
 * 
 * 
 * size() Map 
 * isEmpty() Map 
 * clear() Map 
 * put(key, value) Mapkey, value)  
 * remove(key) keytruefalse 
 * get(key) keyvaluenull 
 * element(index) element.keyelement.valuekeyvaluenull 
 * containsKey(key) Mapkey 
 * containsValue(value) Mapvalue 
 * keys() Mapkeyarray 
 * values() Mapvaluearray 
 * 
 */
function Map() {
	this.elements = new Array();

	// Map
	this.size = function() {
		return this.elements.length;
	},

	// Map
	this.isEmpty = function() {
		return (this.elements.length < 1);
	},

	// Map
	this.clear = function() {
		this.elements = new Array();
	},

	// Mapkey, value)
	this.put = function(_key, _value) {
		if (this.containsKey(_key) == true) {
			if (this.containsValue(_value)) {
				if (this.remove(_key) == true) {
					this.elements.push({
						key : _key,
						value : _value
					});
				}
			} else {
				this.elements.push({
					key : _key,
					value : _value
				});
			}
		} else {
			this.elements.push({
				key : _key,
				value : _value
			});
		}
	},

	// keytruefalse
	this.remove = function(_key) {
		var bln = false;
		try {
			for (i = 0; i < this.elements.length; i++) {
				if (this.elements[i].key == _key) {
					this.elements.splice(i, 1);
					return true;
				}
			}
		} catch (e) {
			bln = false;
		}
		return bln;
	},
	
	// truefalse
	this.removeLastOne = function() {
		var bln = false;
		try {
			this.elements.splice(this.elements.length-1, 1);
			bln=true;
		} catch (e) {
			bln = false;
		}
		return bln;
	},

	// keyvaluenull
	this.get = function(_key) {
		try {
			for (i = 0; i < this.elements.length; i++) {
				if (this.elements[i].key == _key) {
					return this.elements[i].value;
				}
			}
		} catch (e) {
			return null;
		}
	},

	// element.keyelement.valuekeyvaluenull
	this.element = function(_index) {
		if (_index < 0 || _index >= this.elements.length) {
			return null;
		}
		return this.elements[_index];
	},

	// Mapkey
	this.containsKey = function(_key) {
		var bln = false;
		try {
			for (i = 0; i < this.elements.length; i++) {
				if (this.elements[i].key == _key) {
					bln = true;
				}
			}
		} catch (e) {
			bln = false;
		}
		return bln;
	},

	// Mapvalue
	this.containsValue = function(_value) {
		var bln = false;
		try {
			for (i = 0; i < this.elements.length; i++) {
				if (this.elements[i].value == _value) {
					bln = true;
				}
			}
		} catch (e) {
			bln = false;
		}
		return bln;
	},

	// Mapkeyarray
	this.keys = function() {
		var arr = new Array();
		for (i = 0; i < this.elements.length; i++) {
			arr.push(this.elements[i].key);
		}
		return arr;
	},

	// Mapvaluearray
	this.values = function() {
		var arr = new Array();
		for (i = 0; i < this.elements.length; i++) {
			arr.push(this.elements[i].value);
		}
		return arr;
	};
}

if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
    define( "map", [], function () { return Map; } );
}
/**
 * jQuery JSON Plugin
 * version: 2.3 (2011-09-17)
 *
 * This document is licensed as free software under the terms of the
 * MIT License: http://www.opensource.org/licenses/mit-license.php
 *
 * Brantley Harris wrote this plugin. It is based somewhat on the JSON.org
 * website's http://www.json.org/json2.js, which proclaims:
 * "NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.", a sentiment that
 * I uphold.
 *
 * It is also influenced heavily by MochiKit's serializeJSON, which is
 * copyrighted 2005 by Bob Ippolito.
 */

(function( $ ) {

	var	escapeable = /["\\\x00-\x1f\x7f-\x9f]/g,
		meta = {
			'\b': '\\b',
			'\t': '\\t',
			'\n': '\\n',
			'\f': '\\f',
			'\r': '\\r',
			'"' : '\\"',
			'\\': '\\\\'
		};

	/**
	 * jQuery.toJSON
	 * Converts the given argument into a JSON respresentation.
	 *
	 * @param o {Mixed} The json-serializble *thing* to be converted
	 *
	 * If an object has a toJSON prototype, that will be used to get the representation.
	 * Non-integer/string keys are skipped in the object, as are keys that point to a
	 * function.
	 *
	 */
	$.toJSON = typeof JSON === 'object' && JSON.stringify
		? JSON.stringify
		: function( o ) {

		if ( o === null ) {
			return 'null';
		}

		var type = typeof o;

		if ( type === 'undefined' ) {
			return undefined;
		}
		if ( type === 'number' || type === 'boolean' ) {
			return '' + o;
		}
		if ( type === 'string') {
			return $.quoteString( o );
		}
		if ( type === 'object' ) {
			if ( typeof o.toJSON === 'function' ) {
				return $.toJSON( o.toJSON() );
			}
			if ( o.constructor === Date ) {
				var	month = o.getUTCMonth() + 1,
					day = o.getUTCDate(),
					year = o.getUTCFullYear(),
					hours = o.getUTCHours(),
					minutes = o.getUTCMinutes(),
					seconds = o.getUTCSeconds(),
					milli = o.getUTCMilliseconds();

				if ( month < 10 ) {
					month = '0' + month;
				}
				if ( day < 10 ) {
					day = '0' + day;
				}
				if ( hours < 10 ) {
					hours = '0' + hours;
				}
				if ( minutes < 10 ) {
					minutes = '0' + minutes;
				}
				if ( seconds < 10 ) {
					seconds = '0' + seconds;
				}
				if ( milli < 100 ) {
					milli = '0' + milli;
				}
				if ( milli < 10 ) {
					milli = '0' + milli;
				}
				return '"' + year + '-' + month + '-' + day + 'T' +
					hours + ':' + minutes + ':' + seconds +
					'.' + milli + 'Z"';
			}
			if ( o.constructor === Array ) {
				var ret = [];
				for ( var i = 0; i < o.length; i++ ) {
					ret.push( $.toJSON( o[i] ) || 'null' );
				}
				return '[' + ret.join(',') + ']';
			}
			var	name,
				val,
				pairs = [];
			for ( var k in o ) {
				type = typeof k;
				if ( type === 'number' ) {
					name = '"' + k + '"';
				} else if (type === 'string') {
					name = $.quoteString(k);
				} else {
					// Keys must be numerical or string. Skip others
					continue;
				}
				type = typeof o[k];

				if ( type === 'function' || type === 'undefined' ) {
					// Invalid values like these return undefined
					// from toJSON, however those object members
					// shouldn't be included in the JSON string at all.
					continue;
				}
				val = $.toJSON( o[k] );
				pairs.push( name + ':' + val );
			}
			return '{' + pairs.join( ',' ) + '}';
		}
	};

	/**
	 * jQuery.evalJSON
	 * Evaluates a given piece of json source.
	 *
	 * @param src {String}
	 */
	$.evalJSON = typeof JSON === 'object' && JSON.parse
		? JSON.parse
		: function( src ) {
		return eval('(' + src + ')');
	};

	/**
	 * jQuery.secureEvalJSON
	 * Evals JSON in a way that is *more* secure.
	 *
	 * @param src {String}
	 */
	$.secureEvalJSON = typeof JSON === 'object' && JSON.parse
		? JSON.parse
		: function( src ) {

		var filtered = 
			src
			.replace( /\\["\\\/bfnrtu]/g, '@' )
			.replace( /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
			.replace( /(?:^|:|,)(?:\s*\[)+/g, '');

		if ( /^[\],:{}\s]*$/.test( filtered ) ) {
			return eval( '(' + src + ')' );
		} else {
			throw new SyntaxError( 'Error parsing JSON, source is not valid.' );
		}
	};

	/**
	 * jQuery.quoteString
	 * Returns a string-repr of a string, escaping quotes intelligently.
	 * Mostly a support function for toJSON.
	 * Examples:
	 * >>> jQuery.quoteString('apple')
	 * "apple"
	 *
	 * >>> jQuery.quoteString('"Where are we going?", she asked.')
	 * "\"Where are we going?\", she asked."
	 */
	$.quoteString = function( string ) {
		if ( string.match( escapeable ) ) {
			return '"' + string.replace( escapeable, function( a ) {
				var c = meta[a];
				if ( typeof c === 'string' ) {
					return c;
				}
				c = a.charCodeAt();
				return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
			}) + '"';
		}
		return '"' + string + '"';
	};

})( jQuery );

//mod.defineModule("boxUtil",["base"],function(){
    $.boxLayoutUtil = $.boxLayoutUtil || {};
    $.extend($.boxLayoutUtil,{
        getBorderWidth:function(elem){
            var leftwidth =parseInt($(elem).css('borderLeftWidth'),10);
            if($.isNaN(leftwidth)) leftwidth = 0;
            var rightwidth =parseInt($(elem).css('borderRightWidth'),10);
            if($.isNaN(rightwidth)) rightwidth = 0;
            return (leftwidth + rightwidth);
        },
        getPaddingWidth:function(elem){
            var leftwidth =parseInt($(elem).css('paddingLeft'),10);
            if($.isNaN(leftwidth)) leftwidth = 0;
            var rightwidth =parseInt($(elem).css('paddingRight'),10);
            if($.isNaN(rightwidth)) rightwidth = 0;
            return (leftwidth + rightwidth);
        },
        getMarginWidth:function(elem){
            var leftwidth =parseInt($(elem).css('marginLeft'),10);
            if($.isNaN(leftwidth)) leftwidth = 0;
            var rightwidth =parseInt($(elem).css('marginRight'),10);
            if($.isNaN(rightwidth)) rightwidth = 0;
            return (leftwidth + rightwidth);
        },
        getElementWidth:function(elem){
            if($.browser.msie&&($.browser.version == "6.0"||$.browser.version == "7.0")&&!$.support.style){
                return $(elem).width();
            }else{
                if($(elem).width()==0) return 0;
                return $(elem).width() +
                    $.boxLayoutUtil.getBorderWidth(elem) +
                    $.boxLayoutUtil.getPaddingWidth(elem) +
                    $.boxLayoutUtil.getMarginWidth(elem);
            }
        },
        getBorderHeight:function(elem){
            var topHeight =parseInt($(elem).css('borderTopWidth'),10);
            if($.isNaN(topHeight)) topHeight = 0;
            var bottomHeight =parseInt($(elem).css('borderBottomWidth'),10);
            if($.isNaN(bottomHeight)) bottomHeight = 0;
            return (topHeight + bottomHeight);
        },
        getPaddingHeight:function(elem){
            var topHeight =parseInt($(elem).css('paddingTop'),10);
            var bottomHeight =parseInt($(elem).css('paddingBottom'),10);
            return (topHeight + bottomHeight);
        },
        getMarginHeight:function(elem){
            var top = $(elem).css('marginTop');
            var bottom = $(elem).css('marginBottom');
            top = $.isNaN(top)?0:parseInt(top,10);
            bottom = $.isNaN(bottom)?0:parseInt(bottom,10);
            return (top + bottom);
        },
        getElementHeight:function(elem){
            if($.browser.msie&&($.browser.version == "6.0"||$.browser.version == "7.0")&&!$.support.style){
                return $(elem).height();
            }else{
                if($(elem).height()==0) return 0;
                return $(elem).height() +
                    $.boxLayoutUtil.getBorderHeight(elem) +
                    $.boxLayoutUtil.getPaddingHeight(elem) +
                    $.boxLayoutUtil.getMarginHeight(elem);
            }
        },
        userBrowser:function () {
            return $.browserUtil.userBrowser();
        },
        getContentHeight:function(elem){
            var browser = $.boxLayoutUtil.userBrowser();
            if("ie"===browser || "opera"===browser){
                return elem.scrollHeight;
            }else if("firefox"===browser || "chrome"===browser ||"webkit"===browser){
                return elem.offsetHeight();
            }
        }
    });
//});
/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */



var Hogan = {};

(function (Hogan, useArrayBuffer) {
  Hogan.Template = function (renderFunc, text, compiler, options) {
    this.r = renderFunc || this.r;
    this.c = compiler;
    this.options = options;
    this.text = text || '';
    this.buf = (useArrayBuffer) ? [] : '';
  }

  Hogan.Template.prototype = {
    // render: replaced by generated code.
    r: function (context, partials, indent) { return ''; },

    // variable escaping
    v: hoganEscape,

    // triple stache
    t: coerceToString,

    render: function render(context, partials, indent) {
      return this.ri([context], partials || {}, indent);
    },

    // render internal -- a hook for overrides that catches partials too
    ri: function (context, partials, indent) {
      return this.r(context, partials, indent);
    },

    // tries to find a partial in the curent scope and render it
    rp: function(name, context, partials, indent) {
      var partial = partials[name];

      if (!partial) {
        return '';
      }

      if (this.c && typeof partial == 'string') {
        partial = this.c.compile(partial, this.options);
      }

      return partial.ri(context, partials, indent);
    },

    // render a section
    rs: function(context, partials, section) {
      var tail = context[context.length - 1];

      if (!isArray(tail)) {
        section(context, partials, this);
        return;
      }

      for (var i = 0; i < tail.length; i++) {
        context.push(tail[i]);
        section(context, partials, this);
        context.pop();
      }
    },

    // maybe start a section
    s: function(val, ctx, partials, inverted, start, end, tags) {
      var pass;

      if (isArray(val) && val.length === 0) {
        return false;
      }

      if (typeof val == 'function') {
        val = this.ls(val, ctx, partials, inverted, start, end, tags);
      }

      pass = (val === '') || !!val;

      if (!inverted && pass && ctx) {
        ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);
      }

      return pass;
    },

    // find values with dotted names
    d: function(key, ctx, partials, returnFound) {
      var names = key.split('.'),
          val = this.f(names[0], ctx, partials, returnFound),
          cx = null;

      if (key === '.' && isArray(ctx[ctx.length - 2])) {
        return ctx[ctx.length - 1];
      }

      for (var i = 1; i < names.length; i++) {
        if (val && typeof val == 'object' && names[i] in val) {
          cx = val;
          val = val[names[i]];
        } else {
          val = '';
        }
      }

      if (returnFound && !val) {
        return false;
      }

      if (!returnFound && typeof val == 'function') {
        ctx.push(cx);
        val = this.lv(val, ctx, partials);
        ctx.pop();
      }

      return val;
    },

    // find values with normal names
    f: function(key, ctx, partials, returnFound) {
      var val = false,
          v = null,
          found = false;

      for (var i = ctx.length - 1; i >= 0; i--) {
        v = ctx[i];
        if (v && typeof v == 'object' && key in v) {
          val = v[key];
          found = true;
          break;
        }
      }

      if (!found) {
        return (returnFound) ? false : "";
      }

      if (!returnFound && typeof val == 'function') {
        val = this.lv(val, ctx, partials);
      }

      return val;
    },

    // higher order templates
    ho: function(val, cx, partials, text, tags) {
      var compiler = this.c;
      var options = this.options;
      options.delimiters = tags;
      var text = val.call(cx, text);
      text = (text == null) ? String(text) : text.toString();
      this.b(compiler.compile(text, options).render(cx, partials));
      return false;
    },

    // template result buffering
    b: (useArrayBuffer) ? function(s) { this.buf.push(s); } :
                          function(s) { this.buf += s; },
    fl: (useArrayBuffer) ? function() { var r = this.buf.join(''); this.buf = []; return r; } :
                           function() { var r = this.buf; this.buf = ''; return r; },

    // lambda replace section
    ls: function(val, ctx, partials, inverted, start, end, tags) {
      var cx = ctx[ctx.length - 1],
          t = null;

      if (!inverted && this.c && val.length > 0) {
        return this.ho(val, cx, partials, this.text.substring(start, end), tags);
      }

      t = val.call(cx);

      if (typeof t == 'function') {
        if (inverted) {
          return true;
        } else if (this.c) {
          return this.ho(t, cx, partials, this.text.substring(start, end), tags);
        }
      }

      return t;
    },

    // lambda replace variable
    lv: function(val, ctx, partials) {
      var cx = ctx[ctx.length - 1];
      var result = val.call(cx);

      if (typeof result == 'function') {
        result = coerceToString(result.call(cx));
        if (this.c && ~result.indexOf("{\u007B")) {
          return this.c.compile(result, this.options).render(cx, partials);
        }
      }

      return coerceToString(result);
    }

  };

  var rAmp = /&/g,
      rLt = /</g,
      rGt = />/g,
      rApos =/\'/g,
      rQuot = /\"/g,
      hChars =/[&<>\"\']/;


  function coerceToString(val) {
    return String((val === null || val === undefined) ? '' : val);
  }

  function hoganEscape(str) {
    str = coerceToString(str);
    return hChars.test(str) ?
      str
        .replace(rAmp,'&amp;')
        .replace(rLt,'&lt;')
        .replace(rGt,'&gt;')
        .replace(rApos,'&#39;')
        .replace(rQuot, '&quot;') :
      str;
  }

  var isArray = Array.isArray || function(a) {
    return Object.prototype.toString.call(a) === '[object Array]';
  };

})(typeof exports !== 'undefined' ? exports : Hogan);




(function (Hogan) {
  // Setup regex  assignments
  // remove whitespace according to Mustache spec
  var rIsWhitespace = /\S/,
      rQuot = /\"/g,
      rNewline =  /\n/g,
      rCr = /\r/g,
      rSlash = /\\/g,
      tagTypes = {
        '#': 1, '^': 2, '/': 3,  '!': 4, '>': 5,
        '<': 6, '=': 7, '_v': 8, '{': 9, '&': 10
      };

  Hogan.scan = function scan(text, delimiters) {
    var len = text.length,
        IN_TEXT = 0,
        IN_TAG_TYPE = 1,
        IN_TAG = 2,
        state = IN_TEXT,
        tagType = null,
        tag = null,
        buf = '',
        tokens = [],
        seenTag = false,
        i = 0,
        lineStart = 0,
        otag = '{{',
        ctag = '}}';

    function addBuf() {
      if (buf.length > 0) {
        tokens.push(new String(buf));
        buf = '';
      }
    }

    function lineIsWhitespace() {
      var isAllWhitespace = true;
      for (var j = lineStart; j < tokens.length; j++) {
        isAllWhitespace =
          (tokens[j].tag && tagTypes[tokens[j].tag] < tagTypes['_v']) ||
          (!tokens[j].tag && tokens[j].match(rIsWhitespace) === null);
        if (!isAllWhitespace) {
          return false;
        }
      }

      return isAllWhitespace;
    }

    function filterLine(haveSeenTag, noNewLine) {
      addBuf();

      if (haveSeenTag && lineIsWhitespace()) {
        for (var j = lineStart, next; j < tokens.length; j++) {
          if (!tokens[j].tag) {
            if ((next = tokens[j+1]) && next.tag == '>') {
              // set indent to token value
              next.indent = tokens[j].toString()
            }
            tokens.splice(j, 1);
          }
        }
      } else if (!noNewLine) {
        tokens.push({tag:'\n'});
      }

      seenTag = false;
      lineStart = tokens.length;
    }

    function changeDelimiters(text, index) {
      var close = '=' + ctag,
          closeIndex = text.indexOf(close, index),
          delimiters = trim(
            text.substring(text.indexOf('=', index) + 1, closeIndex)
          ).split(' ');

      otag = delimiters[0];
      ctag = delimiters[1];

      return closeIndex + close.length - 1;
    }

    if (delimiters) {
      delimiters = delimiters.split(' ');
      otag = delimiters[0];
      ctag = delimiters[1];
    }

    for (i = 0; i < len; i++) {
      if (state == IN_TEXT) {
        if (tagChange(otag, text, i)) {
          --i;
          addBuf();
          state = IN_TAG_TYPE;
        } else {
          if (text.charAt(i) == '\n') {
            filterLine(seenTag);
          } else {
            buf += text.charAt(i);
          }
        }
      } else if (state == IN_TAG_TYPE) {
        i += otag.length - 1;
        tag = tagTypes[text.charAt(i + 1)];
        tagType = tag ? text.charAt(i + 1) : '_v';
        if (tagType == '=') {
          i = changeDelimiters(text, i);
          state = IN_TEXT;
        } else {
          if (tag) {
            i++;
          }
          state = IN_TAG;
        }
        seenTag = i;
      } else {
        if (tagChange(ctag, text, i)) {
          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,
                       i: (tagType == '/') ? seenTag - ctag.length : i + otag.length});
          buf = '';
          i += ctag.length - 1;
          state = IN_TEXT;
          if (tagType == '{') {
            if (ctag == '}}') {
              i++;
            } else {
              cleanTripleStache(tokens[tokens.length - 1]);
            }
          }
        } else {
          buf += text.charAt(i);
        }
      }
    }

    filterLine(seenTag, true);

    return tokens;
  }

  function cleanTripleStache(token) {
    if (token.n.substr(token.n.length - 1) === '}') {
      token.n = token.n.substring(0, token.n.length - 1);
    }
  }

  function trim(s) {
    if (s.trim) {
      return s.trim();
    }

    return s.replace(/^\s*|\s*$/g, '');
  }

  function tagChange(tag, text, index) {
    if (text.charAt(index) != tag.charAt(0)) {
      return false;
    }

    for (var i = 1, l = tag.length; i < l; i++) {
      if (text.charAt(index + i) != tag.charAt(i)) {
        return false;
      }
    }

    return true;
  }

  function buildTree(tokens, kind, stack, customTags) {
    var instructions = [],
        opener = null,
        token = null;

    while (tokens.length > 0) {
      token = tokens.shift();
      if (token.tag == '#' || token.tag == '^' || isOpener(token, customTags)) {
        stack.push(token);
        token.nodes = buildTree(tokens, token.tag, stack, customTags);
        instructions.push(token);
      } else if (token.tag == '/') {
        if (stack.length === 0) {
          throw new Error('Closing tag without opener: /' + token.n);
        }
        opener = stack.pop();
        if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {
          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);
        }
        opener.end = token.i;
        return instructions;
      } else {
        instructions.push(token);
      }
    }

    if (stack.length > 0) {
      throw new Error('missing closing tag: ' + stack.pop().n);
    }

    return instructions;
  }

  function isOpener(token, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].o == token.n) {
        token.tag = '#';
        return true;
      }
    }
  }

  function isCloser(close, open, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].c == close && tags[i].o == open) {
        return true;
      }
    }
  }

  Hogan.generate = function (tree, text, options) {
    var code = 'var _=this;_.b(i=i||"");' + walk(tree) + 'return _.fl();';
    if (options.asString) {
      return 'function(c,p,i){' + code + ';}';
    }

    return new Hogan.Template(new Function('c', 'p', 'i', code), text, Hogan, options);
  }

  function esc(s) {
    return s.replace(rSlash, '\\\\')
            .replace(rQuot, '\\\"')
            .replace(rNewline, '\\n')
            .replace(rCr, '\\r');
  }

  function chooseMethod(s) {
    return (~s.indexOf('.')) ? 'd' : 'f';
  }

  function walk(tree) {
    var code = '';
    for (var i = 0, l = tree.length; i < l; i++) {
      var tag = tree[i].tag;
      if (tag == '#') {
        code += section(tree[i].nodes, tree[i].n, chooseMethod(tree[i].n),
                        tree[i].i, tree[i].end, tree[i].otag + " " + tree[i].ctag);
      } else if (tag == '^') {
        code += invertedSection(tree[i].nodes, tree[i].n,
                                chooseMethod(tree[i].n));
      } else if (tag == '<' || tag == '>') {
        code += partial(tree[i]);
      } else if (tag == '{' || tag == '&') {
        code += tripleStache(tree[i].n, chooseMethod(tree[i].n));
      } else if (tag == '\n') {
        code += text('"\\n"' + (tree.length-1 == i ? '' : ' + i'));
      } else if (tag == '_v') {
        code += variable(tree[i].n, chooseMethod(tree[i].n));
      } else if (tag === undefined) {
        code += text('"' + esc(tree[i]) + '"');
      }
    }
    return code;
  }

  function section(nodes, id, method, start, end, tags) {
    return 'if(_.s(_.' + method + '("' + esc(id) + '",c,p,1),' +
           'c,p,0,' + start + ',' + end + ',"' + tags + '")){' +
           '_.rs(c,p,' +
           'function(c,p,_){' +
           walk(nodes) +
           '});c.pop();}';
  }

  function invertedSection(nodes, id, method) {
    return 'if(!_.s(_.' + method + '("' + esc(id) + '",c,p,1),c,p,1,0,0,"")){' +
           walk(nodes) +
           '};';
  }

  function partial(tok) {
    return '_.b(_.rp("' +  esc(tok.n) + '",c,p,"' + (tok.indent || '') + '"));';
  }

  function tripleStache(id, method) {
    return '_.b(_.t(_.' + method + '("' + esc(id) + '",c,p,0)));';
  }

  function variable(id, method) {
    return '_.b(_.v(_.' + method + '("' + esc(id) + '",c,p,0)));';
  }

  function text(id) {
    return '_.b(' + id + ');';
  }

  Hogan.parse = function(tokens, text, options) {
    options = options || {};
    return buildTree(tokens, '', [], options.sectionTags || []);
  },

  Hogan.cache = {};

  Hogan.compile = function(text, options) {
    // options
    //
    // asString: false (default)
    //
    // sectionTags: [{o: '_foo', c: 'foo'}]
    // An array of object with o and c fields that indicate names for custom
    // section tags. The example above allows parsing of {{_foo}}{{/foo}}.
    //
    // delimiters: A string that overrides the default delimiters.
    // Example: "<% %>"
    //
    options = options || {};

    var key = text + '||' + !!options.asString;

    var t = this.cache[key];

    if (t) {
      return t;
    }

    t = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
    return this.cache[key] = t;
  };
})(typeof exports !== 'undefined' ? exports : Hogan);

if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
    define( "hogan", [], function () { return Hogan; } );
}

(function ($) {
	var enter2tabClass = "enter2tab",
		dataFlg = "enter2tab.data",
		stableSortKey = "enter2tabSortKey";
	
    $.fn.enter2tab = function(options){
    	return this.each(function(){
    		if(!$(this).hasClass(enter2tabClass)){
				options = $.extend(true, {}, {beforeFocus:null, onFocus:null}, options);
				$(this).addClass(enter2tabClass).data(dataFlg, options);
    		} else {
                var opts = $(this).data(dataFlg);
                options = $.extend(true, {}, opts, options);
                $(this).data(dataFlg, options);
            }
    	});
    }

	$.enter2tab = $.enter2tab || {};
	
	$.extend($.enter2tab, {
		enter : function(id, isPrev) {
			var self = $("#"+id),
				isPrev = !!isPrev;
				
			if(self[0]){
				_goAfter(self, isPrev);
			}
		},
		initFocus : function() {
			var list = _getKeyboardList(),
				initFocusEle = list[0];
			
			list.each(function(idx, v){
				if(v.tabIndex > 0){
					initFocusEle = v;
					return false;
				}
				return true;
			});
			
            if(initFocusEle && initFocusEle.tabIndex == 0 && $(initFocusEle).hasClass('ui-linkbutton')){
               list.each(function(idx, v){
                    if(!$(v).hasClass('ui-linkbutton')){
                        initFocusEle = v;
                        return false;
                    }
                    return true;
                }); 
            }
            
			if(initFocusEle){
				$(initFocusEle).focus();
                $(initFocusEle).select();
			}
		}
	});
 
	$("." + enter2tabClass).live("keydown", function(event){
		if(event.keyCode == 13 || event.keyCode == 9){
			var self = $(this);
			if((self.is("textarea") || self.is("table")) && !event.ctrlKey && !event.shiftKey && event.keyCode !== 9){
				return true;
			}
            if(self.is(".ui-linkbutton") && event.keyCode == 13){
                return true;
            }
		 	_goAfter(self, (event.shiftKey));
		 	return false;
		}
	});
	
	function _goAfter(self, isPrev){
		var isPrev = !!isPrev,
			after = _getAfter(self, isPrev);
	 	
	 	if(after){
	 		var options = after.data(dataFlg);
	 		if(!options.beforeFocus || options.beforeFocus.apply(this) !== false){
		 		after.focus();
		 		after.select();
                 var event = jQuery.Event("focus");
                 event.target = after;
		 		if(options.onFocus) options.onFocus.call(this,event);
	 		}
	 	}
	}
	
	function _getAfter(self, isPrev){
		isPrev = !!isPrev;
		var list = _getKeyboardList(),
			afterIdx = list.index(self),
			isRadio = self.is(":radio"),
			name = self.attr("name"),
			after;
			
		while(true){
			if(isPrev){
				afterIdx--;
				afterIdx = afterIdx >= 0 ? afterIdx : (list.length - 1);
			}else{
				afterIdx++;
				afterIdx = afterIdx > (list.length - 1) ? 0 : afterIdx;
			}
			
			after = list.eq(afterIdx);
			if(after[0] == self[0]){
				after = null;
				break;
			}
			if(isRadio && after.is(":radio") && name == after.attr("name")){
				continue;
			}
			break;
		}
		
		if(after && after.is(":radio")){
	 		var afterRadioName = after.attr("name"),
	 			afterCheckedRadio;
	 		if(afterRadioName){
	 			afterCheckedRadio = list.filter(':radio:checked[name="'+afterRadioName+'"]:eq(0)');
	 			after = afterCheckedRadio[0] ? afterCheckedRadio : after;
	 		}
	 	}
	 	return after;
	}
	
	function _getKeyboardList(){
		return $("." + enter2tabClass + ":visible:not(.ui-state-disabled):not(:disabled)").filter(function(idx){
			return this.tabIndex >= 0;	
		})
		.each(function(i, v){
			v[stableSortKey] = i;
		})
		.sort(function(a, b){
			if(a.tabIndex == b.tabIndex){
				return a[stableSortKey] - b[stableSortKey];
			}
			return a.tabIndex - b.tabIndex;
		});
	}
			
	function log(lg){
		if(console){
			console.log(lg);
		}
	}
})(jQuery);
//mod.defineModule("msgbox",["base","waf","button","dialog","msgbox_i18n"],function(){
    /*
     * Depends:
     *	jquery.ui.core.js
     *	jquery.ui.widget.js
     *  jquery.ui.button.js
     *	jquery.ui.draggable.js
     *	jquery.ui.mouse.js
     *	jquery.ui.position.js
     *	jquery.ui.resizable.js
     */
    (function( $, undefined ) {
        function makeOptions(type, opts, func) {
            var newopts = {
                'type': type
            };

            if(typeof opts === "string") {
                newopts.summaryMsg = opts;
                if(func && $.isFunction(func)) {
                    newopts.buttonCallBack = [];
                    newopts.buttonCallBack.push(func);
                }
            } else {
                $.extend(newopts, opts);
            }
            if(!newopts.position){
                //
                if(window.parent&&window.parent.jPortal){
                    newopts.position = $.extend({
                        my: 'center',
                        at: 'center',
                        collision: 'fit',
                        of: window.parent,
                        // ensure that the titlebar is never outside the document
                        using: function(pos) {
                            var topOffset = $(this).css(pos).offset().top;
                            if (topOffset < 0) {
                                $(this).css('top', pos.top - topOffset);
                            }
                            try{
                                var width = $(window.parent.document.body).find("iframe[src*='easweb']").width();
                                if(!$.isNaN(width)){
                                    $(this).css("left",Math.round((width-$(this).width())/2));
                                }
                            }catch(e){}
                        }
                    },newopts.position||{});
                }else if(top && top.jPortal){
                    var page = $("body").find(".page_margins");
                    if(page.length>0){
                        var wh = $(window).height();
                        var ph = $(page).height();
                        if(ph<wh){
                            newopts.position = $.extend({
                                my: 'center',
                                at: 'center',
                                collision: 'fit',
                                of: page
                            },newopts.position||{});
                        }
                    }
                }
            }
            return newopts;
        }

        $.msgBox = $.msgBox || {};
        $.extend($.msgBox, {
            showConfirm: function(opts, func) {
                var options = makeOptions("confirm", opts, func);
                return $.msgBox.util.initMsg(options);
            },
            showInfo: function(opts) {
                var options = makeOptions("info", opts);
                return $.msgBox.util.initMsg(options);
            },
            showWarning: function(opts) {
                var options = makeOptions("warning", opts);
                return $.msgBox.util.initMsg(options);
            },
            showError: function(opts) {
                var options = makeOptions("error", opts);
                return $.msgBox.util.initMsg(options);
            },
            showPrompt: function(opts, func) {
                var options = makeOptions("prompt", opts);
                return $.msgBox.util.initMsg(options);
            },
            close: function(curDialog) {
                if(curDialog) curDialog.dialog('close');
            }
        });
        $.msgBox.util = $.msgBox.util || {};
        $.extend($.msgBox.util,{
            createConfirmDiv:function(opts){
                var rootDiv = $('<div class="ui-msgbox"></div>');
                var imgClass="ui-" + opts.type;

                var contDiv = "<div class='" +imgClass+ "'><table><tr><td style='white-space:normal;'>";
                if(opts.icon){
                    contDiv +="<div class='" + opts.icon + " content'>";
                }else{
                    contDiv +="<div class='icon content'>";
                }
                contDiv+="<br>"+opts.summaryMsg+"<br><br></div>" +
                    "</td></tr></table></div>";
                rootDiv.append(contDiv);
                return rootDiv;
            },
            createPromptDiv:function(opts){
                var rootDiv = $('<div class="ui-msgbox"></div>');

                var contDiv = "<div class='ui-prompt'><table><tr><td style='white-space:normal;'>";
                if(opts.icon){
                    contDiv +="<div class='" + opts.icon + "' content>";
                }else{
                    contDiv +="<div class='content'><br>";
                }

                function modifyPromptHeightForIE6(opts){
                    var browser=navigator.appName
                    var b_version=navigator.appVersion
                    var version=b_version.split(";");
                    if(version.length>1){
                        var trim_Version=version[1].replace(/[ ]/g,"");
                        if(browser=="Microsoft Internet Explorer" && trim_Version=="MSIE6.0")
                        {
                            opts.height=70;
                        }
                    }
                }

                modifyPromptHeightForIE6(opts);

                contDiv+=opts.summaryMsg+"<br><br></div></td></tr>" +
                    "</table><input id='waf-messageBox-prompt-input' type='text'/><br></div>";

                rootDiv.append(contDiv)

                return rootDiv;
            },
            createDetailBtn:function(contentDiv,detailMsgCont){
                var btnDiv = $(contentDiv[0].parentNode).find(".ui-dialog-buttonpane");
                var innerBtn = "<div class='ui-dialog-buttonset' style='float:left'>" +
                    "<button type='button' class='ui-button ui-widget ui-state-default ui-corner-all msg_detailBtn ui-msg-button-text-only ' role='button' aria-disabled='false'>" +
                    "<span class='ui-msg-button-text'>" + $.msgbox.buttonText.detail + ">></span>" +
                    "</button></div>";
                btnDiv.append(innerBtn);

                var btnDetail = btnDiv.find("button.msg_detailBtn");
                btnDetail.hover(
                    function() {
                        btnDetail.addClass('ui-state-hover');
                    },
                    function() {
                        btnDetail.removeClass('ui-state-hover');
                    }
                )
                btnDetail.click(
                    //alert(btnDetail[0].id);
                    function() {
                        $.msgBox.util.detailBtnClickHandler(this);
                    }
                )

                var contDiv = "<div class='ui-msg-detail-content ui-content waf-widget-content msg_detailDiv' style='display:none;font-size:10pt;'>" + detailMsgCont + "</div>";
                $(contentDiv[0].parentNode).append(contDiv);
                if($("div.msg_detailDiv",contentDiv[0].parentNode).height()>300)
                    $("div.msg_detailDiv",contentDiv[0].parentNode).css("height","300px");
            },
            detailBtnClickHandler:function(e){
                if($("div.msg_detailDiv").css("display")=="none"){
                    //update by liyue ,ie8 is different from other
                    var ua = navigator.userAgent.toLowerCase();
                    var newHtml = $.msgbox.buttonText.detail + "<<<";
                    if(!ua.match(/msie ([\d.]+)/)){
                        newHtml = $.msgbox.buttonText.detail + "<<";  //if is not IE
                    }
                    $("button.msg_detailBtn .ui-msg-button-text").html(newHtml);
                }
                else
                    $("button.msg_detailBtn .ui-msg-button-text").html($.msgbox.buttonText.detail + ">>");
                $("div.msg_detailDiv").toggle("fast");
            },
            styleJqueryButton:function(contentDiv){
                var btnDiv = $(contentDiv[0].parentNode).find(".ui-button-text-only");
                btnDiv.removeClass("ui-button-text-only").addClass("ui-msg-button-text-only");
                var btnSpan = btnDiv.find(".ui-button-text");
                btnSpan.removeClass("ui-button-text").addClass("ui-msg-button-text");

                var btnDiv = $(contentDiv[0].parentNode).find(".ui-dialog-buttonpane");
                btnDiv.css('padding-right','0.1em');
                btnDiv.css('padding-bottom','0.1em');
            },
            modifyUserButtonHanlder:function(opts,rootDiv){
                var buttons=opts.buttons;
                $.each(buttons,function(n,value) {
                    var curBtn = value;
                    var curFunc = curBtn.click;
                    if(curFunc && $.isFunction(curFunc)){
                        curBtn.click = function(){
                            curFunc(rootDiv);
                            if(opts.autoBtnClose){
                                rootDiv.dialog('close');
                            }
                        }
                    }else{
                        if(opts.autoBtnClose){
                            curBtn.click = function(){
                                rootDiv.dialog('close');
                            }
                        }
                    }
                });
            },
            initMsg:function(opts){
                opts.modal=true;
                opts.resizable=false;
                if(!opts.title){
                    opts.title=$.msgbox.other.title;
                }
                if(opts.autoBtnClose==undefined){
                    opts.autoBtnClose=true;
                }
                if(opts.width && opts.width.indexOf("px") > 0){
                    opts.width = opts.width.substring(0, opts.width.length - 2);
                }
                if(opts.height && opts.height.indexOf("px") > 0){
                    opts.height = opts.height.substring(0, opts.height.length - 2);
                }
                if(opts.target){
                    rootDiv = opts.target;
                    if(opts.removeTarget!=undefined && opts.removeTarget){
                        opts.close=function(event, ui) {
                            opts.target.remove();
                        }
                    }
                    //opts.target = null;
                }else{
                    if(opts.type=="prompt"){
                        rootDiv = $.msgBox.util.createPromptDiv(opts);
                    }else{
                        rootDiv = $.msgBox.util.createConfirmDiv(opts);
                    }
                }

                if(!opts.buttons && !opts.buttonType){
                    if(opts.type=="confirm" || opts.type=="prompt")
                        opts.buttonType="ok-cancel";
                    else
                        opts.buttonType="ok";
                }

                if(opts.type=="prompt"){
                    opts.width=310;
                }



                rootDiv.dialog(opts);
                $.msgBox.util.initButtons(rootDiv,opts);

                $(rootDiv[0].parentNode).css('padding','0');

                //href='#'"javascript:void(null)"
                var newCtrl = '<a id="a_close" class="ui-dialog-titlebar-close ui-corner-all" href="javascript:void(null)">' +
                                '<span class="ui-icon ui-icon-closethick ">close</span></a>'
                newCtrl = waf(newCtrl);
                $(rootDiv[0].parentNode).find(".ui-dialog-titlebar-close").replaceWith(newCtrl[0]);
                newCtrl.click(rootDiv, function (event) {
                    event.data.dialog("close");
                });

                return rootDiv;
            },
            initButtons:function(rootDiv,opts){
                var buttonCallBacks = opts.buttonCallBack,
                    self = this;
                var okClickHandler,noClickHandler;
                if(!opts.autoBtnClose){
                    opts.autoBtnClose=false;
                }

                if(opts.type=="prompt"){
                    if(opts.autoBtnClose){
                        okClickHandler= function(){buttonCallBacks[0]($("#waf-messageBox-prompt-input").val(),rootDiv);rootDiv.dialog('close');}
                    }else{
                        okClickHandler= function(){buttonCallBacks[0]($("#waf-messageBox-prompt-input").val(),rootDiv);}
                    }
                }else{
                    if(opts.autoBtnClose){
                        okClickHandler= $.isFunction(buttonCallBacks && buttonCallBacks[0])?function(){rootDiv.dialog('close');buttonCallBacks[0](rootDiv);}:function(){rootDiv.dialog('close');}
                    }else{
                        okClickHandler= $.isFunction(buttonCallBacks && buttonCallBacks[0])?function(){buttonCallBacks[0](rootDiv);}:function(){rootDiv.dialog('close');}
                    }
                }
                if(opts.autoBtnClose){
                    noClickHandler= $.isFunction(buttonCallBacks && buttonCallBacks[1])?function(){rootDiv.dialog('close');buttonCallBacks[1](rootDiv);}:function(){rootDiv.dialog('close');}
                }else{
                    noClickHandler= $.isFunction(buttonCallBacks && buttonCallBacks[1])?function(){buttonCallBacks[1](rootDiv);}:function(){rootDiv.dialog('close');}
                }

                if(opts.buttons){
                    $.msgBox.util.modifyUserButtonHanlder(opts,rootDiv);
                    rootDiv.dialog( "option", "buttons",opts.buttons);
                }else if(opts.buttonType=="ok"){
                    rootDiv.dialog( "option", "buttons", [
                        {
                            text: $.msgbox.buttonText.ok,
                            click: okClickHandler
                        }
                    ] );
                }
                else if(opts.buttonType=="ok-cancel"){
                    rootDiv.dialog( "option", "buttons", [
                        {
                            text: $.msgbox.buttonText.ok,
                            click: okClickHandler
                        },{
                            text: $.msgbox.buttonText.cancel,
                            click: $.isFunction(buttonCallBacks && buttonCallBacks[1])?function(){rootDiv.dialog('close');buttonCallBacks[1]();}:function(){rootDiv.dialog('close');}
                        }
                    ] );
                }else if(opts.buttonType=="yes-no"){
                    rootDiv.dialog( "option", "buttons", [
                        {
                            text: $.msgbox.buttonText.yes,
                            click: okClickHandler
                        },{
                            text: $.msgbox.buttonText.no,
                            click: noClickHandler//$.isFunction(buttonCallBacks && buttonCallBacks[1])?function(){rootDiv.dialog('close');buttonCallBacks[1]();}:function(){rootDiv.dialog('close');}
                        }
                    ] );
                }else if(opts.buttonType=="yes-no-cancel"){
                    rootDiv.dialog( "option", "buttons", [
                        {
                            text: $.msgbox.buttonText.yes,
                            click: okClickHandler
                        },{
                            text: $.msgbox.buttonText.no,
                            click: noClickHandler//function(){rootDiv.dialog('close');buttonCallBacks[1]();}
                        },{
                            text: $.msgbox.buttonText.cancel,
                            click: $.isFunction(buttonCallBacks && buttonCallBacks[2])?function(){rootDiv.dialog('close');buttonCallBacks[2]();}:function(){rootDiv.dialog('close');}
                        }
                    ] );
                }
                if(!opts.target){
                    rootDiv.bind( "dialogclose", function(event, ui) {
                        rootDiv.remove();
                    });
                }

                rootDiv.dialog('open');
                if(opts.type == "prompt") {
                    var promptInput = rootDiv.find('#waf-messageBox-prompt-input');
                    if(promptInput.length) {
                        promptInput.focus();
                        promptInput.bind('keydown.msgbox', function(e) {
                            if($.ui.keyCode.ENTER == e.keyCode) {
                                if(okClickHandler) {
                                    okClickHandler.call(self);
                                }
                            }
                        });
                    }
                } else {
                    var btns = rootDiv.parent().find('.ui-dialog-buttonset').find('button');
                    if(btns && btns.length > 0) {
                        var firstBtn = waf(btns[0]);
                        firstBtn[0].focus();
                    }
                }

                if(opts.detailMsg!=null){
                    $.msgBox.util.createDetailBtn(rootDiv,opts.detailMsg);
                }
                $.msgBox.util.styleJqueryButton(rootDiv);
            }
        });


    }(jQuery));
//});
//mod.defineModule("form",["base","waf","validator"],function(){
    (function($, undefined) {
        $.wafForm = $.wafForm || {};
        $.widget("ui.wafForm", {
            options: {
                id: null,
                action: null,
                accept: null,
                acceptCharset: null,
                enctype: null,
                method: null,
                name: null,
                target: null,
                tagClass: null,
                validateOptions: null,
                style: null,
                hidden: false
            },
            _create: function() {
                var self = this;
                $(this.element).attr("ctrlrole", "form");
                this.options.initCreate = true;
                $(this.element).attr('data-domcreated', "true");
                $.each(this.options, function(key, value) {
                    self._setOption(key, value);
                });
            },
            destory: function() {
                this.element.removeClass(defaultClass);
                $.Widget.prototype.destroy.call(this);
            },

            widget: function() {
                return this.element;
            },

            _setOption: function(key, value) {
                var form = $(this.element);
                switch(key) {
                case "tagClass":
                    $(form).removeClass(this.options.tagClass).addClass(value);
                    break;
                case "hidden":
                    $(form).toggle(!value);
                    break;
                case "style":
                case "action":
                case "acceptCharset":
                case "enctype":
                case "method":
                case "accept":
                case "name":
                case "target":
                    $(form).attr(key, value);
                    break;
                case "validateOptions":
                    var create = this.options.initCreate;
                    if(create) {
                        if(value) {
                            $(form).attr("validateOptions", value);
                            var opts = {};
                            opts = eval('(' + value + ')');
                            opts.formId = this.options.id;
                            if(!opts.suspend && $(form).wafFormValidator != undefined) {
                                $(form).wafFormValidator(opts);
                            }
                        } else {
                            if($(form).wafFormValidator != undefined) {
                                $(form).wafFormValidator({
                                    'formId': $(form).attr("id")
                                });
                            }
                        }
                    } else {
                        $(form).attr("validateOptions", value);
                    }
                    break;
                }
                $.Widget.prototype._setOption.apply(this, arguments);
            },
            appendChildren: function(source, pos) {
                $.dynamicutil.appendChildren($(this.element), source, pos);
            },
            removeChildren: function(source) {
                //idsourcejquery
                if(typeof source == "string") {
                    if(source.substr(0, 1) != "#") {
                        source = "#" + source;
                    }
                    source = $(source, $(this.element));
                }
                $.dynamicutil.removeChildren($(this.element), source);
            }
        });

        /*
         * Form
         * 2012-11-13
         */
        $.extend($.wafForm, {
            createFormDOM: function(opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    var elem = $("<form id='"+opts.id+"' class='ui-form wform'></form>");
                    if (opts.modelId) {
                        var hidden = $("<input type='hidden' id='id' path='id' value='"+opts.modelId+"' />");
                        elem.append(hidden);
                    }
                    return elem;
                } else {
                    return obj;
                }
            },
            initForm: function(opts, el) {
                if(el && $(el).hasClass("ui-form")) {
                    $(el).wafForm(opts);
                }
            },
            removeForm: function(opts) {
                $("#" + opts.id).remove();
            },
            modifyForm: function(opts) {
                $("#" + opts.id).wafForm("option", opts);
            }
        });
        $(function() {
            if($.registerComponent) $.registerComponent("form", {
                createDOMFun: $.wafForm.createFormDOM,
                initFun: $.wafForm.initForm,
                deleteFun: $.wafForm.removeForm,
                modifyFun: $.wafForm.modifyForm,
                lazyInit:false
            });
        });
    }(jQuery));
//});
    /*
     * MsgArea
     */
//mod.defineModule("msgArea", ["base","waf"], function() {
    (function($, undefined) {

        var defaultClass = "ui-msgarea";

        

        $.widget("ui.wafMsgArea", {
            options : {
                id:null,
                tagClass:null,
                style:null,
                detailClass:null
            },
            _create:function(){
                this._createMsgArea();
            },
            _setOptions: function( options ) {
                var o = options;

                if(o.tagClass){
                   this.element.addClass(o.tagClass);
                }

                if(o.style){
                   this.element.attr("style",o.style);
                }


            },
            _createMsgArea:function(){
                var element = this.element,o=this.options;
                //idclass
                this._setOptions(o);

                var obj = o && o.id && $("#" + o.id);
                if (!obj.data("domcreated")) {
                    element.attr("id", o.id).addClass(defaultClass).attr("ctrlrole", "msgArea");
                    //
                    var buttonpanel = "<div class='buttonpanel cf'><div class='detail-box'></div><div class='close-box'></div></div>";
                    var contentpanel = "<div class='contentpanel cf'><div class='summaryMsg'></div></div><div class='detailMsg'></div>";
                    element.append(buttonpanel).append(contentpanel);
                    element.attr('data-domcreated', "true");
                }

                this._bindEvent();
                //msgArea
                this.element.css("display","none");
                //documentclickmsgareaopenMsgDetail
                $(document).click(function(){
                    $(element).removeClass("openMsgDetail");
                })
            },
            _bindEvent:function(){
                //
                var self = this;
                this.element.find(".close-box").unbind("click");
                this.element.find(".close-box").bind("click",function(){
                    $("#waf_msg_detail_"+self.options.id).css("display","none");
                    $(this).parent().parent().css("display","none");
                });

                var elem = this;
                this.element.find(".detail-box").unbind("click");
                this.element.find(".detail-box").bind("click",function(e){
                    var parent = $(this).parent().parent();
                    elem._detailMsgClickHandler($(parent).find(".detailMsg"),$(parent).attr("id"));
                    e.preventDefault();
                    e.stopPropagation();
                });

                $(document).click(function (event) {
                        if (!$(event.target).closest(".ui-msgarea").length) {
                            var detailDiv = $("#waf_msg_detail_" + elem.element.attr("id"));
                            detailDiv.hide();
                        }
                    }
                );
            },
            _detailMsgClickHandler:function(detail,id){
                var detailDiv = $("#waf_msg_detail_" + id);
                var msgDiv = $("#"+id);
                if(detailDiv.is(":hidden")){
                    msgDiv.addClass("openMsgDetail");
                }else{
                    msgDiv.removeClass("openMsgDetail");
                }
                if(detailDiv.length!=0){
                    detailDiv.toggle(200);
                }else{
                    detailDiv = $("<div id='waf_msg_detail_" + id + "' class='waf-msg-content-detail'>" + detail.html() + "</div>")
                    if(this.options.detailClass){
                        detailDiv.addClass(this.options.detailClass);
                    }
                    detailDiv.appendTo($(".page_margins .page")[0] ||'body');
                    if(detailDiv.height()>300){
                        detailDiv.css("height","300px");
                    }

                    detailDiv.css("width",msgDiv.width()+"px");
                    detailDiv.position({
                        of: msgDiv,
                        my: "left top",
                        at: "left bottom",
                        offset: "0 0",
                        collision: "none none"
                    });
                    msgDiv.addClass("openMsgDetail");
                }
                detailDiv.click(function(){return false;});
            },
            show:function(opts){
                this.init();
                if(opts.detailMsg){
                    this.element.find(".detailMsg").append(opts.detailMsg);
                    this.element.find(".detail-box").css("display","inline-block");
                    var detailDiv = $("#waf_msg_detail_" + this.element.attr("id"));
                    detailDiv.html(opts.detailMsg);
                }
                if(opts.summaryMsg){
                    var infoclass = "msg-info";
                    if(opts.iconClass){
                        infoclass = opts.iconClass;
                    }else{
                        if(opts.type==="info"){
                            infoclass = "msg-info";
                        }else if(opts.type==="warning"){
                            infoclass = "msg-warning";
                        }else if(opts.type==="error"){
                            infoclass = "msg-error";
                        }
                    }
                    this.element.find(".summaryMsg").append("<span class='content "+infoclass+"'>"+opts.summaryMsg+"</span>");
                }
                this.element.css("display","block");
    //            this.element.children().show();

                if(opts.closeDetailTime && opts.closeDetailTime>0){
                    this._autoHideMsgArea(this.element.attr("id"),opts.closeDetailTime);
                }
            },
            init:function(){
                this.element.find(".detailMsg").css("display","none");
                this.element.find(".detail-box").css("display","none");

                this.element.find(".detailMsg").html("");
                this.element.find(".summaryMsg").html("");
            },
            _autoHideMsgArea:function(elem,delayTime){
                var delay = 1000;
                timer = setTimeout('$.msgArea.hideMsgArea("' + elem + '")', delay * delayTime);
            }
        });


        $.msgArea = $.msgArea || {};
        $.extend($.msgArea,{
            hideMsgArea:function(elem){
               $("#" + elem).css("display","none").fadeOut(1000);
                var detailDiv = $("#waf_msg_detail_" + elem);
                detailDiv.hide();

            }
        });


        $.wafMsgArea=$.wafMsgArea || {};

    $.extend($.wafMsgArea, {
            createMsgAreaDOM:function (opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    return $("<div id='" + opts.id + "'></div>");
                } else {
                    return obj;
                }
            },
            initMsgArea:function (opts, el) {
                return el.wafMsgArea(opts);
            },
            removeMsgArea:function (opts) {

            },
            modifyMsgArea:function (opts) {

            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("msgArea", {createDOMFun:$.wafMsgArea.createMsgAreaDOM, initFun:$.wafMsgArea.initMsgArea,
                    modifyFun:$.wafMsgArea.modifyMsgArea,lazyInit:true});
        });
    }(jQuery));
//});
//mod.defineModule("text", ["base", "waf"], function () {
    /*
     * author: Zhang Yanfang
     * date: 2012-2-3
     * log:
     * 2012-12-13 17:54:28
     * 1valuejsreset
     * 2autocompletevaluejsonupdategetValuesetValue
     */

    (function ($, undefined) {

        $.wafText = $.wafText || {};
        $.widget("ui.wafText", $.ui.wafctrl, {
            options:{
                disabled:false,
                height:null,
                hidden:false,
                maxlength:null,
                onblur:null,
                onchange:null,
                onclick:null,
                ondblclick:null,
                onfocus:null,
                onkeydown:null,
                onkeypress:null,
                onkeyup:null,
                onmousedown:null,
                onmousemove:null,
                onmouseout:null,
                onmouseover:null,
                onmouseup:null,
                onselect:null,
                readonly:false,
                style:null,
                tabindex:0,
                tagClass:null,
                value:null,
                width:null
            },
            _create:function () {
                $.ui.wafctrl.prototype._create.apply(this, arguments);

                var self = this,
                    text = this.element,
                    o = this.options;
                //
                self.widgetEventPrefix = "";
                this._enter2tab();

                if (!text.data("domcreated")) {
                    text.attr("ctrlrole", "text").addClass("ui-text");
                    text.attr('data-domcreated', "true");
                }

                this.dataFlag = "data.wafText";
                this.initFlag = true;

                this._initByOptions("disabled", "readonly", "style", "tagClass", "maxlength", "tabindex",
                    "width", "height", "hidden", "onblur", "onchange", "onclick", "ondblclick", "onfocus",
                    "onkeydown", "onkeypress", "onkeyup", "onmousedown", "onmousemove", "onmouseout",
                    "onmouseover", "onmouseup", "onselect", "value");

                text.bind("focus.wafText",
                    function () {
                        var packedValue = null;
                        if (o["hasAutoComplete"] === true) {
                            packedValue = {label:text.val(), value:$("#" + text[0].id + "_el").val()};
                        } else {
                            packedValue = text.val();
                        }
                        text.data(self.dataFlag, packedValue);
                    });
                if (o["hasAutoComplete"] !== true) {
                    text.bind("change.wafText", function () {
                        var oldValue = text.data(self.dataFlag),
                            value = text.val();
                        self._update(oldValue, value);
                    });
                }

                // formreset, .
                $(text[0].form).bind('reset.wafText', function () {
                    setTimeout($.proxy(self._reset, self), 10);
                });
                //
                this.setDefaultValue(o.value);
                //
                this._operateState();
            },
            _reset:function () {
                var el = this.element, ctrlrole = el.attr("ctrlrole");
                if (ctrlrole == "text") {
                    el.val(this.defaultValue);
                    this._setDisplayValue(this.defaultValue);
                    $("#" + el[0].id + "_el").val(this.defaultValue);
                } else {
                    el.val(this.defaultValue.label);
                    this._setDisplayValue(this.defaultValue.label);
                    $("#" + el[0].id + "_el").val(this.defaultValue.value);
                }
            },
            setDefaultValue:function (value) {
                this.defaultValue = value;
            },
            _setOption:function (key, value) {
                if (value === undefined) {
                    return;
                }
                var text = this.element, o = this.options;
                if (key == "value") {
                    var oldValue = text.val();
                    text.data(this.dataFlag, oldValue);
                    this._update(oldValue, value);
                } else if (key.substring(0, 2) == "on" && key != "onchange") {
                    var name = key.substring(2, key.length);
                    text.handleFunction(name + ".wafText", value);
                } else if (key == "tagClass") {
                    text.removeClass(this.options.tagClass).addClass(value);
                } else if (key == "height") {
                    text.height(value);
                } else if (key == "width") {
                    text.width(value);
                } else if (key == "disabled") {
                    text.attr(key, value);
                    this.widget()
                        [ value ? "addClass" : "removeClass"](
                        this.widgetBaseClass + "-disabled" + " " +
                            "ui-state-disabled")
                        .attr("aria-disabled", value);
                } else if (key == "readonly") {
                    text.attr(key, value);
                    this.widget()
                        [ value ? "addClass" : "removeClass"](
                        "ui-state-readonly");
                } else if (key == "hidden") {
                    text[value ? "hide" : "show"]();
                } else if (key != "onchange") {
                    text.attr(key, value);
                }
                this.options[ key ] = value;
                return this;
            },
            getValue:function () {
                var el = this.element,
                    ctrlrole = el.attr("ctrlrole");
                if (ctrlrole == "text") {
                    return el.val();
                } else {
                    var hidden = $("#" + el[0].id + "_el");
                    return {label:el.val(), value:hidden.val()};
                }

            },
            setValue:function (value) {
                var oldValue = this.getValue(), el = this.element;
                el.data(this.dataFlag, oldValue);
                var ctrlrole = el.attr("ctrlrole");
                if (ctrlrole !== "text" && !$.type.isJson(value)) {
                    value = {label:value, value:value};
                }
                this._update(oldValue, value);
            },
            _enter2tab:function () {
                if ($.fn.enter2tab) {
                    this.element.enter2tab();
                }
            },
            _update:function (oldValue, value) {
                var el = this.element, hidden = $("#" + el[0].id + "_el");
                if (this.initFlag) {
                    this.initFlag = false;
                } else {
                    var equalFlag = false;
                    if (this.options["hasAutoComplete"] === true) {
                        equalFlag = (oldValue.label === value.label);
                    } else {
                        equalFlag = (oldValue === value);
                    }
                    if (!equalFlag && !this._trigger("onchange", "onchange", {"previous":oldValue, "current":value})) {
                        value = oldValue;
                    }
                }
                if (this.options["hasAutoComplete"] === true) {
                    el.val(value.label.toString());
                    this._setDisplayValue(value.label.toString());
                    hidden.val(value.value);
                } else {
                    el.val(value);
                    this._setDisplayValue(value);
                    hidden.val(value);
                }
            },
            _viewDisable:function (isDisable) {
                $.ui.wafctrl.prototype._viewDisable.apply(this, arguments);
                this.element.attr('disabled', isDisable);
            }
        });

        /*
         * Text
         * author:Zhang yanfang
         * 2012-11-13
         */
        $.extend($.wafText, {
            createTextDOM:function (opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                var doms = [];
                if (!(obj && obj.data("domcreated"))) {
                    var text = $("<input type='text' name='" + opts.name + "_el' id='" + opts.id + "' >"),
                        hidden = $("<input type='hidden' class='text-hidden' name='" + opts.name + "' id='" + opts.id + "_el'>"),
                        label = $("<label class='viewStatus' id='" + opts.id + "_view'></label>");
                    doms.push(text, hidden, label);
                    return doms;
                } else {
                    return obj;
                }
            },
            initText:function (opts, el) {
                el=$.isArray(el)?el[0]:el;
                opts.displayField = "#" + opts.id + "_view";
                $(el).wafText(opts);
//                if (el && opts && el.length > 0) {
                    /*var value = opts.value;   //
                     var inputValue = "", hiddenValue = "";
                     if ($.type.isJson(value)) {
                     inputValue = value.alias || value.label;
                     hiddenValue = value.value;
                     } else {
                     inputValue = value;
                     hiddenValue = value;
                     }
                     //hasAutoComplete
                     if (opts["hasAutoComplete"] === true) {
                     opts.value = {label:inputValue, value:hiddenValue};
                     } else {
                     opts.value = hiddenValue;
                     }*/
//                    el[1].addClass("text-hidden");
                    //idname
                    /*var temp = {
                     id:opts.id,
                     name:opts.name
                     };
                     delete opts.id;
                     delete opts.name;*/

//                    $.extend(opts, temp);
//                    return el[0];
//                }
            },
            removeText:function (opts) {
                var text = $("#" + opts.id),
                    hidden = $("#" + opts.id + "_el");
                text.remove();
                if (hidden.length > 0) {
                    hidden.remove();
                }


            },
            modifyText:function (opts) {
                var text = $("#" + opts.id),
                    temp = {
                        id:opts.id,
                        name:opts.name,
                        value:opts.value
                    };
                delete opts.id;
                delete opts.name;
                delete opts.value;
                text.wafText("option", opts);
                text.wafText("setValue", temp.value);
                $.extend(opts, temp);
                return text;
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("text", {createDOMFun:$.wafText.createTextDOM, initFun:$.wafText.initText,
                    deleteFun:$.wafText.removeText, modifyFun:$.wafText.modifyText,lazyInit:true});
        });
    }(jQuery));
//});

//mod.defineModule("password", ["base","waf"], function() {
    /*
     * author: Zhang Yanfang
     * date: 2012-2-3
     */

    (function($, undefined) {
        $.wafPassword = {};
        $.widget("ui.wafPassword", {
            options : {
                value:'',
                disabled:false,
                readonly:false,
                width:null,
                height:null,
                maxlength:null,
                style:null,
                tagClass:'',
                tabindex:0,
                ctrlrole:'',
                onclick:null,
                onchange:null,
                onblur:null,
                ondblclick:null,
                onfocus:null,
                onselect:null,
                onkeyup:null,
                onkeypress:null,
                onkeydown:null,
                onmouseover:null,
                onmouseup:null,
                onmouseout:null,
                onmousemove:null,
                onmousedown:null,
                hidden:false
            },
            _create:function() {
                var self = this,password = this.element,o = this.options;
                this._enter2tab();
                this.options.ctrlrole = "password";
                $.each(this.options, function (key, value) {
                    self._setOption(key, value);
                });
                password.attr("style", o.style);
                password.height(o.height);
                password.width(o.width);
            },
            _setOption: function(key, value) {
                var password = this.element,
                        o = this.options;

                if (key.substring(0, 2) == "on") {
                    var name = key.substring(2, key.length);
                    password.handleFunction(name + ".wafPassword", value);
                } else if (key == "tagClass") {
                    password.removeClass(o.tagClass).addClass(value);
                } else if (key == "height" || key == "width") {
                    password.css(key, value);
                } else if (key == "hidden") {
                    password.toggle(!value);
                }
                else {
                    password.attr(key, value);
                }
                if (key == "disabled") {
                    this.widget()
                            [ o.disabled ? "addClass" : "removeClass"](
                            this.widgetBaseClass + "-disabled" + " " +
                            "ui-state-disabled")
                            .attr("aria-disabled", o.disabled);
                }
                if (key == "readonly") {
                    this.widget()
                            [ o.readonly ? "addClass" : "removeClass"](
                            "ui-state-readonly");
                }

                this.options[key] = value;
                return this;
            },
            _enter2tab:function() {
                if ($.fn.enter2tab) {
                    this.element.enter2tab();
                }
            }
        });
    }(jQuery));
//});
//mod.defineModule("labelContainer",["base","waf"],function(){
    ;(function($, undefined) {
        var requiredSpanWidth = 0;
        $.widget("ui.labelContainer", {
            options : {
                id : null,
                labelPosition : "left",
                tip : null,
                width : null,
                labelWidth : null,
                labelAlign : "left",
                style : null,
                tagClass : null,
                caption : null,
                hidden:false
            },
            _create:function(){
                var self = this;
                //labelContainer,
                this.userinput = $(this.element).find("span[class='userinput']");
                this.label = $("#" +this.options.id+ "_label");
                self._labelContainerInit(self.options);
            },
            append:function(el){
                this.appendChildren(el);
            },
            appendChildren:function(el){
                waf.appendDOM(this.userinput, el);
            },
            removeChildren:function(source){                
                $.dynamicutil.removeChildren(this.userinput,source);
            },
            destory:function(){
                this.element.removeClass("ui-lablecontainer");
                this.userinput.remove();
                this.label.remove();
                $.Widget.prototype.destroy.call( this );
            },
            widget:function(){
                return this.element;
            },
            getInnerContainer:function(){
                return this.userinput;
            },
            _setOption: function( key, value ) {
                var labelContainer = this.element, o = this.options;
                switch(key){
                    case "tagClass":
                        value&&labelContainer.removeClass(o.tagClass).addClass(value);
                        break;
                    case "style":
                        value&&labelContainer.attr("style",value);
                        break;
                    case "width":
                        value&&labelContainer.width(value);
                        break;
                    case "labelWidth":
                        if(value&&!$.wafutil.isViewOperateState()){
                            this.label.css('width',value);
                        }
                        break;
                    case "labelAlign":
                        if(value&&!$.wafutil.isViewOperateState()){
                            this.label.addClass(value+"align");
                        }
                        break;
                    case "tip":
                        var imgID=$("#"+o.id + "_img");
                        if(value){
                            imgID.powerFloat&&$(imgID).powerFloat({
                                targetMode: "remind",
                                position:'3-2',
                                offsets:{x:20,y:0},
                                reverseSharp:false,
                                target:value
                            });
                        }else{
                            imgID.css('display','none');
                        }
                        break;
                    case "labelPosition":
                        value && labelContainer.attr(key,value);
                        if(value && value=='top'){
                            this.label.css('display','block').removeClass("leftPosition");
                        }else{
                            this.label.addClass("leftPosition");
                            if(o.labelWidth && o.labelWidth!=null&&!$.wafutil.isViewOperateState()){
                                var width = this.element.find(".requiredspan").width();
                                if(o.labelAlign=="left"){
                                    this.element.find(".inner-label").css("width",(parseFloat(o.labelWidth)-width));
                                }
                            }
                        }
                        break;
                    case "hidden":
                        labelContainer[value? 'hide' : 'show']();
                        break;
                    case "caption":
                        value && this.label.find('span.inner-label').html(value);
                        break;
                }
            },
            _labelContainerInit:function(curJson){
                var labelContainer = this.element, self = this;
                if(curJson!=null){
                    $.each(curJson, function (key, value) {
                        self._setOption(key, value);
                    });
                    this.initRequiredMask();
                    var realCtrl = $("#" +curJson.id).find("textarea");
                    if(realCtrl.size()>0){
                        this.label.css('vertical-align','top');
                    }
                    if($.wafutil.isViewOperateState(curJson)){
                        this.label.addClass("viewlabel");
                        this.userinput.addClass("viewvalue");
                        labelContainer.addClass("cf");
                    }else{
                        this.label.removeClass("viewlabel");
                        this.userinput.removeClass("viewvalue");
                        labelContainer.removeClass("cf");
                    }
                    labelContainer.attr("data-domcreated","true");
                }
            },
            removeRequiredMask:function(){
                var lcId = this.element[0].id;
                this.label.find('span[role=required]').remove();
                var labelPosition = this.element.attr("labelPosition");
                if(labelPosition!='top'){
                    var marginLeft = this.label.find('span.inner-label').css("margin-left");
                    if(marginLeft && marginLeft=='0px')
                        this.label.find('span.inner-label').css("margin-left",requiredSpanWidth);
                }
            },
            initRequiredMask:function(){
                var lcId = this.element[0].id;
                var elements = this.userinput.find("input, select, textarea,label")
                        .not(":submit, :reset, :image, [disabled]");
                if(elements.length==0) return;
                var element;
                if(elements.length==1) element=$(elements[0]);
                else{
                    waf.each(elements,function(index,elem){
                        if(waf(elem).attr("validate")){
                            element = waf(elem);
                            return false;
                        }else if(waf(elem).css('display')!='none' && waf(elem).attr('type')!='hidden'){
                            element = waf(elem);
                        }else if(elem.nodeName=='SELECT'){
                            element = waf(elem);
                        }else if(elem.nodeName=='LABEL'){
                            element = waf(elem);
                        }
                    });
                }

                if(!element){
                    return;
                }

                var labelPosition = this.element.attr("labelPosition");
                if(element.attr("validate")){
                    if(element.attr("validate").indexOf('required:true')<0){
                        if(labelPosition=='top')
                            this.label.find('span[role=required]').width(0);
                    }else{
                        if(element.attr("suspend") && element.attr("suspend")=='true'){
                            if(labelPosition=='top')
                                this.label.find('span[role=required]').width(0);
                        }else{
                            this.label.find('span[role=required]')[0].innerText = '*';
                        }
                    }
                }else{
                    if(labelPosition=='top')
                        this.label.find('span[role=required]').width(0);
                }
            }
        });

        $.fn.wafLabelContainer = $.fn.labelContainer;
        $.wafLabelContainer = $.wafLabelContainer || {};
        $.extend($.wafLabelContainer,{
           createLabelContainerDOM:function(data){
                var obj = data && data.id && $("#" + data.id);
                if (!(obj && obj.data("domcreated"))) {
                    var divLc = $("<div id='" + data.id + "' class='ui-lablecontainer' ctrlrole='labelContainer'></div>");
                    var curLabel = $("<label id='" + data.id + "_label' class='label' role='label'></label>");
                    curLabel.appendTo(divLc);

                    var requiredSpan = $("<span role='required' class='requiredspan requiredDisplay'></span>");
                    requiredSpan.appendTo(curLabel);

                    var labelSpan = $("<span role='label' class='inner-label'>" + data.caption + "</span>");
                    labelSpan.appendTo(curLabel);

                    var ctrlSpan =$("<span id='" + data.id + "_ctrl' class='userinput' role='lc-userinput'></span>");
                    ctrlSpan.appendTo(divLc);

                    var imgSpan = $("<span id='" + data.id + "_img' class='help'>&nbsp;</span>");
                    imgSpan.appendTo(divLc);

                    if($.wafutil.isViewOperateState(data)){
                        divLc.addClass("viewStatus");
                    }

                    return divLc;
                }else{
                    return obj;
                }

           },
           initLabelContainer:function(options,el){
                el=$.isArray(el)?el[0]:el;
                return el.wafLabelContainer(options);
           }

        });
        $(function(){
            if($.registerComponent)
                $.registerComponent("labelContainer",{createDOMFun:$.wafLabelContainer.createLabelContainerDOM,initFun:$.wafLabelContainer.initLabelContainer,lazyInit:true});
        });
    }(jQuery));
//});
//mod.defineModule("numberField", ["base","waf","boxUtil"], function() {
    /*******************************************************************************
     * number field
     *
     * @version 1.0
     * @author peng_zhou1
     * @Depends:
     *         jquery.ui.core.js
     *         jquery.ui.widget.js
     ******************************************************************************/
    (function($) {

        var defaultClass = "ui-numberfield ui-widget",
                disabledStateClass = "ui-state-disabled",
                dataFlg = "data.numberfield",
                POINT = ".",
                defaultFormat = {
                    number : {
                        pattern : [ "-n", "n" ]
                    },
                    percent : {
                        pattern : [ "-n %", "n %" ]
                    },
                    thousandth : {
                        pattern : [ "-n %", "n %" ]
                    },
                    currency : {
                        pattern : [ "$ -n", "$ n" ]
                    }
                };

        //input
        function caret(element, position) {
            var range, isPosition = position !== undefined;

            if (document.selection) {
                //ie
                element.focus();
                var range = document.selection.createRange();
                if (isPosition) {
                    range.move("character", position);
                    range.select();
                } else {
                    var rangeElement = element.createTextRange(), rangeDuplicated = rangeElement
                            .duplicate();
                    rangeElement.moveToBookmark(range.getBookmark());
                    rangeDuplicated.setEndPoint('EndToStart', rangeElement);

                    position = rangeDuplicated.text.length;

                }
            } else if (element.selectionStart !== undefined) {
                //
                if (isPosition) {
                    element.focus();
                    element.setSelectionRange(position, position);
                } else {
                    position = element.selectionStart;
                }
            }

            return position;
        }

        //
        var defaultOptions = {
            allowGroup: false,
            allowNegative: true,
            decimalPrecision: 2,
            groupSize: 3,
            min: null,
            max: null,
            formatType: "number",
            value: null,
            onchange: null,
            currencySymbol: "",
            percentSymbol: "%",
            thousandthSymbol: "",
            groupSymbol: ",",
            tagClass: null,
            submitField: null,
            dataType: "bigdecimal",
            roundType: "round",
            width: null,
            height: null,
            readonly: null,
            style: null,
            tabindex: 0,
            maxlength: null,
            hidden: false,
            onlyPrecision: false,
            onclick: null,
            onblur: null,
            ondblclick: null,
            onfocus: null,
            onselect: null,
            onkeyup: null,
            onkeypress: null,
            onkeydown: null,
            onmouseover: null,
            onmouseup: null,
            onmouseout: null,
            onmousemove: null,
            onmousedown: null
        };

        $.widget("ui.wafNumberField", $.ui.wafctrl, {
            options : defaultOptions,
            allowDecimals : true,
            format : null,
            handleFunctions: ["onclick", "onblur", "ondblclick", "onfocus", "onselect",
                "onkeyup", "onkeypress", "onkeydown", "onmouseover", "onmouseup",
                "onmouseout", "onmousemove", "onmousedown"],
            _create : function() {
                $.ui.wafctrl.prototype._create.apply(this, arguments);
                var self = this,
                        suppressBlur;

                this._enter2tab();

                this.options.submitField = this.options.submitField || ("#" + this.options.id + "_el");

                if (!this.element.data("domcreated")) {
                    this.element.addClass(defaultClass).attr("ctrlrole", "numberField");
                    this.element.attr('data-domcreated', "true");
                }

                this.allowDecimals = this.options.dataType === "bigdecimal" ? true : false;
                this._initByOptions("disabled", "readonly", "style", "tagClass", "tabindex", "width", "height", "maxlength", "hidden");

                $.each(this.handleFunctions, function(i, v) {
                    self.element.handleFunction(v.substr(2) + ".wafNumberFieldInner", self.options[v]);
                });

                this._update(this._getDisplayValue(this.options.value), {nochange: true});

                this.element.bind("focus.wafNumberField", function() {
                    suppressBlur = false;
                    var realValue = self.element.data(dataFlg);
                    self.element.val(self._getDisplayValue(realValue));
                    window.setTimeout(function() {
                        self.element[0].select();
                    }, 0);
                }).bind("blur.wafNumberField", function() {
                    if (!suppressBlur) {
                        self._update(this.value);
                    }
                    suppressBlur = true;
                }).bind("keydown.wafNumberField", function(e) {
                    if (self._prevent(e.which, e.ctrlKey)) {
                        e.preventDefault();
                    }
                    if (e.which == $.ui.keyCode.ENTER) {
                        //
                        self._update(this.value, {isNotFormat: true});
                    }
                });

                this.defaultValue = this.options.value;
                // formreset, .
                $(this.element[0].form).bind('reset.wafNumberField', function() {
                    setTimeout($.proxy(self._reset, self), 10);
                });
                this._operateState();

            },

            _enter2tab:function() {
                if ($.fn.enter2tab) {
                    this.element.enter2tab();
                }
            },

            _setMaxlength : function(add) {
                add ? this.element.attr('maxlength', this.options.maxlength) : this.element.attr('maxlength', null);
            },

            _reset : function() {
                var parseValue = this._getDefaultValue();
                this.element.data(dataFlg, parseValue);
                this._updateSubmitField();
                this.element.val($.wafNumberField.format(parseValue, this.options));
            },

            _getDefaultValue : function() {
                return this._adjust(this._getRealValue(this._round(this._getDisplayValue(this._parse(this.defaultValue)))));
            },

            _setOption : function(key, value) {
                var oldTagClass = this.options.tagClass;

                $.Widget.prototype._setOption.apply(this, arguments);
                if (key === "disabled" || key === "readonly" || key === "style" || key === "tabindex") {
                    this.element.attr(key, value);
                } else if (key === "width" || key === "height") {
                    this.element.css(key, value ? value : '');
                } else if (key === "tagClass") {
                    this.element.removeClass(oldTagClass).addClass(value);
                } else if (key === "currencySymbol" || key === "allowGroup" || key === "allowNegative" ||
                           key === "dataType" || key === "decimalPrecision" || key === "formatType" ||
                           key === "max" || key === "min") {
                    if (key === "dataType") {
                        this.allowDecimals = this.options.dataType === "bigdecimal" ? true : false;
                    }
                    this._refresh();
                } else if (key === "maxlength") {
                    this._setMaxlength(value !== null);
                } else if (key === "hidden") {
                    this.element[value ? "hide" : "show"]();
                } else if ($.inArray(key, this.handleFunctions) > -1) {
                    this.element.handleFunction(key.substr(2) + ".wafNumberFieldInner", value);
                } else if (key === "value") {
                    this.setValue(value);
                }
            },
            _prevent : function(key, isCtrlkey) {
                var self = this,
                        prevent = true,
                        min = self.options.min,
                        element = self.element[0],
                        value = element.value,
                        separator = ".",
                        idx = caret(element);

                if (isCtrlkey && (key === 67 || key === 86 || key === 88)) {
                    //copy paster
                    prevent = false;
                } else if ((key > 47 && key < 58) || (key > 95 && key < 106)) {
                    //47-5895-106,
                    if (!(this.options.onlyPrecision && value.indexOf(".") >= 0 && idx > value.indexOf(".") && ((value.length - value.indexOf(".") - 1) == this.options.decimalPrecision))) {
                        prevent = false;
                    }
                } else if ((key > 16 && key < 21)
                        || (key > 32 && key < 37)
                        || key == 45 /* INSERT */
                        || key == 46 /* DELETE */
                        || key == $.ui.keyCode.LEFT
                        || key == $.ui.keyCode.RIGHT
                        || key == $.ui.keyCode.TAB
                        || key == $.ui.keyCode.BACKSPACE
                        || key == $.ui.keyCode.ENTER) {
                    prevent = false;
                } else if (this.allowDecimals && (190 == key || 110 == key) && value.indexOf(separator) == -1) {
                    //
                    prevent = false;
                } else if (this.options.allowNegative && (min === null || min < 0) && value.indexOf("-") == -1 &&
                           this._isNegativeInput(key) && idx == 0) { // sign
                    prevent = false;
                }

                return prevent;
            },
            _isNegativeInput: function(key) {
                //keyCodekey
                var browser = $.boxLayoutUtil.userBrowser();
                if ('firefox' == browser) {
                    return key == 173 || key == 109;
                } else if ('opera' == browser) {
                    return key == 109 || key == 45;
                } else {
                    return key == 189 || key == 109;
                }
            },
            _parse : function(value) {
                if (this._isEmpty(value)) {
                    return null;
                }
                if (typeof value !== "number") {
                    value = parseFloat(value);
                }
                return isNaN(value) ? null : value;
            },
            _isEmpty : function(value) {
                return value == null || value == undefined || value === "";
            },
            _adjust : function(value) {
                //
                if (value == null) return value;
                var min = this._round(this.options.min),
                        max = this._round(this.options.max);

                if (!this.options.allowNegative && value < 0) {
                    value = 0;
                } else if (min !== null && value < min) {
                    value = min;
                } else if (max !== null && value > max) {
                    value = max;
                }
                return value;
            },
            _updateSubmitField : function() {
                if (this.options.submitField) {
                    $(this.options.submitField).val(this.element.data(dataFlg));
                }
            },

            _update: function(value, prop) {
                var self = this,
                        displayValue = this._round(this._parse(value)),
                        realValue = this._getRealValue(displayValue),
                        parseValue = this._adjust(realValue),
                        oldValue = this.element.data(dataFlg),
                        nochange = prop != null ? prop.nochange : false,
                        isNotFormat = prop != null ? prop.isNotFormat : false,
                        setValue = function(val) {
                            self.element.data(dataFlg, val);
                            self._updateSubmitField();

                            var formatedValue = $.wafNumberField.format(val, self.options);
                            self.element.val(isNotFormat ? self._getDisplayValue(val) : formatedValue);
                            self._setDisplayValue(formatedValue);
                        };

                setValue(parseValue);
                if (!nochange && oldValue != parseValue && !this._trigger("onchange", "onchange", {
                    "previous": oldValue,
                    "current": parseValue
                })) {
                    setValue(oldValue);
                }

                if (!nochange) {
                    this.element.trigger('change');
                }
            },

            _round : function(value) {
                //
                if (value == null) return value;
                if (this.allowDecimals && this.options.decimalPrecision != 0) {
                    var precision = this.options.decimalPrecision,
                            tmpValue = $.wafNumberField.move(value, precision);
                    //
                    return $.wafNumberField.move(Math[this.options.roundType](tmpValue), 0 - precision);
                } else {
                    return Math[this.options.roundType](value);
                }
            },
            setValue : function(value) {
                this._update(this._getDisplayValue(value));
            },
            getValue : function() {
                return this.element.data(dataFlg);
            },
            widget : function() {
                return this.element;
            },
            destroy : function() {
                this.element.removeClass(defaultClass).removeAttr("ctrlrole");
                $.Widget.prototype.destroy.call(this);
            },
            _refresh : function() {
                this._update(this._getDisplayValue(this.element.data(dataFlg)), {nochange: true});
            },
            _getRealValue : function(displayValue) {
                if (displayValue == null) {
                    return displayValue;
                }
                var formatType = this.options.formatType;
                if (formatType == "percent") {
                    return $.wafNumberField.move(displayValue, -2);
                } else if (formatType == "thousandth") {
                    return $.wafNumberField.move(displayValue, -3);
                }
                return displayValue;
            },
            //.
            _getDisplayValue : function(realValue) {
                if (realValue == null) {
                    return realValue;
                }
                var formatType = this.options.formatType;
                if (formatType == "percent") {
                    return $.wafNumberField.move(realValue, 2);
                } else if (formatType == "thousandth") {
                    return $.wafNumberField.move(realValue, 3);
                }
                return realValue;
            },
            _viewDisable: function(isDisable) {
                $.ui.wafctrl.prototype._viewDisable.apply(this, arguments);
                this.element.attr('disabled', isDisable);
            }
        });

        $.wafNumberField = $.wafNumberField || {};
        $.extend($.wafNumberField, {
            format: function(number, options) {
                options = $.extend({}, defaultOptions, options);

                var numberFormat = defaultFormat[options.formatType],
                        allowGroup = options.allowGroup,
                        groupSize = options.groupSize,
                        groupSeparator = options.groupSymbol,
                        precision = options.dataType === "bigdecimal" ? options.decimalPrecision : 0,
                        negative = number < 0,
                        pattern = numberFormat ? numberFormat.pattern[negative ? 0 : 1] : "",
                        symbol,
                        isNumber = options.formatType == "number",
                        isCurrency = options.formatType == "currency",
                        isPercent = options.formatType == "percent",
                        isThousandth = options.formatType == "thousandth",
                        integer,
                        fraction,
                        integerLength,
                        fractionLength,
                        value,
                        idx,
                        length,
                        ch;

                // return empty string if no number
                if (number === undefined || number === null) {
                    return "";
                }

                if (!isFinite(number)) {
                    return number;
                }

                /* standard formatting */
                if (!isNumber && !isCurrency && !isPercent && !isThousandth) {
                    return "";
                }

                if (isCurrency) {
                    symbol = options.currencySymbol;
                } else if (isPercent) {
                    symbol = options.percentSymbol;
                } else if (isThousandth) {
                    symbol = options.thousandthSymbol;
                }

                // multiply if format is percent
                if (isPercent) {
                    //precision = precision <= 2 ? 0 : precision - 2;
                    number *= 100;
                } else if (isThousandth) {
                    //precision = precision <= 3 ? 0 : precision - 3;
                    number *= 1000;
                }

                var tmpValue = $.wafNumberField.move(number, precision);
                //
                number = $.wafNumberField.move(Math[options.roundType || 'round'](tmpValue), 0 - precision);
                number = $.formatNumber(number, precision);
                number = number.split(".");

                integer = number[0];
                fraction = number[1];

                // exclude "-" if number is negative.
                if (negative) {
                    integer = integer.substring(1);
                }

                value = integer;
                integerLength = integer.length;

                // add group separator to the number if it is
                // longer enough
                if (integerLength >= groupSize && allowGroup) {
                    value = "";
                    for (idx = 0; idx < integerLength; idx++) {
                        if (idx > 0 && (integerLength - idx) % groupSize === 0) {
                            value += groupSeparator;
                        }
                        value += integer.charAt(idx);
                    }
                }

                if (fraction) {
                    value += POINT + fraction;
                }

                if (isNumber && !negative) {
                    return value;
                }

                number = "";

                for (idx = 0,length = pattern.length; idx < length; idx++) {
                    ch = pattern.charAt(idx);

                    if (ch === "n") {
                        number += value;
                    } else if (ch === "$" || ch === "%") {
                        number += symbol;
                    } else {
                        number += ch;
                    }
                }

                return number;
            },
            //123.4,Number100
            move: function(number, step) {
                var negative = number < 0,
                        numberStr = new String(number),
                        pointIdx = numberStr.indexOf("."),
                        exponentialIdx = numberStr.indexOf("e"),
                        exponentialStr = "",
                        left,
                        right,
                        result;

                if (exponentialIdx >= 0) {
                    exponentialStr = numberStr.substr(exponentialIdx);
                    numberStr = numberStr.substring(0, exponentialIdx);
                }

                if (pointIdx >= 0) {
                    left = numberStr.substring(0, pointIdx);
                    right = numberStr.substring(pointIdx + 1, numberStr.length);
                } else {
                    left = numberStr;
                    right = "";
                }

                if (negative) {
                    left = left.substr(1);
                }

                if (step > 0) {
                    if (step > right.length) {
                        for (var i = right.length; i < step; i++) {
                            right += "0";
                        }
                    } else {
                        right = right.substring(0, step) + "." + right.substring(step, right.length);
                    }
                } else {
                    step = Math.abs(step);
                    if (step > left.length) {
                        for (var i = left.length; i < step; i++) {
                            left = "0" + left;
                        }
                        left = "0." + left;
                    } else {
                        step = left.length - step;
                        left = left.substring(0, step) + "." + left.substring(step, left.length);
                    }
                }

                result = left + right;
                if (negative) {
                    result = "-" + result;
                }
                if (exponentialIdx >= 0 && exponentialStr) {
                    result += exponentialStr;
                }
                return new Number(result).valueOf();
            },
            createNumberFieldDOM: function(opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    return [$('<input id="' + opts.id + '" name="' + opts.name + '_el" type="text">'),
                    $('<input id="' + opts.id + '_el" name="' + opts.name + '" type="hidden">'),
                    $('<label class="viewStatus" id="' + opts.id + '_view"></label>')];
                } else {
                    return obj;
                }
            },
            initNumberField: function(opts, el) {
               var el=$.isArray(el)?el[0]:el;
               el.wafNumberField(opts);
            },
            removeNumberField: function(opts) {
                var el = $("#" + opts.id),
                        subel = $("#" + opts.id + "_el"),
                        view = $("#" + opts.id + "_view");

                if (el.length) {
                    el.wafNumberField("destroy");
                    el.remove();
                }
                if (subel.length) {
                    subel.remove();
                }
                if (view.length) {
                    view.remove();
                }
            },
            modifyNumberField: function(opts) {
                var option = $.extend(true, {}, opts);
                _value = option.value,el = $("#" + option.id);
                delete option.value;
                el.wafNumberField("option", option);
                if (_value != null) {
                    el.wafNumberField("setValue", _value);
                }
            }
        });

        $(function () {
            if ($.registerComponent)
                $.registerComponent("numberField", {createDOMFun: $.wafNumberField.createNumberFieldDOM,
                    initFun: $.wafNumberField.initNumberField,
                    deleteFun: $.wafNumberField.removeNumberField,
                    modifyFun: $.wafNumberField.modifyNumberField,lazyInit:true});
        });
    })(jQuery);
//});
/*
 * Metadata - jQuery plugin for parsing metadata from elements
 *
 * Copyright (c) 2006 John Resig, Yehuda Katz, Jrn Zaefferer, Paul McLanahan
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
 * Revision: $Id: jquery.metadata.js 4187 2007-12-16 17:15:27Z joern.zaefferer $
 *
 */

/**
 * Sets the type of metadata to use. Metadata is encoded in JSON, and each property
 * in the JSON will become a property of the element itself.
 *
 * There are three supported types of metadata storage:
 *
 *   attr:  Inside an attribute. The name parameter indicates *which* attribute.
 *          
 *   class: Inside the class attribute, wrapped in curly braces: { }
 *   
 *   elem:  Inside a child element (e.g. a script tag). The
 *          name parameter indicates *which* element.
 *          
 * The metadata for an element is loaded the first time the element is accessed via jQuery.
 *
 * As a result, you can define the metadata type, use $(expr) to load the metadata into the elements
 * matched by expr, then redefine the metadata type and run another $(expr) for other elements.
 * 
 * @name $.metadata.setType
 *
 * @example <p id="one" class="some_class {item_id: 1, item_label: 'Label'}">This is a p</p>
 * @before $.metadata.setType("class")
 * @after $("#one").metadata().item_id == 1; $("#one").metadata().item_label == "Label"
 * @desc Reads metadata from the class attribute
 * 
 * @example <p id="one" class="some_class" data="{item_id: 1, item_label: 'Label'}">This is a p</p>
 * @before $.metadata.setType("attr", "data")
 * @after $("#one").metadata().item_id == 1; $("#one").metadata().item_label == "Label"
 * @desc Reads metadata from a "data" attribute
 * 
 * @example <p id="one" class="some_class"><script>{item_id: 1, item_label: 'Label'}</script>This is a p</p>
 * @before $.metadata.setType("elem", "script")
 * @after $("#one").metadata().item_id == 1; $("#one").metadata().item_label == "Label"
 * @desc Reads metadata from a nested script element
 * 
 * @param String type The encoding type
 * @param String name The name of the attribute to be used to get metadata (optional)
 * @cat Plugins/Metadata
 * @descr Sets the type of encoding to be used when loading metadata for the first time
 * @type undefined
 * @see metadata()
 */
//mod.defineModule("validatorMetadata", ["base"], function() {
    (function($) {

    $.extend({
        metadata : {
            defaults : {
                type: 'class',
                name: 'metadata',
                cre: /({.*})/,
                single: 'metadata'
            },
            setType: function( type, name ){
                this.defaults.type = type;
                this.defaults.name = name;
            },
            get: function( elem, opts ){
                var settings = $.extend({},this.defaults,opts);
                // check for empty string in single property
                if ( !settings.single.length ) settings.single = 'metadata';

                var data = $.data(elem, settings.single);
                // returned cached data if it already exists
                if ( data && !$.isEmptyObject(data) ) return data;

                data = "{}";

                if ( settings.type == "class" ) {
                    var m = settings.cre.exec( elem.className );
                    if ( m )
                        data = m[1];
                } else if ( settings.type == "elem" ) {
                    if( !elem.getElementsByTagName )
                        return undefined;
                    var e = elem.getElementsByTagName(settings.name);
                    if ( e.length )
                        data = $.trim(e[0].innerHTML);
                } else if ( elem.getAttribute != undefined ) {
                    var attr = elem.getAttribute( settings.name );
                    if ( attr )
                        data = attr;
                }

                if ( data.indexOf( '{' ) <0 )
                data = "{" + data + "}";

                data = eval("(" + data + ")");

                $.data( elem, settings.single, data );
                return data;
            }
        }
    });

    /**
     * Returns the metadata object for the first member of the jQuery object.
     *
     * @name metadata
     * @descr Returns element's metadata object
     * @param Object opts An object contianing settings to override the defaults
     * @type jQuery
     * @cat Plugins/Metadata
     */
    $.fn.metadata = function( opts ){
        return $.metadata.get( this[0], opts );
    };
    })(jQuery);
//});
    /**
     * jQuery Validation Plugin 1.9.0
     *
     * http://bassistance.de/jquery-plugins/jquery-plugin-validation/
     * http://docs.jquery.com/Plugins/Validation
     *
     * Copyright (c) 2006 - 2011 Jrn Zaefferer
     *
     * Dual licensed under the MIT and GPL licenses:
     *   http://www.opensource.org/licenses/mit-license.php
     *   http://www.gnu.org/licenses/gpl.html
     */
//mod.defineModule("validator_inner", ["base"], function() {
    (function($) {

    $.extend($.fn, {
        // http://docs.jquery.com/Plugins/Validation/validate
        validate: function( options ) {

            // if nothing is selected, return nothing; can't chain anyway
            if (!this.length) {
                options && options.debug && window.console && console.warn( "nothing selected, can't validate, returning nothing" );
                return;
            }

            // check if a validator for this form was already created
            var validator = $.data(this[0], 'validator');
            if ( validator ) {
                return validator;
            }

            // Add novalidate tag if HTML5.
            this.attr('novalidate', 'novalidate');

            validator = new $.validator( options, this[0] );
            $.data(this[0], 'validator', validator);

            if ( validator.settings.onsubmit ) {

                var inputsAndButtons = this.find("input, button");

                // allow suppresing validation by adding a cancel class to the submit button
                inputsAndButtons.filter(".cancel").click(function () {
                    validator.cancelSubmit = true;
                });

                // when a submitHandler is used, capture the submitting button
                if (validator.settings.submitHandler) {
                    inputsAndButtons.filter(":submit").click(function () {
                        validator.submitButton = this;
                    });
                }

                // validate the form on submit
                this.submit( function( event ) {
                    if ( validator.settings.debug )
                        // prevent form submit to be able to see console output
                        event.preventDefault();

                    function handle() {
                        if ( validator.settings.submitHandler ) {
                            if (validator.submitButton) {
                                // insert a hidden input as a replacement for the missing submit button
                                var hidden = $("<input type='hidden'/>").attr("name", validator.submitButton.name).val(validator.submitButton.value).appendTo(validator.currentForm);
                            }
                            validator.settings.submitHandler.call( validator, validator.currentForm );
                            if (validator.submitButton) {
                                // and clean up afterwards; thanks to no-block-scope, hidden can be referenced
                                hidden.remove();
                            }
                            return false;
                        }
                        return true;
                    }

                    // prevent submit for invalid forms or custom submit handlers
                    if ( validator.cancelSubmit ) {
                        validator.cancelSubmit = false;
                        return handle();
                    }
                    if ( validator.form() ) {
                        if ( validator.pendingRequest ) {
                            validator.formSubmitted = true;
                            return false;
                        }
                        return handle();
                    } else {
                        validator.focusInvalid();
                        return false;
                    }
                });
            }

            return validator;
        },
        // http://docs.jquery.com/Plugins/Validation/valid
        valid: function() {
            if ( $(this[0]).is('form')) {
                return this.validate().form();
            } else {
                var valid = true;
                var validator = $(this[0].form).validate();
                this.each(function() {
                    valid &= validator.element(this);
                });
                return valid;
            }
        },
        // attributes: space seperated list of attributes to retrieve and remove
        removeAttrs: function(attributes) {
            var result = {},
                $element = this;
            $.each(attributes.split(/\s/), function(index, value) {
                result[value] = $element.attr(value);
                $element.removeAttr(value);
            });
            return result;
        },
        // http://docs.jquery.com/Plugins/Validation/rules
        rules: function(command, argument) {
            var element = this[0];
            if (command) {
                var settings = $.data(element.form, 'validator').settings;
                var staticRules = settings.rules;
                var existingRules = $.validator.staticRules(element);
                switch(command) {
                case "add":
                    $.extend(existingRules, $.validator.normalizeRule(argument));
                    staticRules[element.name] = existingRules;
                    if (argument.messages)
                        settings.messages[element.name] = $.extend( settings.messages[element.name], argument.messages );
                    break;
                case "remove":
                    if (!argument) {
                        delete staticRules[element.name];
                        return existingRules;
                    }
                    var filtered = {};
                    $.each(argument.split(/\s/), function(index, method) {
                        filtered[method] = existingRules[method];
                        delete existingRules[method];
                    });
                    return filtered;
                }
            }

            var data = $.validator.normalizeRules(
            $.extend(
                {},
                $.validator.metadataRules(element),
                $.validator.classRules(element),
                $.validator.attributeRules(element),
                $.validator.staticRules(element)
            ), element);

            // make sure required is at front
            if (data.required) {
                var param = data.required;
                delete data.required;
                data = $.extend({required: param}, data);
            }

            return data;
        }
    });

    // Custom selectors
    $.extend($.expr[":"], {
        // http://docs.jquery.com/Plugins/Validation/blank
        blank: function(a) {return !$.trim("" + a.value);},
        // http://docs.jquery.com/Plugins/Validation/filled
        filled: function(a) {return !!$.trim("" + a.value);},
        // http://docs.jquery.com/Plugins/Validation/unchecked
        unchecked: function(a) {return !a.checked;}
    });

    // constructor for validator
    $.validator = function( options, form ) {
        this.settings = $.extend( true, {}, $.validator.defaults, options );
        this.currentForm = form;
        this.init();
    };

    $.validator.format = function(source, params) {
        if ( arguments.length == 1 )
            return function() {
                var args = $.makeArray(arguments);
                args.unshift(source);
                return $.validator.format.apply( this, args );
            };
        if ( arguments.length > 2 && params.constructor != Array  ) {
            params = $.makeArray(arguments).slice(1);
        }
        if ( params.constructor != Array ) {
            params = [ params ];
        }
        $.each(params, function(i, n) {
            source = source.replace(new RegExp("\\{" + i + "\\}", "g"), n);
        });
        return source;
    };

    $.extend($.validator, {

        defaults: {
            messages: {},
            groups: {},
            rules: {},
            errorClass: "error",
            validClass: "valid",
            errorElement: "label",
            focusInvalid: true,
            errorContainer: $( [] ),
            errorLabelContainer: $( [] ),
            onsubmit: true,
            ignore: ":hidden",
            ignoreTitle: false,
            onfocusin: function(element, event) {
                this.lastActive = element;

                // hide error label and remove error class on focus if enabled
                if ( this.settings.focusCleanup && !this.blockFocusCleanup ) {
                    this.settings.unhighlight && this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );
                    this.addWrapper(this.errorsFor(element)).hide();
                }
            },
            onfocusout: function(element, event) {
                if ( !this.checkable(element) && (element.name in this.submitted || !this.optional(element)) ) {
                    this.element(element);
                }
            },
            onkeyup: function(element, event) {
                if ( element.name in this.submitted || element == this.lastElement ) {
                    this.element(element);
                }
            },
            onclick: function(element, event) {
                // click on selects, radiobuttons and checkboxes
                if ( element.name in this.submitted )
                    this.element(element);
                // or option elements, check parent select in that case
                else if (element.parentNode.name in this.submitted)
                    this.element(element.parentNode);
            },
            highlight: function(element, errorClass, validClass) {
                if (element.type === 'radio') {
                    this.findByName(element.name).addClass(errorClass).removeClass(validClass);
                } else {
                    $(element).addClass(errorClass).removeClass(validClass);
                }
            },
            unhighlight: function(element, errorClass, validClass) {
                if (element.type === 'radio') {
                    this.findByName(element.name).removeClass(errorClass).addClass(validClass);
                } else {
                    $(element).removeClass(errorClass).addClass(validClass);
                }
            }
        },

        // http://docs.jquery.com/Plugins/Validation/Validator/setDefaults
        setDefaults: function(settings) {
            $.extend( $.validator.defaults, settings );
        },

        messages: {
            required: "This field is required.",
            remote: "Please fix this field.",
            email: "Please enter a valid email address.",
            url: "Please enter a valid URL.",
            date: "Please enter a valid date.",
            dateISO: "Please enter a valid date (ISO).",
            number: "Please enter a valid number.",
            digits: "Please enter only digits.",
            creditcard: "Please enter a valid credit card number.",
            equalTo: "Please enter the same value again.",
            accept: "Please enter a value with a valid extension.",
            maxlength: $.validator.format("Please enter no more than {0} characters."),
            minlength: $.validator.format("Please enter at least {0} characters."),
            rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),
            range: $.validator.format("Please enter a value between {0} and {1}."),
            max: $.validator.format("Please enter a value less than or equal to {0}."),
            min: $.validator.format("Please enter a value greater than or equal to {0}.")
        },

        autoCreateRanges: false,

        prototype: {

            init: function() {
                this.labelContainer = $(this.settings.errorLabelContainer);
                this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);
                this.containers = $(this.settings.errorContainer).add( this.settings.errorLabelContainer );
                this.submitted = {};
                this.valueCache = {};
                this.pendingRequest = 0;
                this.pending = {};
                this.invalid = {};
                this.reset();

                var groups = (this.groups = {});
                $.each(this.settings.groups, function(key, value) {
                    $.each(value.split(/\s/), function(index, name) {
                        groups[name] = key;
                    });
                });
                var rules = this.settings.rules;
                $.each(rules, function(key, value) {
                    rules[key] = $.validator.normalizeRule(value);
                });

                function delegate(event) {
                    var validator = $.data(this[0].form, "validator"),
                        eventType = "on" + event.type.replace(/^validate/, "");
                    validator.settings[eventType] && validator.settings[eventType].call(validator, this[0], event);
                }
                $(this.currentForm)
                       .validateDelegate("[type='text'], [type='password'], [type='file'], select, textarea, " +
                            "[type='number'], [type='search'] ,[type='tel'], [type='url'], " +
                            "[type='email'], [type='datetime'], [type='date'], [type='month'], " +
                            "[type='week'], [type='time'], [type='datetime-local'], " +
                            "[type='range'], [type='color'] ",
                            "focusin focusout keyup ", delegate)
                    .validateDelegate("[type='radio'], [type='checkbox'], select, option", "click", delegate);

                if (this.settings.invalidHandler)
                    $(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler);
            },

            // http://docs.jquery.com/Plugins/Validation/Validator/form
            form: function() {
                this.checkForm();
                $.extend(this.submitted, this.errorMap);
                this.invalid = $.extend({}, this.errorMap);
                if (!this.valid())
                    $(this.currentForm).triggerHandler("invalid-form", [this]);
                this.showErrors();
                return this.valid();
            },

            checkForm: function() {
                this.prepareForm();
                for ( var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++ ) {
                    this.check( elements[i] );
                }
                return this.valid();
            },

            // http://docs.jquery.com/Plugins/Validation/Validator/element
            element: function( element ) {
                element = this.validationTargetFor( this.clean( element ) );
                if(!element) return;
                this.lastElement = element;
                this.prepareElement( element );
                this.currentElements = $(element);
                var result = this.check( element );
                if ( result ) {
                    delete this.invalid[element.name];
                } else {
                    this.invalid[element.name] = true;
                }
                if ( !this.numberOfInvalids() ) {
                    // Hide error containers on last error
                    this.toHide = this.toHide.add( this.containers );
                }
                this.showErrors();
                return result;
            },

            // http://docs.jquery.com/Plugins/Validation/Validator/showErrors
            showErrors: function(errors) {
                if(errors) {
                    // add items to error list and map
                    $.extend( this.errorMap, errors );
                    this.errorList = [];
                    for ( var name in errors ) {
                        this.errorList.push({
                            message: errors[name],
                            element: this.findByName(name)[0]
                        });
                    }
                    // remove items from success list
                    this.successList = $.grep( this.successList, function(element) {
                        return !(element.name in errors);
                    });
                }
                this.settings.showErrors
                    ? this.settings.showErrors.call( this, this.errorMap, this.errorList )
                    : this.defaultShowErrors();
            },

            // http://docs.jquery.com/Plugins/Validation/Validator/resetForm
            resetForm: function() {
                if ( $.fn.resetForm )
                    $( this.currentForm ).resetForm();
                this.submitted = {};
                this.lastElement = null;
                this.prepareForm();
                this.hideErrors();
                this.elements().removeClass( this.settings.errorClass );
            },

            numberOfInvalids: function() {
                return this.objectLength(this.invalid);
            },

            objectLength: function( obj ) {
                var count = 0;
                for ( var i in obj )
                    count++;
                return count;
            },

            hideErrors: function() {
                this.addWrapper( this.toHide ).hide();
            },

            valid: function() {
                return this.size() == 0;
            },

            size: function() {
                return this.errorList.length;
            },

            focusInvalid: function() {
                if( this.settings.focusInvalid ) {
                    try {
                        $(this.findLastActive() || this.errorList.length && this.errorList[0].element || [])
                        .filter(":visible")
                        .focus()
                        // manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
                        .trigger("focusin");
                    } catch(e) {
                        // ignore IE throwing errors when focusing hidden elements
                    }
                }
            },

            findLastActive: function() {
                var lastActive = this.lastActive;
                return lastActive && $.grep(this.errorList, function(n) {
                    return n.element.name == lastActive.name;
                }).length == 1 && lastActive;
            },

            elements: function() {
                var validator = this,
                    rulesCache = {};

                // select all valid inputs inside the form (no submit or reset buttons)
                return $(this.currentForm)
                .find("input, select, textarea")
                .not(":submit, :reset, :image, [disabled]")
                .not( this.settings.ignore )
                .filter(function() {
                    !this.name && validator.settings.debug && window.console && console.error( "%o has no name assigned", this);

                    // select only the first element for each name, and only those with rules specified
                    if ( this.name in rulesCache || !validator.objectLength($(this).rules()) )
                        return false;

                    rulesCache[this.name] = true;
                    return true;
                });
            },

            clean: function( selector ) {
                return $( selector )[0];
            },

            errors: function() {
                return $( this.settings.errorElement + "." + this.settings.errorClass, this.errorContext );
            },

            reset: function() {
                this.successList = [];
                this.errorList = [];
                this.errorMap = {};
                this.toShow = $([]);
                this.toHide = $([]);
                this.currentElements = $([]);
            },

            prepareForm: function() {
                this.reset();
                this.toHide = this.errors().add( this.containers );
            },

            prepareElement: function( element ) {
                this.reset();
                this.toHide = this.errorsFor(element);
            },

            check: function( element ) {

                element = this.validationTargetFor( this.clean( element ) );

                var rules = $(element).rules();
                var dependencyMismatch = false;
                for (var method in rules ) {
                    var rule = { method: method, parameters: rules[method] };
                    try {
                        var result = $.validator.methods[method].call( this, element.value.replace(/\r/g, ""), element, rule.parameters );

                        // if a method indicates that the field is optional and therefore valid,
                        // don't mark it as valid when there are no other rules
                        if ( result == "dependency-mismatch" ) {
                            dependencyMismatch = true;
                            continue;
                        }
                        dependencyMismatch = false;

                        if ( result == "pending" ) {
                            this.toHide = this.toHide.not( this.errorsFor(element) );
                            return;
                        }

                        if( !result ) {
                            this.formatAndAdd( element, rule );
                            return false;
                        }
                    } catch(e) {
                        this.settings.debug && window.console && console.log("exception occured when checking element " + element.id
                             + ", check the '" + rule.method + "' method", e);
                        throw e;
                    }
                }
                if (dependencyMismatch)
                    return;
                if ( this.objectLength(rules) )
                    this.successList.push(element);
                return true;
            },

            // return the custom message for the given element and validation method
            // specified in the element's "messages" metadata
            customMetaMessage: function(element, method) {
                if (!$.metadata)
                    return;

                var meta = this.settings.meta
                    ? $(element).metadata()[this.settings.meta]
                    : $(element).metadata();

                return meta && meta.messages && meta.messages[method];
            },

            // return the custom message for the given element name and validation method
            customMessage: function( name, method ) {
                var m = this.settings.messages[name];
                return m && (m.constructor == String
                    ? m
                    : m[method]);
            },

            // return the first defined argument, allowing empty strings
            findDefined: function() {
                for(var i = 0; i < arguments.length; i++) {
                    if (arguments[i] !== undefined)
                        return arguments[i];
                }
                return undefined;
            },

            defaultMessage: function( element, method) {
                return this.findDefined(
                    this.customMessage( element.name, method ),
                    this.customMetaMessage( element, method ),
                    // title is never undefined, so handle empty string as undefined
                    !this.settings.ignoreTitle && element.title || undefined,
                    $.validator.messages[method],
                    "<strong>Warning: No message defined for " + element.name + "</strong>"
                );
            },

            formatAndAdd: function( element, rule ) {
                var message = this.defaultMessage( element, rule.method ),
                    theregex = /\$?\{(\d+)\}/g;
                if ( typeof message == "function" ) {
                    message = message.call(this, rule.parameters, element);
                } else if (theregex.test(message)) {
                    message = jQuery.format(message.replace(theregex, '{$1}'), rule.parameters);
                }
                this.errorList.push({
                    message: message,
                    element: element
                });

                this.errorMap[element.name] = message;
                this.submitted[element.name] = message;
            },

            addWrapper: function(toToggle) {
                if ( this.settings.wrapper )
                    toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );
                return toToggle;
            },

            defaultShowErrors: function() {
                for ( var i = 0; this.errorList[i]; i++ ) {
                    var error = this.errorList[i];
                    this.settings.highlight && this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );
                    this.showLabel( error.element, error.message );
                }
                if( this.errorList.length ) {
                    this.toShow = this.toShow.add( this.containers );
                }
                if (this.settings.success) {
                    for ( var i = 0; this.successList[i]; i++ ) {
                        this.showLabel( this.successList[i] );
                    }
                }
                if (this.settings.unhighlight) {
                    for ( var i = 0, elements = this.validElements(); elements[i]; i++ ) {
                        this.settings.unhighlight.call( this, elements[i], this.settings.errorClass, this.settings.validClass );
                    }
                }
                this.toHide = this.toHide.not( this.toShow );
                this.hideErrors();
                this.addWrapper( this.toShow ).show();
            },

            validElements: function() {
                return this.currentElements.not(this.invalidElements());
            },

            invalidElements: function() {
                return $(this.errorList).map(function() {
                    return this.element;
                });
            },

            showLabel: function(element, message) {
                var label = this.errorsFor( element );
                if ( label.length ) {
                    // refresh error/success class
                    label.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );

                    // check if we have a generated label, replace the message then
                    label.attr("generated") && label.html(message);
                } else {
                    // create label
                    label = $("<" + this.settings.errorElement + "/>")
                        .attr({"for":  this.idOrName(element), generated: true})
                        .addClass(this.settings.errorClass)
                        .html(message || "");
                    if ( this.settings.wrapper ) {
                        // make sure the element is visible, even in IE
                        // actually showing the wrapped element is handled elsewhere
                        label = label.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();
                    }
                    if ( !this.labelContainer.append(label).length )
                        this.settings.errorPlacement
                            ? this.settings.errorPlacement(label, $(element) )
                            : label.insertAfter(element);
                }
                if ( !message && this.settings.success ) {
                    label.text("");
                    typeof this.settings.success == "string"
                        ? label.addClass( this.settings.success )
                        : this.settings.success( label );
                }
                this.toShow = this.toShow.add(label);
            },

            errorsFor: function(element) {
                var name = this.idOrName(element);
                return this.errors().filter(function() {
                    return $(this).attr('for') == name;
                });
            },

            idOrName: function(element) {
                return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);
            },

            validationTargetFor: function(element) {
                // if radio/checkbox, validate first element in group instead
                if (this.checkable(element)) {
                    element = this.findByName( element.name ).not(this.settings.ignore)[0];
                }
                return element;
            },

            checkable: function( element ) {
                return /radio|checkbox/i.test(element.type);
            },

            findByName: function( name ) {
                // select by name and filter by form for performance over form.find("[name=...]")
                var form = this.currentForm;
                return $(document.getElementsByName(name)).map(function(index, element) {
                    return element.form == form && element.name == name && element  || null;
                });
            },

            getLength: function(value, element) {
                switch( element.nodeName.toLowerCase() ) {
                case 'select':
                    return $("option:selected", element).length;
                case 'input':
                    if( this.checkable( element) )
                        return this.findByName(element.name).filter(':checked').length;
                }
                return value.length;
            },

            depend: function(param, element) {
                return this.dependTypes[typeof param]
                    ? this.dependTypes[typeof param](param, element)
                    : true;
            },

            dependTypes: {
                "boolean": function(param, element) {
                    return param;
                },
                "string": function(param, element) {
                    return !!$(param, element.form).length;
                },
                "function": function(param, element) {
                    return param(element);
                }
            },

            optional: function(element) {
                return !$.validator.methods.required.call(this, $.trim(element.value), element) && "dependency-mismatch";
            },

            startRequest: function(element) {
                if (!this.pending[element.name]) {
                    this.pendingRequest++;
                    this.pending[element.name] = true;
                }
            },

            stopRequest: function(element, valid) {
                this.pendingRequest--;
                // sometimes synchronization fails, make sure pendingRequest is never < 0
                if (this.pendingRequest < 0)
                    this.pendingRequest = 0;
                delete this.pending[element.name];
                if ( valid && this.pendingRequest == 0 && this.formSubmitted && this.form() ) {
                    $(this.currentForm).submit();
                    this.formSubmitted = false;
                } else if (!valid && this.pendingRequest == 0 && this.formSubmitted) {
                    $(this.currentForm).triggerHandler("invalid-form", [this]);
                    this.formSubmitted = false;
                }
            },

            previousValue: function(element) {
                return $.data(element, "previousValue") || $.data(element, "previousValue", {
                    old: null,
                    valid: true,
                    message: this.defaultMessage( element, "remote" )
                });
            }

        },

        classRuleSettings: {
            required: {required: true},
            email: {email: true},
            url: {url: true},
            date: {date: true},
            dateISO: {dateISO: true},
            dateDE: {dateDE: true},
            number: {number: true},
            numberDE: {numberDE: true},
            digits: {digits: true},
            creditcard: {creditcard: true}
        },

        addClassRules: function(className, rules) {
            className.constructor == String ?
                this.classRuleSettings[className] = rules :
                $.extend(this.classRuleSettings, className);
        },

        classRules: function(element) {
            var rules = {};
            var classes = $(element).attr('class');
            classes && $.each(classes.split(' '), function() {
                if (this in $.validator.classRuleSettings) {
                    $.extend(rules, $.validator.classRuleSettings[this]);
                }
            });
            return rules;
        },

        attributeRules: function(element) {
            var rules = {};
            var $element = $(element);

            for (var method in $.validator.methods) {
                var value;
                // If .prop exists (jQuery >= 1.6), use it to get true/false for required
                if (method === 'required' && typeof $.fn.prop === 'function') {
                    value = $element.prop(method);
                } else {
                    value = $element.attr(method);
                }
                if (value) {
                    rules[method] = value;
                } else if ($element[0].getAttribute("type") === method) {
                    rules[method] = true;
                }
            }

            // maxlength may be returned as -1, 2147483647 (IE) and 524288 (safari) for text inputs
            if (rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength)) {
                delete rules.maxlength;
            }

            return rules;
        },

        metadataRules: function(element) {
            if (!$.metadata) return {};

            var meta = $.data(element.form, 'validator')?$.data(element.form, 'validator').settings.meta:undefined;
            return meta ?
                $(element).metadata()[meta] :
                $(element).metadata();
        },

        staticRules: function(element) {
            var rules = {};
            var validator = $.data(element.form, 'validator');
            if (validator&&validator.settings.rules) {
                rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};
            }
            return rules;
        },

        normalizeRules: function(rules, element) {
            // handle dependency check
            $.each(rules, function(prop, val) {
                // ignore rule when param is explicitly false, eg. required:false
                if (val === false) {
                    delete rules[prop];
                    return;
                }
                if (val.param || val.depends) {
                    var keepRule = true;
                    switch (typeof val.depends) {
                        case "string":
                            keepRule = !!$(val.depends, element.form).length;
                            break;
                        case "function":
                            keepRule = val.depends.call(element, element);
                            break;
                    }
                    if (keepRule) {
                        rules[prop] = val.param !== undefined ? val.param : true;
                    } else {
                        delete rules[prop];
                    }
                }
            });

            // evaluate parameters
            $.each(rules, function(rule, parameter) {
                rules[rule] = $.isFunction(parameter) ? parameter(element) : parameter;
            });

            // clean number parameters
            $.each(['minlength', 'maxlength', 'min', 'max'], function() {
                if (rules[this]) {
                    rules[this] = Number(rules[this]);
                }
            });
            $.each(['rangelength', 'range'], function() {
                if (rules[this]) {
                    rules[this] = [Number(rules[this][0]), Number(rules[this][1])];
                }
            });

            if ($.validator.autoCreateRanges) {
                // auto-create ranges
                if (rules.min && rules.max) {
                    rules.range = [rules.min, rules.max];
                    delete rules.min;
                    delete rules.max;
                }
                if (rules.minlength && rules.maxlength) {
                    rules.rangelength = [rules.minlength, rules.maxlength];
                    delete rules.minlength;
                    delete rules.maxlength;
                }
            }

            // To support custom messages in metadata ignore rule methods titled "messages"
            if (rules.messages) {
                delete rules.messages;
            }

            return rules;
        },

        // Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
        normalizeRule: function(data) {
            if( typeof data == "string" ) {
                var transformed = {};
                $.each(data.split(/\s/), function() {
                    transformed[this] = true;
                });
                data = transformed;
            }
            return data;
        },

        // http://docs.jquery.com/Plugins/Validation/Validator/addMethod
        addMethod: function(name, method, message) {
            $.validator.methods[name] = method;
            $.validator.messages[name] = message != undefined ? message : $.validator.messages[name];
            if (method&&method.length < 3) {
                $.validator.addClassRules(name, $.validator.normalizeRule(name));
            }
        },

        methods: {

            // http://docs.jquery.com/Plugins/Validation/Methods/required
            required: function(value, element, param) {
                // check if dependency is met
                if ( !this.depend(param, element) )
                    return "dependency-mismatch";
                switch( element.nodeName.toLowerCase() ) {
                case 'select':
                    // could be an array for select-multiple or a string, both are fine this way
                    var val = $(element).val();
                    return val && val.length > 0;
                case 'input':
                    if ( this.checkable(element) )
                        return this.getLength(value, element) > 0;
                default:
                    return $.trim(value).length > 0;
                }
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/remote
            remote: function(value, element, param) {
                if ( this.optional(element) )
                    return "dependency-mismatch";

                var previous = this.previousValue(element);
                if (!this.settings.messages[element.name] )
                    this.settings.messages[element.name] = {};
                previous.originalMessage = this.settings.messages[element.name].remote;
                this.settings.messages[element.name].remote = previous.message;

                param = typeof param == "string" && {url:param} || param;

                if ( this.pending[element.name] ) {
                    return "pending";
                }
                if ( previous.old === value ) {
                    return previous.valid;
                }

                previous.old = value;
                var validator = this;
                this.startRequest(element);
                var data = {};
                data[element.name] = value;
                $.ajax($.extend(true, {
                    url: param,
                    mode: "abort",
                    port: "validate" + element.name,
                    dataType: "json",
                    data: data,
                    success: function(response) {
                        validator.settings.messages[element.name].remote = previous.originalMessage;
                        var valid = response === true;
                        if ( valid ) {
                            var submitted = validator.formSubmitted;
                            validator.prepareElement(element);
                            validator.formSubmitted = submitted;
                            validator.successList.push(element);
                            validator.showErrors();
                        } else {
                            var errors = {};
                            var message = response || validator.defaultMessage( element, "remote" );
                            errors[element.name] = previous.message = $.isFunction(message) ? message(value) : message;
                            validator.showErrors(errors);
                        }
                        previous.valid = valid;
                        validator.stopRequest(element, valid);
                    }
                }, param));
                return "pending";
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/minlength
            minlength: function(value, element, param) {
                return this.optional(element) || this.getLength($.trim(value), element) >= param;
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/maxlength
            maxlength: function(value, element, param) {
                return this.optional(element) || this.getLength($.trim(value), element) <= param;
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/rangelength
            rangelength: function(value, element, param) {
                var length = this.getLength($.trim(value), element);
                return this.optional(element) || ( length >= param[0] && length <= param[1] );
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/min
            min: function( value, element, param ) {
                return this.optional(element) || value >= param;
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/max
            max: function( value, element, param ) {
                return this.optional(element) || value <= param;
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/range
            range: function( value, element, param ) {
                return this.optional(element) || ( value >= param[0] && value <= param[1] );
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/email
            email: function(value, element) {
                // contributed by Scott Gonzalez: http://projects.scottsplayground.com/email_address_validation/
                return this.optional(element) || /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(value);
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/url
            url: function(value, element) {
                // contributed by Scott Gonzalez: http://projects.scottsplayground.com/iri/
                return this.optional(element) || /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(value);
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/date
            date: function(value, element) {
                //IE8new Date,modify by jlg.
                //var startDate   = value;
                //startDate       = startDate.split("-");
                //startDate       = new Date(startDate[0], + startDate[1], startDate[2]);
                //return this.optional(element) || !/Invalid|NaN/.test(startDate);
                try{
                    var date = $.datepicker.parseDateTime("yy-mm-dd","hh:mm:ss", value);
                    return true;
                }catch(e){
                    return false;
                }
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/dateISO
            dateISO: function(value, element) {
                return this.optional(element) || /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(value);
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/number
            number: function(value, element) {
                return this.optional(element) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/.test(value);
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/digits
            digits: function(value, element) {
                return this.optional(element) || /^\d+$/.test(value);
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/creditcard
            // based on http://en.wikipedia.org/wiki/Luhn
            creditcard: function(value, element) {
                if ( this.optional(element) )
                    return "dependency-mismatch";
                // accept only spaces, digits and dashes
                if (/[^0-9 -]+/.test(value))
                    return false;
                var nCheck = 0,
                    nDigit = 0,
                    bEven = false;

                value = value.replace(/\D/g, "");

                for (var n = value.length - 1; n >= 0; n--) {
                    var cDigit = value.charAt(n);
                    var nDigit = parseInt(cDigit, 10);
                    if (bEven) {
                        if ((nDigit *= 2) > 9)
                            nDigit -= 9;
                    }
                    nCheck += nDigit;
                    bEven = !bEven;
                }

                return (nCheck % 10) == 0;
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/accept
            accept: function(value, element, param) {
                param = typeof param == "string" ? param.replace(/,/g, '|') : "png|jpe?g|gif";
                return this.optional(element) || value.match(new RegExp(".(" + param + ")$", "i"));
            },

            // http://docs.jquery.com/Plugins/Validation/Methods/equalTo
            equalTo: function(value, element, param) {
                // bind to the blur event of the target in order to revalidate whenever the target field is updated
                // TODO find a way to bind the event just once, avoiding the unbind-rebind overhead
                var target = $(param).unbind(".validate-equalTo").bind("blur.validate-equalTo", function() {
                    $(element).valid();
                });
                return value == target.val();
            }

        }

    });

    // deprecated, use $.validator.format instead
    $.format = $.validator.format;

    })(jQuery);

    // ajax mode: abort
    // usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
    // if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()
    ;(function($) {
        var pendingRequests = {};
        // Use a prefilter if available (1.5+)
        if ( $.ajaxPrefilter ) {
            $.ajaxPrefilter(function(settings, _, xhr) {
                var port = settings.port;
                if (settings.mode == "abort") {
                    if ( pendingRequests[port] ) {
                        pendingRequests[port].abort();
                    }
                    pendingRequests[port] = xhr;
                }
            });
        } else {
            // Proxy ajax
            var ajax = $.ajax;
            $.ajax = function(settings) {
                var mode = ( "mode" in settings ? settings : $.ajaxSettings ).mode,
                    port = ( "port" in settings ? settings : $.ajaxSettings ).port;
                if (mode == "abort") {
                    if ( pendingRequests[port] ) {
                        pendingRequests[port].abort();
                    }
                    return (pendingRequests[port] = ajax.apply(this, arguments));
                }
                return ajax.apply(this, arguments);
            };
        }
    })(jQuery);

    // provides cross-browser focusin and focusout events
    // IE has native support, in other browsers, use event caputuring (neither bubbles)

    // provides delegate(type: String, delegate: Selector, handler: Callback) plugin for easier event delegation
    // handler is only called when $(event.target).is(delegate), in the scope of the jquery-object for event.target
    ;(function($) {
        // only implement if not provided by jQuery core (since 1.4)
        // TODO verify if jQuery 1.4's implementation is compatible with older jQuery special-event APIs
        if (!jQuery.event.special.focusin && !jQuery.event.special.focusout && document.addEventListener) {
            $.each({
                focus: 'focusin',
                blur: 'focusout'
            }, function( original, fix ){
                $.event.special[fix] = {
                    setup:function() {
                        this.addEventListener( original, handler, true );
                    },
                    teardown:function() {
                        this.removeEventListener( original, handler, true );
                    },
                    handler: function(e) {
                        arguments[0] = $.event.fix(e);
                        arguments[0].type = fix;
                        return $.event.handle.apply(this, arguments);
                    }
                };
                function handler(e) {
                    e = $.event.fix(e);
                    e.type = fix;
                    return $.event.handle.call(this, e);
                }
            });
        };
        $.extend($.fn, {
            validateDelegate: function(delegate, type, handler) {
                return this.bind(type, function(event) {
                    var target = $(event.target);
                    if (target.is(delegate)) {
                        return handler.apply(target, arguments);
                    }
                });
            }
        });
    })(jQuery);
//});
/**
 * jQuery Validation Plugin 1.9.0
 *
 * http://bassistance.de/jquery-plugins/jquery-plugin-validation/
 * http://docs.jquery.com/Plugins/Validation
 *
 * Copyright (c) 2006 - 2011 Jrn Zaefferer
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */

(function() {

	function stripHtml(value) {
		// remove html tags and space chars
		return value.replace(/<.[^<>]*?>/g, ' ').replace(/&nbsp;|&#160;/gi, ' ')
		// remove numbers and punctuation
		.replace(/[0-9.(),;:!?%#$'"_+=\/-]*/g,'');
	}
	jQuery.validator.addMethod("maxWords", function(value, element, params) {
	    return this.optional(element) || stripHtml(value).match(/\b\w+\b/g).length < params;
	}, jQuery.validator.format("Please enter {0} words or less."));

	jQuery.validator.addMethod("minWords", function(value, element, params) {
	    return this.optional(element) || stripHtml(value).match(/\b\w+\b/g).length >= params;
	}, jQuery.validator.format("Please enter at least {0} words."));

	jQuery.validator.addMethod("rangeWords", function(value, element, params) {
	    return this.optional(element) || stripHtml(value).match(/\b\w+\b/g).length >= params[0] && value.match(/bw+b/g).length < params[1];
	}, jQuery.validator.format("Please enter between {0} and {1} words."));

})();

jQuery.validator.addMethod("letterswithbasicpunc", function(value, element) {
	return this.optional(element) || /^[a-z-.,()'\"\s]+$/i.test(value);
}, "Letters or punctuation only please");

jQuery.validator.addMethod("alphanumeric", function(value, element) {
	return this.optional(element) || /^\w+$/i.test(value);
}, "Letters, numbers, spaces or underscores only please");

jQuery.validator.addMethod("lettersonly", function(value, element) {
	return this.optional(element) || /^[a-z]+$/i.test(value);
}, "Letters only please");

jQuery.validator.addMethod("nowhitespace", function(value, element) {
	return this.optional(element) || /^\S+$/i.test(value);
}, "No white space please");

jQuery.validator.addMethod("ziprange", function(value, element) {
	return this.optional(element) || /^90[2-5]\d\{2}-\d{4}$/.test(value);
}, "Your ZIP-code must be in the range 902xx-xxxx to 905-xx-xxxx");

jQuery.validator.addMethod("integer", function(value, element) {
	return this.optional(element) || /^-?\d+$/.test(value);
}, "A positive or negative non-decimal number please");

/**
* Return true, if the value is a valid vehicle identification number (VIN).
*
* Works with all kind of text inputs.
*
* @example <input type="text" size="20" name="VehicleID" class="{required:true,vinUS:true}" />
* @desc Declares a required input element whose value must be a valid vehicle identification number.
*
* @name jQuery.validator.methods.vinUS
* @type Boolean
* @cat Plugins/Validate/Methods
*/
jQuery.validator.addMethod(
	"vinUS",
	function(v){
		if (v.length != 17)
			return false;
		var i, n, d, f, cd, cdv;
		var LL    = ["A","B","C","D","E","F","G","H","J","K","L","M","N","P","R","S","T","U","V","W","X","Y","Z"];
		var VL    = [1,2,3,4,5,6,7,8,1,2,3,4,5,7,9,2,3,4,5,6,7,8,9];
		var FL    = [8,7,6,5,4,3,2,10,0,9,8,7,6,5,4,3,2];
		var rs    = 0;
		for(i = 0; i < 17; i++){
		    f = FL[i];
		    d = v.slice(i,i+1);
		    if(i == 8){
		        cdv = d;
		    }
		    if(!isNaN(d)){
		        d *= f;
		    }
		    else{
		        for(n = 0; n < LL.length; n++){
		            if(d.toUpperCase() === LL[n]){
		                d = VL[n];
		                d *= f;
		                if(isNaN(cdv) && n == 8){
		                    cdv = LL[n];
		                }
		                break;
		            }
		        }
		    }
		    rs += d;
		}
		cd = rs % 11;
		if(cd == 10){cd = "X";}
		if(cd == cdv){return true;}
		return false;
	},
	"The specified vehicle identification number (VIN) is invalid."
);

/**
  * Return true, if the value is a valid date, also making this formal check dd/mm/yyyy.
  *
  * @example jQuery.validator.methods.date("01/01/1900")
  * @result true
  *
  * @example jQuery.validator.methods.date("01/13/1990")
  * @result false
  *
  * @example jQuery.validator.methods.date("01.01.1900")
  * @result false
  *
  * @example <input name="pippo" class="{dateITA:true}" />
  * @desc Declares an optional input element whose value must be a valid date.
  *
  * @name jQuery.validator.methods.dateITA
  * @type Boolean
  * @cat Plugins/Validate/Methods
  */
jQuery.validator.addMethod(
	"dateITA",
	function(value, element) {
		var check = false;
		var re = /^\d{1,2}\/\d{1,2}\/\d{4}$/;
		if( re.test(value)){
			var adata = value.split('/');
			var gg = parseInt(adata[0],10);
			var mm = parseInt(adata[1],10);
			var aaaa = parseInt(adata[2],10);
			var xdata = new Date(aaaa,mm-1,gg);
			if ( ( xdata.getFullYear() == aaaa ) && ( xdata.getMonth () == mm - 1 ) && ( xdata.getDate() == gg ) )
				check = true;
			else
				check = false;
		} else
			check = false;
		return this.optional(element) || check;
	},
	"Please enter a correct date"
);

jQuery.validator.addMethod("dateNL", function(value, element) {
		return this.optional(element) || /^\d\d?[\.\/-]\d\d?[\.\/-]\d\d\d?\d?$/.test(value);
	}, "Vul hier een geldige datum in."
);

jQuery.validator.addMethod("time", function(value, element) {
	return this.optional(element) || /^([01]\d|2[0-3])(:[0-5]\d){0,2}$/.test(value);
}, "Please enter a valid time, between 00:00 and 23:59");
jQuery.validator.addMethod("time12h", function(value, element) {
	return this.optional(element) || /^((0?[1-9]|1[012])(:[0-5]\d){0,2}(\ [AP]M))$/i.test(value);
}, "Please enter a valid time, between 00:00 am and 12:00 pm");

/**
 * matches US phone number format
 *
 * where the area code may not start with 1 and the prefix may not start with 1
 * allows '-' or ' ' as a separator and allows parens around area code
 * some people may want to put a '1' in front of their number
 *
 * 1(212)-999-2345
 * or
 * 212 999 2344
 * or
 * 212-999-0983
 *
 * but not
 * 111-123-5434
 * and not
 * 212 123 4567
 */
jQuery.validator.addMethod("phoneUS", function(phone_number, element) {
    phone_number = phone_number.replace(/\s+/g, "");
	return this.optional(element) || phone_number.length > 9 &&
		phone_number.match(/^(1-?)?(\([2-9]\d{2}\)|[2-9]\d{2})-?[2-9]\d{2}-?\d{4}$/);
}, "Please specify a valid phone number");

jQuery.validator.addMethod('phoneUK', function(phone_number, element) {
return this.optional(element) || phone_number.length > 9 &&
phone_number.match(/^(\(?(0|\+44)[1-9]{1}\d{1,4}?\)?\s?\d{3,4}\s?\d{3,4})$/);
}, 'Please specify a valid phone number');

jQuery.validator.addMethod('mobileUK', function(phone_number, element) {
return this.optional(element) || phone_number.length > 9 &&
phone_number.match(/^((0|\+44)7(5|6|7|8|9){1}\d{2}\s?\d{6})$/);
}, 'Please specify a valid mobile number');

// TODO check if value starts with <, otherwise don't try stripping anything
jQuery.validator.addMethod("strippedminlength", function(value, element, param) {
	return jQuery(value).text().length >= param;
}, jQuery.validator.format("Please enter at least {0} characters"));

// same as email, but TLD is optional
jQuery.validator.addMethod("email2", function(value, element, param) {
	return this.optional(element) || /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)*(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i.test(value);
}, jQuery.validator.messages.email);

// same as url, but TLD is optional
jQuery.validator.addMethod("url2", function(value, element, param) {
	return this.optional(element) || /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)*(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(value);
}, jQuery.validator.messages.url);

// NOTICE: Modified version of Castle.Components.Validator.CreditCardValidator
// Redistributed under the the Apache License 2.0 at http://www.apache.org/licenses/LICENSE-2.0
// Valid Types: mastercard, visa, amex, dinersclub, enroute, discover, jcb, unknown, all (overrides all other settings)
jQuery.validator.addMethod("creditcardtypes", function(value, element, param) {

	if (/[^0-9-]+/.test(value))
		return false;

	value = value.replace(/\D/g, "");

	var validTypes = 0x0000;

	if (param.mastercard)
		validTypes |= 0x0001;
	if (param.visa)
		validTypes |= 0x0002;
	if (param.amex)
		validTypes |= 0x0004;
	if (param.dinersclub)
		validTypes |= 0x0008;
	if (param.enroute)
		validTypes |= 0x0010;
	if (param.discover)
		validTypes |= 0x0020;
	if (param.jcb)
		validTypes |= 0x0040;
	if (param.unknown)
		validTypes |= 0x0080;
	if (param.all)
		validTypes = 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040 | 0x0080;

	if (validTypes & 0x0001 && /^(51|52|53|54|55)/.test(value)) { //mastercard
		return value.length == 16;
	}
	if (validTypes & 0x0002 && /^(4)/.test(value)) { //visa
		return value.length == 16;
	}
	if (validTypes & 0x0004 && /^(34|37)/.test(value)) { //amex
		return value.length == 15;
	}
	if (validTypes & 0x0008 && /^(300|301|302|303|304|305|36|38)/.test(value)) { //dinersclub
		return value.length == 14;
	}
	if (validTypes & 0x0010 && /^(2014|2149)/.test(value)) { //enroute
		return value.length == 15;
	}
	if (validTypes & 0x0020 && /^(6011)/.test(value)) { //discover
		return value.length == 16;
	}
	if (validTypes & 0x0040 && /^(3)/.test(value)) { //jcb
		return value.length == 16;
	}
	if (validTypes & 0x0040 && /^(2131|1800)/.test(value)) { //jcb
		return value.length == 15;
	}
	if (validTypes & 0x0080) { //unknown
		return true;
	}
	return false;
}, "Please enter a valid credit card number.");

jQuery.validator.addMethod("ipv4", function(value, element, param) {
    return this.optional(element) || /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/i.test(value);
}, "Please enter a valid IP v4 address.");

jQuery.validator.addMethod("ipv6", function(value, element, param) {
    return this.optional(element) || /^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$/i.test(value);
}, "Please enter a valid IP v6 address.");

/**
  * Return true if the field value matches the given format RegExp
  *
  * @example jQuery.validator.methods.pattern("AR1004",element,/^AR\d{4}$/)
  * @result true
  *
  * @example jQuery.validator.methods.pattern("BR1004",element,/^AR\d{4}$/)
  * @result false
  *
  * @name jQuery.validator.methods.pattern
  * @type Boolean
  * @cat Plugins/Validate/Methods
  */
jQuery.validator.addMethod("pattern", function(value, element, param) {
    return this.optional(element) || param.test(value);
}, "Invalid format.");


//mod.defineModule("validator", ["base","waf","labelContainer","validator_i18n","validatorMetadata"], function() {
    (function ($, undefined) {
        var requiredSpanWidth = 0;
        $.widget("ui.wafFormValidator", {
            options:{
                formId:null,
                formValidateOptions:null,
                validateOnSumbit:true
    //			submitHandler  : null,
    //			onsubmit : true,
    //			errorShowMode : "embeded",
    //			onfocus : true,
    //			onblur : true,
    //			onkeyup : true,
    //			onchange : true,
    //			onclick : true,
    //			errorClass : "error"
            }, //////////////////////////////////////////////////
            _create:function () {
                var self = this;
                $(this.element).wafValidator(self.options);
                this.options.formValidateOptions = _getFormValidateOptions(self.options);
            },

            destory:function () {
                this.element.removeClass(defaultClass);
                this.container.remove();
                $.Widget.prototype.destroy.call(this);
            },

            widget:function () {
                return this.element;
            },

            _setOption:function (key, value) {
                if (key == "formValidateOptions") {
                    var validator = waf.data(this.element[0], "validator");
                    var options = value;
                    if (options.errorContainer === null) {
                        if (validator.settings.errorContainer && validator.settings.errorContainer.length > 0) {
                            validator.settings.errorContainer.hide();
                            validator.settings.errorContainer.children().hide();
                        }
                        validator.settings.errorContainer = null;
                        validator.toShow.remove(validator.settings.errorContainer);
                    } else if (options.errorContainer !== undefined && options.errorContainer != "undefined") {
                        validator.settings.errorContainer = options.errorContainer;
                        validator.toShow.add(options.errorContainer);
                    }

                    if (options.validateOnSumbit !== undefined) {
                        validator.settings.validateOnSumbit = options.validateOnSumbit;
                    }

                    if (options.errorClass !== undefined) {
                        validator.settings.errorClass = options.errorClass;
                    }

                    if (options.submitHandler !== undefined) {
                        validator.settings.submitHandler = options.submitHandler;
                    }

                    if (options.errorShowMode !== undefined) {
                        validator.settings.errorShowMode = options.errorShowMode;
                        if (options.errorShowMode == "float") {
                            var label = $(validator.settings.errorElement + "." + validator.settings.errorClass, validator.errorContext);//validator.errorsFor(this);
                            label.remove();
                        }
                    }

                    if (options.onfocus == true) {
                        //validator.settings.focus = options.onfocus;
                        if (!validator.settings.onfocus) {
                            validator.settings.onfocus = _focusFuncWhenValidate;
                        }
                    } else if (options.onfocus == false) {
                        validator.settings.onfocus = null;
                    }

                    if (options.onblur == true) {
                        if (!validator.settings.onblur) {
                            validator.settings.onblur = _blurFuncWhenValidate;
                        }
                    } else if (options.onblur == false) {
                        validator.settings.onblur = null;
                    }

                    if (options.onkeyup == true) {
                        if (!validator.settings.onkeyup) {
                            validator.settings.onkeyup = _keyupFuncWhenValidate;
                        }
                    } else if (options.onkeyup == false) {
                        validator.settings.onkeyup = null;
                    }

                    if (options.onchange == true) {
                        if (!validator.settings.onchange) {
                            validator.settings.onchange = _datachangeFuncWhenValidate;
                        }
                    } else if (options.onchange == false) {
                        validator.settings.onchange = null;
                    }

                    if (options.onclick == true) {
                        if (!validator.settings.onclick) {
                            validator.settings.onclick = _clickFuncWhenValidate;
                        }
                    } else if (options.onclick == false) {
                        validator.settings.onclick = null;
                    }
                    this.options.formValidateOptions = _getFormValidateOptions(validator.settings);
                }
            },
            resetFormValidate:function () {
                var validator = $.data(this.element[0], "validator");
                validator.resetForm();
            },
            validateForm:function (full) {
                var validator = $.data(this.element[0], "validator");
                this.element.data('submitted',true);
                var ret = validator.form(null,full);
                if(ret===false){
                    var firstElem = validator.errorList[0].element;
                    if ($(firstElem).hasClass("ui-f7-frame")) {
                        window.setTimeout(function () {
                            $(firstElem).find("input.ui-f7").focus()
                        }, 1);
                    } else if ($(firstElem).attr("ctrlrole") === "select") {
                        window.setTimeout(function () {
                            $(firstElem).next(".ui-multiselect").focus()
                        }, 1);
                    } else {
                        window.setTimeout(function () {
                            $(firstElem).focus()
                        }, 1);
                    }
                }
                return ret;
            },
            getElemNumberOfInvalids:function () {
                var validator = $.data(this.element[0], "validator");
                return validator.numberOfInvalids();
            },
            getElemsOfInvalids:function () {
                var validator = $.data(this.element[0], "validator");
                return validator.elements();
            },
            validateElement:function (elem) {
                var validator = $.data(this.element[0], "validator");
                return validator.element(elem);
            },
            validateChangedRow:function (table, checkForm) {
                if (this.element.length > 0 && table && table.length > 0) {
                    var validator = $.data(this.element[0], "validator");
                    if (validator) {
                        return validator.gridChangedRow(table, checkForm);
                    }
                }
            },
            showErrors:function(errors){
                if(!errors) return;
                var validator = $.data(this.element[0], "validator");
                if(validator){
                    if(errors && $.isArray(errors)){
                        for(var i=0;i<errors.length;i++){
                            validator.showLabel(errors[i].element,errors[i].message);
                        }
                    }
                }
            }
        });

        function _getFormValidateOptions(settings) {
            var tempJson = {};
            tempJson.errorContainer = settings.errorContainer;
            tempJson.onsubmit = settings.validateOnSumbit;
            tempJson.validateOnSumbit = settings.onsubmit;
            tempJson.errorClass = settings.errorClass;
            tempJson.submitHandler = settings.submitHandler;
            tempJson.errorShowMode = settings.errorShowMode;
            if (settings.onfocus && $.isFunction(settings.onfocus))
                tempJson.onfocus = true;
            else
                tempJson.onfocus = false;

            if (settings.onblur && $.isFunction(settings.onblur))
                tempJson.onblur = true;
            else
                tempJson.onblur = false;

            if (settings.onkeyup && $.isFunction(settings.onkeyup))
                tempJson.onkeyup = true;
            else
                tempJson.onkeyup = false;

            if (settings.onchange && $.isFunction(settings.onchange))
                tempJson.onchange = true;
            else
                tempJson.onchange = false;

            if (settings.onclick && $.isFunction(settings.onclick))
                tempJson.onclick = true;
            else
                tempJson.onclick = false;

            return tempJson;
        }

        function _focusFuncWhenValidate(element, event) {
            this.lastActive = element;
            if ($(element).attr("validatetrigger") && $(element).attr("validatetrigger").indexOf("focus") < 0)
                return;

            if (!this.checkable(element) && (element.name in this.submitted || (!this.settings.validateOnSumbit && $(element).attr("validateOnSumbit") != 'true') || $(element).attr("validateOnSumbit") == 'false')) { // || !this.optional(element)
                this.element(element);
            }
            // hide error label and remove error class on focus if enabled
            if (this.settings.focusCleanup && !this.blockFocusCleanup) {
                this.settings.unhighlight && this.settings.unhighlight.call(this, element, this.settings.errorClass, this.settings.validClass);
                this.addWrapper(this.errorsFor(element)).hide();

                if ($(element).attr('ctrlrole') == 'promptBox' || $(element).attr('ctrlrole') == 'F7') {
                    var f7Elm = $(element).closest(".ui-f7-frame");
                    this.settings.unhighlight.call(this, f7Elm, this.settings.errorClass, this.settings.validClass);
                } else if ($(element).attr('ctrlrole') == 'datePicker') {
                    var dateElm = $(element).closest(".ui-datepicker-frame");
                    this.settings.unhighlight.call(this, dateElm, this.settings.errorClass, this.settings.validClass);
                }else if($(element).attr('ctrlrole')=='multiLangBox'){
                    var langElm = $(element).closest(".ui-multiLangBox");
                    this.settings.unhighlight.call(this, langElm, this.settings.errorClass, this.settings.validClass);
                }else if($(element).attr('ctrlrole')=='multiLangArea'){
                    var langElm = $(element).closest(".ui-multiLangArea");
                    this.settings.unhighlight.call(this, langElm, this.settings.errorClass, this.settings.validClass);
                }else if($(element).attr('ctrlrole')=='timePicker'){
                    var langElm = $(element).closest(".ui-timepicker-frame");
                    this.settings.unhighlight.call(this, langElm, this.settings.errorClass, this.settings.validClass);
                }
            }
        }


        function _blurFuncWhenValidate(element, event) {
            $("div.ui-validate-div").remove();
            $("#floatCorner_top").remove();
            if ($(element).attr("validatetrigger") && $(element).attr("validatetrigger").indexOf("blur") < 0)
                return;
            if (!this.checkable(element) && (element.name in this.submitted || (!this.settings.validateOnSumbit && $(element).attr("validateOnSumbit") != 'true') || $(element).attr("validateOnSumbit") == 'false')) { // || !this.optional(element)
                this.element(element);
            }
        }


        function _keyupFuncWhenValidate(element, event) {
            if ($(element).attr("validatetrigger") && $(element).attr("validatetrigger").indexOf("keyup") < 0)
                return;
            if (element.name in this.submitted || element == this.lastElement || (!this.settings.validateOnSumbit && $(element).attr("validateOnSumbit") != 'true') || $(element).attr("validateOnSumbit") == 'false') {
                this.element(element);
            }
        }


        function _datachangeFuncWhenValidate(element, event) {
            if ($(element).attr("validatetrigger") && $(element).attr("validatetrigger").indexOf("change") < 0)
                return;
            if (element.name in this.submitted || element == this.lastElement || (!this.settings.validateOnSumbit && $(element).attr("validateOnSumbit") != 'true') || $(element).attr("validateOnSumbit") == 'false') {
                this.element(element);
            }
        }


        function _clickFuncWhenValidate(element, event) {
            if (element.type && element.type == "checkbox") {
                if ($("input[name='" + element.name + "']").length > 1) {
                    element = $("input[name='" + element.name + "']")[0];
                }
            }

            if ($(element).attr("validatetrigger") && $(element).attr("validatetrigger").indexOf("click") < 0)
                return;
            // click on selects, radiobuttons and checkboxes
            if (element.name in this.submitted || (!this.settings.validateOnSumbit && $(element).attr("validateOnSumbit") != 'true') || $(element).attr("validateOnSumbit") == 'false')
                this.element(element);
            // or option elements, check parent select in that case
            else if (element.parentNode.name in this.submitted || (!this.settings.validateOnSumbit && $(element).attr("validateOnSumbit") != 'true') || $(element).attr("validateOnSumbit") == 'false')
                this.element(element.parentNode);
        }

        $.fn.wafValidator = function (arg1, arg2, arg3) {
            var numargs = arguments.length; // 
            var opts = {};
            if (numargs == 1) {
                opts = arguments[0];

                if (!opts.errorPlacement) {
                    opts.errorPlacement = wafErrorPlacement;
                }

                opts.ignore = "";

                var elements = this.find("input, select, textarea")
                    .not(":submit, :reset, :image, [disabled]");

                var rules = '';
                var msgs = '';
                $.each(elements, function (i, item) {
                    if ($(item).attr('customvalidate')) {
                        //rules+=item.name + ":{" + $(item).attr('customvalidate') + ":true},";
                        if ($(item).attr('remoteRule')) {
                            rules += "'" + item.name + "'" + ":{" + "'" + item.name + "'" + ":true,";
                        } else {
                            rules += "'" + item.name + "'" + ":{" + "'" + item.name + "'" + ":true},";
                        }
                    }
                    if ($(item).attr('remoteRule')) {
                        if ($(item).attr('customvalidate')) {
                            rules += getRemoteJsonStr($(item).attr('remoteRule'), item) + "},";
                        } else {
                            rules += "'" + item.name + "'" + ":{" + getRemoteJsonStr($(item).attr('remoteRule'), item) + "},";
                        }
                    }

                    if ($(item).attr('validateErrMsg') && $(item).attr('validateErrMsg').indexOf(':') > 0) {
                        msgs += "'" + item.name + "'"  + ":{" + $(item).attr('validateErrMsg') + "},";
                        if (!$(item).attr('errorShowMode')) {
                            $(item).attr('errorShowMode', opts.errorShowMode);
                        }
                    }
                });
                if (rules.length > 0) {
                    rules = rules.substring(0, rules.length - 1);
                    rules = "{" + rules + "}";
                    opts.rules = {};
                    opts.rules = eval('(' + rules + ')');
                }


                if (msgs.length > 0) {
                    msgs = msgs.substring(0, msgs.length - 1);
                    msgs = "{" + msgs + "}";
                    opts.messages = {};
                    opts.messages = eval('(' + msgs + ')');
                }

                if (opts.onfocus == undefined || opts.onfocus) {
                    opts.onfocus = _focusFuncWhenValidate;
                }

                if (opts.onblur == undefined || opts.onblur) {
                    opts.onblur = _blurFuncWhenValidate;
                }

                if (opts.onkeyup == undefined || opts.onkeyup) {
                    opts.onkeyup = _keyupFuncWhenValidate;
                }

                if (opts.onchange == undefined || opts.onchange) {
                    opts.onchange = _datachangeFuncWhenValidate;
                }

                if (opts.onclick == undefined || opts.onclick) {
                    opts.onclick = _clickFuncWhenValidate;
                }

                if(opts.onsubmit!=undefined)
                    opts.validateOnSumbit = opts.onsubmit;

                var validator = this.validate(opts);

                this.bind("invalid-form.validate",opts.showFormInvalid?opts.showFormInvalid: function () {
                    var curForm = waf(validator.currentForm);
                    if ((curForm.data('submitted')==true || validator.settings.validateOnSumbit==false) && opts.errorContainer != "undefined" && $(opts.errorContainer).length > 0) {
                        $(opts.errorContainer).wafMsgArea("show", {
                            type:"info",
                            summaryMsg:jQuery.validator.format(jQuery.validator.messages.summaryMsg,validator.numberOfInvalids()),
                            closeDetailTime:-1
                        });
                    }
                });

                $.each(elements, function (i, item) {
                    if ($(item).is('select')) {
                        var realEnumElem = $("#ui-multiselect-btn-" + item.id);
                        if (realEnumElem) {
                            realEnumElem.bind("click", function () {
                                if (validator.submitted && item.name in validator.submitted)
                                    validator.element($(item));
                            });
                        }
                    }
                });
                return validator;
            } else if (numargs == 2) {
                if (arguments[0] == "option") {
                    var key = arguments[1];
                    if (key == "rules") {
                        return this.attr("validate");
                    } else if (key == "suspendValidate" || key =="suspend") {
                        return this.attr("suspend");
                    } else {
                        return this.attr(key);
                    }
                }else if(arguments[0]=="loadElemValidator"){
                        var elem=this;jsonid=arguments[1];
                        if (elem && jsonid != null) {
                            if ($(elem).attr("name") == undefined) {
                                $(elem).attr("name", $(elem).attr("id"));
                            }
                            if (jsonid.rules) {
                                $(elem).attr("validate", jsonid.rules);
                            }
                            if (jsonid.customvalidate) {
                                $(elem).attr("customvalidate", jsonid.customvalidate);
                            }
                            if (jsonid.errMsg) {
                                $(elem).attr("validateErrMsg", jsonid.errMsg);
                            }

                            if (jsonid.suspend) {
                                $(elem).attr("suspend", jsonid.suspend);
                            }

                            if (jsonid.errorLabelPosition) {
                                $(elem).attr("errorLabelPosition", jsonid.errorLabelPosition);
                            }
                            if (jsonid.errorShowMode) {
                                $(elem).attr("errorShowMode", jsonid.errorShowMode);
                            }

                            if (jsonid.remoteRule) {
                                $(elem).attr("remoteRule", jsonid.remoteRule);
                            }
                            if (jsonid.validatetrigger) {
                                $(elem).attr("validatetrigger", jsonid.validatetrigger);
                            }
                            //alert(jsonid.customvalidate + "-" + $.isFunction(eval(jsonid.customvalidate)));
                            if (jsonid.customvalidate) {
                                if ($(elem).is('select')) {
                                    if($(elem).attr("name").lastIndexOf('_el')==-1){
                                        $.validator.addMethod($(elem).attr("name") + "_el", eval(jsonid.customvalidate), "");//jsonid.errMsg
                                    }else{
                                        $.validator.addMethod($(elem).attr("name"), eval(jsonid.customvalidate), "");//jsonid.errMsg
                                    }
                                } else {
                                    $.validator.addMethod($(elem).attr("name"), eval(jsonid.customvalidate), "");
                                }
                            }
                            if (jsonid.validateOnSumbit!=undefined) {
                                $(elem).attr("validateOnSumbit", jsonid.validateOnSumbit);
                            }
                        }
                }
            } else if (numargs == 3) {
                if (arguments[0] == "option") {
                    var key = arguments[1];
                    opts = arguments[2];
                    if (this.attr("name") == undefined) {
                        this.attr("name", this.attr("id"));
                    }
                    var form = this.closest('form');
                    if(form.length==0) return;
                    var validator = $.data(form[0], "validator");
                    if(!validator) return;
                    if (key == "rules") {
                        var oriValidate =  this.attr("validate");
                        this.attr("validate", opts);
                        try{
                            if(opts.indexOf("required")>=0){
                                var oriRequired = oriValidate==undefined?null:eval('(' + "{" + oriValidate + "}" + ')').required;
                                var newRequired = eval('(' + "{" + opts + "}" + ')').required;
                                if(newRequired!=oriRequired){
                                    var lc = this.closest("div.ui-lablecontainer");
                                    if(lc && lc.length>0){
                                        lc.wafLabelContainer('initRequiredMask');
                                    }
                                }
                            }
                        }catch(e){

                        }

                    } else if (key == "errMsg") {
                        this.attr("errMsg", opts);
                        validator.settings.messages[this.attr("name")] = eval('({' + opts + '})');
                    } else if (key == "customvalidate") {
                        this.attr("customvalidate", opts);
                        $.validator.addMethod(this.attr("name"), eval(opts), "");
                        validator.settings.rules[this.attr("name")] = eval('({' + this.attr("name") + ':true})');
                        //                    }
                    } else if (key == "validatetrigger") {
                        this.attr("validatetrigger", opts);
                    } else if (key == "errorLabelPosition") {
                        this.attr("errorLabelPosition", opts);
                    } else if (key == "errorShowMode") {
                        this.attr("errorShowMode", opts);
                        if (opts == "float") {
                            var label = $(validator.settings.errorElement + "." + validator.settings.errorClass, validator.errorContext);//validator.errorsFor(this);
                            label.remove();
                        }
                    } else if (key == "validateOnSumbit") {
                        this.attr("validateOnSumbit", opts);
                    } else if (key == "remoteRule") {
                        this.attr("remoteRule", opts);
                        var rules = "";
                        if (this.attr('customvalidate')) {
                            rules += getRemoteJsonStr(this.attr('remoteRule'), this[0]) + "}";
                        } else {
                            rules += getRemoteJsonStr(this.attr('remoteRule'), this[0]);
                        }
                        validator.settings.rules[this.attr("name")] = eval('({' + rules + '})');
                    } else if (key == "suspendValidate"|| key =="suspend") {
                        if (opts == true || opts == "true") {
                            this.attr('suspend', "true");
                            var lablecontainer = this.closest(".ui-lablecontainer");
                            if (lablecontainer && lablecontainer.length > 0 && lablecontainer.find('span[role=required]').length > 0) {
                                lablecontainer.find('span[role=required]').html("");
                            }
                        } else {
                            this.removeAttr('suspend');
                            if (this.attr("validate")) {
                                var lablecontainer = this.closest(".ui-lablecontainer");
                                if (lablecontainer && lablecontainer.length > 0) {
                                    if (this.attr("validate").indexOf('required:true') >= 0) {
                                        lablecontainer.find('span[role=required]').html("*");
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        $.validator.prototype.element = function (element) {
            if (!this.settings.validateOnSumbit || $(element).attr("validateOnSumbit") == 'false') {
                this.checkElems = this.elements();

                var isInCheckElems = false;
                for (var i = 0; i < this.checkElems.size(); i++) {
                    if ($(element).attr("name") && ($(element).is(":radio") || $(element).is(":checkbox"))) {
                        if ($(this.checkElems[i]).is(":radio") || $(this.checkElems[i]).is(":checkbox")) {
                            if ($(element).attr("name") == $(this.checkElems[i]).attr("name")) {
                                isInCheckElems = true;
                                break;
                            }
                        }
                    } else {
                        if ($(element).attr("id") == $(this.checkElems[i]).attr("id")) {
                            isInCheckElems = true;
                            break;
                        }
                    }
                }
                if (!isInCheckElems) return;
            }

            element = this.validationTargetFor(this.clean(element));
            if (!element) return;
            this.lastElement = element;
            this.prepareElement(element);
            this.currentElements = $(element);
            var result = this.check(element);
            if (result) {
                delete this.invalid[element.name];
                //add by jlg
                var tdparent = this.getTdParent($(element));
                if (tdparent && tdparent != null) {
                    $(tdparent).removeClass("errorinput");
                }
            } else {
                this.invalid[element.name] = true;
            }
            if (!this.numberOfInvalids()) {
                // Hide error containers on last error
                this.toHide = this.toHide.add(this.containers);
            }
            this.showErrors();
            return result;
        }

        $.validator.attributeRules = function (element) {
            var rules = {};
            var $element = $(element);

            if ($element.attr('validate')) {
                rules = eval('({' + $element.attr('validate') + '})');
    //			if(validateAttr){
    //				for (var method in $.validator.methods) {
    //					var value=validateAttr[method];
    //					rules[method] = value;
    //				}
    //			}
            } else {
                for (var method in $.validator.methods) {
                    var value;
                    // If .prop exists (jQuery >= 1.6), use it to get true/false for required
                    if (method === 'required' && typeof $.fn.prop === 'function') {
                        value = $element.prop(method);
                    } else {
                        value = $element.attr(method);
                    }
                    if (value) {
                        rules[method] = value;
                    } else if ($element[0].getAttribute("type") === method) {
                        rules[method] = true;
                    }
                }

                // maxlength may be returned as -1, 2147483647 (IE) and 524288 (safari) for text inputs
                if (rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength)) {
                    delete rules.maxlength;
                }
            }

            return rules;
        },

            $.validator.prototype.initElement = function (element,doCheckQuickly) {
                if (!this.settings.validateOnSumbit || $(element).attr("validateOnSumbit") == 'false') {
                    //if(!this.checkElems){
                    this.checkElems = this.elements();
                    //}
                    var isInCheckElems = false;
                    for (var i = 0; i < this.checkElems.size(); i++) {
                        if ($(element).attr("name") && ($(element).is(":radio") || $(element).is(":checkbox"))) {
                            if ($(this.checkElems[i]).is(":radio") || $(this.checkElems[i]).is(":checkbox")) {
                                if ($(element).attr("name") == $(this.checkElems[i]).attr("name")) {
                                    isInCheckElems = true;
                                    break;
                                }
                            }
                        } else {
                            if ($(element).attr("id") == $(this.checkElems[i]).attr("id")) {
                                isInCheckElems = true;
                                break;
                            }
                        }
                    }
                    if (!isInCheckElems) return;
                }

                var msg = $(element).attr('validateErrMsg')||"";
                msg = "{" + msg + "}";
                var messages = {};
                try {
                    messages = eval('(' + msg + ')');
                } catch (e) {
                    alert(e);
                }
                if (messages)
                    this.settings.messages[$(element).attr('name')] = $.extend(this.settings.messages[$(element).attr('name')], messages);

                element = this.validationTargetFor(this.clean(element));
                if (!element) return;
                /////errors[element.name] = previous.message

                //
                if ($(element).attr("customvalidate") && $.isFunction(eval($(element).attr("customvalidate")))) {
                    var rule = eval( "({'" + $(element).attr("name") + "':{'" + $(element).attr("name") + "'" + ":true}" + "})" );

                    var validator = $.data(element.form, 'validator');
                    validator.settings.rules = $.extend(validator.settings.rules,eval(rule));


                    if ($(element).is('select')) {
                        if($(element).attr("name").lastIndexOf('_el')){
                            $.validator.addMethod($(element).attr("name") + "_el", eval($(element).attr("customvalidate")), "");//jsonid.errMsg
                        }else{
                            $.validator.addMethod($(element).attr("name"), eval($(element).attr("customvalidate")), "");//jsonid.errMsg
                        }
                    } else {
                        $.validator.addMethod($(element).attr("name"), eval($(element).attr("customvalidate")), "");
                    }
                }

                this.lastElement = element;
                this.prepareElement(element);
                this.currentElements = $(element);
                if(doCheckQuickly==undefined || doCheckQuickly!=false){
                    var result = this.check(element);
                    if (result) {
                        delete this.invalid[element.name];
                        //add by jlg
                        var tdparent = this.getTdParent($(element));
                        if (tdparent && tdparent != null) {
                            $(tdparent).removeClass("errorinput");
                        }
                    } else {
                        this.invalid[element.name] = true;
                    }
                    if (!this.numberOfInvalids()) {
                        // Hide error containers on last error
                        this.toHide = this.toHide.add(this.containers);
                    }
                    this.showErrors();
                    return result;
                }
            }

        $.validator.prototype.form = function (errors) {
            this.checkForm();
            $.extend(this.submitted, this.errorMap);
            this.invalid = $.extend({}, this.errorMap);
            if (!this.valid())
                $(this.currentForm).triggerHandler("invalid-form", [this]);
            this.showErrors(false, 'form');
            return this.valid();
        }

        $.validator.prototype.form = function (errors, full) {
            this.checkForm();
            if (full && full === true) {
                //
                this.checkGrid(errors);
            }
            $.extend(this.submitted, this.errorMap);
            this.invalid = $.extend({}, this.errorMap);
            if (!this.valid())
                $(this.currentForm).triggerHandler("invalid-form", [this]);
            this.showErrors(false, 'form');
            return this.valid();
        }

        $.validator.prototype.gridChangedRow = function (table, checkForm) {
            if (checkForm && checkForm === true) {
                this.checkForm();
            }
            if (table && table.length > 0) {
                //
                this.checkChangedRow(table);
            }
            $.extend(this.submitted, this.errorMap);
            this.invalid = $.extend({}, this.errorMap);
            if (!this.valid())
                $(this.currentForm).triggerHandler("invalid-form", [this]);
            //this.showErrors(false, 'form');
            return this.valid();
        }

        //add by jlg
        $.validator.prototype.checkChangedRow = function (table) {
            if (table && table.length > 0) {
                var $t = table[0];
                if (!$t.grid || $t.p.cellEdit !== true) {
                    return;
                }
                //colModels
                var rowdatas = $(table).jqGrid("getChangedRows");
                rowdatas = rowdatas.modifys;
                if (rowdatas && rowdatas.length > 0) {
                    for (var i = 0; i < rowdatas.length; i++) {
                        this.checkGridRow(null, table, rowdatas[i], rowdatas[i].id);
                    }
                }
            }
        }

        //add by jlg
        $.validator.prototype.checkGrid = function (errors) {
            var table = $(this.currentForm).find("table.ui-jqgrid-btable");
            if (table && table.length > 0) {
                var $t = table[0];
                if (!$t.grid || $t.p.cellEdit !== true) {
                    return;
                }
                //colModels
                var rowIds = $(table).jqGrid("getDataIDs");
                if (rowIds && rowIds.length > 0) {
                    for (var i = 0; i < rowIds.length; i++) {
                        var rowData = $(table).jqGrid("getRowRealData", rowIds[i]);
                        this.checkGridRow(errors, table, rowData, rowIds[i]);
                    }
                }
            }
        }

        $.validator.prototype.checkGridRow = function (errors, table, rowData, rowId) {
            if (rowData && table && table.length > 0) {
                var value;
                for (var prop in rowData) {
                    value = rowData[prop];
                    this.checkGridCell(errors, table, prop, value, rowId);
                }
            }
        }

        $.validator.prototype.checkGridCell = function (errors, table, prop, value, rowId) {
            if (prop === "rn" || prop === "cb") return;
            var cm = $(table).jqGrid("getCellConfig",prop,rowId), editop, validateop, ret,iCol = $.jgrid.getIndex(prop,table[0]);
            editop = cm.editoptions;
            validateop = editop ? editop.validateJson : undefined;
            if (validateop) {
                value = value || "";
                ret = this.createElement(table, prop, value, rowId);
                if (ret != "undefined" && ret === false) {
                    //
                    var cell = $(table).jqGrid("getCellObject", rowId, iCol);
                    if (cell) {
                        cell.addClass("errorinput");
                    }
                } else if (ret === true) {
                    var cell = $(table).jqGrid("getCellObject", rowId, iCol);
                    if (cell.hasClass("errorinput")) {
                        cell.removeClass("errorinput");
                    }
                }
            }
        }

        $.validator.prototype.createElement = function (table, col, value, rowId) {
            var cellEditorConfig = $(table).jqGrid("getCellConfig", col, rowId);
            var iRow = $(table).jqGrid("getRowIndex", rowId);
            var edittype = cellEditorConfig.edittype,editoptions = cellEditorConfig.editoptions;
            var opt = $.extend({grid:table[0]}, editoptions, {id:iRow + "_" + col, name:col});
            var ret = true, elc,iCol = $.jgrid.getIndex(col,table[0]);
            try {
                var type = eval("celleditor."+edittype);
                var cc = $("td:eq(" + iCol + ")", table[0].rows[iRow]);
                var editor = new type(table[0],opt,iRow,iCol,cc);
                editor.init();
                editor.createEditor(value);
                $(this.currentForm).append(editor.elem);
                if("datepicker"==edittype){
                    //
                    if(editor.tmp){
                        var type = editor.opts.datepickerjson.type;
                        var elc = $(editor.elem).find("input.hasDatepicker");
                        if("datetime"===type){
                            var date = $.datepicker.parseDateTime("yy-mm-dd","hh:mm:ss", editor.tmp);
                            $(elc).wafDatePicker("setValue", date);
                        }else{
                            var date = $.datepicker.parseDate("yy-mm-dd",editor.tmp);
                            $(elc).wafDatePicker("setValue", date);
                        }
                        delete editor.tmp;
                    }
                }
                $.powerFloat.hide();
                $(editor.elem).css("display", "none");
                var elements = $("#" + editor.getId());
                elements = $(elements).not(":submit,:reset,:image,[disabled],[suspend='true']");
                if(elements.length>0){
                    ret = this.check(elements);
                }else{ret = ""}
                editor.clear();
            } catch (e) {
                alert(e);
            }
            return ret;
        }

        $.validator.prototype.elements = function () {
            var validator = this,
                rulesCache = {};

            // select all valid inputs inside the form (no submit or reset buttons)
            return $(this.currentForm)
                .find("input, select, textarea")
                .not(":submit, :reset, :image, [disabled],[suspend='true']")
                .not(this.settings.ignore)
                .filter(function () {
                    !this.name && validator.settings.debug && window.console && console.error("%o has no name assigned", this);

                    // select only the first element for each name, and only those with rules specified
                    if (this.name in rulesCache || !validator.objectLength($(this).rules()))
                        return false;

                    rulesCache[this.name] = true;
                    return true;
                });
        }

        $.validator.prototype.showErrors = function (errors, source) {
            if (errors) {
                // add items to error list and map
                $.extend(this.errorMap, errors);
                this.errorList = [];
                for (var name in errors) {
                    this.errorList.push({
                        message:errors[name],
                        element:this.findByName(name)[0]
                    });
                }
                // remove items from success list
                this.successList = $.grep(this.successList, function (element) {
                    return !(element.name in errors);
                });
            }
            this.settings.showErrors
                ? this.settings.showErrors.call(this, this.errorMap, this.errorList)
                : this.defaultShowErrors(source);
        }

        $.validator.prototype.defaultShowErrors = function (source) {
            if (source == 'form') {
    //			var error = this.errorList[0];
    //			this.showLabel( error.element, error.message );
                var k = true;
                for (var i = 0; this.errorList[i]; i++) {
                    var error = this.errorList[i];

                    if($(error.element).attr("grid") && $("#"+$(error.element).attr("id")).length==0){
                        continue;
                    }

                    if ($(error.element).attr('ctrlrole') == 'promptBox' || $(error.element).attr('ctrlrole') == 'F7') {
                        var f7Elm = $(error.element).closest(".ui-f7-frame");
                        this.settings.highlight.call(this, f7Elm, this.settings.errorClass, this.settings.validClass);
                        if (k) {
                            this.showLabel(error.element, error.message);
                            k = !k;
                        }
                    } else if ($(error.element).attr('ctrlrole') == 'datePicker') {
                        var dateElm = $(error.element).closest(".ui-datepicker-frame");
                        this.settings.highlight.call(this, dateElm, this.settings.errorClass, this.settings.validClass);
                        if (k) {
                            this.showLabel(error.element, error.message);
                            k = !k;
                        }
                    }else if($(error.element).attr('ctrlrole') =='multiLangBox'){
                        var langElm = $(error.element).closest(".ui-multiLangBox");
                        this.settings.highlight.call(this, langElm, this.settings.errorClass, this.settings.validClass);
                        if (k) {
                            this.showLabel(error.element, error.message);
                            k = !k;
                        }
                    }else if($(error.element).attr('ctrlrole') == 'multiLangArea'){
                        var langElm = $(error.element).closest(".ui-multiLangArea");
                        this.settings.highlight.call(this, langElm, this.settings.errorClass, this.settings.validClass);
                        if (k) {
                            this.showLabel(error.element, error.message);
                            k = !k;
                        }
                    }else if($(error.element).attr('ctrlrole') == 'timePicker'){
                        var langElm = $(error.element).closest(".ui-timepicker-frame");
                        this.settings.highlight.call(this, langElm, this.settings.errorClass, this.settings.validClass);
                        if (k) {
                            this.showLabel(error.element, error.message);
                            k = !k;
                        }
                    }else if ($(error.element).is(":radio")) {
                        this.settings.highlight && this.settings.highlight.call(this, $(error.element).parent().parent(), this.settings.errorClass, this.settings.validClass);

                        //var radioElm = $(error.element).closest(".ui-radiogroup-span").parent();
                        //this.settings.highlight.call(this, radioElm, this.settings.errorClass, this.settings.validClass);
                        if (k) {
                            this.showLabel(error.element, error.message);
                            k = !k;
                        }
                    }

                    else if ($(error.element).is(":checkbox")) {
                        this.settings.highlight && this.settings.highlight.call(this, $(error.element).parent().parent(), this.settings.errorClass, this.settings.validClass);
                        if (k) {
                            this.showLabel(error.element, error.message);
                            k = !k;
                        }
                    } else if ($(error.element).is("select")) {
                        var realEnumElem = $("#ui-multiselect-btn-" + error.element.id);
                        if (realEnumElem)
                            this.settings.highlight && this.settings.highlight.call(this, realEnumElem, this.settings.errorClass, this.settings.validClass);
                        else
                            this.settings.highlight && this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass);
                        if (k) {
                            this.showLabel(error.element, error.message);
                            k = !k;
                        }
                    } else {
                        this.settings.highlight && this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass);
                        if (k) {
                            this.showLabel(error.element, error.message);
                            k = !k;
                        }
                    }
                    //this.showLabel( error.element, error.message );
                }
            } else {
                for (var i = 0; this.errorList[i]; i++) {
                    var error = this.errorList[i];
                    if ($(error.element).is(":radio") || $(error.element).is(":checkbox")) {
                        this.settings.highlight && this.settings.highlight.call(this, $(error.element).parent().parent(), this.settings.errorClass, this.settings.validClass);
                        this.showLabel(error.element, error.message);
                    } else if ($(error.element).is("select")) {
                        var realEnumElem = $("#ui-multiselect-btn-" + error.element.id);
                        if (realEnumElem)
                            this.settings.highlight && this.settings.highlight.call(this, realEnumElem, this.settings.errorClass, this.settings.validClass);
                        else
                            this.settings.highlight && this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass);
                        this.showLabel(error.element, error.message);
                    } else {

                        if ($(error.element).attr('ctrlrole') == 'promptBox' || $(error.element).attr('ctrlrole') == 'F7') {
                            var f7Elm = $(error.element).closest(".ui-f7-frame");
                            this.settings.highlight && this.settings.highlight.call(this, f7Elm, this.settings.errorClass, this.settings.validClass);
                            this.showLabel(error.element, error.message);
                        } else if ($(error.element).attr('ctrlrole') == 'datePicker') {
                            var dateElm = $(error.element).closest(".ui-datepicker-frame");
                            this.settings.highlight && this.settings.highlight.call(this, dateElm, this.settings.errorClass, this.settings.validClass);
                            this.showLabel(error.element, error.message);
                        }else if($(error.element).attr('ctrlrole') =='multiLangBox'){
                            var langElm = $(error.element).closest(".ui-multiLangBox");
                            this.settings.highlight && this.settings.highlight.call(this, langElm, this.settings.errorClass, this.settings.validClass);
                            this.showLabel(error.element, error.message);
                        }else if($(error.element).attr('ctrlrole') =='multiLangArea'){
                            var langElm = $(error.element).closest(".ui-multiLangArea");
                            this.settings.highlight && this.settings.highlight.call(this, langElm, this.settings.errorClass, this.settings.validClass);
                            this.showLabel(error.element, error.message);
                        }else if($(error.element).attr('ctrlrole') =='timePicker'){
                            var langElm = $(error.element).closest(".ui-timepicker-frame");
                            this.settings.highlight && this.settings.highlight.call(this, langElm, this.settings.errorClass, this.settings.validClass);
                            this.showLabel(error.element, error.message);
                        }
                        else {
                            this.settings.highlight && this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass);
                            this.showLabel(error.element, error.message);
                        }
                    }
                }
            }
            //alert(this.errorList.length);
            var curForm = $(this.currentForm);
            if (this.errorList.length && (curForm.data('submitted')==true || this.settings.validateOnSumbit==false)) {
                this.toShow = this.toShow.add(this.containers);
            }
            if (this.settings.success) {
                for (var i = 0; this.successList[i]; i++) {
                    this.showLabel(this.successList[i]);
                }
            }
            if (this.settings.unhighlight) {
                var elements = this.validElements();
                unhighlightElems(this, elements);
    //			var elements = this.validElements();
    //			if(elements.length>0){
    //				$("div.ui-validate-div").remove();
    //				$("#floatCorner_top").remove();
    //			}
    //			for ( var i = 0;elements[i]; i++ ) {
    //				if($(elements[i]).attr('ctrlrole')=='f7'){
    //					this.settings.unhighlight.call( this, $(elements[i]).parent() , this.settings.errorClass, this.settings.validClass );
    //				}else if($(elements[i]).is(":radio") || $(elements[i]).is(":checkbox")){
    //					this.settings.unhighlight.call( this, $(elements[i]).parent().parent() , this.settings.errorClass, this.settings.validClass );
    //				}else if($(elements[i]).is("select")){
    //					var realEnumElem = $("#ui-multiselect-btn-" + elements[i].id);
    //					if(realEnumElem)
    //						this.settings.unhighlight.call( this, realEnumElem, this.settings.errorClass, this.settings.validClass );
    //					else
    //						this.settings.unhighlight.call( this, elements[i], this.settings.errorClass, this.settings.validClass );
    //				}else{
    //					this.settings.unhighlight.call( this, elements[i], this.settings.errorClass, this.settings.validClass );
    //				}
    //			}
            }
            //if(this.toHide.length>0) alert('1113');
            this.toHide = this.toHide.not(this.toShow);
    //		hideErroeMsgArea(this.toHide,this.settings.errorContainer,this.currentForm);
            this.hideErrors();
            updateMsgAreaNumber(this);
            this.addWrapper(this.toShow).show();
        }

        $.validator.prototype.check = function (element) {
    //		if(element.id.indexOf('rq')>0) alert('rr');
            element = this.validationTargetFor(this.clean(element));

            /**
             * 
             */
            if ($.isFunction(this.settings.onCheckFilter) && this.settings.onCheckFilter.call(this, element) === false) {
                return true;
            }

            var rules = $(element).rules();
            var dependencyMismatch = false;
            for (var method in rules) {
                var rule = { method:method, parameters:rules[method] };
                try {

    //				if($.validator.methods[method]==undefined) alert('und');
    //                var realValue = element.value;
                    var realValue = $(element).val();


                    //onblur
                    if ($(element).attr('ctrlrole') == 'numberField' && $("#" + element.id + "_el")) {
                        if ($(element).attr('grid') === undefined) {
                            if($(element).attr('validatetrigger') != 'keyup'){
                                realValue = $("#" + element.id + "_el").val();
                            }
                            if (realValue == undefined || realValue=='') realValue = "";
                            else realValue = parseFloat(realValue);
                        }else{
                            realValue = $(element).wafNumberField("getValue");
                        }
                    }

                    if (($(element).attr('ctrlrole') == 'promptBox' || $(element).attr('ctrlrole') == 'F7') && $("#" + element.id + "_el")) {
                        if ($(element).attr('grid') === undefined) {
                            realValue = $("#" + element.id + "_el").val();
                            if (realValue == undefined) realValue = "";
                        }
                    }
                    if (($(element).attr('ctrlrole') == 'datePicker') && $("#" + element.id + "_el")) {
                        var tempValue = $("#" + element.id + "_el").val();
                        //if(tempValue!="")
                            realValue = tempValue;
                        if (realValue == undefined) realValue = "";
                    }
                    if(isNaN(realValue)){
                        realValue=realValue.replace(/\r/g, "");
                    }
                    var result = $.validator.methods[method].call(this, realValue, element, rule.parameters);

                    if (result == undefined) result = true;
                    // if a method indicates that the field is optional and therefore valid,
                    // don't mark it as valid when there are no other rules
                    if (result == "dependency-mismatch") {
                        dependencyMismatch = true;
                        continue;
                    }
                    dependencyMismatch = false;

                    if (result == "pending") {
                        this.toHide = this.toHide.not(this.errorsFor(element));
                        return;
                    }

                    if (!result) {
                        this.formatAndAdd(element, rule,undefined,method);
                        return false;
                    }

                    if (result != true && result != 'true') {
                        this.formatAndAdd(element, rule, result,method);
                        return false;
                    }
                } catch (e) {
                    this.settings.debug && window.console && console.log("exception occured when checking element " + element.id
                        + ", check the '" + rule.method + "' method", e);
                    throw e;
                }
            }
            if (dependencyMismatch)
                return;
            if (this.objectLength(rules))
                this.successList.push(element);
            return true;
        }

        $.validator.prototype.elementCheck = function (options) {
            var validator = options.validator;
            var element = options.powerFloat.trigger[0];

            if (element.id.indexOf('ui-multiselect-btn-') >= 0) {
                var selectElemId = element.id.substring(element.id.indexOf('ui-multiselect-btn-') + 19);
                var selectElem = $("#" + selectElemId);
                if (selectElem) element = selectElem[0];
            }
            element = validator.validationTargetFor(element);

            var rules = $(element).rules();
            var dependencyMismatch = false;
            for (var method in rules) {
                var rule = { method:method, parameters:rules[method] };
                try {
                    var result = $.validator.methods[method].call(validator, element.value.replace(/\r/g, ""), element, rule.parameters);

                    if (result == "dependency-mismatch") {
                        dependencyMismatch = true;
                        continue;
                    }
                    dependencyMismatch = false;

                    if (result == "pending") {
                        return;
                    }

                    if (!result) {
                        return false;
                    }

                    if (result != true && result != 'true') {
                        return false;
                    }
                } catch (e) {
                    validator.settings.debug && window.console && console.log("exception occured when checking element " + element.id
                        + ", check the '" + rule.method + "' method", e);
                    throw e;
                }
            }
            if (dependencyMismatch)
                return;
            return true;
        }

        $.validator.prototype.formatAndAdd = function (element, rule, msg, method) {
            var message = msg;
            if (!message) {
                message = this.defaultMessage(element, rule.method),
                    theregex = /\$?\{(\d+)\}/g;
                if (typeof message == "function") {
                    message = message.call(this, rule.parameters, element);
                } else if (theregex.test(message)) {
                    message = jQuery.format(message.replace(theregex, '{$1}'), rule.parameters);
                }
            }
            this.errorList.push({
                message:message,
                element:element,
                method:method
            });

            this.errorMap[element.name] = message;
            this.submitted[element.name] = message;
        }

        $.validator.prototype.showLabel = function (element, message) {
            var label = this.errorsFor(element);
            if (label.length) {
                // refresh error/success class
                label.removeClass(this.settings.validClass).addClass(this.settings.errorClass);

                // check if we have a generated label, replace the message then
                label.attr("generated") && label.find(".error-label").html(message);
                label.width(getWafErrorLabelWidth(label));
            } else {
                // create label
                label = $("<" + this.settings.errorElement + "/>")
                    .attr({"for":this.idOrName(element), generated:true})
                    .addClass(this.settings.errorClass)
                    .append("<span class='error-icon'></span><span class='error-label'></span>");
                label.find(".error-label").html(message || "");
                if (this.settings.wrapper) {
                    // make sure the element is visible, even in IE
                    // actually showing the wrapped element is handled elsewhere
                    label = label.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();
                }
                if (!this.labelContainer.append(label).length)
                    this.settings.errorPlacement
                        ? label = this.settings.errorPlacement(label, $(element), this)
                        : label.insertAfter(element);
            }
            if (!message && this.settings.success) {
                label.text("");
                typeof this.settings.success == "string"
                    ? label.addClass(this.settings.success)
                    : this.settings.success(label);
            }

            _adjustErrorLabelOffsetLeft($(element),label);

            this.toShow = this.toShow.add(label);
        }


        $.validator.prototype.init = function (el) {
            function delegate(event) {
                    if (this[0].form) {
                        var validator = $.data(this[0].form, "validator"),
                            eventType = "on" + event.type.replace(/^validate/, "");

                        var elem = $(event.target);
                        if(elem.is(':radio') || elem.is(':checkbox')){
                            elem = $(elem.parent().find("input[name='" + elem.attr("name") + "']")[0]);
                        }
                        //validatetrigger
                        if(elem.attr('validatetrigger')){
                            if (elem.attr('validatetrigger').indexOf(event.type)>=0) {
                                if(event.type=='focus')
                                    _focusFuncWhenValidate.call(validator, this[0], event);
                                if(event.type=='blur')
                                    _blurFuncWhenValidate.call(validator, this[0], event);
                                if(event.type=='keyup')
                                    _keyupFuncWhenValidate.call(validator, this[0], event);
                                if(event.type=='change')
                                    _datachangeFuncWhenValidate.call(validator, this[0], event);
                                if(event.type=='click')
                                    _clickFuncWhenValidate.call(validator, this[0], event);
                            }
                        }else if(validator.settings[eventType] && $.isFunction(validator.settings[eventType]) ){
                            validator.settings[eventType].call(validator, this[0], event);
                        }
                    }
                }
            if(el){
                if(waf.isArray(el)){
                    waf.each(el,function(index,element){
                        element.bind("focus blur keyup change click", function(event) {
                            delegate.apply(el, arguments);
                        });
                    });
                }else{
                    el.bind("focus blur keyup change click", function(event) {
                        delegate.apply(el, arguments);
                    });
                }
                this.checkElems=null;
            }else{
                this.labelContainer = $(this.settings.errorLabelContainer);
                this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);
                this.containers = $(this.settings.errorContainer).add(this.settings.errorLabelContainer);
                this.submitted = {};
                this.valueCache = {};
                this.pendingRequest = 0;
                this.pending = {};
                this.invalid = {};
                this.reset();

                var groups = (this.groups = {});
                $.each(this.settings.groups, function (key, value) {
                    $.each(value.split(/\s/), function (index, name) {
                        groups[name] = key;
                    });
                });
                var rules = this.settings.rules;
                $.each(rules, function (key, value) {
                    rules[key] = $.validator.normalizeRule(value);
                });

                $(this.currentForm)
                    .validateDelegate("[type='text'], [type='password'], [type='file'], select, textarea, " +
                    "[type='number'], [type='search'] ,[type='tel'], [type='url'], " +
                    "[type='email'], [type='datetime'], [type='date'], [type='month'], " +
                    "[type='week'], [type='time'], [type='datetime-local'], " +
                    "[type='range'], [type='color'], [type='radio'] ",
                    "focus blur keyup change", delegate)

                    .validateDelegate("[type='radio'], [type='checkbox'], select, option", "click", delegate);

                if (this.settings.invalidHandler)
                    $(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler);
            }
        }

        $.validator.prototype.getTdParent = function (element) {
            var tdparent, tmp;
            tmp = $(element).closest("td").eq(0);
            if (tmp && tmp.length > 0 && tmp[0].tagName.toUpperCase() === "TD") {
                tdparent = tmp;
            }
            return tdparent;
        }

        function _adjustErrorLabelOffsetLeft(element,error){
            var errorLabelPosition = element.attr("errorLabelPosition");
            var lc = $(element).closest(".ui-lablecontainer");
            if (errorLabelPosition == undefined || errorLabelPosition == 'bottom') {
                error.css('display', 'block');
                //label
                if(lc.length>0){
                    var label=lc.find(".label");
                    var span=lc.find(".userinput");
                    if(lc.hasClass("colspan")){
                        var marginLeft = parseInt(span.css("padding-left")) + 5;
                        error.css("margin-left", (marginLeft + "px"));
                    }else{
                        var marginLeft = span.offset().left - label.offset().left + 5;
                        error.css("margin-left", (marginLeft + "px"));
                    }
                }
                errorLabelPosition = "bottom";
            } else {
                error.css('display', 'inline-block');
            }
            if(lc.length>0){
                error.addClass(errorLabelPosition+"position");
            }
        }


        function createPowerFloat(element, error, validator) {
            var s = $('<div class="ui-validate-div" validateElem="' + element[0].id + '"></div>');
            s.attr("id", "error_" + element[0].id);
            s.html(error.html() + "&nbsp;");
            s.width(element.width());
            s.appendTo(document.body);
            var opts = {};
            opts.validator = validator;

            var powerFloatOptions = {
                width:"auto",
                eventType:"click",
                targetMode:"common",
                reverseSharp:true,
                target:s,
                position:"1-4"
    //            beforeTrigger:validator.elementCheck,
    //            beforeTriggerParam:opts
            };
            var realElem, inGrid;
            if (element.is("select")) {
                realElem = $("#ui-multiselect-btn-" + element[0].id);
                inGrid = $(element).attr("grid");
                realElem.powerFloat(powerFloatOptions);
            } else if (element.is(":radio") || element.is(":checkbox")) {
                realElem = element;
                inGrid = $(element).attr("grid");
                if (element.parent().is("div")) {
                    realElem = element.parent();
                }
                powerFloatOptions.eventType = "click";
                realElem.powerFloat(powerFloatOptions);
            } else if (element.attr("ctrlrole") && (element.attr("ctrlrole") === "promptBox" || element.attr("ctrlrole") === "datePicker"
                 || element.attr("ctrlrole") === "multiLangBox" || element.attr("ctrlrole") === "multiLangArea")) {
                realElem = element;
                inGrid = $(element).attr("grid");
                powerFloatOptions.eventType = "focus";
                var validatetrigger = $(element).attr("validatetrigger");
                if (validatetrigger && validatetrigger.indexOf("click") >= 0) {
                    powerFloatOptions.eventType = "click";
                } else if (validatetrigger && validatetrigger.indexOf("blur") >= 0) {
                    powerFloatOptions.eventType = "blur";
                }
                element.powerFloat(powerFloatOptions);
            } else {
                realElem = element;
                inGrid = $(element).attr("grid");
                powerFloatOptions.eventType = "focus";
                var validatetrigger = $(element).attr("validatetrigger");
                if(validatetrigger){
                    if (validatetrigger.indexOf("click") >= 0) {
                        powerFloatOptions.eventType = "click";
                    } else if (validatetrigger.indexOf("focus") >= 0) {
                        powerFloatOptions.eventType = "focus";
                    }else if (validatetrigger.indexOf("blur") >= 0) {
                        powerFloatOptions.eventType = "blur";
                    }
                }else{
                    powerFloatOptions.eventType = "test";
                }

                element.powerFloat(powerFloatOptions);
            }
            if (inGrid != undefined) {
                var tdparent = $.validator.prototype.getTdParent(element);
                if (tdparent) {
                    $(tdparent).addClass("errorinput");
                }
                powerFloatOptions.eventType = "test";
                realElem.powerFloat(powerFloatOptions);
            }
        }

        function getWafErrorLabelWidth(error){
            var p = $(error).clone();
            p.appendTo($(document.body));
            p.css({"position":"static","display":"inline-block",width:"auto"});
            var wid = p.width()+5;
            p.remove();
            return wid;
        }

        function wafErrorPlacement(error, element, validator) {
            var errorShowMode = element.attr("errorShowMode");
            var errorLabelPosition = element.attr("errorLabelPosition");
            if (!errorShowMode) {
                errorShowMode = validator.settings.errorShowMode;
            }
            if (errorShowMode === "float") {
                //var s = $('<ul class="float_list_ul"><li class="float_list_li_last">222sdfsfsfs</li></ul>');
                createPowerFloat(element, error, validator);
                return error;
            } else {
                if (errorShowMode == undefined || errorShowMode == 'embeded' || element.is(":radio") || element.is(":checkbox")) {
                    _adjustErrorLabelOffsetLeft($(element),error);
                    var lc = $(element).closest(".ui-lablecontainer");
                    if(lc.length>0){
                        if(!lc.is(":hidden")){
                            //hiddenwidth0
                            $(error).width(getWafErrorLabelWidth(error));
                            if(errorLabelPosition=="right"){
                                lc.append(error);
                            }else{
                                lc.find(".label").append(error);
                            }
                        }
                    }else{
                        var elem;
                        if ($(element).attr('ctrlrole') == 'promptBox' || $(element).attr('ctrlrole') == 'F7') {
                            elem = $(element).closest(".ui-f7-frame");
                        } else if ($(element).attr('ctrlrole') == 'datePicker') {
                            elem = $(element).closest(".ui-datepicker-frame");
                        }else if($(element).attr('ctrlrole') =='multiLangBox'){
                            elem = $(element).closest(".ui-multiLangBox");
                        }else if($(element).attr('ctrlrole') =='multiLangArea'){
                            elem = $(element).closest(".ui-multiLangArea");
                        }else if($(element).attr('ctrlrole') =='timePicker'){
                            elem = $(element).closest(".ui-timepicker-frame");
                        }else if (element.is("select")) {
                            elem = $("#ui-multiselect-btn-" + element[0].id);
                        } else if (element.is(":radio") || element.is(":checkbox")) {
                            if (element.parent().is("div")) {
                                elem = element.parent();
                            } else {
                                elem = (element.parent().parent());
                            }
                        } else {
                            elem = element;
                        }
                        $(error).insertAfter(elem);
                        $(error).css("margin-left","5px");
                    }
                    return error;
                }
            }
        }


        $.validator.methods.remoteWithMsg = function (value, element, param) {
    //			if ( this.optional(element) )
    //		        return "dependency-mismatch";

            var previous = this.previousValue(element);

            if (!this.settings.messages[element.name])
                this.settings.messages[element.name] = {};
            this.settings.messages[element.name].remoteWithMsg = typeof previous.message == "function" ? previous.message(value) : previous.message;

            param = typeof param == "string" && {url:param} || param;

            if (previous.old !== value) {
                previous.old = value;
                var validator = this;
                this.startRequest(element);
                var data = {};
                data[element.name] = value;

                var rootPath = waf.getContextPath();
                if (param.url.indexOf(rootPath) < 0)
                    param.url = rootPath + param.url + "?conversationid=null";

                var jsonData = $.extend(true, {
                    url:param.url,
                    async:param.async==undefined?false:param.async,
                    mode:"abort",
                    port:"validate" + element.name,
                    dataType:"json",
                    data:param.data,
                    success:function (response) {
                        var valid = response.status;
                        if (valid) {
                            var submitted = validator.formSubmitted;
                            validator.prepareElement(element);
                            validator.formSubmitted = submitted;
                            validator.successList.push(element);
                            validator.showErrors();

                            delete validator.invalid[element.name];
                            updateMsgAreaNumber(validator);
                            //validator.invalid[element.name] = true;
                        } else {
                            var errors = {};
                            errors[element.name] = previous.message = response.info;
                            validator.invalid[element.name] = true;
                            validator.showErrors(errors);

                            updateMsgAreaNumber(validator);
                        }
                        previous.valid = valid;
                        validator.stopRequest(element, valid);
                    }
                }, param);

                $.ajax(jsonData);
                return "pending";
            } else if (this.pending[element.name]) {
                return "pending";
            }
            return previous.valid;
        }

        $.validator.prototype.resetForm = function () {
            if ($.fn.resetForm)
                $(this.currentForm).resetForm();
            if (!this.checkElems) {
                this.checkElems = this.elements();
            }
            unhighlightElems(this, this.checkElems);
            this.submitted = {};
            this.lastElement = null;
            this.prepareForm();
            this.hideErrors();
            this.settings.errorContainer.show();
            this.settings.errorContainer.children().hide();
            this.elements().removeClass(this.settings.errorClass);

        }

        function unhighlightElems(validator, elements) {
            if (elements.length > 0) {
                $("div.ui-validate-div").remove();
                $("#floatCorner_top").remove();
            }
            for (var i = 0; elements[i]; i++) {
                if ($(elements[i]).attr('ctrlrole') == 'promptBox' || $(elements[i]).attr('ctrlrole') == 'F7') {
                    var f7Elm = $(elements[i]).closest(".ui-f7-frame");
                    validator.settings.unhighlight.call(validator, f7Elm, validator.settings.errorClass, validator.settings.validClass);
                } else if ($(elements[i]).attr('ctrlrole') == 'datePicker') {
                    var dateElm = $(elements[i]).closest(".ui-datepicker-frame");
                    validator.settings.unhighlight.call(validator, dateElm, validator.settings.errorClass, validator.settings.validClass);
                } else if ($(elements[i]).attr('ctrlrole') == 'multiLangBox') {
                    var langElm = $(elements[i]).closest(".ui-multiLangBox");
                    validator.settings.unhighlight.call(validator, langElm, validator.settings.errorClass, validator.settings.validClass);
                } else if ($(elements[i]).attr('ctrlrole') == 'multiLangArea') {
                    var langElm = $(elements[i]).closest(".ui-multiLangArea");
                    validator.settings.unhighlight.call(validator, langElm, validator.settings.errorClass, validator.settings.validClass);
                } else if ($(elements[i]).attr('ctrlrole') == 'timePicker') {
                    var langElm = $(elements[i]).closest(".ui-timepicker-frame");
                    validator.settings.unhighlight.call(validator, langElm, validator.settings.errorClass, validator.settings.validClass);
                }

                else if ($(elements[i]).is(":radio") || $(elements[i]).is(":checkbox")) {
                    validator.settings.unhighlight.call(validator, $(elements[i]).parent().parent(), validator.settings.errorClass, validator.settings.validClass);
                } else if ($(elements[i]).is("select")) {
                    var realEnumElem = $("#ui-multiselect-btn-" + elements[i].id);
                    if (realEnumElem)
                        validator.settings.unhighlight.call(validator, realEnumElem, validator.settings.errorClass, validator.settings.validClass);
                    else
                        validator.settings.unhighlight.call(validator, elements[i], validator.settings.errorClass, validator.settings.validClass);
                } else {
                    validator.settings.unhighlight.call(validator, elements[i], validator.settings.errorClass, validator.settings.validClass);
                }
            }
        }

        function updateMsgAreaNumber(validator) {
            if (!validator.settings.errorContainer) return;
            var errNumber = validator.numberOfInvalids();
            if (errNumber == 0) {
                validator.settings.errorContainer.hide();
    //            validator.settings.errorContainer.children().hide();
                validator.toHide[0] = {}
            } else {
                validator.settings.errorContainer.children().show();
                var summarySpan = validator.settings.errorContainer.find(".summaryMsg span");
                if (summarySpan.length > 0)
    //                summarySpan.html("" + validator.numberOfInvalids() + "");
                    summarySpan.html(jQuery.validator.format(jQuery.validator.messages.summaryMsg,validator.numberOfInvalids()));
                else {
                    var curForm = $(validator.currentForm);
                    if((curForm.data('submitted')==true || validator.settings.validateOnSumbit==false) && validator.settings.errorContainer.length>0){
                        validator.settings.errorContainer.wafMsgArea("show", {
                            type:"info",
                            summaryMsg:jQuery.validator.format(jQuery.validator.messages.summaryMsg,validator.numberOfInvalids()),
                            closeDetailTime:-1
                        });
                    }
                }
            }
        }

        function getRemoteJsonStr(remoteRule, elem) {
            var remote;
            if (remoteRule.indexOf('data:') > 0)
                remote = "remoteWithMsg:{" + remoteRule + "}";
            else
                remote = "remoteWithMsg:{" + remoteRule + ",data:{"
                    + elem.id + ":function(){return $('#" + elem.id + "').val();}"
                    + "}}";
            return remote;
        }

        $.metadata.setType("attr", "validate");


        if ($.validator.defaults) {
            $.validator.defaults.onchange = _datachangeFuncWhenValidate;
        }

        $.extend($.fn, {
            validateDelegate: function(delegate, type, handler) {
                return $(delegate).bind(type, function(event) {
                    var target = $(event.target);
                    if (target.is(delegate)) {
                        return handler.apply(target, arguments);
                    }
                });
            }
        });

    $.wafValidator=$.wafValidator || {};

    $.extend($.wafValidator, {
            createValidatorDOM:function (opts) {

            },
            initValidator:function (opts, el) {
                //el=el[0];
                var initEl=el;
                if(el.length==1 && el[0].nodeName=='SPAN'){
                    initEl = el.find("input[type='radio']");
                    if(initEl.length>0) el=waf(initEl[0]);
                }
                if(el.length>1 || el.attr("ctrlrole")=="radio"){
                    var elem;
                    for(var i=0;i<el.length;i++){
                        elem=waf(el[i]);
                        if(elem.attr("ctrlrole")){
                            el=elem;
                            initEl=el;
                            if(elem.attr("ctrlrole")=="checkbox" || elem.attr("ctrlrole")=="radio"){
                                var groupName = elem.attr("name");
                                initEl = waf("input[name='" + groupName + "']");
                            }
                            break;
                        }
                    }
                }
                if(opts.rules){
                    el.wafValidator("option","rules",opts.rules);
                }
                if(opts.errMsg){
                    el.wafValidator("option","errMsg",opts.errMsg);
                }
                if(opts.validatetrigger){
                    el.wafValidator("option","validatetrigger",opts.validatetrigger);
                }
                if(opts.customvalidate){
                    el.wafValidator("option","customvalidate",opts.customvalidate);
                }
                if(opts.errorLabelPosition){
                    el.wafValidator("option","errorLabelPosition",opts.errorLabelPosition);
                }
                if(opts.errorShowMode){
                    el.wafValidator("option","errorShowMode",opts.errorShowMode);
                }
                if(opts.remoteRule){
                    el.wafValidator("option","remoteRule",opts.remoteRule);
                }
                if(opts.validateOnSumbit){
                    el.wafValidator("option","validateOnSumbit",opts.validateOnSumbit);
                }
                if(opts.suspendValidate){
                    el.wafValidator("option","suspendValidate",opts.suspendValidate);
                }
                if(opts.suspend){
                    el.wafValidator("option","suspendValidate",opts.suspend);
                }
                console.info("-----"+el[0].form);
                var validator = el[0].form&&waf.data(el[0].form, "validator");
                if(validator) validator.init(initEl);
            },
            removeValidator:function (opts) {
                var dom = waf('#' + opts.id);
                var validator = dom[0].form&&waf.data(dom[0].form, "validator");
                if(!validator) return;
                dom.removeAttr("validate");
                dom.removeAttr("errMsg");
                dom.removeAttr("validatetrigger");
                dom.removeAttr("errorLabelPosition");
                dom.removeAttr("errorShowMode");
                dom.removeAttr("validateOnSumbit");
                dom.removeAttr("suspend");
                dom.removeAttr("suspendValidate");

                if(dom.attr("customvalidate")){
                    if(validator.settings.rules[dom.attr("name")])
                        validator.settings.rules[dom.attr("name")] = null;
                    waf.validator.methods[dom.attr("name")] = null;
                    waf.validator.messages[dom.attr("name")] = null;
                    dom.removeAttr("customvalidate");
                }

                if(dom.attr("remoteRule")){
                    if(validator.settings.rules[dom.attr("name")])
                        validator.settings.rules[dom.attr("name")] = null;
                    dom.removeAttr("remoteRule");
                }

                $.data(dom[0], 'metadata',null);
                unhighlightElems(validator,dom);
                waf.each(validator.toShow,function(index,elem){
                    elem=$(elem);
                    if(elem.attr('for')==opts.id)
                        elem.hide();
                });

                var lc = dom.closest("div.ui-lablecontainer");
                if(lc && lc.length>0){
                    lc.wafLabelContainer('removeRequiredMask');
                }
                //validator.toShow.find("label[for='" + opts.id + "']").hide();
                //dom.removeClass( validator.settings.errorClass );
            },
            modifyValidator:function (opts) {

            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("validator", {createDOMFun:$.wafValidator.createValidatorDOM, initFun:$.wafValidator.initValidator,
                    modifyFun:$.wafValidator.modifyValidator,deleteFun:$.wafValidator.removeValidator});
        });

        function obj2str(o){
            var r = [];
            if(typeof o =="string") return "\""+o.replace(/([\'\"\\])/g,"\\$1").replace(/(\n)/g,"\\n").replace(/(\r)/g,"\\r").replace(/(\t)/g,"\\t")+"\"";
                if(typeof o == "object"){
                    if(!o.sort){
                        for(var i in o)
                            r.push(i+":"+obj2str(o[i]));
                        if(!!document.all && !/^\n?function\s*toString\(\)\s*\{\n?\s*\[native code\]\n?\s*\}\n?\s*$/.test(o.toString)){
                            r.push("toString:"+o.toString.toString());
                        }
                        r="{"+r.join()+"}"
                    }else{
                        for(var i =0;i<o.length;i++)
                            r.push(obj2str(o[i]))
                        r="["+r.join()+"]"
                    }
                    return r;
                }
                return o.toString();
            }
    }(jQuery));
//});



/* jshint forin:true, noarg:true, noempty:true, eqeqeq:true, boss:true, undef:true, curly:true, browser:true, jquery:true */
/*
 * jQuery MultiSelect UI Widget 1.12
 * Copyright (c) 2011 Eric Hynds
 *
 * http://www.erichynds.com/jquery/jquery-ui-multiselect-widget/
 *
 * Depends:
 *   - jQuery 1.4.2+
 *   - jQuery UI 1.8 widget factory
 *
 * Optional:
 *   - jQuery UI effects
 *   - jQuery UI position utility
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
*/
//2012-6-8 onchange susanna
//2012-6-11 div susanna
//2012-6-14 onchange update handleChangeEvent  susanna
//2012-10-16 setButtonHeightbutton susanna
//mod.defineModule("multiselect",["base","waf"],function(){
    (function($, undefined){
    
    var multiselectID = 0;

    $.widget("ech.multiselect",$.ui.wafctrl, {

        // default options
        options: {
            header: true,
            height: 175,
            minWidth: 0,
            classes: '',
            checkAllText: 'Check all',
            uncheckAllText: 'Uncheck all',
            noneSelectedText: 'Select options',
            selectedText: '# selected',
            selectedList: 0,
            show: '',
            hide: '',
            autoOpen: false,
            multiple: true,
            position: {} ,
            tagClass : '',
            formatter:null
        },

        _create: function(){
            var el = this.element.hide(),
                o = this.options,
                id = el.attr('id');

            this.speed = $.fx.speeds._default; // default speed for effects
            this._isOpen = false; // assume no

            //if inIframe is true, menu should be show the page's parent.
            var target = $(".page_margins .page")[0]||window.document.body,button;

            if(this.element.data('domcreated')) {
                button = (this.button = $('#ui-multiselect-btn-' + id));
                button.find(".ui-multiselect-label").remove();
            } else {
                button = (this.button = $('<div id="ui-multiselect-btn-' + id + '" type="text"><span class="ui-icon ui-icon-triangle-2-n-s"></span></div>'))
                    .addClass('ui-multiselect ui-widget ui-state-default ui-corner-all')
                    .insertAfter(el);
                this.element.attr("data-domcreated","true");
            }

            button.addClass(o.tagClass)
                .addClass(o.classes)
                .attr({
                    'title': el.attr('title'),
                    'aria-haspopup': true,
                    'tabIndex': el.attr('tabIndex')
                });

            $("#ui-multiselect-menu-" + id).remove();
            var buttonlabel = (this.buttonlabel = $('<span class="ui-multiselect-label"/>'))
                        .html( o.noneSelectedText )
                        .appendTo( button ),

                menu = (this.menu = $('<div />'))
                    .addClass('ui-multiselect-menu ui-widget ui-widget-content ui-corner-all')
                    .addClass( o.classes )
                    .css("top",0)
                    .css("left",0)
                    .appendTo(target)
                    .attr("id","ui-multiselect-menu-" + id),

                header = (this.header = $('<div />'))
                    .addClass('ui-widget-header ui-corner-all ui-multiselect-header ui-helper-clearfix')
                    .appendTo( menu ),

                headerLinkContainer = (this.headerLinkContainer = $('<ul />'))
                    .addClass('ui-helper-reset')
                    .html(function(){
                        if( o.header === true ){
                            return '<li><a class="ui-multiselect-all" style="cursor: pointer"><span class="ui-icon ui-icon-check"></span><span>' + o.checkAllText + '</span></a></li><li><a class="ui-multiselect-none" style="cursor: pointer"><span class="ui-icon ui-icon-closethick"></span><span>' + o.uncheckAllText + '</span></a></li>';
                        } else if(typeof o.header === "string"){
                            return '<li>' + o.header + '</li>';
                        } else {
                            return '';
                        }
                    })
                    .append('<li class="ui-multiselect-close"><a style="cursor: pointer" class="ui-multiselect-close"><span class="ui-icon ui-icon-circle-close"></span></a></li>')
                    .appendTo( header ),

                checkboxContainer = (this.checkboxContainer = $('<ul />'))
                    .addClass('ui-multiselect-checkboxes ui-helper-reset')
                    .appendTo( menu );

            if($.fn.enter2tab){
                button.enter2tab();
            }
            //div
            button.attr("style",o.style);
    //        button.css("height",o.buttonHeight) ;


            // build menu
            this.refresh( true );

            // perform event bindings
            this._bindEvents();

            // some addl. logic for single selects
            if( !o.multiple ){
                menu.addClass('ui-multiselect-single');
            }
            this._setButtonHeight();
            //
            this._operateState();
        },

        _init: function(){
            if( this.options.header === false ){
                this.header.hide();
            }
            if( !this.options.multiple ){
                this.headerLinkContainer.find('.ui-multiselect-all, .ui-multiselect-none').hide();
            }
            if( this.options.autoOpen ){
                this.open();
            }
            if( this.element.is(':disabled') ){
                this.disable();
            }else{
                this.enable();
            }
        },

        refresh: function( init,changeFlag ){
            var el = this.element,
                o = this.options,
                menu = this.menu,
                checkboxContainer = this.checkboxContainer,
                optgroups = [],
                html = [],
                self = this,
                id = el.attr('id') || multiselectID++; // unique ID for the label & option tags

            // build items
            el.find('option').each(function( i ){
                var $this = $(this),
                    parent = this.parentNode,
                    title = this.innerHTML,
                    description = this.title,
                    value = this.value,
                    inputID = this.id || 'ui-multiselect-' + id + '-option-' + i,
                    isDisabled = this.disabled,
                    isSelected = this.selected,
                    labelClasses = ['ui-corner-all'],
                    optLabel,
                    //Zhang Yanfang 2012-1-11 11:33:32
                    optGroupDisabled = false;

                // is this an optgroup?
                if( parent.tagName.toLowerCase() === 'optgroup' ){
                    optLabel = parent.getAttribute('label');
                    //Zhang Yanfang 2012-1-11 11:33:32
                    if(parent.getAttribute('disabled')!=null){
                        optGroupDisabled = parent.getAttribute('disabled');
                    }

                    // has this optgroup been added already?
                    if( $.inArray(optLabel, optgroups) === -1 ){
                        //---------------------------------------------------------------------------------
                        //Zhang Yanfang 2012-1-9 18:34:40
                        var optgrpstr =  optLabel ;
                        if(o.multiple){
                            optgrpstr = '<a href="#">' + optLabel + '</a>';
                        }
                        //---------------------------------------------------------------------------------
                        html.push('<li class="ui-multiselect-optgroup-label">' + optgrpstr + '</li>');
                        optgroups.push( optLabel );
                    }
                }
                //
                if( isDisabled ||optGroupDisabled){
                    labelClasses.push('ui-state-disabled');
                }

                // browsers automatically select the first option
                // by default with single selects
                if( isSelected && !o.multiple ){
                    labelClasses.push('ui-state-active');
                }

                html.push('<li class="' + ((isDisabled|| optGroupDisabled)? 'ui-multiselect-disabled' : '') + '">');

                // create the label
                html.push('<div title="' + description + '" class="' + labelClasses.join(' ') + '">');
                html.push('<input id="' + inputID + '" name="multiselect_' + id + '" type="' + (o.multiple ? "checkbox" : "radio") + '" value="' + value + '" title="' + title + '"');

                // pre-selected?
                if( isSelected ){
                    html.push(' checked="checked"');
                    html.push(' aria-selected="true"');
                }

                // disabled?
                //
                if( isDisabled ||optGroupDisabled){
                    html.push(' disabled="disabled"');
                    html.push(' aria-disabled="true"');
                }

                //format options
                if(o.formatter && $.isFunction(o.formatter)){
                    title = o.formatter.call(self,value,title);
                }

                // add the title and close everything off
                html.push(" /><span>" + title + "</span></div></li>");
            });

            // insert into the DOM
            checkboxContainer.html( html.join('') );
            //rebind menu events
            this._bindMenuEvents();
            // cache some moar useful elements
            this.labels = menu.find('div');

            // set widths
            this._setButtonWidth();
            this._setMenuWidth();
             if(changeFlag){
                 this._handleChangeEvent();
             }


            // remember default value
            this.button[0].defaultValue = this.update();

            if(!this.options.operateState || (this.options.operateState && this.options.operateState.toUpperCase()=="edit".toUpperCase())){
                this.button.toggle(!this.options.hidden);
            }

            if($.wafutil.isViewOperateState(this.options)){
                this.button.hide();
            }


            // broadcast refresh event; useful for widgets
            if( !init ){
                this._trigger('refresh');
            }
        },

        // updates the button text. call refresh() to rebuild
        update: function(){
            var o = this.options,
                $inputs = this.labels.find('input'),
                $checked = $inputs.filter('[checked]'),
                numChecked = $checked.length,
                value,selectedLabels;

            if( numChecked === 0 ){
                value = o.noneSelectedText;
            } else {
                if($.isFunction( o.selectedText )){
                    value = o.selectedText.call(this, numChecked, $inputs.length, $checked.get());
                } else if( /\d/.test(o.selectedList) && o.selectedList > 0 && numChecked <= o.selectedList){
                    value = $checked.map(function(){ return $(this).next().text(); }).get().join(', ');
                } else {
                    value = o.selectedText.replace('#', numChecked).replace('#', $inputs.length);
                }
                selectedLabels = $checked.map(function(){ return $(this).next().text(); }).get().join(', ');
            }

            this.button.attr('title', value);
            this.buttonlabel.html( value );
            this._setDisplayValue(selectedLabels);
            //selectehiddenvalue
            var hidden = this.element.multiselect("getChecked");
            var hidden_value =  hidden.map(function(){ return $(this).val(); }).get().join(',');
            $("input[id='"+this.element.attr("id")+"_el']").val(hidden_value);
            //---------------------------------------------------------------------------------------

            return value;
        },
        // binds events
        _bindEvents: function(){
            var self = this, button = this.button;

            function clickHandler(){
                self[ self._isOpen ? 'close' : 'open' ]();
                return false;
            }

            // webkit doesn't like it when you click on the span :(
            button
                .find('span')
                .bind('click.multiselect', clickHandler);

            // button events
            button.bind({
                click: clickHandler,
                keydown: function( e ){   //modify keypress to keydown by zhangyanfang
                    switch(e.which){
                        case 27: // esc
                        case 38: // up
                        case 37: // left
                            self.close();
                            self.button.focus();  //add by zhangyanfang
                            break;
                        case 39: // right
                        case 40: // down
                            e.preventDefault(); //add by zhangyanfang
                            self.open();
                            break;
                    }
                },
                mouseenter: function(){
                    if( !button.hasClass('ui-state-disabled') ){
                        $(this).addClass('ui-state-hover');
                    }
                },
                mouseleave: function(){
                    $(this).removeClass('ui-state-hover');
                },
                focus: function(){
                    if( !button.hasClass('ui-state-disabled') ){
                        $(this).addClass('ui-state-focus');
                    }
                },
                blur: function(){
                    $(this).removeClass('ui-state-focus');
                }
            });

            // header links
            this.header
                .delegate('a', 'click.multiselect', function( e ){
                    // close link
                    if( $(this).hasClass('ui-multiselect-close') ){
                        self.close();

                    // check all / uncheck all
                    } else {
                        self[ $(this).hasClass('ui-multiselect-all') ? 'checkAll' : 'uncheckAll' ]();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                });

             //bind menu events
            this._bindMenuEvents();


            // close each widget when clicking on any other element/anywhere else on the page
            $(document).bind('mousedown.multiselect', function( e ){
                if(self._isOpen && !$.contains(self.menu[0], e.target) && !$.contains(self.button[0], e.target) && e.target !== self.button[0]){
                    self.close();
                }
            });

            // deal with form resets.  the problem here is that buttons aren't
            // restored to their defaultValue prop on form reset, and the reset
            // handler fires before the form is actually reset.  delaying it a bit
            // gives the form inputs time to clear.
            $(this.element[0].form).bind('reset.multiselect', function(){
                setTimeout($.proxy(self.refresh, self,false,false), 10);
            });


        },
        _bindMenuEvents:function(){
            var self = this;
            // optgroup label toggle support
            this.menu.find("li.ui-multiselect-optgroup-label a").unbind("click.multiselect").bind("click.multiselect",function( e ){
                e.preventDefault();

                var $this = $(this),
                    $inputs = $this.parent().nextUntil('li.ui-multiselect-optgroup-label').find('input:visible:not(:disabled)'),
                    nodes = $inputs.get(),
                    label = $this.parent().text();

                // trigger event and bail if the return is false
                if( self._trigger('beforeoptgrouptoggle', e, { inputs:nodes, label:label }) === false ){
                    return;
                }

                // toggle inputs
                self._toggleChecked(
                    $inputs.filter('[checked]').length !== $inputs.length,
                    $inputs
                );

                self._trigger('onoptgrouptoggle', e, {
                    inputs: nodes,
                    label: label,
                    checked: nodes[0].checked
                });
                e.stopPropagation();
            });
            this.menu.find("div").unbind("mouseenter.multiselect").bind("mouseenter.multiselect",function(){
                if( !$(this).hasClass('ui-state-disabled') ){
                    self.labels.removeClass('ui-state-hover');
                    $(this).addClass('ui-state-hover').find('input').focus();
                }
            });
            this.menu.find("div").unbind("keydown.multiselect").bind("keydown.multiselect",function( e ){
                e.preventDefault();

                switch(e.which){
                    case 9: // tab
                    case 27: // esc
                        self.close();
                        self.button.focus();//add by zhangyanfang
                        break;
                    case 38: // up
                    case 40: // down
                    case 37: // left
                    case 39: // right
                        self._traverse(e.which, this);
                        break;
                    case 13: // enter
                        //menuenter
                        if(!self.options.multiple){
                            if(self._isOpen) {
                                $(this).find('span')[0].click();
                            }
                        }else{
                            self.close();
                        }
                        self.button.focus();//add by zhangyanfang
                        //add by zhangyanfang
                        var tdparent = self.button.closest("td");
                        if(tdparent.length>0 && tdparent.attr("role")==="gridcell"){
                            var event = jQuery.Event("keydown");
                            event.keyCode = 13;
                            self.button.trigger(event);
                        }
                        break;
                    case 32: //space
                        if(self._isOpen) {
                            $(this).find('span')[0].click();
                        }
                        break;
                }
            });
            function optionClickHandler( e ){
                var $this = $(e.target);
                if($(e.target).is("div")){
                    if(self.options.multiple){
                        $this = $(e.target).find('input');
                    }else{
                        return;
                    }
                }else if($(e.target).is("span")){
                    $this = $(e.target).parent().find('input');
                }
                var selfOption = $this[0];
                if( !self.options.multiple ){
                    var checked=self.getChecked();
                    if(checked&&checked.length>0){
                        if(checked[0].value != selfOption.value){
                            selfOption.checked = !selfOption.checked;
                        }
                    }
                }else{
                    if(!$(e.target).is("input")){
                        selfOption.checked = !selfOption.checked;
                    }
                }
                //span
                var val = selfOption.value,
                    tags = self.element.find('option');
                checked = selfOption.checked;

                // bail if this input is disabled or the event is cancelled
                if( selfOption.disabled || self._trigger('onclick', e, { value: val, text: selfOption.title, checked: checked }) === false ){
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }


                // make sure the input has focus. otherwise, the esc key
                // won't close the menu after clicking an item.
                $this.focus();

                // toggle aria state
                $this.attr('aria-selected', checked);

                // change state on the original option tags
                tags.each(function(){
                    if( this.value === val ){
                        this.selected = checked;
                    } else if( !self.options.multiple ){
                        this.selected = false;
                    }
                });

                // some additional single select-specific logic
                if( !self.options.multiple ){
                    self.labels.removeClass('ui-state-active');
                    $this.closest('div').toggleClass('ui-state-active', checked );

                    // close menu
                    self.close();
                }


                self._handleChangeEvent(false,true);

                // setTimeout is to fix multiselect issue #14 and #47. caused by jQuery issue #3827
                // http://bugs.jquery.com/ticket/3827
                //setTimeout(self.adjustHeight, 10);
                setTimeout($.proxy(self.adjustHeight, self), 10);
                e.stopPropagation();
                if( !self.options.multiple ){
                    return false;
                }
            }
            //this.menu.find("input[type='checkbox'], input[type='radio']").unbind("click.multiselect").bind("click.multiselect",optionClickHandler);
            if(!this.options.multiple){
                this.menu.find("div>span").unbind("click.multiselect").bind("click.multiselect",optionClickHandler);
            }else{
                this.menu.find("div").unbind("click.multiselect").bind("click.multiselect",optionClickHandler);
            }

        },

        adjustHeight:function(){
            this.update();
            this._setButtonHeight();
            this.menu.position(this.options.position);
        },

        _setButtonHeight:function(buttonHeight){
            //button22pxselectlistheight
            buttonHeight = buttonHeight || this.options.buttonHeight;
            var o = this.options;
            if (buttonHeight != null) {
                this.button.css("height", buttonHeight);
                this.buttonlabel.css("lineHeight", buttonHeight + 'px');
            } else if (this.buttonlabel.height() > this.button.height()) {
                this.button.css("height", "auto");
            }
        },
        // set button width
        _setButtonWidth: function(){
    //      var width = this.element.outerWidth(),
    //          o = this.options;
    //
    //      if( /\d/.test(o.minWidth) && width < o.minWidth){
    //          width = o.minWidth;
    //      }
    //
    //      // set widths
    //      this.button.width( width );

           var o = this.options,
               width = o.buttonWidth;
            if(width){
                this.button.width(width);
            }
        },

        // set menu width
        _setMenuWidth: function(){
            var m = this.menu,
                width = this.button.outerWidth()-
                    parseInt(m.css('padding-left'),10)-
                    parseInt(m.css('padding-right'),10)-
                    parseInt(m.css('border-right-width'),10)-
                    parseInt(m.css('border-left-width'),10);

            m.width( width || this.button.outerWidth() );
        },

        // move up or down within the menu
        _traverse: function( which, start ){
            var $start = $(start),
                moveToLast = which === 38 || which === 37,

                // select the first li that isn't an optgroup label / disabled
                $next = $start.parent()[moveToLast ? 'prevAll' : 'nextAll']('li:not(.ui-multiselect-disabled, .ui-multiselect-optgroup-label)')[ moveToLast ? 'last' : 'first']();

            // if at the first/last element
            if( !$next.length ){
                var $container = this.menu.find('ul').last();

                // move to the first/last
                this.menu.find('div')[ moveToLast ? 'last' : 'first' ]().trigger('mouseover');

                // set scroll position
                $container.scrollTop( moveToLast ? $container.height() : 0 );

            } else {
                $next.find('div').trigger('mouseover');
            }
        },

        // This is an internal function to toggle the checked property and
        // other related attributes of a checkbox.
        //
        // The context of this function should be a checkbox; do not proxy it.
        _toggleState: function( prop, flag ){
            return function(){
                if( !this.disabled ) {
                    this[ prop ] = flag;
                }

                if( flag ){
                    this.setAttribute('aria-selected', true);
                } else {
                    this.removeAttribute('aria-selected');
                }
            };
        },

        _toggleChecked: function( flag, group ){
            var $inputs = (group && group.length) ?
                group :
                this.labels.find('input'),

                self = this;

            // toggle state on inputs
            $inputs.each(this._toggleState('checked', flag));

            // give the first input focus
            $inputs.eq(0).focus();

            // gather an array of the values that actually changed
            var values = $inputs.map(function(){
                return this.value;
            }).get();

            // toggle state on original option tags
            this.element
                .find('option')
                .each(function(){
                    if( !this.disabled && $.inArray(this.value, values) > -1 ){
                        self._toggleState('selected', flag).call( this );
                    }
                });

            // trigger the change event on the select
            if( $inputs.length ) {
                this.element.trigger("change");
            }

           this._handleChangeEvent();

                // update button text
                this.update();
        },

        _toggleDisabled: function( flag ){
            this.button
                .attr({ 'disabled':flag, 'aria-disabled':flag })[ flag ? 'addClass' : 'removeClass' ]('ui-state-disabled');

            this.menu
                .find('input')
                .attr({ 'disabled':flag, 'aria-disabled':flag })
                .parent()[ flag ? 'addClass' : 'removeClass' ]('ui-state-disabled');

            this.element
                .attr({ 'disabled':flag, 'aria-disabled':flag });
        },

        // open the menu
        open: function( e ){
            var self = this,
                button = this.button,
                menu = this.menu,
                speed = this.speed,
                o = this.options;
            // bail if the multiselectopen event returns false, this widget is disabled, or is already open
            if( this._trigger('beforeopen') === false || button.hasClass('ui-state-disabled') || this._isOpen ){
                return;
            }
            menu.css("top",0).css("left",0);
            this._setMenuWidth();
            var $container = menu.find('ul').last(),
                effect = o.show,
                pos = button.offset();

            // figure out opening effects/speeds
            if( $.isArray(o.show) ){
                effect = o.show[0];
                speed = o.show[1] || self.speed;
            }

            // set the scroll of the checkbox container
    //        $container.scrollTop(0).height(o.height);
            $container.scrollTop(0).css("max-height",o.height)

            // position and show menu
            if( $.ui.position && !$.isEmptyObject(o.position) ){
                o.position.of = o.position.of || button;

                menu
                    .show()
                    .position( o.position )
                    .hide()
                    .show( effect, speed );

            // if position utility is not available...
            } else {
                menu.css({
                    top: pos.top + button.outerHeight(),
                    left: pos.left
                }).show( effect, speed );
            }

            // select the first option
            // triggering both mouseover and mouseover because 1.4.2+ has a bug where triggering mouseover
            // will actually trigger mouseenter.  the mouseenter trigger is there for when it's eventually fixed
            this.labels.eq(0).trigger('mouseover').trigger('mouseenter').find('input').trigger('focus');

            button.addClass('ui-state-active');
            this._isOpen = true;
            this._trigger('onopen');
        },

        // close the menu
        close: function(){
            if(this._trigger('beforeclose') === false){
                return;
            }

            var o = this.options, effect = o.hide, speed = this.speed;

            // figure out opening effects/speeds
            if( $.isArray(o.hide) ){
                effect = o.hide[0];
                speed = o.hide[1] || this.speed;
            }

    //      this.menu.hide(effect, speed);
            this.menu.hide();
            this.button.removeClass('ui-state-active').trigger('blur').trigger('mouseleave');
            this._isOpen = false;
            this._trigger('onclose');
            var tdparent = this.button.closest("td");
            if(tdparent.length>0 && tdparent.attr("role")==="gridcell"){
                //
                this.button.focus();
            }
        },

        enable: function(){
            this._toggleDisabled(false);
        },

        disable: function(){
            this._toggleDisabled(true);
        },

        checkAll: function( e ){
            this._toggleChecked(true);
            this._trigger('oncheckall');
        },

        uncheckAll: function(){
            this._toggleChecked(false);
            this._trigger('onuncheckall');
        },

        getChecked: function(){
            return this.menu.find('input').filter(':checked');
        },

        _destroy: function(){
            // remove classes + data
            $.Widget.prototype.destroy.call( this );

            this.button.remove();
            this.menu.remove();
            this.element.show();

            return this;
        },

        isOpen: function(){
            return this._isOpen;
        },

        widget: function(){
            return this.button;
        },
        // react to option changes after initialization
        _setOption: function( key, value ){
            if(undefined === value){
                return;
            }
            var menu = this.menu;

            switch(key){
                case 'header':
                    menu.find('div.ui-multiselect-header')[ value ? 'show' : 'hide' ]();
                    break;
                case 'checkAllText':
                    menu.find('a.ui-multiselect-all span').eq(-1).text(value);
                    break;
                case 'uncheckAllText':
                    menu.find('a.ui-multiselect-none span').eq(-1).text(value);
                    break;
                case 'height':
    //                menu.find('ul').last().height( parseInt(value,10) );
                    menu.find('ul').last().css("max-height",parseInt(value,10));
                    break;
                case 'minWidth':
                    this.options[ key ] = parseInt(value,10);
                    this._setButtonWidth();
                    this._setMenuWidth();
                    break;
                case 'selectedText':
                case 'selectedList':
                case 'noneSelectedText':
                    this.options[key] = value; // these all needs to update immediately for the update() call
                    this.update();
                    break;
                case 'classes':
                    menu.add(this.button).removeClass(this.options.classes).addClass(value);
                    break;
                case 'buttonWidth':
                    this.button.css("width",value);
                    break;
                case 'buttonHeight':
                    this._setButtonHeight(value);
                    break;
                case 'style':
                    this.button.attr("style",value);
                    break;
                case 'tabindex':
                    this.button.attr("tabindex",value);
                    break;
                case 'tagClass':
                    this.button.removeClass(this.options.tagClass).addClass(value);
                    break;
            }

            $.Widget.prototype._setOption.apply( this, arguments );
        },
        _handleChangeEvent:function (init,update) {

            //onchange
            var oldValue = $("input[id='" + this.element.attr("id") + "_el']").val(),
                $inputs = this.labels.find('input'),
                $checked = $inputs.filter('[checked]'),
                checkedValue = $checked.map(
                    function () {
                        return $(this).val();
                    }).get().join(', ');
            var flag = false;
            if(init  ){
                oldValue = "";
                if(!this.options.multiple && $inputs.length>0){
                    oldValue =  $inputs[0].value;
                }
            }
            if(update){
                this.update();
            }
            if (oldValue != checkedValue ) {
                // fire change on the select box
                this.element.trigger("change");
                if (this._trigger("onchange", "onchange", {"previous":oldValue, "current":checkedValue}) === false) {
                  var tags = this.element.find('option'),
                      oldValueArray = oldValue.split(","),
                      self = this;
                    tags.each(function(){
                        if(!self.options.multiple ){
                            if(this.value == oldValue){
                                this.selected = true;
                            }
                        }else{
                            if(jQuery.inArray(this.value, oldValueArray)>=0){
                                this.selected = true;
                            } else{
                                this.selected = false;
                            }
                        }
    //                    $this.attr('aria-selected', checked);
                    });
                    $inputs.each(function(){
                        if(!self.options.multiple ){
                            if(this.value == oldValue){
                                this.checked = true;
                            } else{
                                $(this).closest('div').removeClass('ui-state-active');
                            }
                        }else{
                            if(jQuery.inArray(this.value, oldValueArray)>=0){
                                this.checked = true;
                            } else{
                                this.checked = false;
                            }
                        }
                    });

                }
            }
            //--------------------------------------------------------------------------------------------------
        }
    });

    })(jQuery);
//});
/* jshint forin:true, noarg:true, noempty:true, eqeqeq:true, boss:true, undef:true, curly:true, browser:true, jquery:true */
/*
 * jQuery MultiSelect UI Widget Filtering Plugin 1.4
 * Copyright (c) 2011 Eric Hynds
 *
 * http://www.erichynds.com/jquery/jquery-ui-multiselect-widget/
 *
 * Depends:
 *   - jQuery UI MultiSelect widget
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
*/
//IE8placeholder 2012-5-28
//mod.defineModule("selectfilter",["base","waf","multiselect","select_i18n"],function(){
    (function($){
        var rEscape = /[\-\[\]{}()*+?.,\\\^$|#\s]/g;

        $.widget("ech.multiselectfilter", {

            options: {
                label: "Filter:",
                width: null, /* override default width set in css file (px). null will inherit */
                placeholder: "Enter keywords",
                autoReset: false
            },

            _create: function(){



                var self = this,
                    opts = this.options,
                    instance = (this.instance = $(this.element).data("multiselect")),

                    // store header; add filter class so the close/check all/uncheck all links can be positioned correctly
                    header = (this.header = instance.menu.find(".ui-multiselect-header").addClass("ui-multiselect-hasfilter")),
                    inputFilter = this._getInputFilter(opts);
                // wrapper elem
                this.wrapper = $('<div class="ui-multiselect-filter">'+(opts.label.length ? opts.label : '')+'</div>');
                var wrapper = (this.wrapper.append(inputFilter).prependTo( this.header ));





                // reference to the actual inputs
                this.inputs = instance.menu.find('input[type="checkbox"], input[type="radio"]');

                // build the input box
                this.input = wrapper
                    .find("input")
                    .bind({
                        keydown: function( e ){
                            // prevent the enter key from submitting the form / closing the widget
                            if( e.which === 13 ){
                                e.preventDefault();
                            }
                        },
                        keyup: $.proxy(self._handler, self),
                        click: $.proxy(self._handler, self)
                    });

                // cache input values for searching
                this.updateCache();

                // rewrite internal _toggleChecked fn so that when checkAll/uncheckAll is fired,
                // only the currently filtered elements are checked
                instance._toggleChecked = function(flag, group){
                    var $inputs = (group && group.length) ?
                        group :
                        this.labels.find('input'),

                        _self = this,

                        // do not include hidden elems if the menu isn't open.
                        selector = self.instance._isOpen ?
                            ":disabled, :hidden" :
                            ":disabled";

                    $inputs = $inputs.not( selector ).each(this._toggleState('checked', flag));

                    // update text
                    this.update();

                    // figure out which option tags need to be selected
                    var values = $inputs.map(function(){
                        return this.value;
                    }).get();

                    // select option tags
                    this.element
                        .find('option')
                        .filter(function(){
                            if( !this.disabled && $.inArray(this.value, values) > -1 ){
                                _self._toggleState('selected', flag).call( this );
                            }
                        });
                };

                // rebuild cache when multiselect is updated
                var doc = $(document).bind("multiselectrefresh", function(){
                    self.updateCache();
                    self._handler();
                });

                // automatically reset the widget on close?
                if(this.options.autoReset) {
                    doc.bind("multiselectclose", $.proxy(this._reset, this));
                }
            },

            // thx for the logic here ben alman
            _handler: function( e ){
                var term = $.trim( this.input[0].value.toLowerCase() ),

                    // speed up lookups
                    rows = this.rows, inputs = this.inputs, cache = this.cache;

                if( !term ){
                    rows.show();
                } else {
                    rows.hide();

                    var regex = new RegExp(term.replace(rEscape, "\\$&"), 'gi');

                    this._trigger( "onfilter", e, $.map(cache, function(v, i){
                        if( v.search(regex) !== -1 ){
                            rows.eq(i).show();
                            return inputs.get(i);
                        }

                        return null;
                    }));
                }

                // show/hide optgroups
                this.instance.menu.find(".ui-multiselect-optgroup-label").each(function(){
                    var $this = $(this);
                    var isVisible = $this.nextUntil('.ui-multiselect-optgroup-label').filter(function(){
                        return $.css(this, "display") !== 'none';
                    }).length;

                    $this[ isVisible ? 'show' : 'hide' ]();
                });
            },

            _reset: function() {
                this.input.val('').trigger('keyup');
            },

            updateCache: function(){
                // each list item
                this.rows = this.instance.menu.find(".ui-multiselect-checkboxes li:not(.ui-multiselect-optgroup-label)");

                // cache
                this.cache = this.element.children().map(function(){
                    var self = $(this);

                    // account for optgroups
                    if( this.tagName.toLowerCase() === "optgroup" ){
                        self = self.children();
                    }

                    return self.map(function(){
                        return this.innerHTML.toLowerCase();
                    }).get();
                }).get();
            },

            widget: function(){
                return this.wrapper;
            },

            destroy: function(){
                $.Widget.prototype.destroy.call( this );
                this.input.val('').trigger("keyup");
                this.wrapper.remove();
            },
            _getInputFilter:function(opts){
                //IE8placeholder 2012-5-28
                var inputfilter;
                if($.browser.msie){
                    inputfilter = $("<input type='search'>");
                    if(inputfilter.val().length==0){
                        inputfilter.val(opts.placeholder);
                        inputfilter.addClass("ui-filter-placeholder");
                    }
                    inputfilter.focus(function(){
                        if(inputfilter.hasClass("ui-filter-placeholder")){
                            inputfilter.val("");
                            inputfilter.removeClass("ui-filter-placeholder");
                        }
                    });
                    inputfilter.blur(function(){
                        if(inputfilter.val().length == 0){
                            inputfilter.val(opts.placeholder);
                            inputfilter.addClass("ui-filter-placeholder") ;
                        }
                    });
                }else{
                    inputfilter = $("<input type='search' placeholder='"+opts.placeholder+"'>");
                }
                inputfilter.css("width",opts.width);
                return  inputfilter;
            }
        });
        if($.wafSelect&&$.wafSelect.textOptions){
            $.extend($.ech.multiselectfilter.prototype.options, {
                label: $.wafSelect.textOptions.label,
                placeholder: $.wafSelect.textOptions.placeholder
            });
        }
    })(jQuery);
//});


//mod.defineModule("select",["base","waf","selectfilter","select_i18n"],function(){
    /*
     * html select
     * Zhang Yanfang
     * 2012-1-9 14:23:10
     */
    (function ($, undefined) {
        $.wafSelect =  $.wafSelect || {};
        var defaultOptions = {
                size:null,
                title:null,
                tabindex:0,
                disabled:false,
                hidden:false,

                enumSource:null,
                urlSource:null,
                value:null,

                style:null,
                tagClass:null,
                height:null,
                width:null,
                listHeight:null,


                header:false,
                checkAllText:"",
                uncheckAllText:"",
                noneSelectedText:"",
                selectedText:"# ",
                selectedList:1,
                position:{my:'left top', at:'left bottom', collision:'flip'},
                multiple:false,
                formatter:null
            };
        $.extend(defaultOptions,$.wafSelect.textOptions);
        $.widget("ui.wafSelect", $.ui.wafctrl,{
            options:defaultOptions,
            _create:function () {
                $.ui.wafctrl.prototype._create.apply(this, arguments);
                var o = this.options,
                    select = this;
                o.initFlag = true;
                this.element.attr("ctrlrole", "select").addClass("ui-select");
                if (o.urlSource && undefined == o.enumSource) {
                    if (o.urlSource.substring(0, 1) != "?" && o.urlSource.indexOf($.getContextPath())==-1) {
                        o.urlSource = $.getContextPath() + o.urlSource;
                    }
                    $.ajax({
                        type:"get",
                        url:o.urlSource,
                        async:false,
                        success:function (data) {
                            o.optionJson = data;
                            o.handle = true;
                            select._setOptions(o);
                        },
                        dataType:"json"
                    });
                } else {
                    o.optionJson = o.enumSource;
                    o.handle = true;
                    select._setOptions(o);
                }
                o.initFlag = false;
                //
                this._operateState();
            },
            _analyzeSource:function (sourceJson) {
                var select = this.element;
                if (sourceJson != null) {
                    for (var p in sourceJson) {
                        var objGroup = sourceJson[p];
                        var groupAlias = objGroup.groupAlias;
                        if (groupAlias || objGroup.childs) {
                            var selectOptions = "";
                            for (var t in objGroup.childs) {
                                var objOpt = (objGroup.childs)[t];
                                selectOptions += "<option value = \"" + objOpt.value + "\" >" + objOpt.alias + "</option>";
                            }
                            var strGroup = "<optgroup label=\"" + groupAlias + "\">"+selectOptions+"</optgroup>";
                            select.append(strGroup);
                        } else {
                            var strOpt = $("<option value = \"" + objGroup.value + "\">" + objGroup.alias + "</option>");
                            select.append(strOpt);
                        }
                    }
                }

                return select;
            },
            _setOptions:function (options) {
                var multiselect = {},
                    select = this.element,
                    orginalAttrArray = [ "size", "title", "tabindex", "disabled"],
                    multiselectAttrArray = ["header", "checkAllText", "uncheckAllText", "noneSelectedText", "selectedText",
                        "selectedList", "position", "multiple", "hidden"],
                    eventArray = ["beforeopen", "onopen", "beforeclose", "onclose", "oncheckall", "onuncheckall", "onoptgrouptoggle", "onclick", "onchange"],
                    selectforeach = this, btnheight_bak = options.height, iehack = false;

                if(options.multiple){
                    select.attr("multiple", options.multiple);
                }

                $.each(options, function (key, value) {
                    if (jQuery.inArray(key, orginalAttrArray) >= 0) {
                        select.attr(key, value);
                    } else if (jQuery.inArray(key, multiselectAttrArray) >= 0) {
                        multiselect[key] = value;
                    } else if (jQuery.inArray(key, eventArray) >= 0) {
                        select.unbind("multiselect" + key)
                            .bind("multiselect" + key, value);
                    } else if (key == "name") {
                        select.attr(key, value + "_el");
                    } else if (key == "optionJson") {
                        select.children().parent().empty();
                        select = selectforeach._analyzeSource(value);
                    } else if (key == "urlSource" && options.handle === undefined) {
                        iehack = true;
                        if (options.urlSource && options.urlSource.substring(0, 1) != "?" && options.urlSource.indexOf($.getContextPath())==-1) {
                            options.urlSource = $.getContextPath() + options.urlSource;
                        }
                        $.getJSON(options.urlSource, function (data) {
                            options.optionJson = data;
                            select.children().parent().empty();
                            select = selectforeach._analyzeSource(data);
                            selectforeach._iehack(options, btnheight_bak, multiselect);
                        });
                    } else if (key == "enumSource" && options.handle === undefined) {
                        options.optionJson = value;
                        select.children().parent().empty();
                        select = selectforeach._analyzeSource(value);
                    } else if (key == "width") {
                        select.css("width", value);
                        multiselect["buttonWidth"] = options.width;
                    } else if (key == "listHeight") {
                        multiselect["height"] = value;
                    } else if( key=="formatter"){
                        if(value!=undefined){
                            multiselect["formatter"] = value;
                        }
                    } else if (key=="operateState" && value){
                        multiselect["operateState"] = value;
                    }
                    selectforeach.options[ key ] = value;
                });
                if (!iehack) {
                    this._iehack(options, btnheight_bak, multiselect);
                }
                this._operateState();
                return this;
            },
            _iehack:function (options, btnheight_bak, multiselect) {
                //ie6selectedbutton
                var self = this;
                if ($.browser.msie && ($.browser.version == "6.0") && !$.support.style) {
                    if ($.browser.msie && ($.browser.version == "6.0") && !$.support.style) {
                        setTimeout(function () {
                            self._specialAction(options, btnheight_bak, multiselect)
                        }, 1);
                    }
                } else {
                    this._specialAction(options, btnheight_bak, multiselect)
                }
            },
            _handleSelectedValue:function (obj) {
                //valueJsonvalue.
                var selectedValue;
                if (typeof obj === "object") {
                    selectedValue = obj.value;
                } else {
                    selectedValue = obj;
                }
                this.element.find("option[value='" + selectedValue + "']").attr("selected", true);
            },
            _specialAction:function (options, btnheight, multiselect) {
                //valueJsonvalue.
                var select = this.element;
                if (options.value) {
                    var selectedValue;
                    if (typeof options.value === "object") {
                        selectedValue = options.value.value;
                    } else {
                        selectedValue = options.value;
                    }
                    if (selectedValue) {
                        var selectedArray = String(selectedValue).split(","),alias=[],option;
                        for (var i = 0; i < selectedArray.length; i++) {
                            option = select.find("option[value='" + selectedArray[i] + "']");
                            if(option && option.length>0){
                                option.attr("selected", true);
                                alias.push($(option).text());
                            }
                        }
                        this._setDisplayValue(alias.join(","));
                    }

                }
                //buttonclass
                multiselect["style"] = options.style;
                //button
                multiselect["buttonHeight"] = btnheight;
                //class
                multiselect["tagClass"] = options.tagClass;
                //tabindex
                multiselect["tabindex"] = options.tabindex;

                var exist = select.data("multiselect");
                multiselect.displayField = "#"+this.options.id+"_view";
                select.multiselect(multiselect);
                if (options.filterJson) {
                    //remove it.
//                    select.multiselectfilter(options.filterJson);
                }
                if (exist) {
                    select.multiselect("refresh", options.initFlag, !options.initFlag);
                    options.initFlag = false;
                }

            },
            enable:function () {
                this.options.disabled = false;
                this.element.multiselect("enable");
            },

            disable:function () {
                this.options.disabled = true;
                this.element.multiselect("disable");
            },
            _viewDisable: function(isDisable) {
                $.ui.wafctrl.prototype._viewDisable.apply( this, arguments );
                if(isDisable){
                    this.element.multiselect("disable");
                }else{
                    this.element.multiselect("enable");
                }
            },

            checkAll:function (e) {
                this.element.multiselect("checkAll");
            },

            uncheckAll:function () {
                this.element.multiselect("uncheckAll");
            },
            isOpen:function () {
                return this.element.multiselect("isOpen");
            },
            open:function () {
                this.element.multiselect("open");
            },
            close:function () {
                this.element.multiselect("close");
            },
            getChecked:function () {
                return this.element.multiselect("getChecked");
            },
            widget:function () {
                return this.element.multiselect("widget");
            },
            refresh:function () {
                this.element.multiselect("refresh", false, true);
            },
            getValueObject:function () {
                var selectedOptions = this.element.multiselect("getChecked");
                var optionValue = selectedOptions.map(
                    function () {
                        return {value:this.value, alias:this.title};
                    }).get();
                //.
                if (!this.options.multiple && optionValue.length > 0) {
                    optionValue = optionValue[0];
                }
                return optionValue;
            },

            getValue:function () {
                var selectedOptions = this.element.multiselect("getChecked");
                var optionValue = selectedOptions.map(
                    function () {
                        return this.value;
                    }).get().join(",");
                return optionValue;
            },

            getSelectedAlias:function () {
                var selectedOptions = this.element.multiselect("getChecked");
                var optionValue = selectedOptions.map(
                    function () {
                        return this.title;
                    }).get().join(",");
                return optionValue;
            },
            setValue:function (obj) {
                this.options.value = obj;
                if (obj!=undefined && obj!=null) {
                    obj = obj.toString().split(",");
                    var el = this.element,
                        selectedOptions = el.find("option").filter(function () {
                            return $.inArray(this.value, obj) != -1;
                        });
                    $.each(selectedOptions, function (index, item) {
                        this.selected = true;
                    });
                    el.multiselect("refresh", false, true);
                    var text = selectedOptions.map(
                        function () {
                            return $(this).text();
                        }).get().join(",");
                    this._setDisplayValue(text);
                }
            },
            setSelectedValue:function (obj) {
                this.options.value = obj;
                if (obj) {
                    obj = obj.toString().split(",");
                    var el = this.element,
                        selectedOptions = el.find("option").filter(function () {
                            return $.inArray(this.value, obj) != -1;
                        });
                    $.each(selectedOptions, function (index, item) {
                        this.selected = true;
                    });
                    el.multiselect("refresh", false, true);
                }
            },
            addOption:function (obj, index) {
                if (arguments.length === 0) {
                    return false;
                }
                var options;
                if ($.isArray(obj)) {
                    for (var i in obj) {
                        var opt = $('<option />', {value:obj[i].value, text:obj[i].alias});
                        if (i == 0) {
                            options = opt;
                        } else {
                            options = options.add(opt);
                        }
                    }

                } else if ($.type.isJson(obj)) {
                    options = $('<option />', {value:obj.value, text:obj.alias});
                }
                var el = this.element;
                if (options && options.length > 0) {
                    if (index === undefined) {
                        el.append(options);
                    } else if (index == 0) {
                        el.prepend(options);
                    } else {
                        var temp = el.find("option:eq(" + (index - 1) + ")");
                        if (temp.length == 0) {
                            el.append(options);
                        } else {
                            temp.after(options);
                        }

                    }
                    el.multiselect("refresh", false, true);
                    this.options.optionJson = this._reverseAnalyzeSource();
                }
            },
            getIndex:function (value) {
                var el = this.element, result = 0, flag = false;
                el.find("option").each(function (index) {
                    if ($(this)[0].value == value) {
                        flag = true;
                        result = index;
                        return false;
                    }
                });
                if (flag) {
                    return result;
                }
            },
            removeOption:function (index) {
                var el = this.element;
                if (arguments.length === 0) {
                    var objs = el.children();
                    objs.remove();
                    el.multiselect("refresh", false, true);
                    this.options.optionJson.splice(0);
                }
                if ($.type.isNumber(index)) {
                    var obj = el.find("option:eq(" + (index) + ")");
                    obj.remove();
    //                this.options.optionJson.splice(index,1);
                    el.multiselect("refresh", false, true);
                    this.options.optionJson = this._reverseAnalyzeSource();
                }
            },
            getAllOptions:function () {
                return this.options.optionJson;
            },
            _reverseAnalyzeSource:function () {
                //slctoption
                var select = this.element,
                    jsonArray = [];

                select.children().each(function () {
                    var curObj = $(this),
                        result = {};
                    if (curObj.is("optgroup")) {

                        var childOption = [];
                        curObj.children().each(function () {
                            var childObj = {};
                            childObj.alias = $(this)[0].text;
                            childObj.value = $(this)[0].value;
                            childOption.push(childObj);
                        });
                        if (childOption.length > 0) {
                            result.groupAlias = curObj[0].label;
                            result.childs = childOption;
                        }
                    } else {
                        result.alias = curObj[0].text;
                        result.value = curObj[0].value;
                    }
                    if (!$.isEmptyObject(result)) {
                        jsonArray.push(result);
                    }

                });

                return jsonArray;
            }
        });

        $.extend($.wafSelect, {
            createSelectDOM:function (opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    var select = $("<select id='" + opts.id + "'></select>"),
                        hidden = $("<input name='" + opts.name + "' " +
                            "type='hidden' " +
                            "id='" + opts.id + "_el' " +
                            "value='" + opts.value + "'>"),
                        label = $("<label class='viewStatus' id='"+opts.id+"_view'></label>"),
                        dom = [];
                    dom.push(label,select, hidden);
                    return dom;
                }else{
                    return obj;
                }
            },
            initSelect:function (opts, el) {
                el=$.isArray(el)?el[1]:el;
                el.wafSelect(opts);
            },
            _searchItem:function (sourceArray, valueArray, resultArray) {
                var sourceLength = sourceArray.length,
                    valueLength = valueArray.length;
                for (var i = 0; i < sourceLength; i++) {
                    var item = sourceArray[i];
                    if (item.childs) {
                        $.wafSelect._searchItem(item.childs, valueArray, resultArray);
                    } else if (item.value) {
                        for (var j = 0; j < valueLength; j++) {
                            if (valueArray[j] == item.value) {
                                resultArray.push(item.alias);
                            }
                        }
                    }
                }
            },
            modifySelect:function (opts) {
                var select = $("#" + opts.id);
                select.wafSelect("option", opts);
                return select;
            },
            deleteSelect:function (opts) {
                var select = $("#" + opts.id),
                    hidden = $("#" + opts.id + "_el"),
                    label = $("#" + opts.id + "_view"),
                    btn = $("#ui-multiselect-btn-" + opts.id),
                    menu = $("#ui-multiselect-menu-" + opts.id),
                    array = [select, hidden, btn, menu,label];
                $.each(array, function (index, item) {
                    item.remove();
                });
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("select", {
                    createDOMFun:$.wafSelect.createSelectDOM,
                    initFun:$.wafSelect.initSelect,
                    deleteFun:$.wafSelect.deleteSelect,
                    modifyFun:$.wafSelect.modifySelect,lazyInit:true});
        });
    }(jQuery));
//});
//mod.defineModule("ztree_core", ["base"], function() {
    /*
     * JQuery zTree core 3.1
     * http://code.google.com/p/jquerytree/
     *
     * Copyright (c) 2010 Hunter.z (baby666.cn)
     *
     * Licensed same as jquery - MIT License
     * http://www.opensource.org/licenses/mit-license.php
     *
     * email: hunter.z@263.net
     * Date: 2012-02-14
     */
    (function($){
        var settings = {}, roots = {}, caches = {}, zId = 0,
        //default consts of core
        _consts = {
            event: {
                NODECREATED: "ztree_nodeCreated",
                CLICK: "ztree_click",
                EXPAND: "ztree_expand",
                COLLAPSE: "ztree_collapse",
                ASYNC_SUCCESS: "ztree_async_success",
                ASYNC_ERROR: "ztree_async_error"
            },
            id: {
                A: "_a",
                ICON: "_ico",
                SPAN: "_span",
                SWITCH: "_switch",
                UL: "_ul"
            },
            line: {
                ROOT: "root",
                ROOTS: "roots",
                CENTER: "center",
                BOTTOM: "bottom",
                NOLINE: "noline",
                LINE: "line"
            },
            folder: {
                OPEN: "open",
                CLOSE: "close",
                DOCU: "docu"
            },
            node: {
                CURSELECTED: "curSelectedNode"
            }
        },
        //default setting of core
        _setting = {
            treeId: "",
            treeObj: null,
            view: {
                addDiyDom: null,
                autoCancelSelected: true,
                dblClickExpand: true,
                expandSpeed: "fast",
                fontCss: {},
                nameIsHTML: false,
                selectedMulti: true,
                showIcon: true,
                showLine: true,
                showTitle: true
            },
            data: {
                key: {
                    children: "children",
                    name: "name",
                    title: ""
                },
                simpleData: {
                    enable: false,
                    idKey: "id",
                    pIdKey: "pId",
                    rootPId: null
                },
                keep: {
                    parent: false,
                    leaf: false
                }
            },
            async: {
                enable: false,
                contentType: "application/x-www-form-urlencoded",
                type: "post",
                dataType: "text",
                url: "",
                autoParam: [],
                otherParam: {},
                dataFilter: null
            },
            callback: {
                beforeAsync:null,
                beforeClick:null,
                beforeRightClick:null,
                beforeMouseDown:null,
                beforeMouseUp:null,
                beforeExpand:null,
                beforeCollapse:null,

                onAsyncError:null,
                onAsyncSuccess:null,
                onNodeCreated:null,
                onClick:null,
                onRightClick:null,
                onMouseDown:null,
                onMouseUp:null,
                onExpand:null,
                onCollapse:null
            }
        },
        //default root of core
        //zTree use root to save full data
        _initRoot = function (setting) {
            var r = data.getRoot(setting);
            if (!r) {
                r = {};
                data.setRoot(setting, r);
            }
            r.children = [];
            r.expandTriggerFlag = false;
            r.curSelectedList = [];
            r.noSelection = true;
            r.createdNodes = [];
        },
        //default cache of core
        _initCache = function(setting) {
            var c = data.getCache(setting);
            if (!c) {
                c = {};
                data.setCache(setting, c);
            }
            c.nodes = [];
            c.doms = [];
        },
        //default bindEvent of core
        _bindEvent = function(setting) {
            var o = setting.treeObj,
            c = consts.event;
            o.unbind(c.NODECREATED);
            o.bind(c.NODECREATED, function (event, treeId, node) {
                tools.apply(setting.callback.onNodeCreated, [event, treeId, node]);
            });

            o.unbind(c.CLICK);
            o.bind(c.CLICK, function (event, treeId, node, clickFlag) {
                tools.apply(setting.callback.onClick, [event, treeId, node, clickFlag]);
            });

            o.unbind(c.EXPAND);
            o.bind(c.EXPAND, function (event, treeId, node) {
                tools.apply(setting.callback.onExpand, [event, treeId, node]);
            });

            o.unbind(c.COLLAPSE);
            o.bind(c.COLLAPSE, function (event, treeId, node) {
                tools.apply(setting.callback.onCollapse, [event, treeId, node]);
            });

            o.unbind(c.ASYNC_SUCCESS);
            o.bind(c.ASYNC_SUCCESS, function (event, treeId, node, msg) {
                tools.apply(setting.callback.onAsyncSuccess, [event, treeId, node, msg]);
            });

            o.unbind(c.ASYNC_ERROR);
            o.bind(c.ASYNC_ERROR, function (event, treeId, node, XMLHttpRequest, textStatus, errorThrown) {
                tools.apply(setting.callback.onAsyncError, [event, treeId, node, XMLHttpRequest, textStatus, errorThrown]);
            });
        },
        //default event proxy of core
        _eventProxy = function(event) {
            var target = event.target,
            setting = settings[event.data.treeId],
            tId = "", node = null,
            nodeEventType = "", treeEventType = "",
            nodeEventCallback = null, treeEventCallback = null,
            tmp = null;

            if (tools.eqs(event.type, "mousedown")) {
                treeEventType = "mousedown";
            } else if (tools.eqs(event.type, "mouseup")) {
                treeEventType = "mouseup";
            } else if (tools.eqs(event.type, "contextmenu")) {
                treeEventType = "contextmenu";
            } else if (tools.eqs(event.type, "click")) {
                if (tools.eqs(target.tagName, "button")) {
                    target.blur();
                }
                if (tools.eqs(target.tagName, "button") && target.getAttribute("treeNode"+ consts.id.SWITCH) !== null) {
                    tId = target.parentNode.id;
                    nodeEventType = "switchNode";
                } else {
                    tmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
                    if (tmp) {
                        tId = tmp.parentNode.id;
                        nodeEventType = "clickNode";
                    }
                }
            } else if (tools.eqs(event.type, "dblclick")) {
                treeEventType = "dblclick";
                tmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
                if (tmp) {
                    tId = tmp.parentNode.id;
                    nodeEventType = "switchNode";
                }
            }
            if (treeEventType.length > 0 && tId.length == 0) {
                tmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
                if (tmp) {tId = tmp.parentNode.id;}
            }
            // event to node
            if (tId.length>0) {
                node = data.getNodeCache(setting, tId);
                switch (nodeEventType) {
                    case "switchNode" :
                        if (!node.isParent) {
                            nodeEventType = "";
                        } else if (tools.eqs(event.type, "click")
                            || (tools.eqs(event.type, "dblclick") && tools.apply(setting.view.dblClickExpand, [setting.treeId, node], setting.view.dblClickExpand))) {
                            nodeEventCallback = handler.onSwitchNode;
                        } else {
                            nodeEventType = "";
                        }
                        break;
                    case "clickNode" :
                        nodeEventCallback = handler.onClickNode;
                        break;
                }
            }
            // event to zTree
            switch (treeEventType) {
                case "mousedown" :
                    treeEventCallback = handler.onZTreeMousedown;
                    break;
                case "mouseup" :
                    treeEventCallback = handler.onZTreeMouseup;
                    break;
                case "dblclick" :
                    treeEventCallback = handler.onZTreeDblclick;
                    break;
                case "contextmenu" :
                    treeEventCallback = handler.onZTreeContextmenu;
                    break;
            }
            var proxyResult = {
                stop: false,
                node: node,
                nodeEventType: nodeEventType,
                nodeEventCallback: nodeEventCallback,
                treeEventType: treeEventType,
                treeEventCallback: treeEventCallback
            };
            return proxyResult
        },
        //default init node of core
        _initNode = function(setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {
            if (!n) return;
            var childKey = setting.data.key.children;
            n.level = level;
            n.tId = setting.treeId + "_" + (++zId);
            n.parentTId = parentNode ? parentNode.tId : null;
            if (n[childKey] && n[childKey].length > 0) {
                if (typeof n.open == "string") n.open = tools.eqs(n.open, "true");
                n.open = !!n.open;
                n.isParent = true;
                n.zAsync = true;
            } else {
                n.open = false;
                if (typeof n.isParent == "string") n.isParent = tools.eqs(n.isParent, "true");
                n.isParent = !!n.isParent;
                n.zAsync = !n.isParent;
            }
            n.isFirstNode = isFirstNode;
            n.isLastNode = isLastNode;
            n.getParentNode = function() {return data.getNodeCache(setting, n.parentTId);};
            n.getPreNode = function() {return data.getPreNode(setting, n);};
            n.getNextNode = function() {return data.getNextNode(setting, n);};
            n.isAjaxing = false;
            data.fixPIdKeyValue(setting, n);
        },
        _init = {
            bind: [_bindEvent],
            caches: [_initCache],
            nodes: [_initNode],
            proxys: [_eventProxy],
            roots: [_initRoot],
            beforeA: [],
            afterA: [],
            innerBeforeA: [],
            innerAfterA: [],
            zTreeTools: []
        },
        //method of operate data
        data = {
            addNodeCache: function(setting, node) {
                data.getCache(setting).nodes[node.tId] = node;
            },
            addAfterA: function(afterA) {
                _init.afterA.push(afterA);
            },
            addBeforeA: function(beforeA) {
                _init.beforeA.push(beforeA);
            },
            addInnerAfterA: function(innerAfterA) {
                _init.innerAfterA.push(innerAfterA);
            },
            addInnerBeforeA: function(innerBeforeA) {
                _init.innerBeforeA.push(innerBeforeA);
            },
            addInitBind: function(bindEvent) {
                _init.bind.push(bindEvent);
            },
            addInitCache: function(initCache) {
                _init.caches.push(initCache);
            },
            addInitNode: function(initNode) {
                _init.nodes.push(initNode);
            },
            addInitProxy: function(initProxy) {
                _init.proxys.push(initProxy);
            },
            addInitRoot: function(initRoot) {
                _init.roots.push(initRoot);
            },
            addNodesData: function(setting, parentNode, nodes) {
                var childKey = setting.data.key.children;
                if (!parentNode[childKey]) parentNode[childKey] = [];
                if (parentNode[childKey].length > 0) {
                    parentNode[childKey][parentNode[childKey].length - 1].isLastNode = false;
                    view.setNodeLineIcos(setting, parentNode[childKey][parentNode[childKey].length - 1]);
                }
                parentNode.isParent = true;
                parentNode[childKey] = parentNode[childKey].concat(nodes);
            },
            addSelectedNode: function(setting, node) {
                var root = data.getRoot(setting);
                if (!data.isSelectedNode(setting, node)) {
                    root.curSelectedList.push(node);
                }
            },
            addCreatedNode: function(setting, node) {
                if (!!setting.callback.onNodeCreated || !!setting.view.addDiyDom) {
                    var root = data.getRoot(setting);
                    root.createdNodes.push(node);
                }
            },
            addZTreeTools: function(zTreeTools) {
                _init.zTreeTools.push(zTreeTools);
            },
            exSetting: function(s) {
                $.extend(true, _setting, s);
            },
            fixPIdKeyValue: function(setting, node) {
                if (setting.data.simpleData.enable) {
                    node[setting.data.simpleData.pIdKey] = node.parentTId ? node.getParentNode()[setting.data.simpleData.idKey] : setting.data.simpleData.rootPId;
                }
            },
            getAfterA: function(setting, node, array) {
                for (var i=0, j=_init.afterA.length; i<j; i++) {
                    _init.afterA[i].apply(this, arguments);
                }
            },
            getBeforeA: function(setting, node, array) {
                for (var i=0, j=_init.beforeA.length; i<j; i++) {
                    _init.beforeA[i].apply(this, arguments);
                }
            },
            getInnerAfterA: function(setting, node, array) {
                for (var i=0, j=_init.innerAfterA.length; i<j; i++) {
                    _init.innerAfterA[i].apply(this, arguments);
                }
            },
            getInnerBeforeA: function(setting, node, array) {
                for (var i=0, j=_init.innerBeforeA.length; i<j; i++) {
                    _init.innerBeforeA[i].apply(this, arguments);
                }
            },
            getCache: function(setting) {
                return caches[setting.treeId];
            },
            getNextNode: function(setting, node) {
                if (!node) return null;
                var childKey = setting.data.key.children,
                p = node.parentTId ? node.getParentNode() : data.getRoot(setting);
                if (node.isLastNode) {
                    return null;
                } else if (node.isFirstNode) {
                    return p[childKey][1];
                } else {
                    for (var i=1, l=p[childKey].length-1; i<l; i++) {
                        if (p[childKey][i] === node) {
                            return p[childKey][i+1];
                        }
                    }
                }
                return null;
            },
            getNodeByParam: function(setting, nodes, key, value) {
                if (!nodes || !key) return null;
                var childKey = setting.data.key.children;
                for (var i = 0, l = nodes.length; i < l; i++) {
                    if (nodes[i][key] == value) {
                        return nodes[i];
                    }
                    var tmp = data.getNodeByParam(setting, nodes[i][childKey], key, value);
                    if (tmp) return tmp;
                }
                return null;
            },
            getNodeCache: function(setting, tId) {
                if (!tId) return null;
                var n = caches[setting.treeId].nodes[tId];
                return n ? n : null;
            },
            getNodes: function(setting) {
                return data.getRoot(setting)[setting.data.key.children];
            },
            getNodesByParam: function(setting, nodes, key, value) {
                if (!nodes || !key) return [];
                var childKey = setting.data.key.children,
                result = [];
                for (var i = 0, l = nodes.length; i < l; i++) {
                    if (nodes[i][key] == value) {
                        result.push(nodes[i]);
                    }
                    result = result.concat(data.getNodesByParam(setting, nodes[i][childKey], key, value));
                }
                return result;
            },
            getNodesByParamFuzzy: function(setting, nodes, key, value) {
                if (!nodes || !key) return [];
                var childKey = setting.data.key.children,
                result = [];
                for (var i = 0, l = nodes.length; i < l; i++) {
                    if (typeof nodes[i][key] == "string" && nodes[i][key].indexOf(value)>-1) {
                        result.push(nodes[i]);
                    }
                    result = result.concat(data.getNodesByParamFuzzy(setting, nodes[i][childKey], key, value));
                }
                return result;
            },
            getPreNode: function(setting, node) {
                if (!node) return null;
                var childKey = setting.data.key.children,
                p = node.parentTId ? node.getParentNode() : data.getRoot(setting);
                if (node.isFirstNode) {
                    return null;
                } else if (node.isLastNode) {
                    return p[childKey][p[childKey].length-2];
                } else {
                    for (var i=1, l=p[childKey].length-1; i<l; i++) {
                        if (p[childKey][i] === node) {
                            return p[childKey][i-1];
                        }
                    }
                }
                return null;
            },
            getRoot: function(setting) {
                return setting ? roots[setting.treeId] : null;
            },
            getSetting: function(treeId) {
                return settings[treeId];
            },
            getSettings: function() {
                return settings;
            },
            getTitleKey: function(setting) {
                return setting.data.key.title === "" ? setting.data.key.name : setting.data.key.title;
            },
            getZTreeTools: function(treeId) {
                var r = this.getRoot(this.getSetting(treeId));
                return r ? r.treeTools : null;
            },
            initCache: function(setting) {
                for (var i=0, j=_init.caches.length; i<j; i++) {
                    _init.caches[i].apply(this, arguments);
                }
            },
            initNode: function(setting, level, node, parentNode, preNode, nextNode) {
                for (var i=0, j=_init.nodes.length; i<j; i++) {
                    _init.nodes[i].apply(this, arguments);
                }
            },
            initRoot: function(setting) {
                for (var i=0, j=_init.roots.length; i<j; i++) {
                    _init.roots[i].apply(this, arguments);
                }
            },
            isSelectedNode: function(setting, node) {
                var root = data.getRoot(setting);
                for (var i=0, j=root.curSelectedList.length; i<j; i++) {
                    if(node === root.curSelectedList[i]) return true;
                }
                return false;
            },
            removeNodeCache: function(setting, node) {
                var childKey = setting.data.key.children;
                if (node[childKey]) {
                    for (var i=0, l=node[childKey].length; i<l; i++) {
                        arguments.callee(setting, node[childKey][i]);
                    }
                }
                delete data.getCache(setting).nodes[node.tId];
            },
            removeSelectedNode: function(setting, node) {
                var root = data.getRoot(setting);
                for (var i=0, j=root.curSelectedList.length; i<j; i++) {
                    if(node === root.curSelectedList[i] || !data.getNodeCache(setting, root.curSelectedList[i].tId)) {
                        root.curSelectedList.splice(i, 1);
                        i--;j--;
                    }
                }
            },
            setCache: function(setting, cache) {
                caches[setting.treeId] = cache;
            },
            setRoot: function(setting, root) {
                roots[setting.treeId] = root;
            },
            setZTreeTools: function(setting, zTreeTools) {
                for (var i=0, j=_init.zTreeTools.length; i<j; i++) {
                    _init.zTreeTools[i].apply(this, arguments);
                }
            },
            transformToArrayFormat: function (setting, nodes) {
                if (!nodes) return [];
                var childKey = setting.data.key.children,
                r = [];
                if (tools.isArray(nodes)) {
                    for (var i=0, l=nodes.length; i<l; i++) {
                        r.push(nodes[i]);
                        if (nodes[i][childKey])
                            r = r.concat(data.transformToArrayFormat(setting, nodes[i][childKey]));
                    }
                } else {
                    r.push(nodes);
                    if (nodes[childKey])
                        r = r.concat(data.transformToArrayFormat(setting, nodes[childKey]));
                }
                return r;
            },
            transformTozTreeFormat: function(setting, sNodes) {
                var i,l,
                key = setting.data.simpleData.idKey,
                parentKey = setting.data.simpleData.pIdKey,
                childKey = setting.data.key.children;
                if (!key || key=="" || !sNodes) return [];

                if (tools.isArray(sNodes)) {
                    var r = [];
                    var tmpMap = [];
                    for (i=0, l=sNodes.length; i<l; i++) {
                        tmpMap[sNodes[i][key]] = sNodes[i];
                    }
                    for (i=0, l=sNodes.length; i<l; i++) {
                        if (tmpMap[sNodes[i][parentKey]] && sNodes[i][key] != sNodes[i][parentKey]) {
                            if (!tmpMap[sNodes[i][parentKey]][childKey])
                                tmpMap[sNodes[i][parentKey]][childKey] = [];
                            tmpMap[sNodes[i][parentKey]][childKey].push(sNodes[i]);
                        } else {
                            r.push(sNodes[i]);
                        }
                    }
                    return r;
                }else {
                    return [sNodes];
                }
            }
        },
        //method of event proxy
        event = {
            bindEvent: function(setting) {
                for (var i=0, j=_init.bind.length; i<j; i++) {
                    _init.bind[i].apply(this, arguments);
                }
            },
            bindTree: function(setting) {
                var eventParam = {
                    treeId: setting.treeId
                },
                o = setting.treeObj;
                o.unbind('click', event.proxy);
                o.bind('click', eventParam, event.proxy);
                o.unbind('dblclick', event.proxy);
                o.bind('dblclick', eventParam, event.proxy);
                o.unbind('mouseover', event.proxy);
                o.bind('mouseover', eventParam, event.proxy);
                o.unbind('mouseout', event.proxy);
                o.bind('mouseout', eventParam, event.proxy);
                o.unbind('mousedown', event.proxy);
                o.bind('mousedown', eventParam, event.proxy);
                o.unbind('mouseup', event.proxy);
                o.bind('mouseup', eventParam, event.proxy);
                o.unbind('contextmenu', event.proxy);
                o.bind('contextmenu', eventParam, event.proxy);
            },
            doProxy: function(e) {
                var results = [];
                for (var i=0, j=_init.proxys.length; i<j; i++) {
                    var proxyResult = _init.proxys[i].apply(this, arguments);
                    results.push(proxyResult);
                    if (proxyResult.stop) {
                        break;
                    }
                }
                return results;
            },
            proxy: function(e) {
                var setting = data.getSetting(e.data.treeId);
                if (!tools.uCanDo(setting, e)) return true;
                var results = event.doProxy(e),
                r = true, x = false;
                for (var i=0, l=results.length; i<l; i++) {
                    var proxyResult = results[i];
                    if (proxyResult.nodeEventCallback) {
                        x = true;
                        r = proxyResult.nodeEventCallback.apply(proxyResult, [e, proxyResult.node]) && r;
                    }
                    if (proxyResult.treeEventCallback) {
                        x = true;
                        r = proxyResult.treeEventCallback.apply(proxyResult, [e, proxyResult.node]) && r;
                    }
                }
                try{
                    if (x && $("input:focus").length == 0) {
                        tools.noSel(setting);
                    }
                } catch(e) {}
                return r;
            }
        },
        //method of event handler
        handler = {
            onSwitchNode: function (event, node) {
                var setting = settings[event.data.treeId];
                if (node.open) {
                    if (tools.apply(setting.callback.beforeCollapse, [setting.treeId, node], true) == false) return true;
                    data.getRoot(setting).expandTriggerFlag = true;
                    view.switchNode(setting, node);
                } else {
                    if (tools.apply(setting.callback.beforeExpand, [setting.treeId, node], true) == false) return true;
                    data.getRoot(setting).expandTriggerFlag = true;
                    view.switchNode(setting, node);
                }
                return true;
            },
            onClickNode: function (event, node) {
                var setting = settings[event.data.treeId],
                clickFlag = ( (setting.view.autoCancelSelected && event.ctrlKey) && data.isSelectedNode(setting, node)) ? 0 : (setting.view.autoCancelSelected && event.ctrlKey && setting.view.selectedMulti) ? 2 : 1;
                if (tools.apply(setting.callback.beforeClick, [setting.treeId, node, clickFlag], true) == false) return true;
                if (clickFlag === 0) {
                    view.cancelPreSelectedNode(setting, node);
                } else {
                    view.selectNode(setting, node, clickFlag === 2);
                }
                setting.treeObj.trigger(consts.event.CLICK, [setting.treeId, node, clickFlag]);
                return true;
            },
            onZTreeMousedown: function(event, node) {
                var setting = settings[event.data.treeId];
                if (tools.apply(setting.callback.beforeMouseDown, [setting.treeId, node], true)) {
                    tools.apply(setting.callback.onMouseDown, [event, setting.treeId, node]);
                }
                return true;
            },
            onZTreeMouseup: function(event, node) {
                var setting = settings[event.data.treeId];
                if (tools.apply(setting.callback.beforeMouseUp, [setting.treeId, node], true)) {
                    tools.apply(setting.callback.onMouseUp, [event, setting.treeId, node]);
                }
                return true;
            },
            onZTreeDblclick: function(event, node) {
                var setting = settings[event.data.treeId];
                if (tools.apply(setting.callback.beforeDblClick, [setting.treeId, node], true)) {
                    tools.apply(setting.callback.onDblClick, [event, setting.treeId, node]);
                }
                return true;
            },
            onZTreeContextmenu: function(event, node) {
                var setting = settings[event.data.treeId];
                if (tools.apply(setting.callback.beforeRightClick, [setting.treeId, node], true)) {
                    tools.apply(setting.callback.onRightClick, [event, setting.treeId, node]);
                }
                return (typeof setting.callback.onRightClick) != "function";
            }
        },
        //method of tools for zTree
        tools = {
            apply: function(fun, param, defaultValue) {
                if ((typeof fun) == "function") {
                    return fun.apply(zt, param?param:[]);
                }
                return defaultValue;
            },
            canAsync: function(setting, node) {
                var childKey = setting.data.key.children;
                return (node && node.isParent && !(node.zAsync || (node[childKey] && node[childKey].length > 0)));
            },
            clone: function (jsonObj) {
                var buf;
                if (jsonObj instanceof Array) {
                    buf = [];
                    var i = jsonObj.length;
                    while (i--) {
                        buf[i] = arguments.callee(jsonObj[i]);
                    }
                    return buf;
                }else if (typeof jsonObj == "function"){
                    return jsonObj;
                }else if (jsonObj instanceof Object){
                    buf = {};
                    for (var k in jsonObj) {
                        buf[k] = arguments.callee(jsonObj[k]);
                    }
                    return buf;
                }else{
                    return jsonObj;
                }
            },
            eqs: function(str1, str2) {
                return str1.toLowerCase() === str2.toLowerCase();
            },
            isArray: function(arr) {
                return Object.prototype.toString.apply(arr) === "[object Array]";
            },
            getMDom: function (setting, curDom, targetExpr) {
                if (!curDom) return null;
                while (curDom && curDom.id !== setting.treeId) {
                    for (var i=0, l=targetExpr.length; curDom.tagName && i<l; i++) {
                        if (tools.eqs(curDom.tagName, targetExpr[i].tagName) && curDom.getAttribute(targetExpr[i].attrName) !== null) {
                            return curDom;
                        }
                    }
                    curDom = curDom.parentNode;
                }
                return null;
            },
            noSel: function(setting) {
                var r = data.getRoot(setting);
                if (r.noSelection) {
                    try {
                        window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();
                    } catch(e){}
                }
            },
            uCanDo: function(setting, e) {
                return true;
            }
        },
        //method of operate ztree dom
        view = {
            addNodes: function(setting, parentNode, newNodes, isSilent) {
                if (setting.data.keep.leaf && parentNode && !parentNode.isParent) {
                    return;
                }
                if (!tools.isArray(newNodes)) {
                    newNodes = [newNodes];
                }
                if (setting.data.simpleData.enable) {
                    newNodes = data.transformTozTreeFormat(setting, newNodes);
                }
                if (parentNode) {
                    var target_switchObj = $("#" + parentNode.tId + consts.id.SWITCH),
                    target_icoObj = $("#" + parentNode.tId + consts.id.ICON),
                    target_ulObj = $("#" + parentNode.tId + consts.id.UL);

                    if (!parentNode.open) {
                        view.replaceSwitchClass(parentNode, target_switchObj, consts.folder.CLOSE);
                        view.replaceIcoClass(parentNode, target_icoObj, consts.folder.CLOSE);
                        parentNode.open = false;
                        target_ulObj.css({
                            "display": "none"
                        });
                    }

                    data.addNodesData(setting, parentNode, newNodes);
                    view.createNodes(setting, parentNode.level + 1, newNodes, parentNode);
                    if (!isSilent) {
                        view.expandCollapseParentNode(setting, parentNode, true);
                    }
                } else {
                    data.addNodesData(setting, data.getRoot(setting), newNodes);
                    view.createNodes(setting, 0, newNodes, null);
                }
            },
            appendNodes: function(setting, level, nodes, parentNode, initFlag, openFlag) {
                if (!nodes) return [];
                var html = [],
                childKey = setting.data.key.children,
                nameKey = setting.data.key.name,
                titleKey = data.getTitleKey(setting);
                for (var i = 0, l = nodes.length; i < l; i++) {
                    var node = nodes[i],
                    tmpPNode = (parentNode) ? parentNode: data.getRoot(setting),
                    tmpPChild = tmpPNode[childKey],
                    isFirstNode = ((tmpPChild.length == nodes.length) && (i == 0)),
                    isLastNode = (i == (nodes.length - 1));
                    if (initFlag) {
                        data.initNode(setting, level, node, parentNode, isFirstNode, isLastNode, openFlag);
                        data.addNodeCache(setting, node);
                    }

                    var childHtml = [];
                    if (node[childKey] && node[childKey].length > 0) {
                        //make child html first, because checkType
                        childHtml = view.appendNodes(setting, level + 1, node[childKey], node, initFlag, openFlag && node.open);
                    }
                    if (openFlag) {
                        var url = view.makeNodeUrl(setting, node),
                        fontcss = view.makeNodeFontCss(setting, node),
                        fontStyle = [];
                        for (var f in fontcss) {
                            fontStyle.push(f, ":", fontcss[f], ";");
                        }
                        html.push("<li id='", node.tId, "' class='level", node.level,"' treenode>",
                            "<button type='button' hidefocus='true'",(node.isParent?"":"disabled")," id='", node.tId, consts.id.SWITCH,
                            "' title='' class='", view.makeNodeLineClass(setting, node), "' treeNode", consts.id.SWITCH,"></button>");
                        data.getBeforeA(setting, node, html);
                        html.push("<a id='", node.tId, consts.id.A, "' class='level", node.level,"' treeNode", consts.id.A," onclick=\"", (node.click || ''),
                            "\" ", ((url != null && url.length > 0) ? "href='" + url + "'" : ""), " target='",view.makeNodeTarget(node),"' style='", fontStyle.join(''),
                            "'");
                        if (tools.apply(setting.view.showTitle, [setting.treeId, node], setting.view.showTitle) && node[titleKey]) {html.push("title='", node[titleKey].replace(/'/g,"&#39;").replace(/</g,'&lt;').replace(/>/g,'&gt;'),"'");}
                        html.push(">");
                        data.getInnerBeforeA(setting, node, html);
                        var name = setting.view.nameIsHTML ? node[nameKey] : node[nameKey].replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
                        html.push("<button type='button' hidefocus='true' id='", node.tId, consts.id.ICON,
                            "' title='' treeNode", consts.id.ICON," class='", view.makeNodeIcoClass(setting, node), "' style='", view.makeNodeIcoStyle(setting, node), "'></button><span id='", node.tId, consts.id.SPAN,
                            "'>",name,"</span>");
                        data.getInnerAfterA(setting, node, html);
                        html.push("</a>");
                        data.getAfterA(setting, node, html);
                        if (node.isParent && node.open) {
                            view.makeUlHtml(setting, node, html, childHtml.join(''));
                        }
                        html.push("</li>");
                        data.addCreatedNode(setting, node);
                    }
                }
                return html;
            },
            appendParentULDom: function(setting, node) {
                var html = [],
                nObj = $("#" + node.tId),
                ulObj = $("#" + node.tId + consts.id.UL),
                childKey = setting.data.key.children,
                childHtml = view.appendNodes(setting, node.level+1, node[childKey], node, false, true);
                view.makeUlHtml(setting, node, html, childHtml.join(''));
                if (!nObj.get(0) && !!node.parentTId) {
                    view.appendParentULDom(setting, node.getParentNode());
                    nObj = $("#" + node.tId);
                }
                if (ulObj.get(0)) {
                    ulObj.remove();
                }

                nObj.append(html.join(''));
                view.createNodeCallback(setting);
            },
            asyncNode: function(setting, node, isSilent, callback) {
                var i, l;
                if (node && !node.isParent) {
                    tools.apply(callback);
                    return false;
                } else if (node && node.isAjaxing) {
                    return false;
                } else if (tools.apply(setting.callback.beforeAsync, [setting.treeId, node], true) == false) {
                    tools.apply(callback);
                    return false;
                }
                if (node) {
                    node.isAjaxing = true;
                    var icoObj = $("#" + node.tId + consts.id.ICON);
                    icoObj.attr({"style":"", "class":"ico_loading"});
                }

                var isJson = (setting.async.contentType == "application/json"), tmpParam = isJson ? "{" : "", jTemp="";
                for (i = 0, l = setting.async.autoParam.length; node && i < l; i++) {
                    var pKey = setting.async.autoParam[i].split("="), spKey = pKey;
                    if (pKey.length>1) {
                        spKey = pKey[1];
                        pKey = pKey[0];
                    }
                    var vnode = encodeURIComponent(node[pKey]);
                    if (isJson) {
                        jTemp = (typeof vnode == "string") ? '"' : '';
                        tmpParam += '"' + spKey + ('":' + jTemp + vnode).replace(/'/g,'\\\'') + jTemp + ',';
                    } else {
                        tmpParam += spKey + ("=" + vnode).replace(/&/g,'%26') + "&";
                    }
                }
                if (tools.isArray(setting.async.otherParam)) {
                    for (i = 0, l = setting.async.otherParam.length; i < l; i += 2) {
                        if (isJson) {
                            jTemp = (typeof setting.async.otherParam[i + 1] == "string") ? '"' : '';
                            tmpParam += '"' + setting.async.otherParam[i] + ('":' + jTemp + encodeURIComponent(setting.async.otherParam[i + 1])).replace(/'/g,'\\\'') + jTemp + ",";
                        } else {
                            tmpParam += setting.async.otherParam[i] + ("=" + encodeURIComponent(setting.async.otherParam[i + 1])).replace(/&/g,'%26') + "&";
                        }
                    }
                } else {
                    for (var p in setting.async.otherParam) {
                        if (isJson) {
                            jTemp = (typeof setting.async.otherParam[p] == "string") ? '"' : '';
                            tmpParam += '"' + p + ('":' + jTemp + encodeURIComponent(setting.async.otherParam[p])).replace(/'/g,'\\\'') + jTemp + ",";
                        } else {
                            tmpParam += p + ("=" + encodeURIComponent(setting.async.otherParam[p])).replace(/&/g,'%26') + "&";
                        }
                    }
                }
                if (tmpParam.length > 1) tmpParam = tmpParam.substring(0, tmpParam.length-1);
                if (isJson) tmpParam += "}";

                $.ajax({
                    contentType: setting.async.contentType,
                    type: setting.async.type,
                    url: tools.apply(setting.async.url, [setting.treeId, node], setting.async.url),
                    data: tmpParam,
                    dataType: setting.async.dataType,
                    success: function(msg) {
                        var newNodes = [];
                        try {
                            if (!msg || msg.length == 0) {
                                newNodes = [];
                            } else if (typeof msg == "string") {
                                newNodes = eval("(" + msg + ")");
                            } else {
                                newNodes = msg;
                            }
                        } catch(err) {}

                        if (node) {
                            node.isAjaxing = null;
                            node.zAsync = true;
                        }
                        view.setNodeLineIcos(setting, node);
                        if (newNodes && newNodes != "") {
                            newNodes = tools.apply(setting.async.dataFilter, [setting.treeId, node, newNodes], newNodes);
                            view.addNodes(setting, node, tools.clone(newNodes), !!isSilent);
                        } else {
                            view.addNodes(setting, node, [], !!isSilent);
                        }
                        setting.treeObj.trigger(consts.event.ASYNC_SUCCESS, [setting.treeId, node, msg]);
                        tools.apply(callback);
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown) {
                        view.setNodeLineIcos(setting, node);
                        if (node) node.isAjaxing = null;
                        setting.treeObj.trigger(consts.event.ASYNC_ERROR, [setting.treeId, node, XMLHttpRequest, textStatus, errorThrown]);
                    }
                });
                return true;
            },
            cancelPreSelectedNode: function (setting, node) {
                var list = data.getRoot(setting).curSelectedList;
                for (var i=0, j=list.length-1; j>=i; j--) {
                    if (!node || node === list[j]) {
                        $("#" + list[j].tId + consts.id.A).removeClass(consts.node.CURSELECTED);
                        view.setNodeName(setting, list[j]);
                        if (node) {
                            data.removeSelectedNode(setting, node);
                            break;
                        }
                    }
                }
                if (!node) data.getRoot(setting).curSelectedList = [];
            },
            createNodeCallback: function(setting) {
                if (!!setting.callback.onNodeCreated || !!setting.view.addDiyDom) {
                    var root = data.getRoot(setting);
                    while (root.createdNodes.length>0) {
                        var node = root.createdNodes.shift();
                        tools.apply(setting.view.addDiyDom, [setting.treeId, node]);
                        if (!!setting.callback.onNodeCreated) {
                            setting.treeObj.trigger(consts.event.NODECREATED, [setting.treeId, node]);
                        }
                    }
                }
            },
            createNodes: function(setting, level, nodes, parentNode) {
                if (!nodes || nodes.length == 0) return;
                var root = data.getRoot(setting),
                childKey = setting.data.key.children,
                openFlag = !parentNode || parentNode.open || !!$("#" + parentNode[childKey][0].tId).get(0);
                root.createdNodes = [];
                var zTreeHtml = view.appendNodes(setting, level, nodes, parentNode, true, openFlag);
                if (!parentNode) {
                    setting.treeObj.append(zTreeHtml.join(''));
                } else {
                    var ulObj = $("#" + parentNode.tId + consts.id.UL);
                    if (ulObj.get(0)) {
                        ulObj.append(zTreeHtml.join(''));
                    }
                }
                view.createNodeCallback(setting);
            },
            expandCollapseNode: function(setting, node, expandFlag, animateFlag, callback) {
                var root = data.getRoot(setting),
                childKey = setting.data.key.children;
                if (!node) {
                    tools.apply(callback, []);
                    return;
                }
                if (root.expandTriggerFlag) {
                    var _callback = callback;
                    callback = function(){
                        if (_callback) _callback();
                        if (node.open) {
                            setting.treeObj.trigger(consts.event.EXPAND, [setting.treeId, node]);
                        } else {
                            setting.treeObj.trigger(consts.event.COLLAPSE, [setting.treeId, node]);
                        }
                    };
                    root.expandTriggerFlag = false;
                }
                if (node.open == expandFlag) {
                    tools.apply(callback, []);
                    return;
                }
                if (!node.open && node.isParent && ((!$("#" + node.tId + consts.id.UL).get(0)) || (node[childKey] && node[childKey].length>0 && !$("#" + node[childKey][0].tId).get(0)))) {
                    view.appendParentULDom(setting, node);
                }
                var ulObj = $("#" + node.tId + consts.id.UL),
                switchObj = $("#" + node.tId + consts.id.SWITCH),
                icoObj = $("#" + node.tId + consts.id.ICON);

                if (node.isParent) {
                    node.open = !node.open;
                    if (node.iconOpen && node.iconClose) {
                        icoObj.attr("style", view.makeNodeIcoStyle(setting, node));
                    }

                    if (node.open) {
                        view.replaceSwitchClass(node, switchObj, consts.folder.OPEN);
                        view.replaceIcoClass(node, icoObj, consts.folder.OPEN);
                        if (animateFlag == false || setting.view.expandSpeed == "") {
                            ulObj.show();
                            tools.apply(callback, []);
                        } else {
                            if (node[childKey] && node[childKey].length > 0) {
                                ulObj.slideDown(setting.view.expandSpeed, callback);
                            } else {
                                ulObj.show();
                                tools.apply(callback, []);
                            }
                        }
                    } else {
                        view.replaceSwitchClass(node, switchObj, consts.folder.CLOSE);
                        view.replaceIcoClass(node, icoObj, consts.folder.CLOSE);
                        if (animateFlag == false || setting.view.expandSpeed == "") {
                            ulObj.hide();
                            tools.apply(callback, []);
                        } else {
                            ulObj.slideUp(setting.view.expandSpeed, callback);
                        }
                    }
                } else {
                    tools.apply(callback, []);
                }
            },
            expandCollapseParentNode: function(setting, node, expandFlag, animateFlag, callback) {
                if (!node) return;
                if (!node.parentTId) {
                    view.expandCollapseNode(setting, node, expandFlag, animateFlag, callback);
                    return;
                } else {
                    view.expandCollapseNode(setting, node, expandFlag, animateFlag);
                }
                if (node.parentTId) {
                    view.expandCollapseParentNode(setting, node.getParentNode(), expandFlag, animateFlag, callback);
                }
            },
            expandCollapseSonNode: function(setting, node, expandFlag, animateFlag, callback) {
                var root = data.getRoot(setting),
                childKey = setting.data.key.children,
                treeNodes = (node) ? node[childKey]: root[childKey],
                selfAnimateSign = (node) ? false : animateFlag,
                expandTriggerFlag = data.getRoot(setting).expandTriggerFlag;
                data.getRoot(setting).expandTriggerFlag = false;
                if (treeNodes) {
                    for (var i = 0, l = treeNodes.length; i < l; i++) {
                        if (treeNodes[i]) view.expandCollapseSonNode(setting, treeNodes[i], expandFlag, selfAnimateSign);
                    }
                }
                data.getRoot(setting).expandTriggerFlag = expandTriggerFlag;
                view.expandCollapseNode(setting, node, expandFlag, animateFlag, callback );
            },
            makeNodeFontCss: function(setting, node) {
                var fontCss = tools.apply(setting.view.fontCss, [setting.treeId, node], setting.view.fontCss);
                return (fontCss && ((typeof fontCss) != "function")) ? fontCss : {};
            },
            makeNodeIcoClass: function(setting, node) {
                var icoCss = ["ico"];
                if (!node.isAjaxing) {
                    icoCss[0] = (node.iconSkin ? node.iconSkin + "_" : "") + icoCss[0];
                    if (node.isParent) {
                        icoCss.push(node.open ? consts.folder.OPEN : consts.folder.CLOSE);
                    } else {
                        icoCss.push(consts.folder.DOCU);
                    }
                }
                return icoCss.join('_');
            },
            makeNodeIcoStyle: function(setting, node) {
                var icoStyle = [];
                if (!node.isAjaxing) {
                    var icon = (node.isParent && node.iconOpen && node.iconClose) ? (node.open ? node.iconOpen : node.iconClose) : node.icon;
                    if (icon) icoStyle.push("background:url(", icon, ") 0 0 no-repeat;");
                    if (setting.view.showIcon == false || !tools.apply(setting.view.showIcon, [setting.treeId, node], true)) {
                        icoStyle.push("width:0px;height:0px;");
                    }
                }
                return icoStyle.join('');
            },
            makeNodeLineClass: function(setting, node) {
                var lineClass = [];
                if (setting.view.showLine) {
                    if (node.level == 0 && node.isFirstNode && node.isLastNode) {
                        lineClass.push(consts.line.ROOT);
                    } else if (node.level == 0 && node.isFirstNode) {
                        lineClass.push(consts.line.ROOTS);
                    } else if (node.isLastNode) {
                        lineClass.push(consts.line.BOTTOM);
                    } else {
                        lineClass.push(consts.line.CENTER);
                    }
                } else {
                    lineClass.push(consts.line.NOLINE);
                }
                if (node.isParent) {
                    lineClass.push(node.open ? consts.folder.OPEN : consts.folder.CLOSE);
                } else {
                    lineClass.push(consts.folder.DOCU);
                }
                return view.makeNodeLineClassEx(node) + lineClass.join('_');
            },
            makeNodeLineClassEx: function(node) {
                return "level" + node.level + " switch ";
            },
            makeNodeTarget: function(node) {
                return (node.target || "_blank");
            },
            makeNodeUrl: function(setting, node) {
                return node.url ? node.url : null;
            },
            makeUlHtml: function(setting, node, html, content) {
                html.push("<ul id='", node.tId, consts.id.UL, "' class='level", node.level, " ", view.makeUlLineClass(setting, node), "' style='display:", (node.open ? "block": "none"),"'>");
                html.push(content);
                html.push("</ul>");
            },
            makeUlLineClass: function(setting, node) {
                return ((setting.view.showLine && !node.isLastNode) ? consts.line.LINE : "");
            },
            replaceIcoClass: function(node, obj, newName) {
                if (!obj || node.isAjaxing) return;
                var tmpName = obj.attr("class");
                if (tmpName == undefined) return;
                var tmpList = tmpName.split("_");
                switch (newName) {
                    case consts.folder.OPEN:
                    case consts.folder.CLOSE:
                    case consts.folder.DOCU:
                        tmpList[tmpList.length-1] = newName;
                        break;
                }
                obj.attr("class", tmpList.join("_"));
            },
            replaceSwitchClass: function(node, obj, newName) {
                if (!obj) return;
                var tmpName = obj.attr("class");
                if (tmpName == undefined) return;
                var tmpList = tmpName.split("_");
                switch (newName) {
                    case consts.line.ROOT:
                    case consts.line.ROOTS:
                    case consts.line.CENTER:
                    case consts.line.BOTTOM:
                    case consts.line.NOLINE:
                        tmpList[0] = view.makeNodeLineClassEx(node) + newName;
                        break;
                    case consts.folder.OPEN:
                    case consts.folder.CLOSE:
                    case consts.folder.DOCU:
                        tmpList[1] = newName;
                        break;
                }
                obj.attr("class", tmpList.join("_"));
                if (newName !== consts.folder.DOCU) {
                    obj.removeAttr("disabled");
                } else {
                    obj.attr("disabled", "disabled");
                }
            },
            selectNode: function(setting, node, addFlag) {
                if (!addFlag) {
                    view.cancelPreSelectedNode(setting);
                }
                $("#" + node.tId + consts.id.A).addClass(consts.node.CURSELECTED);
                data.addSelectedNode(setting, node);
            },
            setNodeFontCss: function(setting, treeNode) {
                var aObj = $("#" + treeNode.tId + consts.id.A),
                fontCss = view.makeNodeFontCss(setting, treeNode);
                if (fontCss) {
                    aObj.css(fontCss);
                }
            },
            setNodeLineIcos: function(setting, node) {
                if (!node) return;
                var switchObj = $("#" + node.tId + consts.id.SWITCH),
                ulObj = $("#" + node.tId + consts.id.UL),
                icoObj = $("#" + node.tId + consts.id.ICON),
                ulLine = view.makeUlLineClass(setting, node);
                if (ulLine.length==0) {
                    ulObj.removeClass(consts.line.LINE);
                } else {
                    ulObj.addClass(ulLine);
                }
                switchObj.attr("class", view.makeNodeLineClass(setting, node));
                if (node.isParent) {
                    switchObj.removeAttr("disabled");
                } else {
                    switchObj.attr("disabled", "disabled");
                }
                icoObj.removeAttr("style");
                icoObj.attr("style", view.makeNodeIcoStyle(setting, node));
                icoObj.attr("class", view.makeNodeIcoClass(setting, node));
            },
            setNodeName: function(setting, node) {
                var nameKey = setting.data.key.name,
                titleKey = data.getTitleKey(setting),
                nObj = $("#" + node.tId + consts.id.SPAN);
                nObj.empty();
                if (setting.view.nameIsHTML) {
                    nObj.html(node[nameKey]);
                } else {
                    nObj.text(node[nameKey]);
                }
                if (tools.apply(setting.view.showTitle, [setting.treeId, node], setting.view.showTitle) && node[titleKey]) {
                    var aObj = $("#" + node.tId + consts.id.A);
                    aObj.attr("title", node[titleKey]);
                }
            },
            setNodeTarget: function(node) {
                var aObj = $("#" + node.tId + consts.id.A);
                aObj.attr("target", view.makeNodeTarget(node));
            },
            setNodeUrl: function(setting, node) {
                var aObj = $("#" + node.tId + consts.id.A),
                url = view.makeNodeUrl(setting, node);
                if (url == null || url.length == 0) {
                    aObj.removeAttr("href");
                } else {
                    aObj.attr("href", url);
                }
            },
            switchNode: function(setting, node) {
                if (node.open || !tools.canAsync(setting, node)) {
                    view.expandCollapseNode(setting, node, !node.open);
                } else if (setting.async.enable) {
                    if (!view.asyncNode(setting, node)) {
                        view.expandCollapseNode(setting, node, !node.open);
                        return;
                    }
                } else if (node) {
                    view.expandCollapseNode(setting, node, !node.open);
                }
            }
        };
        // zTree defind
        $.fn.zTree = {
            consts : _consts,
            _z : {
                tools: tools,
                view: view,
                event: event,
                data: data
            },
            getZTreeObj: function(treeId) {
                var o = data.getZTreeTools(treeId);
                return o ? o : null;
            },
            init: function(obj, zSetting, zNodes) {
                var setting = tools.clone(_setting);
                $.extend(true, setting, zSetting);
                setting.treeId = obj.attr("id");
                setting.treeObj = obj;
                setting.treeObj.empty();
                settings[setting.treeId] = setting;
                if ($.browser.msie && parseInt($.browser.version)<7) {
                    setting.view.expandSpeed = "";
                }

                data.initRoot(setting);
                var root = data.getRoot(setting),
                childKey = setting.data.key.children;
                zNodes = zNodes ? tools.clone(tools.isArray(zNodes)? zNodes : [zNodes]) : [];
                if (setting.data.simpleData.enable) {
                    root[childKey] = data.transformTozTreeFormat(setting, zNodes);
                } else {
                    root[childKey] = zNodes;
                }

                data.initCache(setting);
                event.bindTree(setting);
                event.bindEvent(setting);

                var zTreeTools = {
                    setting: setting,
                    cancelSelectedNode : function(node) {
                        view.cancelPreSelectedNode(this.setting, node);
                    },
                    expandAll : function(expandFlag) {
                        expandFlag = !!expandFlag;
                        view.expandCollapseSonNode(this.setting, null, expandFlag, true);
                        return expandFlag;
                    },
                    expandNode : function(node, expandFlag, sonSign, focus, callbackFlag) {
                        if (!node || !node.isParent) return null;
                        if (expandFlag !== true && expandFlag !== false) {
                            expandFlag = !node.open;
                        }
                        callbackFlag = !!callbackFlag;

                        if (callbackFlag && expandFlag && (tools.apply(setting.callback.beforeExpand, [setting.treeId, node], true) == false)) {
                            return null;
                        } else if (callbackFlag && !expandFlag && (tools.apply(setting.callback.beforeCollapse, [setting.treeId, node], true) == false)) {
                            return null;
                        }
                        if (expandFlag && node.parentTId) {
                            view.expandCollapseParentNode(this.setting, node.getParentNode(), expandFlag, false);
                        }
                        if (expandFlag === node.open && !sonSign) {
                            return null;
                        }

                        data.getRoot(setting).expandTriggerFlag = callbackFlag;
                        if (sonSign) {
                            view.expandCollapseSonNode(this.setting, node, expandFlag, true, function() {
                                if (focus !== false) {$("#" + node.tId + consts.id.ICON).focus().blur();}
                            });
                        } else {
                            node.open = !expandFlag;
                            view.switchNode(this.setting, node);
                            if (focus !== false) {$("#" + node.tId + consts.id.ICON).focus().blur();}
                        }
                        return expandFlag;
                    },
                    getNodes : function() {
                        return data.getNodes(this.setting);
                    },
                    getNodeByParam : function(key, value, parentNode) {
                        if (!key) return null;
                        return data.getNodeByParam(this.setting, parentNode?parentNode[this.setting.data.key.children]:data.getNodes(this.setting), key, value);
                    },
                    getNodeByTId : function(tId) {
                        return data.getNodeCache(this.setting, tId);
                    },
                    getNodesByParam : function(key, value, parentNode) {
                        if (!key) return null;
                        return data.getNodesByParam(this.setting, parentNode?parentNode[this.setting.data.key.children]:data.getNodes(this.setting), key, value);
                    },
                    getNodesByParamFuzzy : function(key, value, parentNode) {
                        if (!key) return null;
                        return data.getNodesByParamFuzzy(this.setting, parentNode?parentNode[this.setting.data.key.children]:data.getNodes(this.setting), key, value);
                    },
                    getNodeIndex : function(node) {
                        if (!node) return null;
                        var childKey = setting.data.key.children,
                        parentNode = (node.parentTId) ? node.getParentNode() : data.getRoot(this.setting);
                        for (var i=0, l = parentNode[childKey].length; i < l; i++) {
                            if (parentNode[childKey][i] == node) return i;
                        }
                        return -1;
                    },
                    getSelectedNodes : function() {
                        var r = [], list = data.getRoot(this.setting).curSelectedList;
                        for (var i=0, l=list.length; i<l; i++) {
                            r.push(list[i]);
                        }
                        return r;
                    },
                    isSelectedNode : function(node) {
                        return data.isSelectedNode(this.setting, node);
                    },
                    reAsyncChildNodes : function(parentNode, reloadType, isSilent) {
                        if (!this.setting.async.enable) return;
                        var isRoot = !parentNode;
                        if (isRoot) {
                            parentNode = data.getRoot(this.setting);
                        }
                        if (reloadType=="refresh") {
                            parentNode[this.setting.data.key.children] = [];
                            if (isRoot) {
                                this.setting.treeObj.empty();
                            } else {
                                var ulObj = $("#" + parentNode.tId + consts.id.UL);
                                ulObj.empty();
                            }
                        }
                        view.asyncNode(this.setting, isRoot? null:parentNode, !!isSilent);
                    },
                    refresh : function() {
                        this.setting.treeObj.empty();
                        var root = data.getRoot(this.setting),
                        nodes = root[this.setting.data.key.children]
                        data.initRoot(this.setting);
                        root[this.setting.data.key.children] = nodes
                        data.initCache(this.setting);
                        view.createNodes(this.setting, 0, root[this.setting.data.key.children]);
                    },
                    selectNode : function(node, addFlag) {
                        if (!node) return;
                        if (tools.uCanDo(this.setting)) {
                            addFlag = setting.view.selectedMulti && addFlag;
                            if (node.parentTId) {
                                view.expandCollapseParentNode(this.setting, node.getParentNode(), true, false, function() {
                                    $("#" + node.tId + consts.id.ICON).focus().blur();
                                });
                            } else {
                                $("#" + node.tId + consts.id.ICON).focus().blur();
                            }
                            view.selectNode(this.setting, node, addFlag);
                        }
                    },
                    transformTozTreeNodes : function(simpleNodes) {
                        return data.transformTozTreeFormat(this.setting, simpleNodes);
                    },
                    transformToArray : function(nodes) {
                        return data.transformToArrayFormat(this.setting, nodes);
                    },
                    updateNode : function(node, checkTypeFlag) {
                        if (!node) return;
                        var nObj = $("#" + node.tId);
                        if (nObj.get(0) && tools.uCanDo(this.setting)) {
                            view.setNodeName(this.setting, node);
                            view.setNodeTarget(node);
                            view.setNodeUrl(this.setting, node);
                            view.setNodeLineIcos(this.setting, node);
                            view.setNodeFontCss(this.setting, node);
                        }
                    }
                }
                root.treeTools = zTreeTools;
                data.setZTreeTools(setting, zTreeTools);

                if (root[childKey] && root[childKey].length > 0) {
                    view.createNodes(setting, 0, root[childKey]);
                } else if (setting.async.enable && setting.async.url && setting.async.url !== '') {
                    view.asyncNode(setting);
                }
                return zTreeTools;
            }
        };

        var zt = $.fn.zTree,
        consts = zt.consts;
    })(jQuery);
//});
//mod.defineModule("ztree_excheck", ["base","ztree_core"], function() {
    /*
     * JQuery zTree excheck 3.1
     * http://code.google.com/p/jquerytree/
     *
     * Copyright (c) 2010 Hunter.z (baby666.cn)
     *
     * Licensed same as jquery - MIT License
     * http://www.opensource.org/licenses/mit-license.php
     *
     * email: hunter.z@263.net
     * Date: 2012-02-14
     */
    (function($){
        //default consts of excheck
        var _consts = {
            event: {
                CHECK: "ztree_check"
            },
            id: {
                CHECK: "_check"
            },
            checkbox: {
                STYLE: "checkbox",
                DEFAULT: "chk",
                DISABLED: "disable",
                FALSE: "false",
                TRUE: "true",
                FULL: "full",
                PART: "part",
                FOCUS: "focus"
            },
            radio: {
                STYLE: "radio",
                TYPE_ALL: "all",
                TYPE_LEVEL: "level"
            }
        },
        //default setting of excheck
        _setting = {
            check: {
                enable: false,
                autoCheckTrigger: false,
                chkStyle: _consts.checkbox.STYLE,
                nocheckInherit: false,
                radioType: _consts.radio.TYPE_LEVEL,
                chkboxType: {
                    "Y": "ps",
                    "N": "ps"
                }
            },
            data: {
                key: {
                    checked: "checked"
                }
            },
            callback: {
                beforeCheck:null,
                onCheck:null
            }
        },
        //default root of excheck
        _initRoot = function (setting) {
            var r = data.getRoot(setting);
            r.radioCheckedList = [];
        },
        //default cache of excheck
        _initCache = function(treeId) {},
        //default bind event of excheck
        _bindEvent = function(setting) {
            var o = setting.treeObj,
            c = consts.event;
            o.unbind(c.CHECK);
            o.bind(c.CHECK, function (event, treeId, node) {
                tools.apply(setting.callback.onCheck, [event, treeId, node]);
            });
        },
        //default event proxy of excheck
        _eventProxy = function(e) {
            var target = e.target,
            setting = data.getSetting(e.data.treeId),
            tId = "", node = null,
            nodeEventType = "", treeEventType = "",
            nodeEventCallback = null, treeEventCallback = null;

            if (tools.eqs(e.type, "mouseover")) {
                if (setting.check.enable && tools.eqs(target.tagName, "button") && target.getAttribute("treeNode"+ consts.id.CHECK) !== null) {
                    tId = target.parentNode.id;
                    nodeEventType = "mouseoverCheck";
                }
            } else if (tools.eqs(e.type, "mouseout")) {
                if (setting.check.enable && tools.eqs(target.tagName, "button") && target.getAttribute("treeNode"+ consts.id.CHECK) !== null) {
                    tId = target.parentNode.id;
                    nodeEventType = "mouseoutCheck";
                }
            } else if (tools.eqs(e.type, "click")) {
                if (setting.check.enable && tools.eqs(target.tagName, "button") && target.getAttribute("treeNode"+ consts.id.CHECK) !== null) {
                    tId = target.parentNode.id;
                    nodeEventType = "checkNode";
                }
            }
            if (tId.length>0) {
                node = data.getNodeCache(setting, tId);
                switch (nodeEventType) {
                    case "checkNode" :
                        nodeEventCallback = _handler.onCheckNode;
                        break;
                    case "mouseoverCheck" :
                        nodeEventCallback = _handler.onMouseoverCheck;
                        break;
                    case "mouseoutCheck" :
                        nodeEventCallback = _handler.onMouseoutCheck;
                        break;
                }
            }
            var proxyResult = {
                stop: false,
                node: node,
                nodeEventType: nodeEventType,
                nodeEventCallback: nodeEventCallback,
                treeEventType: treeEventType,
                treeEventCallback: treeEventCallback
            };
            return proxyResult
        },
        //default init node of excheck
        _initNode = function(setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {
            if (!n) return;
            var checkedKey = setting.data.key.checked;
            if (typeof n[checkedKey] == "string") n[checkedKey] = tools.eqs(n[checkedKey], "true");
            n[checkedKey] = !!n[checkedKey];
            n.checkedOld = n[checkedKey];
            n.nocheck = !!n.nocheck || (setting.check.nocheckInherit && parentNode && !!parentNode.nocheck);
            n.chkDisabled = !!n.chkDisabled || (parentNode && !!parentNode.chkDisabled);
            if (typeof n.halfCheck == "string") n.halfCheck = tools.eqs(n.halfCheck, "true");
            n.halfCheck = !!n.halfCheck;
            n.check_Child_State = -1;
            n.check_Focus = false;
            n.getCheckStatus = function() {return data.getCheckStatus(setting, n);};
            if (isLastNode) {
                data.makeChkFlag(setting, parentNode);
            }
        },
        //add dom for check
        _beforeA = function(setting, node, html) {
            var checkedKey = setting.data.key.checked;
            if (setting.check.enable) {
                data.makeChkFlag(setting, node);
                if (setting.check.chkStyle == consts.radio.STYLE && setting.check.radioType == consts.radio.TYPE_ALL && node[checkedKey] ) {
                    var r = data.getRoot(setting);
                    r.radioCheckedList.push(node);
                }
                html.push("<button type='button' ID='", node.tId, consts.id.CHECK, "' class='", view.makeChkClass(setting, node), "' treeNode", consts.id.CHECK," onfocus='this.blur();' ",(node.nocheck === true?"style='display:none;'":""),"></button>");
            }
        },
        //update zTreeObj, add method of check
        _zTreeTools = function(setting, zTreeTools) {
            zTreeTools.checkNode = function(node, checked, checkTypeFlag, callbackFlag) {
                var checkedKey = this.setting.data.key.checked;
                if (node.chkDisabled === true) return;
                if (checked !== true && checked !== false) {
                    checked = !node[checkedKey];
                }
                callbackFlag = !!callbackFlag;

                if (node[checkedKey] === checked && !checkTypeFlag) {
                    return;
                } else if (callbackFlag && tools.apply(this.setting.callback.beforeCheck, [this.setting.treeId, node], true) == false) {
                    return;
                }
                if (tools.uCanDo(this.setting) && this.setting.check.enable && node.nocheck !== true) {
                    node[checkedKey] = checked;
                    var checkObj = $("#" + node.tId + consts.id.CHECK);
                    if (checkTypeFlag || this.setting.check.chkStyle === consts.radio.STYLE) view.checkNodeRelation(this.setting, node);
                    view.setChkClass(this.setting, checkObj, node);
                    view.repairParentChkClassWithSelf(this.setting, node);
                    if (callbackFlag) {
                        setting.treeObj.trigger(consts.event.CHECK, [setting.treeId, node]);
                    }
                }
            }

            zTreeTools.checkAllNodes = function(checked) {
                view.repairAllChk(this.setting, !!checked);
            }

            zTreeTools.getCheckedNodes = function(checked) {
                var childKey = this.setting.data.key.children;
                checked = (checked !== false);
                return data.getTreeCheckedNodes(this.setting, data.getRoot(setting)[childKey], checked);
            }

            zTreeTools.getChangeCheckedNodes = function() {
                var childKey = this.setting.data.key.children;
                return data.getTreeChangeCheckedNodes(this.setting, data.getRoot(setting)[childKey]);
            }

            zTreeTools.setChkDisabled = function(node, disabled) {
                disabled = !!disabled;
                view.repairSonChkDisabled(this.setting, node, disabled);
                if (!disabled) view.repairParentChkDisabled(this.setting, node, disabled);
            }

            var _updateNode = zTreeTools.updateNode;
            zTreeTools.updateNode = function(node, checkTypeFlag) {
                if (_updateNode) _updateNode.apply(zTreeTools, arguments);
                if (!node || !this.setting.check.enable) return;
                var nObj = $("#" + node.tId);
                if (nObj.get(0) && tools.uCanDo(this.setting)) {
                    var checkObj = $("#" + node.tId + consts.id.CHECK);
                    if (checkTypeFlag == true || this.setting.check.chkStyle === consts.radio.STYLE) view.checkNodeRelation(this.setting, node);
                    view.setChkClass(this.setting, checkObj, node);
                    view.repairParentChkClassWithSelf(this.setting, node);
                }
            }
        },
        //method of operate data
        _data = {
            getRadioCheckedList: function(setting) {
                var checkedList = data.getRoot(setting).radioCheckedList;
                for (var i=0, j=checkedList.length; i<j; i++) {
                    if(!data.getNodeCache(setting, checkedList[i].tId)) {
                        checkedList.splice(i, 1);
                        i--; j--;
                    }
                }
                return checkedList;
            },
            getCheckStatus: function(setting, node) {
                if (!setting.check.enable || node.nocheck) return null;
                var checkedKey = setting.data.key.checked,
                r = {
                    checked: node[checkedKey],
                    half: node.halfCheck ? node.halfCheck : (setting.check.chkStyle == consts.radio.STYLE ? (node.check_Child_State === 2) : (node[checkedKey] ? (node.check_Child_State > -1 && node.check_Child_State < 2) : (node.check_Child_State > 0)))
                };
                return r;
            },
            getTreeCheckedNodes: function(setting, nodes, checked, results) {
                if (!nodes) return [];
                var childKey = setting.data.key.children,
                checkedKey = setting.data.key.checked;
                results = !results ? [] : results;
                for (var i = 0, l = nodes.length; i < l; i++) {
                    if (nodes[i].nocheck !== true && nodes[i][checkedKey] == checked) {
                        results.push(nodes[i]);
                    }
                    data.getTreeCheckedNodes(setting, nodes[i][childKey], checked, results);
                }
                return results;
            },
            getTreeChangeCheckedNodes: function(setting, nodes, results) {
                if (!nodes) return [];
                var childKey = setting.data.key.children,
                checkedKey = setting.data.key.checked;
                results = !results ? [] : results;
                for (var i = 0, l = nodes.length; i < l; i++) {
                    if (nodes[i].nocheck !== true && nodes[i][checkedKey] != nodes[i].checkedOld) {
                        results.push(nodes[i]);
                    }
                    data.getTreeChangeCheckedNodes(setting, nodes[i][childKey], results);
                }
                return results;
            },
            makeChkFlag: function(setting, node) {
                if (!node) return;
                var childKey = setting.data.key.children,
                checkedKey = setting.data.key.checked,
                chkFlag = -1;
                if (node[childKey]) {
                    var start = false;
                    for (var i = 0, l = node[childKey].length; i < l; i++) {
                        var cNode = node[childKey][i];
                        var tmp = -1;
                        if (setting.check.chkStyle == consts.radio.STYLE) {
                            if (cNode.nocheck === true) {
                                tmp = cNode.check_Child_State;
                            } else if (cNode.halfCheck === true) {
                                tmp = 2;
                            } else if (cNode.nocheck !== true && cNode[checkedKey]) {
                                tmp = 2;
                            } else {
                                tmp = cNode.check_Child_State > 0 ? 2:0;
                            }
                            if (tmp == 2) {
                                chkFlag = 2; break;
                            } else if (tmp == 0){
                                chkFlag = 0;
                            }
                        } else if (setting.check.chkStyle == consts.checkbox.STYLE) {
                            if (cNode.nocheck === true) {
                                tmp = cNode.check_Child_State;
                            } else if (cNode.halfCheck === true) {
                                tmp = 1;
                            } else if (cNode.nocheck !== true && cNode[checkedKey] ) {
                                tmp = (cNode.check_Child_State === -1 || cNode.check_Child_State === 2) ? 2 : 1;
                            } else {
                                tmp = (cNode.check_Child_State > 0) ? 1 : 0;
                            }
                            if (tmp === 1) {
                                chkFlag = 1; break;
                            } else if (tmp === 2 && start && tmp !== chkFlag) {
                                chkFlag = 1; break;
                            } else if (chkFlag === 2 && tmp > -1 && tmp < 2) {
                                chkFlag = 1; break;
                            } else if (tmp > -1) {
                                chkFlag = tmp;
                            }
                            if (!start) start = (cNode.nocheck !== true);
                        }
                    }
                }
                node.check_Child_State = chkFlag;
            }
        },
        //method of event proxy
        _event = {

        },
        //method of event handler
        _handler = {
            onCheckNode: function (event, node) {
                if (node.chkDisabled === true) return false;
                var setting = data.getSetting(event.data.treeId),
                checkedKey = setting.data.key.checked;
                if (tools.apply(setting.callback.beforeCheck, [setting.treeId, node], true) == false) return true;
                node[checkedKey] = !node[checkedKey];
                view.checkNodeRelation(setting, node);
                var checkObj = $("#" + node.tId + consts.id.CHECK);
                view.setChkClass(setting, checkObj, node);
                view.repairParentChkClassWithSelf(setting, node);
                setting.treeObj.trigger(consts.event.CHECK, [setting.treeId, node]);
                return true;
            },
            onMouseoverCheck: function(event, node) {
                if (node.chkDisabled === true) return false;
                var setting = data.getSetting(event.data.treeId),
                checkObj = $("#" + node.tId + consts.id.CHECK);
                node.check_Focus = true;
                view.setChkClass(setting, checkObj, node);
                return true;
            },
            onMouseoutCheck: function(event, node) {
                if (node.chkDisabled === true) return false;
                var setting = data.getSetting(event.data.treeId),
                checkObj = $("#" + node.tId + consts.id.CHECK);
                node.check_Focus = false;
                view.setChkClass(setting, checkObj, node);
                return true;
            }
        },
        //method of tools for zTree
        _tools = {

        },
        //method of operate ztree dom
        _view = {
            checkNodeRelation: function(setting, node) {
                var pNode, i, l,
                childKey = setting.data.key.children,
                checkedKey = setting.data.key.checked,
                r = consts.radio;
                if (setting.check.chkStyle == r.STYLE) {
                    var checkedList = data.getRadioCheckedList(setting);
                    if (node[checkedKey]) {
                        if (setting.check.radioType == r.TYPE_ALL) {
                            for (i = checkedList.length-1; i >= 0; i--) {
                                pNode = checkedList[i];
                                pNode[checkedKey] = false;
                                checkedList.splice(i, 1);

                                view.setChkClass(setting, $("#" + pNode.tId + consts.id.CHECK), pNode);
                                if (pNode.parentTId != node.parentTId) {
                                    view.repairParentChkClassWithSelf(setting, pNode);
                                }
                            }
                            checkedList.push(node);
                        } else {
                            var parentNode = (node.parentTId) ? node.getParentNode() : data.getRoot(setting);
                            for (i = 0, l = parentNode[childKey].length; i < l; i++) {
                                pNode = parentNode[childKey][i];
                                if (pNode[checkedKey] && pNode != node) {
                                    pNode[checkedKey] = false;
                                    view.setChkClass(setting, $("#" + pNode.tId + consts.id.CHECK), pNode);
                                }
                            }
                        }
                    } else if (setting.check.radioType == r.TYPE_ALL) {
                        for (i = 0, l = checkedList.length; i < l; i++) {
                            if (node == checkedList[i]) {
                                checkedList.splice(i, 1);
                                break;
                            }
                        }
                    }

                } else {
                    if (node[checkedKey] && (!node[childKey] || node[childKey].length==0 || setting.check.chkboxType.Y.indexOf("s") > -1)) {
                        view.setSonNodeCheckBox(setting, node, true);
                    }
                    if (!node[checkedKey] && (!node[childKey] || node[childKey].length==0 || setting.check.chkboxType.N.indexOf("s") > -1)) {
                        view.setSonNodeCheckBox(setting, node, false);
                    }
                    if (node[checkedKey] && setting.check.chkboxType.Y.indexOf("p") > -1) {
                        view.setParentNodeCheckBox(setting, node, true);
                    }
                    if (!node[checkedKey] && setting.check.chkboxType.N.indexOf("p") > -1) {
                        view.setParentNodeCheckBox(setting, node, false);
                    }
                }
            },
            makeChkClass: function(setting, node) {
                var checkedKey = setting.data.key.checked,
                c = consts.checkbox, r = consts.radio,
                fullStyle = "";
                if (node.chkDisabled === true) {
                    fullStyle = c.DISABLED;
                } else if (node.halfCheck) {
                    fullStyle = c.PART;
                } else if (setting.check.chkStyle == r.STYLE) {
                    fullStyle = (node.check_Child_State < 1)? c.FULL:c.PART;
                } else {
                    fullStyle = node[checkedKey] ? ((node.check_Child_State === 2 || node.check_Child_State === -1) ? c.FULL:c.PART) : ((node.check_Child_State < 1)? c.FULL:c.PART);
                }
                var chkName = setting.check.chkStyle + "_" + (node[checkedKey] ? c.TRUE : c.FALSE) + "_" + fullStyle;
                chkName = (node.check_Focus && node.chkDisabled !== true) ? chkName + "_" + c.FOCUS : chkName;
                return c.DEFAULT + " " + chkName;
            },
            repairAllChk: function(setting, checked) {
                if (setting.check.enable && setting.check.chkStyle === consts.checkbox.STYLE) {
                    var checkedKey = setting.data.key.checked,
                    childKey = setting.data.key.children,
                    root = data.getRoot(setting);
                    for (var i = 0, l = root[childKey].length; i<l ; i++) {
                        var node = root[childKey][i];
                        if (node.nocheck !== true) {
                            node[checkedKey] = checked;
                        }
                        view.setSonNodeCheckBox(setting, node, checked);
                    }
                }
            },
            repairChkClass: function(setting, node) {
                if (!node) return;
                data.makeChkFlag(setting, node);
                var checkObj = $("#" + node.tId + consts.id.CHECK);
                view.setChkClass(setting, checkObj, node);
            },
            repairParentChkClass: function(setting, node) {
                if (!node || !node.parentTId) return;
                var pNode = node.getParentNode();
                view.repairChkClass(setting, pNode);
                view.repairParentChkClass(setting, pNode);
            },
            repairParentChkClassWithSelf: function(setting, node) {
                if (!node) return;
                var childKey = setting.data.key.children;
                if (node[childKey] && node[childKey].length > 0) {
                    view.repairParentChkClass(setting, node[childKey][0]);
                } else {
                    view.repairParentChkClass(setting, node);
                }
            },
            repairSonChkDisabled: function(setting, node, chkDisabled) {
                if (!node) return;
                var childKey = setting.data.key.children;
                if (node.chkDisabled != chkDisabled) {
                    node.chkDisabled = chkDisabled;
                    if (node.nocheck !== true) view.repairChkClass(setting, node);
                }
                if (node[childKey]) {
                    for (var i = 0, l = node[childKey].length; i < l; i++) {
                        var sNode = node[childKey][i];
                        view.repairSonChkDisabled(setting, sNode, chkDisabled);
                    }
                }
            },
            repairParentChkDisabled: function(setting, node, chkDisabled) {
                if (!node) return;
                if (node.chkDisabled != chkDisabled) {
                    node.chkDisabled = chkDisabled;
                    if (node.nocheck !== true) view.repairChkClass(setting, node);
                }
                view.repairParentChkDisabled(setting, node.getParentNode(), chkDisabled);
            },
            setChkClass: function(setting, obj, node) {
                if (!obj) return;
                if (node.nocheck === true) {
                    obj.hide();
                } else {
                    obj.show();
                }
                obj.removeClass();
                obj.addClass(view.makeChkClass(setting, node));
            },
            setParentNodeCheckBox: function(setting, node, value, srcNode) {
                var childKey = setting.data.key.children,
                checkedKey = setting.data.key.checked,
                checkObj = $("#" + node.tId + consts.id.CHECK);
                if (!srcNode) srcNode = node;
                data.makeChkFlag(setting, node);
                if (node.nocheck !== true && node.chkDisabled !== true) {
                    node[checkedKey] = value;
                    view.setChkClass(setting, checkObj, node);
                    if (setting.check.autoCheckTrigger && node != srcNode && node.nocheck !== true) {
                        setting.treeObj.trigger(consts.event.CHECK, [setting.treeId, node]);
                    }
                }
                if (node.parentTId) {
                    var pSign = true;
                    if (!value) {
                        var pNodes = node.getParentNode()[childKey];
                        for (var i = 0, l = pNodes.length; i < l; i++) {
                            if ((pNodes[i].nocheck !== true && pNodes[i][checkedKey])
                            || (pNodes[i].nocheck === true && pNodes[i].check_Child_State > 0)) {
                                pSign = false;
                                break;
                            }
                        }
                    }
                    if (pSign) {
                        view.setParentNodeCheckBox(setting, node.getParentNode(), value, srcNode);
                    }
                }
            },
            setSonNodeCheckBox: function(setting, node, value, srcNode) {
                if (!node) return;
                var childKey = setting.data.key.children,
                checkedKey = setting.data.key.checked,
                checkObj = $("#" + node.tId + consts.id.CHECK);
                if (!srcNode) srcNode = node;

                var hasDisable = false;
                if (node[childKey]) {
                    for (var i = 0, l = node[childKey].length; i < l && node.chkDisabled !== true; i++) {
                        var sNode = node[childKey][i];
                        view.setSonNodeCheckBox(setting, sNode, value, srcNode);
                        if (sNode.chkDisabled === true) hasDisable = true;
                    }
                }

                if (node != data.getRoot(setting) && node.chkDisabled !== true) {
                    if (hasDisable && node.nocheck !== true) {
                        data.makeChkFlag(setting, node);
                    }
                    if (node.nocheck !== true) {
                        node[checkedKey] = value;
                        if (!hasDisable) node.check_Child_State = (node[childKey] && node[childKey].length > 0) ? (value ? 2 : 0) : -1;
                    } else {
                        node.check_Child_State = -1;
                    }
                    view.setChkClass(setting, checkObj, node);
                    if (setting.check.autoCheckTrigger && node != srcNode && node.nocheck !== true) {
                        setting.treeObj.trigger(consts.event.CHECK, [setting.treeId, node]);
                    }
                }

            }
        },

        _z = {
            tools: _tools,
            view: _view,
            event: _event,
            data: _data
        };
        $.extend(true, $.fn.zTree.consts, _consts);
        $.extend(true, $.fn.zTree._z, _z);

        var zt = $.fn.zTree,
        tools = zt._z.tools,
        consts = zt.consts,
        view = zt._z.view,
        data = zt._z.data,
        event = zt._z.event;

        data.exSetting(_setting);
        data.addInitBind(_bindEvent);
        data.addInitCache(_initCache);
        data.addInitNode(_initNode);
        data.addInitProxy(_eventProxy);
        data.addInitRoot(_initRoot);
        data.addBeforeA(_beforeA);
        data.addZTreeTools(_zTreeTools);

        var _createNodes = view.createNodes;
        view.createNodes = function(setting, level, nodes, parentNode) {
            if (_createNodes) _createNodes.apply(view, arguments);
            if (!nodes) return;
            view.repairParentChkClassWithSelf(setting, parentNode);
        }
    })(jQuery);
//});
//mod.defineModule("ztree_exedit", ["base","ztree_core"], function() {
    /*
     * JQuery zTree exedit 3.1
     * http://code.google.com/p/jquerytree/
     *
     * Copyright (c) 2010 Hunter.z (baby666.cn)
     *
     * Licensed same as jquery - MIT License
     * http://www.opensource.org/licenses/mit-license.php
     *
     * email: hunter.z@263.net
     * Date: 2012-02-14
     */
    (function($){
        //default consts of exedit
        var _consts = {
            event: {
                DRAG: "ztree_drag",
                DROP: "ztree_drop",
                REMOVE: "ztree_remove",
                RENAME: "ztree_rename"
            },
            id: {
                EDIT: "_edit",
                INPUT: "_input",
                REMOVE: "_remove"
            },
            move: {
                TYPE_INNER: "inner",
                TYPE_PREV: "prev",
                TYPE_NEXT: "next"
            },
            node: {
                CURSELECTED_EDIT: "curSelectedNode_Edit",
                TMPTARGET_TREE: "tmpTargetzTree",
                TMPTARGET_NODE: "tmpTargetNode"
            }
        },
        //default setting of exedit
        _setting = {
            edit: {
                enable: false,
                editNameSelectAll: false,
                showRemoveBtn: true,
                showRenameBtn: true,
                removeTitle: "remove",
                renameTitle: "rename",
                drag: {
                    autoExpandTrigger: false,
                    isCopy: true,
                    isMove: true,
                    prev: true,
                    next: true,
                    inner: true,
                    minMoveSize: 5,
                    borderMax: 10,
                    borderMin: -5,
                    maxShowNodeNum: 5,
                    autoOpenTime: 500
                }
            },
            view: {
                addHoverDom: null,
                removeHoverDom: null
            },
            callback: {
                beforeDrag:null,
                beforeDragOpen:null,
                beforeDrop:null,
                beforeEditName:null,
                beforeRemove:null,
                beforeRename:null,
                onDrag:null,
                onDrop:null,
                onRemove:null,
                onRename:null
            }
        },
        //default root of exedit
        _initRoot = function (setting) {
            var r = data.getRoot(setting);
            r.curEditNode = null;
            r.curEditInput = null;
            r.curHoverNode = null;
            r.dragFlag = 0;
            r.dragNodeShowBefore = [];
            r.dragMaskList = new Array();
            r.showHoverDom = true;
        },
        //default cache of exedit
        _initCache = function(treeId) {},
        //default bind event of exedit
        _bindEvent = function(setting) {
            var o = setting.treeObj;
            var c = consts.event;
            o.unbind(c.RENAME);
            o.bind(c.RENAME, function (event, treeId, treeNode) {
                tools.apply(setting.callback.onRename, [event, treeId, treeNode]);
            });

            o.unbind(c.REMOVE);
            o.bind(c.REMOVE, function (event, treeId, treeNode) {
                tools.apply(setting.callback.onRemove, [event, treeId, treeNode]);
            });

            o.unbind(c.DRAG);
            o.bind(c.DRAG, function (event, treeId, treeNodes) {
                tools.apply(setting.callback.onDrag, [event, treeId, treeNodes]);
            });

            o.unbind(c.DROP);
            o.bind(c.DROP, function (event, treeId, treeNodes, targetNode, moveType) {
                tools.apply(setting.callback.onDrop, [event, treeId, treeNodes, targetNode, moveType]);
            });
        },
        //default event proxy of exedit
        _eventProxy = function(e) {
            var target = e.target,
            setting = data.getSetting(e.data.treeId),
            relatedTarget = e.relatedTarget,
            tId = "", node = null,
            nodeEventType = "", treeEventType = "",
            nodeEventCallback = null, treeEventCallback = null,
            tmp = null;

            if (tools.eqs(e.type, "mouseover")) {
                tmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
                if (tmp) {
                    tId = tmp.parentNode.id;
                    nodeEventType = "hoverOverNode";
                }
            } else if (tools.eqs(e.type, "mouseout")) {
                tmp = tools.getMDom(setting, relatedTarget, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
                if (!tmp) {
                    tId = "remove";
                    nodeEventType = "hoverOutNode";
                }
            } else if (tools.eqs(e.type, "mousedown")) {
                tmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
                if (tmp) {
                    tId = tmp.parentNode.id;
                    nodeEventType = "mousedownNode";
                }
            }
            if (tId.length>0) {
                node = data.getNodeCache(setting, tId);
                switch (nodeEventType) {
                    case "mousedownNode" :
                        nodeEventCallback = _handler.onMousedownNode;
                        break;
                    case "hoverOverNode" :
                        nodeEventCallback = _handler.onHoverOverNode;
                        break;
                    case "hoverOutNode" :
                        nodeEventCallback = _handler.onHoverOutNode;
                        break;
                }
            }
            var proxyResult = {
                stop: false,
                node: node,
                nodeEventType: nodeEventType,
                nodeEventCallback: nodeEventCallback,
                treeEventType: treeEventType,
                treeEventCallback: treeEventCallback
            };
            return proxyResult
        },
        //default init node of exedit
        _initNode = function(setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {
            if (!n) return;
            n.isHover = false;
            n.editNameFlag = false;
        },
        //update zTreeObj, add method of edit
        _zTreeTools = function(setting, zTreeTools) {
            zTreeTools.addNodes = function(parentNode, newNodes, isSilent) {
                if (!newNodes) return null;
                if (!parentNode) parentNode = null;
                if (parentNode && !parentNode.isParent && setting.data.keep.leaf) return null;
                var xNewNodes = tools.clone(tools.isArray(newNodes)? newNodes: [newNodes]);
                function addCallback() {
                    view.addNodes(setting, parentNode, xNewNodes, (isSilent==true));
                }

                if (setting.async.enable && tools.canAsync(setting, parentNode)) {
                    view.asyncNode(setting, parentNode, isSilent, addCallback);
                } else {
                    addCallback();
                }
                return xNewNodes;
            }
            zTreeTools.cancelEditName = function(newName) {
                var root = data.getRoot(setting),
                nameKey = setting.data.key.name,
                node = root.curEditNode;
                if (!root.curEditNode) return;
                view.cancelCurEditNode(setting, newName?newName:node[nameKey]);
            }
            zTreeTools.copyNode = function(targetNode, node, moveType, isSilent) {
                if (!node) return null;
                if (targetNode && !targetNode.isParent && setting.data.keep.leaf && moveType === consts.move.TYPE_INNER) return null;
                var newNode = tools.clone(node);
                if (!targetNode) {
                    targetNode = null;
                    moveType = consts.move.TYPE_INNER;
                }
                if (moveType == consts.move.TYPE_INNER) {
                    function copyCallback() {
                        view.addNodes(setting, targetNode, [newNode], isSilent);
                    }

                    if (setting.async.enable && tools.canAsync(setting, targetNode)) {
                        view.asyncNode(setting, targetNode, isSilent, copyCallback);
                    } else {
                        copyCallback();
                    }
                } else {
                    view.addNodes(setting, targetNode.parentNode, [newNode], isSilent);
                    view.moveNode(setting, targetNode, newNode, moveType, false, isSilent);
                }
                return newNode;
            }
            zTreeTools.editName = function(node) {
                if (!node || !node.tId || node !== data.getNodeCache(setting, node.tId)) return;
                if (node.parentTId) view.expandCollapseParentNode(setting, node.getParentNode(), true);
                view.editNode(setting, node)
            }
            zTreeTools.moveNode = function(targetNode, node, moveType, isSilent) {
                if (!node) return node;
                if (targetNode && !targetNode.isParent && setting.data.keep.leaf && moveType === consts.move.TYPE_INNER) {
                    return null;
                } else if (targetNode && ((node.parentTId == targetNode.tId && moveType == consts.move.TYPE_INNER) || $("#" + node.tId).find("#" + targetNode.tId).length > 0)) {
                    return null;
                } else if (!targetNode) {
                    targetNode = null;
                }
                function moveCallback() {
                    view.moveNode(setting, targetNode, node, moveType, false, isSilent);
                }
                if (setting.async.enable && tools.canAsync(setting, targetNode)) {
                    view.asyncNode(setting, targetNode, isSilent, moveCallback);
                } else {
                    moveCallback();
                }
                return node;
            }
            zTreeTools.removeNode = function(node, callbackFlag) {
                if (!node) return;
                callbackFlag = !!callbackFlag;
                if (callbackFlag && tools.apply(setting.callback.beforeRemove, [setting.treeId, node], true) == false) return;
                view.removeNode(setting, node);
                if (callbackFlag) {
                    this.setting.treeObj.trigger(consts.event.REMOVE, [setting.treeId, node]);
                }
            }
            zTreeTools.removeChildNodes = function(node) {
                if (!node) return null;
                var childKey = setting.data.key.children,
                nodes = node[childKey];
                view.removeChildNodes(setting, node);
                return nodes ? nodes : null;
            }
            zTreeTools.setEditable = function(editable) {
                setting.edit.enable = editable;
                return this.refresh();
            }
        },
        //method of operate data
        _data = {
            setSonNodeLevel: function(setting, parentNode, node) {
                if (!node) return;
                var childKey = setting.data.key.children;
                node.level = (parentNode)? parentNode.level + 1 : 0;
                if (!node[childKey]) return;
                for (var i = 0, l = node[childKey].length; i < l; i++) {
                    if (node[childKey][i]) data.setSonNodeLevel(setting, node, node[childKey][i]);
                }
            }
        },
        //method of event proxy
        _event = {

        },
        //method of event handler
        _handler = {
            onHoverOverNode: function(event, node) {
                var setting = data.getSetting(event.data.treeId),
                root = data.getRoot(setting);
                if (root.curHoverNode != node) {
                    _handler.onHoverOutNode(event);
                }
                root.curHoverNode = node;
                view.addHoverDom(setting, node);
            },
            onHoverOutNode: function(event, node) {
                var setting = data.getSetting(event.data.treeId),
                root = data.getRoot(setting);
                if (root.curHoverNode && !data.isSelectedNode(setting, root.curHoverNode)) {
                    view.removeTreeDom(setting, root.curHoverNode);
                    root.curHoverNode = null;
                }
            },
            onMousedownNode: function(eventMouseDown, _node) {
                var i,l,
                setting = data.getSetting(eventMouseDown.data.treeId),
                root = data.getRoot(setting);
                //right click can't drag & drop
                if (eventMouseDown.button == 2 || !setting.edit.enable || (!setting.edit.drag.isCopy && !setting.edit.drag.isMove)) return true;

                //input of edit node name can't drag & drop
                var target = eventMouseDown.target,
                _nodes = data.getRoot(setting).curSelectedList,
                nodes = [];
                if (!data.isSelectedNode(setting, _node)) {
                    nodes = [_node];
                } else {
                    for (i=0, l=_nodes.length; i<l; i++) {
                        if (_nodes[i].editNameFlag && tools.eqs(target.tagName, "input") && target.getAttribute("treeNode"+consts.id.INPUT) !== null) {
                            return true;
                        }
                        nodes.push(_nodes[i]);
                        if (nodes[0].parentTId !== _nodes[i].parentTId) {
                            nodes = [_node];
                            break;
                        }
                    }
                }

                view.editNodeBlur = true;
                view.cancelCurEditNode(setting, null, true);


                var doc = $(document), curNode, tmpArrow, tmpTarget,
                isOtherTree = false,
                targetSetting = setting,
                preNode, nextNode,
                preTmpTargetNodeId = null,
                preTmpMoveType = null,
                tmpTargetNodeId = null,
                moveType = consts.move.TYPE_INNER,
                mouseDownX = eventMouseDown.clientX,
                mouseDownY = eventMouseDown.clientY,
                startTime = (new Date()).getTime();

                if (tools.uCanDo(setting)) {
                    doc.bind("mousemove", _docMouseMove);
                }
                function _docMouseMove(event) {
                    //avoid start drag after click node
                    if (root.dragFlag == 0 && Math.abs(mouseDownX - event.clientX) < setting.edit.drag.minMoveSize
                        && Math.abs(mouseDownY - event.clientY) < setting.edit.drag.minMoveSize) {
                        return true;
                    }
                    var i, l, tmpNode, tmpDom, tmpNodes,
                    childKey = setting.data.key.children;
                    tools.noSel(setting);
                    $("body").css("cursor", "pointer");

                    if (root.dragFlag == 0) {
                        if (tools.apply(setting.callback.beforeDrag, [setting.treeId, nodes], true) == false) {
                            _docMouseUp(event);
                            return true;
                        }

                        for (i=0, l=nodes.length; i<l; i++) {
                            if (i==0) {
                                root.dragNodeShowBefore = [];
                            }
                            tmpNode = nodes[i];
                            if (tmpNode.isParent && tmpNode.open) {
                                view.expandCollapseNode(setting, tmpNode, !tmpNode.open);
                                root.dragNodeShowBefore[tmpNode.tId] = true;
                            } else {
                                root.dragNodeShowBefore[tmpNode.tId] = false;
                            }
                        }

                        root.dragFlag = 1;
                        root.showHoverDom = false;
                        tools.showIfameMask(setting, true);

                        //sort
                        var isOrder = true, lastIndex = -1;
                        if (nodes.length>1) {
                            var pNodes = nodes[0].parentTId ? nodes[0].getParentNode()[childKey] : data.getNodes(setting);
                            tmpNodes = [];
                            for (i=0, l=pNodes.length; i<l; i++) {
                                if (root.dragNodeShowBefore[pNodes[i].tId] !== undefined) {
                                    if (isOrder && lastIndex > -1 && (lastIndex+1) !== i) {
                                        isOrder = false;
                                    }
                                    tmpNodes.push(pNodes[i]);
                                    lastIndex = i;
                                }
                                if (nodes.length === tmpNodes.length) {
                                    nodes = tmpNodes;
                                    break;
                                }
                            }
                        }
                        if (isOrder) {
                            preNode = nodes[0].getPreNode();
                            nextNode = nodes[nodes.length-1].getNextNode();
                        }

                        //set node in selected
                        curNode = $("<ul class='zTreeDragUL'></ul>");
                        for (i=0, l=nodes.length; i<l; i++) {
                            tmpNode = nodes[i];
                            tmpNode.editNameFlag = false;
                            view.selectNode(setting, tmpNode, i>0);
                            view.removeTreeDom(setting, tmpNode);

                            tmpDom = $("<li id='"+ tmpNode.tId +"_tmp'></li>");
                            tmpDom.append($("#" + tmpNode.tId + consts.id.A).clone());
                            tmpDom.css("padding", "0");
                            tmpDom.children("#" + tmpNode.tId + consts.id.A).removeClass(consts.node.CURSELECTED);
                            curNode.append(tmpDom);
                            if (i == setting.edit.drag.maxShowNodeNum-1) {
                                tmpDom = $("<li id='"+ tmpNode.tId +"_moretmp'><a>  ...  </a></li>");
                                curNode.append(tmpDom);
                                break;
                            }
                        }
                        curNode.attr("id", nodes[0].tId + consts.id.UL + "_tmp");
                        curNode.addClass(setting.treeObj.attr("class"));
                        curNode.appendTo("body");

                        tmpArrow = $("<button class='tmpzTreeMove_arrow'></button>");
                        tmpArrow.attr("id", "zTreeMove_arrow_tmp");
                        tmpArrow.appendTo("body");

                        setting.treeObj.trigger(consts.event.DRAG, [setting.treeId, nodes]);
                    }

                    if (root.dragFlag == 1 && tmpArrow.attr("id") != event.target.id) {
                        if (tmpTarget) {
                            tmpTarget.removeClass(consts.node.TMPTARGET_TREE);
                            if (tmpTargetNodeId) $("#" + tmpTargetNodeId + consts.id.A, tmpTarget).removeClass(consts.node.TMPTARGET_NODE);
                        }
                        tmpTarget = null;
                        tmpTargetNodeId = null;

                        //judge drag & drop in multi ztree
                        isOtherTree = false;
                        targetSetting = setting;
                        var settings = data.getSettings();
                        for (var s in settings) {
                            if (settings[s].treeId && settings[s].edit.enable && settings[s].treeId != setting.treeId
                                && (event.target.id == settings[s].treeId || $(event.target).parents("#" + settings[s].treeId).length>0)) {
                                isOtherTree = true;
                                targetSetting = settings[s];
                            }
                        }

                        var docScrollTop = doc.scrollTop(),
                        docScrollLeft = doc.scrollLeft(),
                        treeOffset = targetSetting.treeObj.offset(),
                        scrollHeight = targetSetting.treeObj.get(0).scrollHeight,
                        scrollWidth = targetSetting.treeObj.get(0).scrollWidth,
                        dTop = (event.clientY + docScrollTop - treeOffset.top),
                        dBottom = (targetSetting.treeObj.height() + treeOffset.top - event.clientY - docScrollTop),
                        dLeft = (event.clientX + docScrollLeft - treeOffset.left),
                        dRight = (targetSetting.treeObj.width() + treeOffset.left - event.clientX - docScrollLeft),
                        isTop = (dTop < setting.edit.drag.borderMax && dTop > setting.edit.drag.borderMin),
                        isBottom = (dBottom < setting.edit.drag.borderMax && dBottom > setting.edit.drag.borderMin),
                        isLeft = (dLeft < setting.edit.drag.borderMax && dLeft > setting.edit.drag.borderMin),
                        isRight = (dRight < setting.edit.drag.borderMax && dRight > setting.edit.drag.borderMin),
                        isTreeInner = dTop > setting.edit.drag.borderMin && dBottom > setting.edit.drag.borderMin && dLeft > setting.edit.drag.borderMin && dRight > setting.edit.drag.borderMin,
                        isTreeTop = (isTop && targetSetting.treeObj.scrollTop() <= 0),
                        isTreeBottom = (isBottom && (targetSetting.treeObj.scrollTop() + targetSetting.treeObj.height()+10) >= scrollHeight),
                        isTreeLeft = (isLeft && targetSetting.treeObj.scrollLeft() <= 0),
                        isTreeRight = (isRight && (targetSetting.treeObj.scrollLeft() + targetSetting.treeObj.width()+10) >= scrollWidth);

                        if (event.target.id && targetSetting.treeObj.find("#" + event.target.id).length > 0) {
                            //get node <li> dom
                            var targetObj = event.target;
                            while (targetObj && targetObj.tagName && !tools.eqs(targetObj.tagName, "li") && targetObj.id != targetSetting.treeId) {
                                targetObj = targetObj.parentNode;
                            }

                            var canMove = true;
                            //don't move to self or children of self
                            for (i=0, l=nodes.length; i<l; i++) {
                                tmpNode = nodes[i];
                                if (targetObj.id === tmpNode.tId) {
                                    canMove = false;
                                    break;
                                } else if ($("#" + tmpNode.tId).find("#" + targetObj.id).length > 0) {
                                    canMove = false;
                                    break;
                                }
                            }
                            if (canMove) {
                                if (event.target.id &&
                                    (event.target.id == (targetObj.id + consts.id.A) || $(event.target).parents("#" + targetObj.id + consts.id.A).length > 0)) {
                                    tmpTarget = $(targetObj);
                                    tmpTargetNodeId = targetObj.id;
                                }
                            }
                        }

                        //the mouse must be in zTree
                        tmpNode = nodes[0];
                        if (isTreeInner && (event.target.id == targetSetting.treeId || $(event.target).parents("#" + targetSetting.treeId).length>0)) {
                            //judge mouse move in root of ztree
                            if (!tmpTarget && (event.target.id == targetSetting.treeId || isTreeTop || isTreeBottom || isTreeLeft || isTreeRight) && (isOtherTree || (!isOtherTree && tmpNode.parentTId))) {
                                tmpTarget = targetSetting.treeObj;
                            }
                            //auto scroll top
                            if (isTop) {
                                targetSetting.treeObj.scrollTop(targetSetting.treeObj.scrollTop()-10);
                            } else if (isBottom)  {
                                targetSetting.treeObj.scrollTop(targetSetting.treeObj.scrollTop()+10);
                            }
                            if (isLeft) {
                                targetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft()-10);
                            } else if (isRight) {
                                targetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft()+10);
                            }
                            //auto scroll left
                            if (tmpTarget && tmpTarget != targetSetting.treeObj && tmpTarget.offset().left < targetSetting.treeObj.offset().left) {
                                targetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft()+ tmpTarget.offset().left - targetSetting.treeObj.offset().left);
                            }
                        }

                        curNode.css({
                            "top": (event.clientY + docScrollTop + 3) + "px",
                            "left": (event.clientX + docScrollLeft + 3) + "px"
                        });

                        var dX = 0;
                        var dY = 0;
                        if (tmpTarget && tmpTarget.attr("id")!=targetSetting.treeId) {
                            var tmpTargetNode = tmpTargetNodeId == null ? null: data.getNodeCache(targetSetting, tmpTargetNodeId),
                            isCopy = (event.ctrlKey && setting.edit.drag.isMove && setting.edit.drag.isCopy) || (!setting.edit.drag.isMove && setting.edit.drag.isCopy),
                            isPrev = !!(preNode && tmpTargetNodeId === preNode.tId),
                            isNext = !!(nextNode && tmpTargetNodeId === nextNode.tId),
                            isInner = (tmpNode.parentTId && tmpNode.parentTId == tmpTargetNodeId),
                            canPrev = (isCopy || !isNext) && tools.apply(targetSetting.edit.drag.prev, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.prev),
                            canNext = (isCopy || !isPrev) && tools.apply(targetSetting.edit.drag.next, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.next),
                            canInner = (isCopy || !isInner) && !(targetSetting.data.keep.leaf && !tmpTargetNode.isParent) && tools.apply(targetSetting.edit.drag.inner, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.inner);
                            if (!canPrev && !canNext && !canInner) {
                                tmpTarget = null;
                                tmpTargetNodeId = "";
                                moveType = consts.move.TYPE_INNER;
                                tmpArrow.css({
                                    "display":"none"
                                });
                                if (window.zTreeMoveTimer) {
                                    clearTimeout(window.zTreeMoveTimer);
                                    window.zTreeMoveTargetNodeTId = null
                                }
                            } else {
                                var tmpTargetA = $("#" + tmpTargetNodeId + consts.id.A, tmpTarget);
                                tmpTargetA.addClass(consts.node.TMPTARGET_NODE);

                                var prevPercent = canPrev ? (canInner ? 0.25 : (canNext ? 0.5 : 1) ) : -1,
                                nextPercent = canNext ? (canInner ? 0.75 : (canPrev ? 0.5 : 0) ) : -1,
                                dY_percent = (event.clientY + docScrollTop - tmpTargetA.offset().top)/tmpTargetA.height();
                                if ((prevPercent==1 ||dY_percent<=prevPercent && dY_percent>=-.2) && canPrev) {
                                    dX = 1 - tmpArrow.width();
                                    dY = 0 - tmpArrow.height()/2;
                                    moveType = consts.move.TYPE_PREV;
                                } else if ((nextPercent==0 || dY_percent>=nextPercent && dY_percent<=1.2) && canNext) {
                                    dX = 1 - tmpArrow.width();
                                    dY = tmpTargetA.height() - tmpArrow.height()/2;
                                    moveType = consts.move.TYPE_NEXT;
                                }else {
                                    dX = 5 - tmpArrow.width();
                                    dY = 0;
                                    moveType = consts.move.TYPE_INNER;
                                }
                                tmpArrow.css({
                                    "display":"block",
                                    "top": (tmpTargetA.offset().top + dY) + "px",
                                    "left": (tmpTargetA.offset().left + dX) + "px"
                                });

                                if (preTmpTargetNodeId != tmpTargetNodeId || preTmpMoveType != moveType) {
                                    startTime = (new Date()).getTime();
                                }
                                if (tmpTargetNode && tmpTargetNode.isParent && moveType == consts.move.TYPE_INNER) {
                                    var startTimer = true;
                                    if (window.zTreeMoveTimer && window.zTreeMoveTargetNodeTId !== tmpTargetNode.tId) {
                                        clearTimeout(window.zTreeMoveTimer);
                                        window.zTreeMoveTargetNodeTId = null;
                                    } else if (window.zTreeMoveTimer && window.zTreeMoveTargetNodeTId === tmpTargetNode.tId) {
                                        startTimer = false;
                                    }
                                    if (startTimer) {
                                        window.zTreeMoveTimer = setTimeout(function() {
                                            if (moveType != consts.move.TYPE_INNER) return;
                                            if (tmpTargetNode && tmpTargetNode.isParent && !tmpTargetNode.open && (new Date()).getTime() - startTime > targetSetting.edit.drag.autoOpenTime
                                                && tools.apply(targetSetting.callback.beforeDragOpen, [targetSetting.treeId, tmpTargetNode], true)) {
                                                view.switchNode(targetSetting, tmpTargetNode);
                                                if (targetSetting.edit.drag.autoExpandTrigger) {
                                                    targetSetting.treeObj.trigger(consts.event.EXPAND, [targetSetting.treeId, tmpTargetNode]);
                                                }
                                            }
                                        }, targetSetting.edit.drag.autoOpenTime+50);
                                        window.zTreeMoveTargetNodeTId = tmpTargetNode.tId;
                                    }
                                }
                            }
                        } else {
                            moveType = consts.move.TYPE_INNER;
                            if (tmpTarget && tools.apply(targetSetting.edit.drag.inner, [targetSetting.treeId, nodes, null], !!targetSetting.edit.drag.inner)) {
                                tmpTarget.addClass(consts.node.TMPTARGET_TREE);
                            } else {
                                tmpTarget = null;
                            }
                            tmpArrow.css({
                                "display":"none"
                            });
                            if (window.zTreeMoveTimer) {
                                clearTimeout(window.zTreeMoveTimer);
                                window.zTreeMoveTargetNodeTId = null;
                            }
                        }
                        preTmpTargetNodeId = tmpTargetNodeId;
                        preTmpMoveType = moveType;
                    }
                    return false;
                }

                doc.bind("mouseup", _docMouseUp);
                function _docMouseUp(event) {
                    if (window.zTreeMoveTimer) {
                        clearTimeout(window.zTreeMoveTimer);
                        window.zTreeMoveTargetNodeTId = null;
                    }
                    preTmpTargetNodeId = null;
                    preTmpMoveType = null;
                    doc.unbind("mousemove", _docMouseMove);
                    doc.unbind("mouseup", _docMouseUp);
                    doc.unbind("selectstart", _docSelect);
                    $("body").css("cursor", "auto");
                    if (tmpTarget) {
                        tmpTarget.removeClass(consts.node.TMPTARGET_TREE);
                        if (tmpTargetNodeId) $("#" + tmpTargetNodeId + consts.id.A, tmpTarget).removeClass(consts.node.TMPTARGET_NODE);
                    }
                    tools.showIfameMask(setting, false);

                    root.showHoverDom = true;
                    if (root.dragFlag == 0) return;
                    root.dragFlag = 0;

                    var i, l, tmpNode,
                    childKey = setting.data.key.children;
                    for (i=0, l=nodes.length; i<l; i++) {
                        tmpNode = nodes[i];
                        if (tmpNode.isParent && root.dragNodeShowBefore[tmpNode.tId] && !tmpNode.open) {
                            view.expandCollapseNode(setting, tmpNode, !tmpNode.open);
                            delete root.dragNodeShowBefore[tmpNode.tId];
                        }
                    }

                    if (curNode) curNode.remove();
                    if (tmpArrow) tmpArrow.remove();

                    var isCopy = (event.ctrlKey && setting.edit.drag.isMove && setting.edit.drag.isCopy) || (!setting.edit.drag.isMove && setting.edit.drag.isCopy);
                    if (!isCopy && tmpTarget && tmpTargetNodeId && nodes[0].parentTId && tmpTargetNodeId==nodes[0].parentTId && moveType == consts.move.TYPE_INNER) {
                        tmpTarget = null;
                    }
                    if (tmpTarget) {
                        var dragTargetNode = tmpTargetNodeId == null ? null: data.getNodeCache(targetSetting, tmpTargetNodeId);
                        if (tools.apply(setting.callback.beforeDrop, [targetSetting.treeId, nodes, dragTargetNode, moveType], true) == false) return;
                        var newNodes = isCopy ? tools.clone(nodes) : nodes;

                        function dropCallback() {
                            if (isOtherTree) {
                                if (!isCopy) {
                                    for(var i=0, l=nodes.length; i<l; i++) {
                                        view.removeNode(setting, nodes[i]);
                                    }
                                }
                                if (moveType == consts.move.TYPE_INNER) {
                                    view.addNodes(targetSetting, dragTargetNode, newNodes);
                                } else {
                                    view.addNodes(targetSetting, dragTargetNode.getParentNode(), newNodes);
                                    if (moveType == consts.move.TYPE_PREV) {
                                        for (i=0, l=newNodes.length; i<l; i++) {
                                            view.moveNode(targetSetting, dragTargetNode, newNodes[i], moveType, false);
                                        }
                                    } else {
                                        for (i=-1, l=newNodes.length-1; i<l; l--) {
                                            view.moveNode(targetSetting, dragTargetNode, newNodes[l], moveType, false);
                                        }
                                    }
                                }
                            } else {
                                if (isCopy && moveType == consts.move.TYPE_INNER) {
                                    view.addNodes(targetSetting, dragTargetNode, newNodes);
                                } else {
                                    if (isCopy) {
                                        view.addNodes(targetSetting, dragTargetNode.getParentNode(), newNodes);
                                    }
                                    if (moveType == consts.move.TYPE_PREV) {
                                        for (i=0, l=newNodes.length; i<l; i++) {
                                            view.moveNode(targetSetting, dragTargetNode, newNodes[i], moveType, false);
                                        }
                                    } else {
                                        for (i=-1, l=newNodes.length-1; i<l; l--) {
                                            view.moveNode(targetSetting, dragTargetNode, newNodes[l], moveType, false);
                                        }
                                    }
                                }
                            }
                            for (i=0, l=newNodes.length; i<l; i++) {
                                view.selectNode(targetSetting, newNodes[i], i>0);
                            }
                            $("#" + newNodes[0].tId + consts.id.ICON).focus().blur();

                        }

                        if (moveType == consts.move.TYPE_INNER && tools.canAsync(targetSetting, dragTargetNode)) {
                            view.asyncNode(targetSetting, dragTargetNode, false, dropCallback);
                        } else {
                            dropCallback();
                        }

                        setting.treeObj.trigger(consts.event.DROP, [targetSetting.treeId, newNodes, dragTargetNode, moveType]);
                    } else {
                        for (i=0, l=nodes.length; i<l; i++) {
                            view.selectNode(targetSetting, nodes[i], i>0);
                        }
                        setting.treeObj.trigger(consts.event.DROP, [setting.treeId, null, null, null]);
                    }
                }

                doc.bind("selectstart", _docSelect);
                function _docSelect() {
                    return false;
                }

                //Avoid FireFox's Bug
                //If zTree Div CSS set 'overflow', so drag node outside of zTree, and event.target is error.
                if(eventMouseDown.preventDefault) {
                    eventMouseDown.preventDefault();
                }
                return true;
            }
        },
        //method of tools for zTree
        _tools = {
            getAbs: function (obj) {
                var oRect = obj.getBoundingClientRect();
                return [oRect.left,oRect.top]
            },
            inputFocus: function(inputObj) {
                if (inputObj.get(0)) {
                    inputObj.focus();
                    tools.setCursorPosition(inputObj.get(0), inputObj.val().length);
                }
            },
            inputSelect: function(inputObj) {
                if (inputObj.get(0)) {
                    inputObj.focus();
                    inputObj.select();
                }
            },
            setCursorPosition: function(obj, pos){
                if(obj.setSelectionRange) {
                    obj.focus();
                    obj.setSelectionRange(pos,pos);
                } else if (obj.createTextRange) {
                    var range = obj.createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', pos);
                    range.moveStart('character', pos);
                    range.select();
                }
            },
            showIfameMask: function(setting, showSign) {
                var root = data.getRoot(setting);
                //clear full mask
                while (root.dragMaskList.length > 0) {
                    root.dragMaskList[0].remove();
                    root.dragMaskList.shift();
                }
                if (showSign) {
                    //show mask
                    var iframeList = $("iframe");
                    for (var i = 0, l = iframeList.length; i < l; i++) {
                        var obj = iframeList.get(i),
                        r = tools.getAbs(obj),
                        dragMask = $("<div id='zTreeMask_" + i + "' class='zTreeMask' style='background-color:yellow;opacity: 0.3;filter: alpha(opacity=30);    top:" + r[1] + "px; left:" + r[0] + "px; width:" + obj.offsetWidth + "px; height:" + obj.offsetHeight + "px;'></div>");
                        dragMask.appendTo("body");
                        root.dragMaskList.push(dragMask);
                    }
                }
            }
        },
        //method of operate ztree dom
        _view = {
            addEditBtn: function(setting, node) {
                if (node.editNameFlag || $("#" + node.tId + consts.id.EDIT).length > 0) {
                    return;
                }
                if (!tools.apply(setting.edit.showRenameBtn, [setting.treeId, node], setting.edit.showRenameBtn)) {
                    return;
                }
                var aObj = $("#" + node.tId + consts.id.A),
                editStr = "<button type='button' class='edit' id='" + node.tId + consts.id.EDIT + "' title='"+tools.apply(setting.edit.renameTitle, [setting.treeId, node], setting.edit.renameTitle)+"' treeNode"+consts.id.EDIT+" onfocus='this.blur();' style='display:none;'></button>";
                aObj.append(editStr);

                $("#" + node.tId + consts.id.EDIT).bind('click',
                    function() {
                        if (!tools.uCanDo(setting) || tools.apply(setting.callback.beforeEditName, [setting.treeId, node], true) == false) return true;
                        view.editNode(setting, node);
                        return false;
                    }
                    ).show();
            },
            addRemoveBtn: function(setting, node) {
                if (node.editNameFlag || $("#" + node.tId + consts.id.REMOVE).length > 0) {
                    return;
                }
                if (!tools.apply(setting.edit.showRemoveBtn, [setting.treeId, node], setting.edit.showRemoveBtn)) {
                    return;
                }
                var aObj = $("#" + node.tId + consts.id.A),
                removeStr = "<button type='button' class='remove' id='" + node.tId + consts.id.REMOVE + "' title='"+tools.apply(setting.edit.removeTitle, [setting.treeId, node], setting.edit.removeTitle)+"' treeNode"+consts.id.REMOVE+" onfocus='this.blur();' style='display:none;'></button>";
                aObj.append(removeStr);

                $("#" + node.tId + consts.id.REMOVE).bind('click',
                    function() {
                        if (!tools.uCanDo(setting) || tools.apply(setting.callback.beforeRemove, [setting.treeId, node], true) == false) return true;
                        view.removeNode(setting, node);
                        setting.treeObj.trigger(consts.event.REMOVE, [setting.treeId, node]);
                        return false;
                    }
                    ).bind('mousedown',
                    function(eventMouseDown) {
                        return true;
                    }
                    ).show();
            },
            addHoverDom: function(setting, node) {
                if (data.getRoot(setting).showHoverDom) {
                    node.isHover = true;
                    if (setting.edit.enable) {
                        view.addEditBtn(setting, node);
                        view.addRemoveBtn(setting, node);
                    }
                    tools.apply(setting.view.addHoverDom, [setting.treeId, node]);
                }
            },
            cancelCurEditNode: function (setting, forceName, isKey) {
                var root = data.getRoot(setting),
                nameKey = setting.data.key.name,
                node = root.curEditNode;

                if (node) {
                    var inputObj = root.curEditInput;
                    var newName = forceName ? forceName:inputObj.val();
                    if (!forceName && tools.apply(setting.callback.beforeRename, [setting.treeId, node, newName], true) === false) {
                        node.editNameFlag = true;
                        return false;
                    } else {
                        node[nameKey] = newName ? newName:inputObj.val();
                        if (!forceName) {
                            setting.treeObj.trigger(consts.event.RENAME, [setting.treeId, node]);
                        }
                    }
                    var aObj = $("#" + node.tId + consts.id.A);
                    aObj.removeClass(consts.node.CURSELECTED_EDIT);
                    inputObj.unbind();
                    view.setNodeName(setting, node);
                    node.editNameFlag = false;
                    root.curEditNode = null;
                    root.curEditInput = null;
                    view.selectNode(setting, node, false);
                }
                root.noSelection = true;
                return true;
            },
            editNode: function(setting, node) {
                var root = data.getRoot(setting);
                view.editNodeBlur = false;
                if (data.isSelectedNode(setting, node) && root.curEditNode == node && node.editNameFlag) {
                    setTimeout(function() {tools.inputFocus(root.curEditInput);}, 0);
                    return;
                }
                var nameKey = setting.data.key.name;
                node.editNameFlag = true;
                view.removeTreeDom(setting, node);
                view.cancelCurEditNode(setting);
                view.selectNode(setting, node, false);
                $("#" + node.tId + consts.id.SPAN).html("<input type=text class='rename' id='" + node.tId + consts.id.INPUT + "' treeNode" + consts.id.INPUT + " >");
                var inputObj = $("#" + node.tId + consts.id.INPUT);
                inputObj.attr("value", node[nameKey]);
                if (setting.edit.editNameSelectAll) {
                    tools.inputSelect(inputObj);
                } else {
                    tools.inputFocus(inputObj);
                }

                inputObj.bind('blur', function(event) {
                    if (!view.editNodeBlur) {
                        view.cancelCurEditNode(setting);
                    }
                }).bind('keydown', function(event) {
                    if (event.keyCode=="13") {
                        view.editNodeBlur = true;
                        view.cancelCurEditNode(setting, null, true);
                    } else if (event.keyCode=="27") {
                        view.cancelCurEditNode(setting, node[nameKey]);
                    }
                }).bind('click', function(event) {
                    return false;
                }).bind('dblclick', function(event) {
                    return false;
                });

                $("#" + node.tId + consts.id.A).addClass(consts.node.CURSELECTED_EDIT);
                root.curEditInput = inputObj;
                root.noSelection = false;
                root.curEditNode = node;
            },
            moveNode: function(setting, targetNode, node, moveType, animateFlag, isSilent) {
                var root = data.getRoot(setting),
                childKey = setting.data.key.children;
                if (targetNode == node) return;
                if (setting.data.keep.leaf && targetNode && !targetNode.isParent && moveType == consts.move.TYPE_INNER) return;
                var oldParentNode = (node.parentTId ? node.getParentNode(): root),
                targetNodeIsRoot = (targetNode === null || targetNode == root);
                if (targetNodeIsRoot && targetNode === null) targetNode = root;
                if (targetNodeIsRoot) moveType = consts.move.TYPE_INNER;
                var targetParentNode = (targetNode.parentTId ? targetNode.getParentNode() : root);

                if (moveType != consts.move.TYPE_PREV && moveType != consts.move.TYPE_NEXT) {
                    moveType = consts.move.TYPE_INNER;
                }

                //move node Dom
                var targetObj, target_ulObj;
                if (targetNodeIsRoot) {
                    targetObj = setting.treeObj;
                    target_ulObj = targetObj;
                } else if (!isSilent) {
                    if (moveType == consts.move.TYPE_INNER) {
                        view.expandCollapseNode(setting, targetNode, true, false);
                    } else {
                        view.expandCollapseNode(setting, targetNode.getParentNode(), true, false);
                    }
                    targetObj = $("#" + targetNode.tId);
                    target_ulObj = $("#" + targetNode.tId + consts.id.UL);
                }
                var nodeDom = $("#" + node.tId).remove();
                if (target_ulObj && moveType == consts.move.TYPE_INNER) {
                    target_ulObj.append(nodeDom);
                } else if (targetObj && moveType == consts.move.TYPE_PREV) {
                    targetObj.before(nodeDom);
                } else if (targetObj && moveType == consts.move.TYPE_NEXT) {
                    targetObj.after(nodeDom);
                }

                //repair the data after move
                var i,l,
                tmpSrcIndex = -1,
                tmpTargetIndex = 0,
                oldNeighbor = null,
                newNeighbor = null,
                oldLevel = node.level;
                if (node.isFirstNode) {
                    tmpSrcIndex = 0;
                    if (oldParentNode[childKey].length > 1 ) {
                        oldNeighbor = oldParentNode[childKey][1];
                        oldNeighbor.isFirstNode = true;
                    }
                } else if (node.isLastNode) {
                    tmpSrcIndex = oldParentNode[childKey].length -1;
                    oldNeighbor = oldParentNode[childKey][tmpSrcIndex - 1];
                    oldNeighbor.isLastNode = true;
                } else {
                    for (i = 0, l = oldParentNode[childKey].length; i < l; i++) {
                        if (oldParentNode[childKey][i].tId == node.tId) {
                            tmpSrcIndex = i;
                            break;
                        }
                    }
                }
                if (tmpSrcIndex >= 0) {
                    oldParentNode[childKey].splice(tmpSrcIndex, 1);
                }
                if (moveType != consts.move.TYPE_INNER) {
                    for (i = 0, l = targetParentNode[childKey].length; i < l; i++) {
                        if (targetParentNode[childKey][i].tId == targetNode.tId) tmpTargetIndex = i;
                    }
                }
                if (moveType == consts.move.TYPE_INNER) {
                    if (targetNodeIsRoot) {
                        //parentTId of root node is null
                        node.parentTId = null;
                    } else {
                        targetNode.isParent = true;
                        targetNode.open = false;
                        node.parentTId = targetNode.tId;
                    }

                    if (!targetNode[childKey]) targetNode[childKey] = new Array();
                    if (targetNode[childKey].length > 0) {
                        newNeighbor = targetNode[childKey][targetNode[childKey].length - 1];
                        newNeighbor.isLastNode = false;
                    }
                    targetNode[childKey].splice(targetNode[childKey].length, 0, node);
                    node.isLastNode = true;
                    node.isFirstNode = (targetNode[childKey].length == 1);
                } else if (targetNode.isFirstNode && moveType == consts.move.TYPE_PREV) {
                    targetParentNode[childKey].splice(tmpTargetIndex, 0, node);
                    newNeighbor = targetNode;
                    newNeighbor.isFirstNode = false;
                    node.parentTId = targetNode.parentTId;
                    node.isFirstNode = true;
                    node.isLastNode = false;

                } else if (targetNode.isLastNode && moveType == consts.move.TYPE_NEXT) {
                    targetParentNode[childKey].splice(tmpTargetIndex + 1, 0, node);
                    newNeighbor = targetNode;
                    newNeighbor.isLastNode = false;
                    node.parentTId = targetNode.parentTId;
                    node.isFirstNode = false;
                    node.isLastNode = true;

                } else {
                    if (moveType == consts.move.TYPE_PREV) {
                        targetParentNode[childKey].splice(tmpTargetIndex, 0, node);
                    } else {
                        targetParentNode[childKey].splice(tmpTargetIndex + 1, 0, node);
                    }
                    node.parentTId = targetNode.parentTId;
                    node.isFirstNode = false;
                    node.isLastNode = false;
                }
                data.fixPIdKeyValue(setting, node);
                data.setSonNodeLevel(setting, node.getParentNode(), node);

                //repair node what been moved
                view.setNodeLineIcos(setting, node);
                view.repairNodeLevelClass(setting, node, oldLevel)

                //repair node's old parentNode dom
                if (!setting.data.keep.parent && oldParentNode[childKey].length < 1) {
                    //old parentNode has no child nodes
                    oldParentNode.isParent = false;
                    oldParentNode.open = false;
                    var tmp_ulObj = $("#" + oldParentNode.tId + consts.id.UL),
                    tmp_switchObj = $("#" + oldParentNode.tId + consts.id.SWITCH),
                    tmp_icoObj = $("#" + oldParentNode.tId + consts.id.ICON);
                    view.replaceSwitchClass(oldParentNode, tmp_switchObj, consts.folder.DOCU);
                    view.replaceIcoClass(oldParentNode, tmp_icoObj, consts.folder.DOCU);
                    tmp_ulObj.css("display", "none");

                } else if (oldNeighbor) {
                    //old neigbor node
                    view.setNodeLineIcos(setting, oldNeighbor);
                }

                //new neigbor node
                if (newNeighbor) {
                    view.setNodeLineIcos(setting, newNeighbor);
                }

                //repair checkbox / radio
                if (setting.check.enable && view.repairChkClass) {
                    view.repairChkClass(setting, oldParentNode);
                    view.repairParentChkClassWithSelf(setting, oldParentNode);
                    if (oldParentNode != node.parent)
                        view.repairParentChkClassWithSelf(setting, node);
                }

                //expand parents after move
                if (!isSilent) {
                    view.expandCollapseParentNode(setting, node.getParentNode(), true, animateFlag);
                }
            },
            removeChildNodes: function(setting, node) {
                if (!node) return;
                var childKey = setting.data.key.children,
                nodes = node[childKey];
                if (!nodes) return;
                $("#" + node.tId + consts.id.UL).remove();
                for (var i = 0, l = nodes.length; i < l; i++) {
                    data.removeNodeCache(setting, nodes[i]);
                }
                data.removeSelectedNode(setting);
                delete node[childKey];

                if (!setting.data.keep.parent) {
                    node.isParent = false;
                    node.open = false;
                    var tmp_switchObj = $("#" + node.tId + consts.id.SWITCH),
                    tmp_icoObj = $("#" + node.tId + consts.id.ICON);
                    view.replaceSwitchClass(node, tmp_switchObj, consts.folder.DOCU);
                    view.replaceIcoClass(node, tmp_icoObj, consts.folder.DOCU);
                }
            },
            removeEditBtn: function(node) {
                $("#" + node.tId + consts.id.EDIT).unbind().remove();
            },
            removeNode: function(setting, node) {
                var root = data.getRoot(setting),
                childKey = setting.data.key.children,
                parentNode = (node.parentTId) ? node.getParentNode() : root;
                if (root.curEditNode === node) root.curEditNode = null;

                node.isFirstNode = false;
                node.isLastNode = false;
                node.getPreNode = function() {return null;};
                node.getNextNode = function() {return null;};

                $("#" + node.tId).remove();
                data.removeNodeCache(setting, node);
                data.removeSelectedNode(setting, node);

                for (var i = 0, l = parentNode[childKey].length; i < l; i++) {
                    if (parentNode[childKey][i].tId == node.tId) {
                        parentNode[childKey].splice(i, 1);
                        break;
                    }
                }
                var tmp_ulObj,tmp_switchObj,tmp_icoObj;

                //repair nodes old parent
                if (!setting.data.keep.parent && parentNode[childKey].length < 1) {
                    //old parentNode has no child nodes
                    parentNode.isParent = false;
                    parentNode.open = false;
                    tmp_ulObj = $("#" + parentNode.tId + consts.id.UL);
                    tmp_switchObj = $("#" + parentNode.tId + consts.id.SWITCH);
                    tmp_icoObj = $("#" + parentNode.tId + consts.id.ICON);
                    view.replaceSwitchClass(parentNode, tmp_switchObj, consts.folder.DOCU);
                    view.replaceIcoClass(parentNode, tmp_icoObj, consts.folder.DOCU);
                    tmp_ulObj.css("display", "none");

                } else if (setting.view.showLine && parentNode[childKey].length > 0) {
                    //old parentNode has child nodes
                    var newLast = parentNode[childKey][parentNode[childKey].length - 1];
                    newLast.isLastNode = true;
                    newLast.isFirstNode = (parentNode[childKey].length == 1);
                    tmp_ulObj = $("#" + newLast.tId + consts.id.UL);
                    tmp_switchObj = $("#" + newLast.tId + consts.id.SWITCH);
                    tmp_icoObj = $("#" + newLast.tId + consts.id.ICON);
                    if (parentNode == root) {
                        if (parentNode[childKey].length == 1) {
                            //node was root, and ztree has only one root after move node
                            view.replaceSwitchClass(newLast, tmp_switchObj, consts.line.ROOT);
                        } else {
                            var tmp_first_switchObj = $("#" + parentNode[childKey][0].tId + consts.id.SWITCH);
                            view.replaceSwitchClass(parentNode[childKey][0], tmp_first_switchObj, consts.line.ROOTS);
                            view.replaceSwitchClass(newLast, tmp_switchObj, consts.line.BOTTOM);
                        }
                    } else {
                        view.replaceSwitchClass(newLast, tmp_switchObj, consts.line.BOTTOM);
                    }
                    tmp_ulObj.removeClass(consts.line.LINE);
                }
            },
            removeRemoveBtn: function(node) {
                $("#" + node.tId + consts.id.REMOVE).unbind().remove();
            },
            removeTreeDom: function(setting, node) {
                node.isHover = false;
                view.removeEditBtn(node);
                view.removeRemoveBtn(node);
                tools.apply(setting.view.removeHoverDom, [setting.treeId, node]);
            },
            repairNodeLevelClass: function(setting, node, oldLevel) {
                if (oldLevel === node.level) return;
                var liObj = $("#" + node.tId),
                aObj = $("#" + node.tId + consts.id.A),
                ulObj = $("#" + node.tId + consts.id.UL),
                oldClass = "level" + oldLevel,
                newClass = "level" + node.level;
                liObj.removeClass(oldClass);
                liObj.addClass(newClass);
                aObj.removeClass(oldClass);
                aObj.addClass(newClass);
                ulObj.removeClass(oldClass);
                ulObj.addClass(newClass);
            }
        },

        _z = {
            tools: _tools,
            view: _view,
            event: event,
            data: _data
        };
        $.extend(true, $.fn.zTree.consts, _consts);
        $.extend(true, $.fn.zTree._z, _z);

        var zt = $.fn.zTree,
        tools = zt._z.tools,
        consts = zt.consts,
        view = zt._z.view,
        data = zt._z.data,
        event = zt._z.event;

        data.exSetting(_setting);
        data.addInitBind(_bindEvent);
        data.addInitCache(_initCache);
        data.addInitNode(_initNode);
        data.addInitProxy(_eventProxy);
        data.addInitRoot(_initRoot);
        data.addZTreeTools(_zTreeTools);

        var _cancelPreSelectedNode = view.cancelPreSelectedNode;
        view.cancelPreSelectedNode = function (setting, node) {
            var list = data.getRoot(setting).curSelectedList;
            for (var i=0, j=list.length; i<j; i++) {
                if (!node || node === list[i]) {
                    view.removeTreeDom(setting, list[i]);
                    if (node) break;
                }
            }
            if (_cancelPreSelectedNode) _cancelPreSelectedNode.apply(view, arguments);
        }

        var _createNodes = view.createNodes;
        view.createNodes = function(setting, level, nodes, parentNode) {
            if (_createNodes) {
                _createNodes.apply(view, arguments);
            }
            if (!nodes) return;
            if (view.repairParentChkClassWithSelf) {
                view.repairParentChkClassWithSelf(setting, parentNode);
            }
        }

        view.makeNodeUrl = function(setting, node) {
            return (node.url && !setting.edit.enable) ? node.url : null;
        }

        var _selectNode = view.selectNode;
        view.selectNode = function(setting, node, addFlag) {
            var root = data.getRoot(setting);
            if (data.isSelectedNode(setting, node) && root.curEditNode == node && node.editNameFlag) {
                return false;
            }
            if (_selectNode) _selectNode.apply(view, arguments);
            view.addHoverDom(setting, node);
            return true;
        }

        var _uCanDo = tools.uCanDo;
        tools.uCanDo = function(setting, e) {
            var root = data.getRoot(setting);
            if (e && (tools.eqs(e.type, "mouseover") || tools.eqs(e.type, "mouseout") || tools.eqs(e.type, "mousedown") || tools.eqs(e.type, "mouseup"))) {
                return true;
            }
            return (!root.curEditNode) && (_uCanDo ? _uCanDo.apply(view, arguments) : true);
        }
    })(jQuery);
//});
//mod.defineModule("tree", ["base","waf","ztree_core","ztree_excheck","ztree_exedit"], function() {
    /*******************************************************************************
     * jQuery Tree
     *
     * @version 1.0
     * @author peng_zhou1
     * @Depends:
     *         jquery.ui.core.js
     *         jquery.ui.widget.js
     ******************************************************************************/
    (function($, undefined) {
        var paramMap = {
            "autoParam": "async.autoParam",
            "contentType": "async.contentType",
            "dataFilter": "async.dataFilter",
            "dataType": "async.dataType",
            "async": "async.enable",
            "otherParam": "async.otherParam",
            "type": "async.type",
            "url": "async.url",
            "beforeAsync": "callback.beforeAsync",
            "beforeCheck": "callback.beforeCheck",
            "beforeClick": "callback.beforeClick",
            "beforeCollapse": "callback.beforeCollapse",
            "beforeDblClick": "callback.beforeDblClick",
            "beforeDrag": "callback.beforeDrag",
            "beforeDragOpen": "callback.beforeDragOpen",
            "beforeDrop": "callback.beforeDrop",
            "beforeEditName": "callback.beforeEditName",
            "beforeExpand": "callback.beforeExpand",
            "beforeMouseDown": "callback.beforeMouseDown",
            "beforeMouseUp": "callback.beforeMouseUp",
            "beforeRemove": "callback.beforeRemove",
            "beforeRename": "callback.beforeRename",
            "beforeRightClick": "callback.beforeRightClick",
            "onAsyncError": "callback.onAsyncError",
            "onAsyncSuccess": "callback.onAsyncSuccess",
            "onCheck": "callback.onCheck",
            "onClick": "callback.onClick",
            "onCollapse": "callback.onCollapse",
            "onDblClick": "callback.onDblClick",
            "onDrag": "callback.onDrag",
            "onDrop": "callback.onDrop",
            "onExpand": "callback.onExpand",
            "onMouseDown": "callback.onMouseDown",
            "onMouseUp": "callback.onMouseUp",
            "onNodeCreated": "callback.onNodeCreated",
            "onRemove": "callback.onRemove",
            "onRename": "callback.onRename",
            "onRightClick": "callback.onRightClick",
            "autoCheckTrigger": "check.autoCheckTrigger",
            "chkboxType": "check.chkboxType",
            "chkStyle": "check.chkStyle",
            "checkable": "check.enable",
            "nocheckInherit": "check.nocheckInherit",
            "radioType": "check.radioType",
            "keepLeaf": "data.keep.leaf",
            "keepParent": "data.keep.parent",
            "checkedKey": "data.key.checked",
            "childrenKey": "data.key.children",
            "nameKey": "data.key.name",
            "tipKey": "data.key.title",
            "simpleData": "data.simpleData.enable",
            "idKey": "data.simpleData.idKey",
            "pIdKey": "data.simpleData.pIdKey",
            "rootPId": "data.simpleData.rootPId",
            "autoExpandTrigger": "edit.drag.autoExpandTrigger",
            "copyable": "edit.drag.isCopy",
            "moveable": "edit.drag.isMove",
            "prev": "edit.drag.prev",
            "next": "edit.drag.next",
            "inner": "edit.drag.inner",
            "borderMax": "edit.drag.borderMax",
            "borderMin": "edit.drag.borderMin",
            "minMoveSize": "edit.drag.minMoveSize",
            "maxShowNodeNum": "edit.drag.maxShowNodeNum",
            "autoOpenTime": "edit.drag.autoOpenTime",
            "editNameSelectAll": "edit.editNameSelectAll",
            "editable": "edit.enable",
            "removeTip": "edit.removeTitle",
            "renameTip": "edit.renameTitle",
            "showRemoveBtn": "edit.showRemoveBtn",
            "showRenameBtn": "edit.showRenameBtn",
            "addDiyDom": "view.addDiyDom",
            "addHoverDom": "view.addHoverDom",
            "autoCancelSelected": "view.autoCancelSelected",
            "dblClickExpand": "view.dblClickExpand",
            "expandSpeed": "view.expandSpeed",
            "fontCss": "view.fontCss",
            "nameIsHTML": "view.nameIsHTML",
            "removeHoverDom": "view.removeHoverDom",
            "selectedMulti": "view.selectedMulti",
            "showIcon": "view.showIcon",
            "showLine": "view.showLine",
            "showTip": "view.showTitle"
        },
                frameClass = "ui-tree-frame";

        $.widget("ui.wafTree", {

            zTreeObj: null,

            options: {
                setting: null,
                data: null,
                style: null,
                tagClass: null,
                tabindex:null,
                width: null,
                height: null,
                hidden: false
            },

            _create: function() {
                this._initByOptions("style", "tagClass", "tabindex", "width", "height", "hidden");

                // WAF,simpleDatafalsechildren
                this.options.setting.simpleData = true;
                if (this.options.setting.url) {
                    this.options.setting.async = true;
                }
                this.options.setting.autoParam = this.options.setting.autoParam || this._getDefaultAutoParam();
                this.options.setting.editNameSelectAll = true;

                var setting = this._getSetting(this.options.setting);
                var data = this.options.data || null;
                this.zTreeObj = $.fn.zTree.init(this.element, setting, data);
                this.element.attr("data-domcreated","true");
            },

            _getDefaultAutoParam: function() {
                var idKey = this.options.setting.idKey || "id",
                        nameKey = this.options.setting.nameKey || "name",
                        pidKey = this.options.setting.nameKey || "pid";
                return [idKey, nameKey, pidKey, 'level'];
            },
            _getSetting: function(opts) {
                var setting = {};
                for (var k in opts) {
                    this._makeSetting(setting, paramMap[k], opts[k]);
                }
                return setting;
            },

            _makeSetting: function(setting, path, value) {
                if (!path) {
                    return;
                }
                var paths = path.split("."),
                        currentSetting = setting;
                for (var i = 0, length = paths.length; i < length; i++) {
                    if (i == length - 1) {
                        currentSetting[paths[i]] = value;
                    } else {
                        if (!currentSetting[paths[i]]) {
                            currentSetting[paths[i]] = {};
                        }
                        currentSetting = currentSetting[paths[i]];
                    }
                }
            },

            destory:function() {
                $.Widget.prototype.destroy.call(this);
            },

            widget: function() {
                return this.element;
            },

            option: function(key, value) {
                var options = key;

                if (arguments.length === 0) {
                    // don't return a reference to the internal hash
                    return $.extend({}, this.zTreeObj.setting);
                }

                if (typeof key === "string") {
                    if (value === undefined) {
                        return this._getOption(key, this.zTreeObj.setting);
                    }
                    options = {};
                    options[ key ] = value;
                }

                this._setOptions(options);

                return this;
            },

            _setOption: function(key, value) {
                if (this._isZtreeSetting(key)) {
                    if (key === "fontCss") {
                        this.zTreeObj.setting.view.fontCss = $.extend(true, {}, value);
                    } else if (key === "otherParam") {
                        this.zTreeObj.setting.async.otherParam = $.extend(true, {}, value);
                        ;
                    } else if (key === "chkboxType") {
                        this.zTreeObj.setting.check.chkboxType = $.extend(true, {}, value);
                        ;
                    } else {
                        var opt = {};
                        opt[key] = value;
                        $.extend(true, this.zTreeObj.setting, this._getSetting(opt));
                    }
                } else {
                    var oldTagClass = this.options.tagClass;

                    $.Widget.prototype._setOption.apply(this, arguments);

                    if (key === "style" || key === "tabindex") {
                        this.element.attr(key, value);
                    } else if (key === "width" || key === "height") {
                        this.element.css(key, value ? value : '');
                    } else if (key === "tagClass") {
                        this.element.removeClass(oldTagClass).addClass(value);
                    } else if (key === "hidden") {
                        this.element[value ? "hide" : "show"]();
                    }
                }
            },

            _isZtreeSetting: function(key) {
                if (paramMap[key]) {
                    return true;
                }
                return false;
            },

            _getOption: function(key, setting) {
                var path = paramMap[key];
                if (!path) {
                    return this.options[ key ];
                }
                var paths = path.split("."),
                        currentSetting = setting;
                for (var i = 0, length = paths.length; i < length; i++) {
                    if (i == length - 1) {
                        return currentSetting[paths[i]];
                    } else {
                        if (!currentSetting[paths[i]]) {
                            currentSetting[paths[i]] = {};
                        }
                        currentSetting = currentSetting[paths[i]];
                    }
                }
                return null;
            },

            addNodes: function(parentNode, newNodes, isSilent) {
                return this.zTreeObj ? this.zTreeObj.addNodes(parentNode, newNodes, isSilent) : null;
            },

            cancelEditName: function(newName) {
                if (this.zTreeObj != null) {
                    this.zTreeObj.cancelEditName(newName);
                }
            },

            cancelSelectedNode: function(treeNode) {
                if (this.zTreeObj != null) {
                    this.zTreeObj.cancelSelectedNode(treeNode);
                }
            },

            checkAllNodes: function(checked) {
                if (this.zTreeObj != null) {
                    this.zTreeObj.checkAllNodes(checked);
                }
            },

            checkNode: function(treeNode, checked, checkTypeFlag, callbackFlag) {
                if (this.zTreeObj != null) {
                    this.zTreeObj.checkNode(treeNode, checked, checkTypeFlag, callbackFlag);
                }
            },

            copyNode: function(targetNode, treeNode, moveType, isSilent) {
                return this.zTreeObj ? this.zTreeObj.copyNode(targetNode, treeNode, moveType, isSilent) : null;
            },

            editName: function(treeNode) {
                if (this.zTreeObj != null) {
                    this.zTreeObj.editName(treeNode);
                }
            },

            expandAll: function(expandFlag) {
                return this.zTreeObj ? this.zTreeObj.expandAll(expandFlag) : null;
            },

            expandNode: function(treeNode, expandFlag, sonSign, focus, callbackFlag) {
                return this.zTreeObj ? this.zTreeObj.expandNode(treeNode, expandFlag, sonSign, focus, callbackFlag) : null;
            },

            getChangeCheckedNodes: function() {
                return this.zTreeObj ? this.zTreeObj.getChangeCheckedNodes() : null;
            },

            getCheckedNodes: function(checked) {
                return this.zTreeObj ? this.zTreeObj.getCheckedNodes(checked) : null;
            },

            getNodeByParam: function(key, value, parentNode) {
                return this.zTreeObj ? this.zTreeObj.getNodeByParam(key, value, parentNode) : null;
            },

            getNodeByTId: function(tId) {
                return this.zTreeObj ? this.zTreeObj.getNodeByTId(tId) : null;
            },

            getNodeIndex: function(treeNode) {
                return this.zTreeObj ? this.zTreeObj.getNodeIndex(treeNode) : null;
            },

            getNodes: function() {
                return this.zTreeObj ? this.zTreeObj.getNodes() : null;
            },

            getNodesByParam: function(key, value, parentNode) {
                return this.zTreeObj ? this.zTreeObj.getNodesByParam(key, value, parentNode) : null;
            },

            getNodesByParamFuzzy: function(key, value, parentNode) {
                return this.zTreeObj ? this.zTreeObj.getNodesByParamFuzzy(key, value, parentNode) : null;
            },

            getSelectedNodes: function() {
                return this.zTreeObj ? this.zTreeObj.getSelectedNodes() : null;
            },

            moveNode: function(targetNode, treeNode, moveType, isSilent) {
                return this.zTreeObj ? this.zTreeObj.moveNode(targetNode, treeNode, moveType, isSilent) : null;
            },

            reAsyncChildNodes: function(parentNode, reloadType, isSilent) {
                if (this.zTreeObj != null) {
                    this.zTreeObj.reAsyncChildNodes(parentNode, reloadType, isSilent);
                }
            },

            refresh: function() {
                if (this.zTreeObj != null) {
                    this.zTreeObj.refresh();
                }
            },

            removeChildNodes: function(parentNode) {
                return this.zTreeObj ? this.zTreeObj.removeChildNodes(parentNode) : null;
            },

            removeNode: function(treeNode, callbackFlag) {
                if (this.zTreeObj != null) {
                    this.zTreeObj.removeNode(treeNode, callbackFlag);
                }
            },

            selectNode: function(treeNode, addFlag) {
                if (this.zTreeObj != null) {
                    this.zTreeObj.selectNode(treeNode, addFlag);
                }
            },

            setChkDisabled: function(node, disabled) {
                if (this.zTreeObj != null) {
                    this.zTreeObj.setChkDisabled(node, disabled);
                }
            },

            setEditable: function(editable) {
                if (this.zTreeObj != null) {
                    this.zTreeObj.setEditable(editable);
                }
            },

            transformToArray: function(treeNodes) {
                return this.zTreeObj ? this.zTreeObj.transformToArray(treeNodes) : null;
            },

            transformTozTreeNodes: function(simpleNodes) {
                return this.zTreeObj ? this.zTreeObj.transformTozTreeNodes(simpleNodes) : null;
            },

            updateNode: function(treeNode, checkTypeFlag) {
                if (this.zTreeObj != null) {
                    this.zTreeObj.updateNode(treeNode, checkTypeFlag);
                }
            }
        });

        $.wafTree = $.wafTree || {};
        $.extend($.wafTree, {
            createTreeDOM: function(opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    return $('<ul id="' + opts.id + '" class="ztree" ctrlrole="tree"></ul>');
                }else{
                    obj.empty();
                    return obj;
                }
            },
            initTree: function(opts, el) {
                $.dynamicutil.addContextPath(opts, "url");

                var style = opts.style,
                        tagClass = opts.tagClass,
                        tabindex = opts.tabindex,
                        width = opts.width,
                        height = opts.height,
                        hidden = opts.hidden
                value = opts.value,
                        beforeTreeInit = opts.beforeTreeInit,
                        option = {};

                delete opts.style;
                delete opts.tagClass;
                delete opts.tabindex;
                delete opts.width;
                delete opts.height;
                delete opts.hidden;
                delete opts.value;
                delete opts.beforeTreeInit;

                if (style != null) {
                    option.style = style;
                }
                if (tagClass != null) {
                    option.tagClass = tagClass;
                }
                if (tabindex != null) {
                    option.tabindex = tabindex;
                }
                if (width != null) {
                    option.width = width;
                }
                if (height != null) {
                    option.height = height;
                }
                if (hidden != null) {
                    option.hidden = hidden;
                }
                option.data = value;
                if ($.isFunction(value)) {
                    option.data = value.call(this);
                    option.value = value;
                }
                if ($.isFunction(beforeTreeInit)) {
                    beforeTreeInit.call(this, opts);
                    option.beforeTreeInit = beforeTreeInit;
                }

                option.setting = opts;

                el.wafTree(option);
            },
            removeTree: function(opts) {
                var id = opts.id,
                        el = $("#" + id);

                if (el.length) {
                    el.wafTree('destroy');
                    el.remove();
                }
            },
            modifyTree: function(opts) {
                $.dynamicutil.addContextPath(opts, "url");
                $("#" + opts.id).wafTree('option', opts);
            }
        });

        $(function () {
            if ($.registerComponent)
                $.registerComponent("tree", {createDOMFun: $.wafTree.createTreeDOM,
                    initFun: $.wafTree.initTree,
                    deleteFun: $.wafTree.removeTree,
                    modifyFun: $.wafTree.modifyTree,lazyInit:true});
        });
    }(jQuery));
//});

//mod.defineModule("promptUtil",["base","waf","jlinq"],function(){
    function createWin(opts) {
        return waf.window.createWin(opts);
    }
    function showWin(target) {
        waf.window.showWin(target);
    }
    function createPanel(){
        return $("<div></div>").appendTo(document.body).hide();
    }
    function removePanel(panel){
        $(panel).remove();
    }



    (function($) {
        f7iframeElementMap = new Map();
        f7iframeRelationMap = new Map();
        PromptIframeMgr = {
            targetFlg : "iframef7uuid",
            getElementMap: function() {
                var topWindow = this.getWAF2TopWindow(window);
                return topWindow.f7iframeElementMap;
            },
            getRelationMap: function() {
                var topWindow = this.getWAF2TopWindow(window);
                return topWindow.f7iframeRelationMap;
            },
            getWAF2TopWindow: function(windowObject) {
                if(windowObject.f7iframeElementMap == windowObject.parent.f7iframeElementMap || windowObject.parent.f7iframeElementMap == null) {
                    return windowObject;
                } else {
                    return this.getWAF2TopWindow(windowObject.parent);
                }
            },
            getValue : function(){
                var uuid = this.getCurrentUUID(),
                    m = this.getElementMap(),
                    element = m.get(uuid);

                return element.wafPromptBox("getValue");
            },
            setReturnValue : function(value, withoutCompare) {
                var uuid = this.getCurrentUUID(),
                    m = this.getElementMap(),
                    element = m.get(uuid);

                element.wafPromptBox("setValue", waf.toJSONString(value), !!withoutCompare);
            },
            close : function() {
                var uuid = this.getCurrentUUID(),
                    m = this.getElementMap(),
                    element = m.get(uuid);

                element.wafPromptIframe("close");
            },
            getCurrentUUID : function(){
                return this.getUrlRequestParam(this.targetFlg);
            },
            getUrlRequestParam : function(paras) {
                var url = location.href,
                    paraString = url.substring(url.indexOf("?") + 1, url.length).split("&"),
                    paraObj = {};

                for (i = 0; j = paraString[i]; i++) {
                    paraObj[j.substring(0, j.indexOf("=")).toLowerCase()] = j
                            .substring(j.indexOf("=") + 1, j.length);
                }
                var returnValue = paraObj[paras.toLowerCase()];
                if (typeof (returnValue) == "undefined") {
                    return null;
                } else {
                    return returnValue;
                }
            },
            createWin : function(opts){
                if(parent.createWin){
                    return parent.createWin(opts);
                }else{
                    return createWin(opts);
                }
            },
            showWin : function(target){
                if(parent.showWin){
                    parent.showWin(target);
                }else{
                    showWin(target);
                }
            },
            createPanel : function(){
                if(parent.createPanel){
                    return parent.createPanel();
                }else{
                    return createPanel();
                }
            },
            removePanel : function(panel){
                if(parent.removePanel){
                    return parent.removePanel(panel);
                }else{
                    return removePanel(panel);
                }
            },
            register : function(targetUUID, element){
                this.getElementMap().put(targetUUID, element);
                this.getRelationMap().put(targetUUID, this.getCurrentUUID());
            },
            unRegister : function(targetUUID){
                this.getElementMap().remove(targetUUID);
                this.getRelationMap().remove(targetUUID);
            },
            canClose : function(targetUUID){
                return !this.getRelationMap().containsValue(targetUUID);
            }
        };


        $.f7QueryUtil = $.f7QueryUtil || {};

        $.extend($.f7QueryUtil, {
            /**
             * (AND)
             *  unitTest\spec\ctrls\f7\waf_f7_spec.coffee
             * @param data 
             * @param autoCompleteItem key,key,,OR
             * @param autoCompleteTerm 
             * @param searchItem key
             * @param searchTerm f7
             * @param sidx 
             * @param sord  'asc''desc'
             * @return 
             * @author hua_yan1@kingdee.com
             */
             //XXX 
            selectByAutoCompleteAndSearchCondition: function(data, autoCompleteItem, autoCompleteTerm,searchItem, searchTerm, sidx, sord, searchLocalHandle){
                if(!autoCompleteItem && !searchItem) return data;
                var d = data;

                var rec =jlinq.from(d);
                if(autoCompleteItem && autoCompleteTerm) {
                    var keys = autoCompleteItem.split(",");
                    $.each(keys, function(index,item){
                        if(index > 0) rec = rec.or();
                        rec = rec.contains(item, autoCompleteTerm);
                    });

                    if(sidx && sord) {
                        rec.sort(sidx);
                        if(sord === "desc") {
                            rec.reverse();
                        }
                    }

                    d = rec.select();
                }

                if(searchItem && searchTerm) {
                    rec = jlinq.from(d);

                    if($.isFunction(searchLocalHandle)) {
                        //searchItemsearchTerm
                        searchLocalHandle.call(this, searchTerm, rec);
                    }else{
                        keys = searchItem.split(",");
                        $.each(keys, function(index,item){
                            if(index > 0) rec = rec.or();
                            rec = rec.contains(item, searchTerm);
                        });
                    }

                    if(sidx && sord) {
                        rec.sort(sidx);
                        if(sord === "desc") {
                            rec.reverse();
                        }
                    }

                    d = rec.select();
                }

                return d;
            }
        });
    }(jQuery));
//});
    /*******************************************************************************
     * jQuery UI PromptBox
     *
     * @version 1.0
     * @author peng_zhou1
     * @Depends:
     *         jquery.ui.core.js
     *         jquery.ui.widget.js
     *         jquery.ui.position.js
     ******************************************************************************/
//mod.defineModule("promptBox",["base","waf","promptBox_i18n"],function(){
    (function($, undefined) {

        var triggerClass = "ui-f7-trigger",
            trashClass = "ui-f7-trash",
            frameClass = "ui-f7-frame",
            layoutClass = "ui-f7-layout",
            defaultClass = "ui-f7",
            dataFlg = "data.f7",
            defaultFieldSeparator = ",",
            defaultDisplayFormat = "{name}",
            defaultSubmitFormat = "{id}";


        $.widget("ui.wafPromptBox", $.ui.wafctrl, {
            options : {
                id : null,
                name : null,
                subWidgetName : null,
                subWidgetOptions : null,
                displayFormat : defaultDisplayFormat,
                submitFormat : defaultSubmitFormat,
                submitField : null,
                fieldSeparator : defaultFieldSeparator,
                onchange : null,
                identification : "id",
                width: null,
                height : null,
                readonly : false,
                style : null,
                tagClass : null,
                tabindex : 0,
                editable : true,
                hidden : false,
                value : null,
                onclick:null,
                onblur:null,
                ondblclick:null,
                onfocus:null,
                onselect:null,
                onkeyup:null,
                onkeypress:null,
                onkeydown:null,
                onmouseover:null,
                onmouseup:null,
                onmouseout:null,
                onmousemove:null,
                onmousedown:null
            },

            suppressRefresh: false, //f7f7f7
            defaultValue: null,
            trash: false,//ctrltrueclick
            handleFunctions: ["onclick", "onblur", "ondblclick", "onfocus", "onselect",
                              "onkeyup", "onkeypress", "onkeydown", "onmouseover", "onmouseup",
                              "onmouseout", "onmousemove", "onmousedown"],

            _create:function(){
                $.ui.wafctrl.prototype._create.apply(this, arguments);
                var self = this,
                    doc = this.element[ 0 ].ownerDocument,
                    suppressBlur;

                this._enter2tab();

                this.options.submitField = this.options.submitField || ("#" + this.options.id + "_el");

                if(this.element.data('domcreated')) {
                    this.frame = this.element.closest("." + frameClass).eq(0);
                    this.iconTrigger = this.frame.find("." + triggerClass);
                } else {
                    this.element.addClass(defaultClass).attr("ctrlrole", "promptBox");
                    this.element.wrap($('<div class="' + frameClass + '"></div>'));
                    this.element.wrap($('<div class="' + layoutClass + '"></div>'));
                    this.iconTrigger = $('<span class="' + triggerClass + '"></span>').insertAfter(this.element).wrap("<div class='ui-f7-icon'></div>");
                    this.element.wrap("<div class='ui-f7-inputframe'></div>");
                    this.frame = this.element.closest("." + frameClass).eq(0);
                    this.element.attr('data-domcreated',"true");
                    if(this.options.submitField) {
                        $(this.options.submitField).insertAfter(this.element);
                    }
                }
                //widgetsetOption
                this._initByOptions("disabled", "readonly", "editable", "style", "tagClass", "tabindex", "width", "height", "hidden");

                $.each(this.handleFunctions, function(i, v){
                    self.element.handleFunction(v.substr(2) + ".wafPromptBoxInner", self.options[v]);
                });

                this.element.bind("keydown.wafPromptBox", function(event){
                    if ( self.options.disabled || self.options.readonly ) {
                        return;
                    }
                    if (!event.altKey && !event.metaKey && !event.ctrlKey){
                        switch(event.keyCode){
                        case 118:
                        case $.ui.keyCode.DOWN:
                            self.open();
                            break;
                        }
                    } else if(event.ctrlKey && (event.keyCode == $.ui.keyCode.CONTROL)){
                        self._addTrashClass();
                    }
                })
                .bind("keyup.wafPromptBox", function(event){
                    if(self.options.disabled || self.options.readonly){
                        return;
                    }
                    if(!event.altKey && !event.metaKey && !event.ctrlKey){
                        switch(event.keyCode){
                        case 8://
                        case $.ui.keyCode.DELETE:
                            //BACKSPACEDELETEnull
                            if(self.element.val() === ""){
                                self.setValue(null);
                            }
                            break;
                        case $.ui.keyCode.CONTROL:
                            //ctrltrashClass
                            self._removeTrashClass();
                            break;
                        }
                    }
                })
                .bind("blur.wafPromptBox", function(event){
                    //
                    self._removeTrashClass();
                    //text
                    self._filterValue();
                    self._refresh();
                    self.iconTrigger.removeClass("triggerFocus");
    //                if(!suppressBlur && !self.suppressRefresh){
    //                }else{
    //                    suppressBlur = false;
    //                }
                })
                .bind("focus.wafPromptBox", function(event){
                    self.iconTrigger.addClass("triggerFocus");
                });

                // formreset, .
                $(this.element[0].form).bind('reset.wafPromptBox', function(){
                    setTimeout($.proxy(self._reset, self), 10);
                });

                this.iconTrigger.click(function(event){
                    if ( self.options.disabled || self.options.readonly || waf.wafutil.isViewOperateState(self.options)) {
                        return;
                    }
                    self.element.focus();
                    if(self.trash || event.ctrlKey){
                        self.setValue(null);
                    }else{
                        self.open();
                    }
                })
                .mousedown(function(e){
                    suppressBlur = true;
                });

                this._setValue(this.options.value);
                this.setDefaultValue(this.options.value);

                if(this.options.subWidgetName && this.options.subWidgetOptions){
                    this.element[this.options.subWidgetName](this.options.subWidgetOptions);
                }
                this._operateState();
            },

            destroy:function(){
                if(this.options.subWidgetName){
                    this.element[this.options.subWidgetName]("destroy");
                }
                this.iconTrigger.parent().remove();
                this.element.removeClass(defaultClass)
                    .unwrap()
                    .unwrap()
                    .unwrap()
                    .removeAttr("ctrlrole");
                $.Widget.prototype.destroy.call( this );
            },

            widget:function(){
                return this.frame;
            },

            _enter2tab:function(){
                if($.fn.enter2tab){
                    this.element.enter2tab();
                }
            },

            _reset:function(){
                this._setValue(this.defaultValue);
            },

            _setOption: function( key, value ) {
                if (key === "disabled" || key === "tabindex") {
                    this.element.attr(key, value);
                } else if (key === "width" || key === "height"){
                    this.frame.css(key, value ? value : '');
                } else if (key === "tagClass") {
                    this.frame.removeClass(this.options.tagClass).addClass(value);
                } else if (key === "style"){
                    this.frame.attr(key, value);
                } else if (key === "hidden"){
                    this.frame[value ? "hide" : "show"]();
                }

                $.Widget.prototype._setOption.apply( this, arguments );

                if (key === "displayFormat" || key === "fieldSeparator" || key === "submitFormat") {
                    this._refresh();
                } else if (key === "readonly" || key === "editable") {
                    this._setReadonly();
                } else if(key === "disabled"){
                    this.frame[ value ? "addClass" : "removeClass"]("ui-state-disabled").attr( "aria-disabled", value );
                } else if($.inArray(key, this.handleFunctions) > -1){
                    this.element.handleFunction(key.substr(2) + ".wafPromptBoxInner", value);
                } else if(key === "value"){
                    this.setValue(value);
                }
            },

            _addTrashClass: function(){
                this.trash = true;
                this.iconTrigger.addClass(trashClass);
            },

            _removeTrashClass: function(){
                this.trash = false;
                this.iconTrigger.removeClass(trashClass);
            },

            _setReadonly: function(){
                if(this.options.readonly || !this.options.editable){
                    this.element.attr("readonly", true);
                } else    {
                    this.element.attr("readonly", false);
                }
            },

            setDefaultValue:function(value){
                this.defaultValue = value;
            },

            setValue:function(value, withoutCompare){
                var previous = this.getValue(),
                    withoutCompare = !!withoutCompare;
                //valuesetReturnValueiframeiframeIE9IE10
                if(value && $.type.isString(value)){
                    try{
                        value = waf.toJSONObject(value);
                    }catch(e){}
                }

                if(withoutCompare || !this._isEqual(previous, value)){
                    this._setValue(value);

                    if(!this._change(previous, value)){
                        this._setValue(previous);
                    }else{
                        this.element.trigger('change');
                    }
                }
                this._refresh();
            },

            getValue:function(){
                var data = this.element.data(dataFlg);
                return data?data:null;
            },

            disable:function(){
                this._setOption("disabled", true);
            },

            enable:function(){
                this._setOption("disabled", false);
            },

            open: function() {
                if(!this.hasOpen()) {
                    this.element[this.options.subWidgetName]("open");
                }
            },

            _change:function(previous, current){
                return this._trigger("onchange", "onchange", {
                    "previous" : previous,
                    "current" : current
                });
            },

            _filterValue:function(){
                //blur
                var value = this.element.data(dataFlg);
                if(!$.isArray(value)) return;
                var text = this.element.val();
                var ret = [],arr=text?text.split(","):[],name;
                if(arr.length==0 || value.length==0) return value;
                for(var i=0;i<arr.length;i++){
                    for(var j=0;j<value.length;j++){
                        name = $.wafPromptBox.format(value[j], this.options.displayFormat);
                        if($.type.isEquals(name,arr[i])){
                            ret.push(value[j]);
                            break;
                        }
                    }
                }
                this._setValue(ret);
            },

            _refresh : function(){
                var value = this.element.data(dataFlg);
                var displayValue = value ? $.wafPromptBox.format(value, this.options.displayFormat, this.options.fieldSeparator) : null;

                this.element.val(displayValue);
                this._setDisplayValue(displayValue);

                if(this.options.submitField){
                    $(this.options.submitField).val(value ? $.wafPromptBox.format(value, this.options.submitFormat, this.options.fieldSeparator) : null);
                }
            },

            _setValue : function(value){
                this.element.data(dataFlg, value || null);
                this._refresh();
            },

            _isEqual : function(val1, val2){
                var self = this,
                    identification = this.options.identification;
                if(val1 != null && val2 != null){
                    if($.isArray(val1) && $.isArray(val2)){
                        if(val1.length != val2.length ){
                            return false;
                        }

                        var sorter = function(a, b){
                            try{
                                var v1 = $.wafutil.getValueByPath(a, identification),
                                    v2 = $.wafutil.getValueByPath(b, identification);

                                return v1.localeCompare(v2);
                            }catch(e){
                                return a - b;
                            }
                        };

                        val1 = val1.slice();
                        val1.sort(sorter);
                        val2 = val2.slice();
                        val2.sort(sorter);

                        for(var i = 0,j = val1.length; i < j; i++){
                            if(!this._isEqual(val1[i],val2[i])){
                                return false;
                            }
                        }
                        return true;
                    }else if(!$.isArray(val1) && !$.isArray(val2)){
                        var v1 = $.wafutil.getValueByPath(val1, identification),
                            v2 = $.wafutil.getValueByPath(val2, identification);

                        return v1 == v2;
                    }else{
                        return false;
                    }
                }else{
                    return val1 === val2;
                }
            },
            getFrame : function(){
                return this.frame;
            },
            getSuppressRefresh: function(){
                return this.suppressRefresh;
            },
            setSuppressRefresh: function(s){
                this.suppressRefresh = s;
            },
            hasOpen: function(){
                return this.element[this.options.subWidgetName]("hasOpen") === true;
            },
            //viewdisabled
            _viewDisable: function(isDisable) {
                $.ui.wafctrl.prototype._viewDisable.apply( this, arguments );
                this.element.attr('disabled', isDisable);
            }
        });


        $.wafPromptBox = $.wafPromptBox || {};
        $.extend($.wafPromptBox, {
            format : function(value, format, fieldSeparator){
                var caller = arguments.callee;

                format = format || defaultDisplayFormat;
                fieldSeparator = fieldSeparator || defaultFieldSeparator;
                if(value && format){
                    if($.isArray(value)){
                        var formatedArray = new Array();
                        $.each(value, function(idx, v){
                            formatedArray[idx] = caller(v, format, fieldSeparator);
                        });
                        return formatedArray.join(fieldSeparator);
                    } else {
                        return format.replace(/\{(.+?)\}/g, function(m, i){
                            var text = $.wafutil.getValueByPath(value, i);
                            if(waf.type.isObject(text) && waf.isMultiLangValue(text)){
                                return text[waf.getContext().locale || "l2"] || "";
                            }
                            if(waf.type.isObject(text) && waf.isEnumValue(text)){
                                return text.alias || "";
                            }
                            if(waf.type.isBoolean(text)){
                                return text ? $.wafPromptBox.bool.yes : $.wafPromptBox.bool.no;
                            }
                            return text || "";
                        });
                    }
                }
                return "";
            },
            createPromptBoxDOM: function(opts) {
                var obj = opts && opts.id && $("#"+opts.id);
                if(!(obj&&obj.data("domcreated"))){
                    return [$('<input id="' + opts.id + '" name="' + opts.name + '_el" type="text">'),
                        $('<input id="' + opts.id + '_el" name="' + opts.name + '" type="hidden">'),
                        $('<label class="viewStatus" id="' + opts.id + '_view"></label>')];
                }else{
                    return obj;
                }
            },
            initPromptBox: function(opts, el) {
                el=$.isArray(el)?$(el[0]):$(el);
                el.wafPromptBox(opts);
            },
            removePromptBox: function(opts) {
                var el = $("#" + opts.id),
                    subel = $("#" + opts.id + "_el"),
                    view = $("#" + opts.id + "_view");

                if(el.length) {
                    el.wafPromptBox("destroy");
                    el.remove();
                }
                if(subel.length) {
                    subel.remove();
                }
                if(view.length) {
                    view.remove();
                }
            },
            modifyPromptBox: function(opts) {
                var option = $.extend(true, {}, opts);
                var _value = option.value, el = $("#" + option.id);
                delete option.value;
                el.wafPromptBox("option", option);
                if(_value != null) {
                    el.wafPromptBox("setValue", _value);
                }
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("promptBox",{createDOMFun: $.wafPromptBox.createPromptBoxDOM,
                                                   initFun: $.wafPromptBox.initPromptBox,
                                                   deleteFun: $.wafPromptBox.removePromptBox,
                                                   modifyFun: $.wafPromptBox.modifyPromptBox,
                                                   lazyInit:true});
        });
    }(jQuery));
//});
    /*******************************************************************************
     * jQuery UI PromptGrid
     *
     * @version 1.0
     * @author peng_zhou1
     * @Depends:
     *         jquery.ui.core.js
     *        jquery.ui.widget.js
     ******************************************************************************/
//mod.defineModule("promptGrid",["base","waf","promptBox","block","promptUtil","position","promptGrid_i18n"],function(){

    (function( $, undefined ) {

        var requestIndex = 0,
            defaultClass = "ui-f7grid",
            panelClass = "ui-f7grid-panel ui-widget ui-widget-content ui-corner-all",
            dataFlg = "data.f7grid";

        $.widget( "ui.wafPromptGrid", {
            options: {
                accessType: "remote",
                ajaxType: "POST",
                allowAutoComplete: false,
                alternate: false,
                autoChoose: true,
                autoCompleteItem: "name",
                beforeProcessing: null,
                beforeOpen: null,
                cellFormatter: null,
                colModel: null,
                cu: true,
                data: null,
                dataUrl: null,
                delay: 300,
                filteritem: null,
                isMulti: false,
                maxHeight: null,
                minlength: 1,
                onselect: null,
                onshow: null,
                position: {
                    my: "left top",
                    at: "left bottom"
                },
                query: null,
                replaceNull: true,
                rows: 10,
                rowsArray: null,
                shrinkToFit: true,
                sidx: null,
                sord: null,
                style: null,
                tagClass: null,
                width: null
            },
            source: null,
            lastOrdered: "",
            cssCol: "",
            pending: 0,
            currentPage: 0,
            rowNumber: 0,
            pos: null,
            panel: null,
            term: "",
            delayClose: false,
            blockKeyForAutoComplete:false,
            _create: function() {
                var self = this,
                    suppressKeyPress;

                if(this.element.hasClass(defaultClass))return;

                this.element.wafPromptBox('option', 'subWidgetName', 'wafPromptGrid');

                this.element.addClass(defaultClass);

                this.options.rowsArray = this.options.rowsArray || [10,20,30];

                this.element
                    .bind( "keydown.wafPromptGrid", function( e ) {
                        var keyCode = $.ui.keyCode,
                            disabled = self.element.wafPromptBox("option", "disabled"),
                            readonly = self.element.wafPromptBox("option", "readonly");

                        if (disabled || readonly) {
                            return;
                        }
                        suppressKeyPress = false;

                        switch( e.keyCode ) {
                            case keyCode.PAGE_UP:
                                if(self.panel){
                                    $('.f7grid-keynav-prev').trigger('click.wafPromptGrid');
                                    e.preventDefault();
                                }
                                break;
                            case keyCode.PAGE_DOWN:
                                if(self.panel){
                                    $('.f7grid-keynav-next').trigger('click.wafPromptGrid');
                                    e.preventDefault();
                                }
                                break;
                            case keyCode.UP:
                                if(self.panel){
                                    self._previous(e);
                                    // prevent moving cursor to end of text field in some browsers
                                    e.preventDefault();
                                }
                                break;
                            case keyCode.DOWN:
                                if(self.panel){
                                    self._next(e);
                                    // prevent moving cursor to end of text field in some browsers
                                    e.preventDefault();
                                }
                                break;
                            case keyCode.SPACE:
                                if(self.panel && self.options.isMulti && self.active){
                                    self._check(e);
                                    e.preventDefault();
                                }
                                break;
                            case keyCode.ENTER:
                            case keyCode.NUMPAD_ENTER:
                                if(self.panel){
                                    if(self.options.isMulti){
                                        self.element.wafPromptBox("setValue", self.model);
                                    }else{
                                        // when menu is open and has focus
                                        if ( self.active ) {
                                            // #6055 - Opera still allows the keypress to occur
                                            // which causes forms to submit
                                            suppressKeyPress = true;
                                            self._select( e );
                                        }
                                    }
                                    e.preventDefault();
                                    e.stopPropagation();
                                } else if(self._isSearching()) {
                                    e.preventDefault();
                                    e.stopImmediatePropagation();
                                }
                            case keyCode.ESCAPE:
                            case keyCode.TAB:
                                if(self.panel){
                                    self._close();
                                }
                                break;
                            default:
                                break;
                        }
                        //autoCompleteautoComplete
                        if(self.options.allowAutoComplete && $.inArray(e.keyCode,$.keyutil.getKeyCodeArr())>-1){
                            self.blockKeyForAutoComplete = true;
                        }else{
                            self.blockKeyForAutoComplete = false;
                        }
                    })
                    .bind( "keypress.wafPromptGrid", function(e) {
                        if ( suppressKeyPress ) {
                            suppressKeyPress = false;
                            e.preventDefault();
                        }
                    })
                    .bind("blur.wafPromptGrid", function(e){
                        if(self.xhr){
                            self.xhr.abort();
                        }
                    });

                this._handleAutocomplete = function _handleAutocomplete(e){
                    if(!self.options.allowAutoComplete){
                        return;
                    }
                    if(self.blockKeyForAutoComplete){
                        return;
                    }
                    var val = self.element.val();
                    if(val.length < self.options.minlength) {
                        self._close();
                        return;
                    }
                    //
                    var multiple = self.options.isMulti;
                    if(!!multiple){
                        val = val.substring(val.lastIndexOf(",")+1);
                    }
                    clearTimeout( self.searching );
                    self.searching = setTimeout(function() {
                        if (self.term != val) {
                            self.term = val;
                            self.open(true);
                        }
                    }, self.options.delay);
                };

                if($.browser.msie){
                    this.element.bind("keyup.wafPromptGrid", this._handleAutocomplete);
                } else {
                    this.element.bind("input.wafPromptGrid", this._handleAutocomplete);
                }

                this._initSource();

                this.response = function() {
                    return self._response.apply( self, arguments );
                };
            },

            destroy: function() {
                this.element.removeClass(defaultClass);
                this._close();
                $.Widget.prototype.destroy.call( this );
            },

            _setOption: function( key, value ) {
                if(this.panel){
                    if (key === "tagClass") {
                        this.panel.removeClass(this.options.tagClass).addClass(value);
                    } else if (key === "style"){
                        this.panel.attr(key, value);
                    }
                }
                $.Widget.prototype._setOption.apply( this, arguments );
            },

            _initSource: function() {
                var self = this;
                if(this.options.accessType == "remote") {
                    this.source =  function( request, response ) {
                        if ( self.xhr ) {
                            self.xhr.abort();
                        }
                        self._block(true);
                        var ajaxParam = {
                            url: self.options.dataUrl,
                            async: true,
                            showBlock: false,
                            data: {
                                "autoCompleteItem": self.options.autoCompleteItem,
                                "autoCompleteTerm": request.autoCompleteTerm,
                                "cu": self.options.cu,
                                "filteritem": self.options.filteritem || "",
                                "page": self.currentPage,
                                "query": self.options.query || "",
                                "rows": self.options.rows,
                                "searchItem": request.searchItem,
                                "searchTerm": request.searchTerm,
                                "sidx": self.options.sidx || "",
                                "sord": self.options.sord || ""
                            },
                            f7gridRequest: ++requestIndex,
                            success: function( data ) {
                                if (this.f7gridRequest === requestIndex) {
                                    response( data );
                                }
                            },
                            complete: function(jqXHR, textStatus){
                                self._block(false);
                            }
                        };
                        self.xhr = self.options.ajaxType === "POST" ? $.doPost(ajaxParam) : $.doGet(ajaxParam);
                    };
                }else{
                    this.source = function(request, response) {
                        response(self._transform(self._query(request, this.options.data)));
                    };
                }
            },

            _isSearching: function() {
                return this.xhr && this.xhr.readyState != 4;
            },

            _select: function( event, ui ) {
                var item = this.active.data(dataFlg);

                // only trigger when focus was lost (click on menu)
                if ( this.element[0] !== this.element[0].ownerDocument.activeElement ) {
                    this.element.focus();
                }

                var data = this.active.data(dataFlg);
                this._trigger('onselect', 'onselect', {'data': data, 'selected':true});
                this.element.wafPromptBox("setValue", data);
                this.term = this.element.val();

                this._close();
            },

            _check: function(event){
                var checkbox = this.active.find(":checkbox:eq(0)"),
                    check = !checkbox.prop("checked"),
                    data = this.active.data(dataFlg);

                if(check){
                    this._addData(data);
                }else{
                    this._removeData(data);
                }

                checkbox.prop("checked", check);

                this._trigger('onselect', 'onselect', {'data':data, 'selected':check});
            },

            open: function(input) {
                if(!this.hasOpen()) {
                    this._trigger('beforeOpen', 'beforeOpen', this.options);
                }
                this._search( !! input);
            },

            _search: function(input) {
                input = !! input;
                var request = {
                    autoCompleteTerm: "",
                    autoCompleteItem: "",
                    searchTerm: ""
                };

                if(this.options.allowAutoComplete && input) {
                    request.autoCompleteTerm = this.term;
                }

                this.currentSearchTerm = request.searchTerm = this.subSearch && !this.subSearch.hasClass("placeholder") ? this.subSearch.val() : "";
                this.currentSearchColumn = request.searchItem = this.searchColunm ? this.searchColunm.val() : "";

                this.source(request, this.response);
            },

            _response: function(data) {
                this._trigger('beforeProcessing', 'beforeProcessing', data);

                if (data) {
                    if(data.totalCount == 1 && this.options.autoChoose) {
                        var val = this.element.wafPromptBox("getValue");
                        if(this.options.isMulti){
                            val = val || [];
                            val.push(content.data[0]);
                        }else{
                            val = content.data[0];
                        }
                        this.element.wafPromptBox("setValue", val);
                        this._close();
                    }else{
                        this._suggest(data);
                    }
                } else {
                    this._close();
                }
            },

            _delayClose: function() {
                this.delayClose = true;
            },

            _close: function() {
                this.element.wafPromptBox("setSuppressRefresh", false);
                if(this.xhr){
                    this.xhr.abort();
                }
                this._block(false);
                this.delayClose = false;
                this.currentPage = 0;
                this.currentSearchTerm = null;
                this.isSearch = null;
                this.term = null;
                if(this.panel){
                    $(document).unbind("mousedown.wafPromptGrid");
                    this.subSearch = null;
                    this.panel.remove();
                    this.panel = null;
                    this.model = null;
                }
            },

            _block: function(isBlock){
                isBlock = !!isBlock;
                this.element[isBlock ? 'addClass' : 'removeClass']("ui-f7-loading");
                if(this.panel){
                    waf.block[isBlock ? 'show' : 'hide'](isBlock ? {target: this.panel} : this.panel);
                }
            },

            _suggest: function(data) {
                var self = this,
                    frame = this.element.wafPromptBox("getFrame");

                this.element.wafPromptBox("setSuppressRefresh", true);
                this._initMultiModel();
                this._normalizeColModel(data.colModel);

                if(this.panel){
                    this.panel.empty();
                }else{
                    this.panel = $('<div class="' + panelClass + '"></div>')
                                    .attr('style', this.options.style)
                                    .css('top', 0)
                                    .css('left', 0)
                                    .addClass(this.options.tagClass)
                                    .appendTo($(".page_margins .page")[0] || "body");
                    this.panel.bind("click.wafPromptGrid", function( e ) {
                        if(self.delayClose) {
                            self._close();
                        }
                        if($( e.target ).closest(".ui-f7grid-item").length
                                && !self.options.isMulti) {
                            self._select( e );
                        }
                        e.stopPropagation();
                    });

                    $(document).bind("mousedown.wafPromptGrid", function(event){
                        var $target = $(event.target);
                        if($target.closest(self.panel).length == 0 && $target.closest(frame).length == 0){
                            self._close();
                        }
                    });
                }

                this._setWidth(data);

                this._createSearcher(data);
                this._createGrid(data);
                this._createPager(data);
                this._createButtonPnl(data);

                this._deactivate();
                this._refresh();

                this._setMaxHeight(data);

                this.panel.zIndex(this.element.zIndex() + 100)
                          .show()
                          .position($.extend({of: frame}, this.options.position));
                this._trigger('onshow', 'onshow', this.panel);

                if(this.isSearch){
                    this.subSearch.focus().select();
                    this.isSearch = null;
                }
            },

            _initMultiModel: function(){
                var f7value = this.element.wafPromptBox("getValue");
                if(this.options.isMulti && this.model == null){
                    if($.isArray(f7value)){
                        this.model = f7value.slice();
                    } else {
                        this.model = f7value ? [f7value] : [];
                    }
                }
            },

            _createSearcher: function(data){
                var self = this,
                    $searcher = $("<div class='ui-f7grid-searcher ui-widget-header'></div>").appendTo(this.panel),
                    colModel = data.colModel;

                // select
                this.searchColunm = $("<select class='ui-f7grid-searchColumn'></select>").appendTo($searcher);
                this.searchColunm.append("<option value='number+name'>" + $.wafPromptGrid.defaults.numberOrName + "</option>");
                for(var i = 0, length = colModel.length; i < length; i++){
                    var col = colModel[i];
                    if(!col.hidden && col.isFilter && (col.type == "String")){
                        this.searchColunm.append("<option value='" + col.columnName + "'>" + col.label + "</option>");
                    }
                }
                if(this.currentSearchColumn)this.searchColunm.val(this.currentSearchColumn);

                // 
                this.subSearch = $('<input type="text" class="ui-f7grid-searchInput">')
                    .appendTo($searcher)
                    .bind("keydown.wafPromptGrid", function(event){
                        var keyCode = $.ui.keyCode;
                        switch( event.keyCode ) {
                        case keyCode.ENTER:
                        case keyCode.NUMPAD_ENTER:
                            self.isSearch = true;
                            self._search();
                            //self.subSearch.focus();
                            event.preventDefault();
                            break;
                        }
                    });

                if(this.currentSearchTerm) this.subSearch.val(this.currentSearchTerm);
                this._addPlaceholder(this.subSearch, $.wafPromptGrid.defaults.searchInResultText);

                // 
                $('<button class="btn btn-b ui-f7grid-searchButton">' + $.wafPromptGrid.button.search + '</button>')
                        .appendTo($searcher)
                        .bind("click.wafPromptGrid", function(event){
                            self.isSearch = true;
                            self._search();
                            //self.subSearch.focus();
                            event.preventDefault();
                        });
            },

            _createGrid: function(data){
                var $grid = $("<div class='ui-f7grid-grid'></div>").appendTo(this.panel);
                this._renderHeader(data, $grid);
                this._renderGrid(data, $grid);
            },

            _createPager: function(data) {
                var self = this,
                    totalCount = data.totalCount,
                    totalPage = data.totalPage,
                    $pager = $("<div class='ui-f7grid-pager'></div>").appendTo(this.panel),
                    initRecord = 0,
                    lastRecord = 0;

                this.currentPage = data.currentPage;
                if(totalCount != 0){
                    initRecord = (self.currentPage - 1) * self.options.rows + 1;
                    if (self.currentPage < totalPage){
                        lastRecord = (self.currentPage * self.options.rows);
                    } else {
                        lastRecord = totalCount;
                    }
                }

                $("<table border='0' class='ui-f7grid-navTable'>"
                    +"<tbody>"
                        +"<td align='right'>"
                            +"<table border='0' class='ui-f7grid-pg-table' style='table-layout: auto;'>"
                            +"<tbody>"
                                +"<tr>"
                                    +"<td dir='ltr' class='ui-f7grid-navInfo'>"
                                    +self._renderPagerPage(self.currentPage, totalPage)
                                    +"</td>"
                                    +"<td class='ui-f7grid-pg-button ui-corner-all ui-state-disabled f7grid-keynav-first'>"
                                        +"<span class='ui-icon ui-icon-seek-first'></span>"
                                    +"</td>"
                                    +"<td class='ui-f7grid-pg-button ui-corner-all ui-state-disabled f7grid-keynav-prev'>"
                                        +"<span class='ui-icon ui-icon-seek-prev'></span>"
                                    +"</td>"
                                    +"<td class='ui-f7grid-pg-button ui-corner-all f7grid-keynav-next'>"
                                        +"<span class='ui-icon ui-icon-seek-next'></span>"
                                    +"</td>"
                                    +"<td class='ui-f7grid-pg-button ui-corner-all f7grid-keynav-last'>"
                                        +"<span class='ui-icon ui-icon-seek-end'></span>"
                                    +"</td>"
                                    +"<td dir='ltr'>"
                                        +"<select class='recordXP'>"
                                        +"</select>"
                                    +"</td>"
                                    +"<td class='ui-paging-info' style='text-align: right;' dir='ltr'>"
                                        + self._renderPagerView(initRecord, lastRecord, totalCount)
                                    +"</td>"
                                +"</tr>"
                            +"</tbody>"
                            +"</table>"
                        +"</td>"
                    +"</tr>"
                +"</tbody>"
                +"</table>").appendTo($pager);

                $.each(self.options.rowsArray, function( index, value ) {
                    $('.recordXP', $pager).append("<option value='"+ value +"' role='option'>"+ value +"</option>");
                });
                $('.recordXP', $pager).val(self.options.rows);
                if(self.currentPage>1){
                    $('.f7grid-keynav-first', $pager).removeClass("ui-state-disabled");
                    $('.f7grid-keynav-prev', $pager).removeClass("ui-state-disabled");
                } else {
                    $('.f7grid-keynav-first', $pager).addClass("ui-state-disabled");
                    $('.f7grid-keynav-prev', $pager).addClass("ui-state-disabled");
                };
                if(self.currentPage==totalPage){
                    $('.f7grid-keynav-next', $pager).addClass("ui-state-disabled");
                    $('.f7grid-keynav-last', $pager).addClass("ui-state-disabled");
                };

                $('.f7grid-keynav-next', $pager).bind('click.wafPromptGrid',function(){
                    if(self.currentPage<totalPage){
                        self.currentPage++;
                        self._search();
                    }
                });
                $('.f7grid-keynav-prev', $pager).bind('click.wafPromptGrid',function(){
                    if(self.currentPage>1){
                        self.currentPage--;
                        self._search();
                    }
                });
                $('.f7grid-keynav-last', $pager).bind('click.wafPromptGrid',function(){
                    if( totalPage>1 && self.currentPage<totalPage ){
                        self.currentPage=totalPage;
                        self._search();
                    }
                });
                $('.f7grid-keynav-first', $pager).bind('click.wafPromptGrid',function(){
                    if( totalPage>1 && self.currentPage>1){
                        self.currentPage=1;
                        self._search();
                    }
                });

                $('.ui-f7grid-pg-button', $pager).hover(function(){if(!$(this).hasClass("ui-state-disabled")){$(this).addClass('ui-state-hover');}}, function(){if(!$(this).hasClass("ui-state-disabled")){$(this).removeClass('ui-state-hover');}});

                $('.currentPage', $pager).keypress(function(e) {
                        var key = e.charCode ? e.charCode : e.keyCode ? e.keyCode : 0;
                        if(key == 13) {
                            if(!isNaN($(this).val()) && $(this).val()!=0){
                                if($(this).val()>totalPage){
                                    self.currentPage=totalPage;
                                }else{
                                    self.currentPage=$(this).val();
                                }
                                self._search();
                            }
                        }
                });
                $('.recordXP', $pager).bind('change',function() {
                        self.options.rows=this.value;
                        self.currentPage=1;
                        self._search();
                    });

            },
            _createButtonPnl: function(data){
                if(this.options.isMulti){
                    var self = this,
                        $buttonPnl = $("<div class='ui-f7grid-buttonPanel'>").appendTo(this.panel);

                    $('<button class="btn btn-b ui-f7grid-submit">' + $.wafPromptGrid.button.submit + '</button>')
                        .appendTo($buttonPnl).click(function(event){
                            self.element.wafPromptBox("setValue", self.model);
                            self._delayClose();
                        });
                    $('<button class="btn btn-b ui-f7grid-cancel">' + $.wafPromptGrid.button.cancel + '</button>')
                        .appendTo($buttonPnl).click(function(event){
                            self._delayClose();
                        });
                }
            },
            _normalizeColModel: function(colModel) {
                for (idx in colModel) {
                    var col = colModel[idx];
                    if (col.width == undefined) {
                        col.width = 100;
                    }
                    if (col.align == null) {
                        col.align = "left";
                    }
                    if (col.hidden === true) {
                        col.width = 0;
                    }
                }
            },
            _setWidth: function(data){
                var colModel = data.colModel;
                this.allWidth = 0;
                this.sumWidth = 0;
                this.realWidth = 0;
                for (idx in colModel) {
                    this.sumWidth += Number(colModel[idx].width);
                }
                if(this.options.width == null){
                    this.allWidth = this.sumWidth + 10 + (this.options.isMulti ? 20 : 0);
                }else{
                    this.allWidth = this.options.width;
                }
                this.realWidth = this.allWidth - 10 - (this.options.isMulti ? 20 : 0);
                this.panel.width(this.allWidth);
            },
            _setMaxHeight: function(data){
                if(this.options.maxHeight != null){
                    var searcher = this.panel.children(".ui-f7grid-searcher"),
                        grid = this.panel.children(".ui-f7grid-grid"),
                        pager = this.panel.children(".ui-f7grid-pager"),
                        panelHeight = this.panel.height(),
                        searcherHeight = searcher.outerHeight(),
                        gridHeight = grid.outerHeight(),
                        pagerHeight = pager.outerHeight(),
                        maxHeight = this.options.maxHeight;

                    if(panelHeight > maxHeight){
                        grid.height(maxHeight - searcherHeight - pagerHeight);
                        this.panel.width(this.allWidth + $.wafutil.getVerticalScrollBarWidth());
                    }
                }
            },
            _getStyle: function(col, isHeader) {
                var style = "",
                    isHeader = !!isHeader;
                if (this.options.shrinkToFit) {
                    style += ("width:" + (col.width / this.sumWidth * this.realWidth) + 'px;');
                } else {
                    style += ("width:" + col.width + 'px;');
                }
                if (col.hidden != undefined && col.hidden) {
                    style += "display:none;";
                }
                if(isHeader){
                    style += ("text-align:center");
                }else{
                    style += ("text-align:" + col.align);
                }
                return style;
            },
            _checkAll: function(checked){
                var self = this;
                $(".ui-f7grid-checkbox", this.panel).each(function(idx, ele){
                    ele = $(ele);
                    var data = ele.closest( ".ui-f7grid-item" ).eq(0).data(dataFlg);
                    ele.prop("checked", checked);
                    if(checked){
                        self._addData(data);
                    }else{
                        self._removeData(data);
                    }

                    self._trigger('onselect', 'onselect', {'data':data, 'selected':checked});
                });
            },
            _renderHeader: function(data, panel) {
                var self = this,
                    colModel = data.colModel,
                    $header = $( "<div class='ui-state-default ui-f7grid-header'></div>" ).appendTo(panel);

                if(this.options.isMulti){
                    var headChecker = $("<div class='ui-f7grid-checker ui-f7grid-colHeader'></div>").appendTo($header);
                    $("<input type='checkbox' class='ui-f7grid-checkbox-total'>").appendTo(headChecker)
                        .change(function(e){
                            self._checkAll(this.checked);
                        });
                }
                $.each( colModel, function( index, col ) {
                    // Check if column is ordered or not to provide asc/desc icon
                    if(col.columnName==self.cssCol){
                        $('<div class="ui-f7grid-colHeader" style="' + self._getStyle(col, true) + '"><label class="ui-f7grid-colHeader-label" id="'+ col.columnName +'">'
                                +self._renderLabel(col.label)
                                +'</label><span class="ui-f7grid-colHeader '+ self.options.sord +'"></span></div>').appendTo($header);
                    } else {
                        $('<div class="ui-f7grid-colHeader" style="' + self._getStyle(col, true) + '"><label class="ui-f7grid-colHeader-label" id="'+ col.columnName +'">'
                                +self._renderLabel(col.label)
                                +'</label></div>').appendTo($header);
                    }
                });

                $(".ui-f7grid-colHeader-label", $header).bind('click.wafPromptGrid',function(){
                    self.options.sord="";
                    self.cssCol = "";
                    value = $(this).attr('id');
                    self.cssCol = value;
                    if(self.lastOrdered==value) {
                        self.lastOrdered = "";
                        self.options.sord = "desc";
                    } else {
                        self.lastOrdered = value;
                        self.options.sord = "asc";
                    }
                    self.options.sidx = value;
                    self._search();
                });
            },

            _renderLabel: function (label) {
                return label;
            },

            _renderGrid: function(data, panel) {
                var self = this;
                $.each( data.rows, function( index, row ) {
                    self._renderItem(row, data.colModel, panel);
                });
            },

            _renderItem: function(row, colModel, panel) {
                var self = this,
                    $item = $("<div></div>").data(dataFlg, row).appendTo(panel),
                    $labelItem = $("<label class='ui-f7grid-rowItem'></label>").appendTo($item);

                this.rowNumber++;

                if(self.options.alternate){
                    if(this.rowNumber%2==0){
                        $item.addClass("ui-f7grid-item-even");
                    } else {
                        $item.addClass("ui-f7grid-item-odd");
                    }
                }

                if(self.options.isMulti){
                    var uuid = "f7grid-chk-" + this.rowNumber + new Date().getTime();
                    $labelItem.attr("for", uuid);
                    var chk = $('<input id="'+ uuid +'"type="checkbox" class="ui-f7grid-checkbox">').change(function(event){
                        var data = $( event.target ).closest( ".ui-f7grid-item" ).eq(0).data(dataFlg);
                        if(this.checked){
                            self._addData(data);
                        }else{
                            self._removeData(data);
                        }

                        self._trigger('onselect', 'onselect', {'data': data, 'selected':this.checked});
                        self.element.focus();
                    });
                    $("<div class='ui-f7grid-checker'></div>").append(chk).appendTo($labelItem);
                    if(this._getIndexOf(row, this.model) != null){
                        chk.prop("checked", true);
                    }
                }

                $.each( colModel, function( index, col ) {
                    var value = $.wafutil.getValueByPath(row, col.columnName),
                        cell;
                    if(value==null && self.options.replaceNull){
                        colItem = "&nbsp";
                    }else{
                        colItem = self._cellFormat(value);
                    }
                    cell = $("<div style=" + self._getStyle(col) + " class='ui-f7grid-colItem'>"+ colItem +"</div>").appendTo($labelItem);
                    self._cellFormatter(cell, value, col);
                });
            },
            _renderPagerPage: function (page, totalPage){
                return this._format($.wafPromptGrid.defaults.pgtext, '<input type="text" size="1" class="currentPage" value="' + page + '"/>', totalPage);
            },
            _renderPagerView: function (initRecord, lastRecord, totalCount){
                return this._format($.wafPromptGrid.defaults.recordtext, initRecord, lastRecord, totalCount);
            },
            widget: function() {
                return this.element;
            },
            _refresh: function() {
                var self = this;

                // don't refresh list items that are already adapted
                var items = this.panel.children(".ui-f7grid-grid").children("div:not(.ui-f7grid-item):not(.ui-f7grid-header):has(label)")
                    .addClass("ui-f7grid-item");

                items.children("label")
                    .addClass("ui-corner-all")
                    .attr("tabindex", -1)
                    // mouseenter doesn't work with event delegation
                    .mouseenter(function( event ) {
                        self._activate( event, $(this).parent() );
                    })
                    .mouseleave(function() {
                        self._deactivate();
                    });
            },
            _activate: function( event, item ) {
                this._deactivate();
                if (this._hasScroll()) {
                    var offset = item.offset().top - this.panel.offset().top,
                        scroll = this.panel.attr("scrollTop"),
                        elementHeight = this.panel.height();
                    if (offset < 0) {
                        this.panel.attr("scrollTop", scroll + offset);
                    } else if (offset >= elementHeight) {
                        this.panel.attr("scrollTop", scroll + offset - elementHeight + item.height());
                    }
                }
                this.active = item.eq(0)
                        .children("label")
                        .addClass("ui-state-hover")
                        .end();
            },
            _deactivate: function() {
                if (!this.active) { return; }
                this.active
                    .children("label")
                    .removeClass("ui-state-hover")
                this.active = null;
            },
            _hasScroll: function() {
                return this.panel.height() < this.panel[ $.fn.prop ? "prop" : "attr" ]("scrollHeight");
            },
            _first: function() {
                return this.active && !this.active.prevAll(".ui-f7grid-item").length;
            },

            _last: function() {
                return this.active && !this.active.nextAll(".ui-f7grid-item").length;
            },

            _next: function(event) {
                this._move("next", ".ui-f7grid-item:first", event);
            },

            _previous: function(event) {
                this._move("prev", ".ui-f7grid-item:last", event);
            },

            _move: function(direction, edge, event) {
                if (!this.active) {
                    this._activate(event, this.panel.children(".ui-f7grid-grid").children(edge));
                    return;
                }
                var next = this.active[direction + "All"](".ui-f7grid-item").eq(0);
                if (next.length) {
                    this._activate(event, next);
                } else {
                    this._activate(event, this.panel.children(".ui-f7grid-grid").children(edge));
                }
            },

            _nextPage: function(event) {
                if (this._hasScroll()) {
                    if (!this.active || this._last()) {
                        this._activate(event, this.panel.children(".ui-f7grid-grid").children(".ui-f7grid-item:first"));
                        return;
                    }
                    var base = this.active.offset().top,
                        height = this.panel.height(),
                        result = this.panel.children(".ui-f7grid-grid").children(".ui-f7grid-item").filter(function() {
                            var close = $(this).offset().top - base - height + $(this).height();
                            return close < 10 && close > -10;
                        });

                    if (!result.length) {
                        result = this.panel.children(".ui-f7grid-grid").children(".ui-f7grid-item:last");
                    }
                    this._activate(event, result);
                } else {
                    this._activate(event, this.panel.children(".ui-f7grid-grid").children(".ui-f7grid-item")
                        .filter(!this.active || this.last() ? ":first" : ":last"));
                }
            },

            _previousPage: function(event) {
                if (this._hasScroll()) {
                    if (!this.active || this._first()) {
                        this._activate(event, this.panel.children(".ui-f7grid-grid").children(".ui-f7grid-item:last"));
                        return;
                    }

                    var base = this.active.offset().top,
                        height = this.panel.height();
                        result = this.panel.children(".ui-f7grid-grid").children(".ui-f7grid-item").filter(function() {
                            var close = $(this).offset().top - base + height - $(this).height();
                            return close < 10 && close > -10;
                        });

                    if (!result.length) {
                        result = this.panel.children(".ui-f7grid-grid").children(".ui-f7grid-item:first");
                    }
                    this._activate(event, result);
                } else {
                    this._activate(event, this.panel.children(".ui-f7grid-grid").children(".ui-f7grid-item")
                        .filter(!this.active || this.first() ? ":last" : ":first"));
                }
            },
            _addData:function(data){
                var index = this._getIndexOf(data, this.model);
                if(index == null){
                    this.model.push(data)
                }

            },
            _removeData:function(data){
                var index = this._getIndexOf(data, this.model);
                if(index != null){
                    this.model.splice(index,1);
                }
            },
            _getIndexOf:function(data,model){
                var self = this,
                    index = null,
                    identification = self.element.wafPromptBox("option", "identification");

                $.each(model,function(idx,val){
                    if(data[identification] == val[identification]){
                        index = idx;
                    }
                });
                return index;
            },
            _format: function (format){
                var args = $.makeArray(arguments).slice(1);
                if(format===undefined) { format = ""; }
                return format.replace(/\{(\d+)\}/g, function(m, i){
                    return args[i];
                });
            },
            hasOpen: function(){
                return this.panel !== null;
            },
            _cellFormat: function(value){
                if($.type.isObject(value) && $.isEnumValue(value)){
                    return value.alias || "";
                }
                if($.type.isBoolean(value)){
                    return value ? $.wafPromptGrid.bool.yes : $.wafPromptGrid.bool.no;
                }
                return value;
            },
            _cellFormatter: function(cell, value, col){
                var cellFormatter = this.options.cellFormatter;
                if(cellFormatter) str = cellFormatter.apply(this, arguments);
            },
            _addPlaceholder: function(input, ph) {
                if(this._isSupportPlaceHolder()) {
                    input.attr("placeholder", ph);
                } else {
                    if (input.val() === "") {
                        input.val(ph);
                        input.addClass("placeholder");
                    }

                    input.focus(function(){
                        if (input.hasClass("placeholder")) {
                            input.removeClass("placeholder");
                            input.val('');
                        }
                    });
                    input.blur(function(){
                        if (input.val() === "") {
                            input.val(ph);
                            input.addClass("placeholder");
                        }
                    });
                }
            },
            _isSupportPlaceHolder: function() {
                return !!('placeholder' in document.createElement('input'));
            },
            _query: function(request, data) {
                var autoCompleteItem = this.options.autoCompleteItem,
                    autoCompleteTerm = request.autoCompleteTerm,
                    searchItem = request.searchItem,
                    searchTerm = request.searchTerm,
                    sidx = this.options.sidx,
                    sord = this.options.sord,
                    rec = jlinq.from(data);

                if(autoCompleteTerm) {
                    rec = rec.contains(autoCompleteItem, autoCompleteTerm);
                }
                if(searchTerm) {
                    if(searchItem == 'number+name'){
                        rec = rec.contains('number', searchTerm).orContains('name', searchTerm);
                    }else{
                        rec = rec.contains(searchItem, searchTerm);
                    }
                }
                if(sidx && sord) {
                    rec.sort(sidx);
                    if(sord === "desc") {
                        rec.reverse();
                    }
                }
                return rec.select();
            },
            _transform: function(data) {
                var rows = this.options.rows,
                    totalCount = data.length,
                    totalPage = Math.ceil(totalCount / rows),
                    currentPage = Math.min(Math.max(this.currentPage, 1), totalPage),
                    start = (currentPage - 1) * rows,
                    end = currentPage * rows;

                data = data.slice(start, end);

                return {
                    'colModel': this.options.colModel,
                    'rows': data,
                    'currentPage': currentPage,
                    'totalCount': totalCount,
                    'totalPage': totalPage
                };
            }
        });

        $.wafPromptGrid = $.wafPromptGrid || {};
        $.extend($.wafPromptGrid, {
            createPromptGridDOM: function(opts){
                return null;
            },
            initPromptGrid: function(opts, el){
                if(!$.wafutil.isViewOperateState(opts)){
                    $.dynamicutil.addContextPath(opts, "dataUrl", "/component/F7Grid.do?method=initalize");
                    $("#" + opts.parentId).wafPromptGrid(opts);
                }
            },
            removePromptGrid: function(opts){
                if(!$.wafutil.isViewOperateState(opts)){
                    $("#" + opts.parentId).wafPromptGrid("destroy");
                }
            },
            modifyPromptGrid: function(opts){
                if(!$.wafutil.isViewOperateState(opts)){
                    $.dynamicutil.addContextPath(opts, "dataUrl", "/component/F7Grid.do?method=initalize");
                    $("#" + opts.parentId).wafPromptGrid('option', opts);
                }
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("promptGrid",{createDOMFun: $.wafPromptGrid.createPromptGridDOM,
                                                   initFun: $.wafPromptGrid.initPromptGrid,
                                                   deleteFun: $.wafPromptGrid.removePromptGrid,
                                                   modifyFun: $.wafPromptGrid.modifyPromptGrid,lazyInit:true});
        });
    }( jQuery ));
//});
    /*******************************************************************************
     * jQuery UI PromptQuick
     *
     * @version 1.0
     * @author peng_zhou1
     * @Depends:
     *         jquery.ui.core.js
     *         jquery.ui.widget.js
     ******************************************************************************/
//mod.defineModule("promptQuick",["base","waf","promptBox","position","block","promptUtil","promptQuick_i18n"],function(){

    (function($, undefined) {

        var requestIndex = 0,
            defaultClass = "ui-f7quick",
            panelClass = "ui-f7quick-panel ui-widget ui-widget-content ui-corner-all",
            dataFlg = "data.f7quick";

        $.widget("ui.wafPromptQuick", {
            options: {
                accessType: "remote",
                ajaxType: "POST",
                allowAutoComplete: false,
                autoChoose: true,
                autoCompleteItem: "name",
                beforeProcessing: null,
                beforeOpen: null,
                cu: true,
                data: null,
                dataUrl: null,
                delay: 300,
                displayItem: "name",
                filteritem: null,
                isMulti: false,
                minlength: 1,
                numberOfContent: [4, 3],
                onselect: null,
                onshow: null,
                serializePromptData: null,
                position: {
                    my: "left top",
                    at: "left bottom"
                },
                query: null,
                sidx: null,
                sord: null,
                style: null,
                tagClass: null,
                width: 400
            },
            currentPage: 0,
            panel: null,
            model: null,//
            term: "",
            delayClose: false, //closepanelremovepanelclickbodydelayClosetrueclickpanelclickpanelclick
            blockKeyForAutoComplete:false,
            _create: function() {
                var self = this,
                    suppressKeyPress;

                if(!this.element.hasClass(defaultClass)) {
                    this.element.addClass(defaultClass);
                }

                this.element.wafPromptBox('option', 'subWidgetName', 'wafPromptQuick');
                //this.elementinput
                this.element.bind("keydown.wafPromptQuick", function(e) {
                    var keyCode = $.ui.keyCode,
                        disabled = self.element.wafPromptBox("option", "disabled"),
                        readonly = self.element.wafPromptBox("option", "readonly");

                    if(disabled || readonly) {
                        return;
                    }
                    suppressKeyPress = false;

                    switch(e.keyCode) {
                    case keyCode.PAGE_UP:
                        if(self.panel) {
                            self._previousPage(e);
                            e.preventDefault();
                        }
                        break;
                    case keyCode.PAGE_DOWN:
                        if(self.panel) {
                            self._nextPage(e);
                            e.preventDefault();
                        }
                        break;
                    case keyCode.SPACE:
                        if(self.panel && self.options.isMulti && self.active) {
                            self._check(e);
                            e.preventDefault();
                        }
                        break;
                    case keyCode.ENTER:
                    case keyCode.NUMPAD_ENTER:
                        if(self.panel) {
                            if(self.options.isMulti) {
                                self.element.wafPromptBox("setValue", self.model);
                            } else {
                                if(self.active) {
                                    suppressKeyPress = true;
                                    self._select(e);
                                }
                            }
                            e.preventDefault();
                            e.stopPropagation();
                        } else if(self._isSearching()) {
                            e.preventDefault();
                            e.stopImmediatePropagation();
                        }
                    case keyCode.ESCAPE:
                    case keyCode.TAB:
                        if(self.panel) {
                            self._close();
                        }
                        break;
                    case keyCode.LEFT:
                        if(self.panel) {
                            self._move("left", e);
                            e.preventDefault();
                        }
                        break;
                    case keyCode.UP:
                        if(self.panel) {
                            self._move("up", e);
                            e.preventDefault();
                        }
                        break;
                    case keyCode.RIGHT:
                        if(self.panel) {
                            self._move("right", e);
                            e.preventDefault();
                        }
                        break;
                    case keyCode.DOWN:
                        if(self.panel) {
                            self._move("down", e);
                            e.preventDefault();
                        }
                        break;
                    default:
                        break;
                    }

                    //autoCompleteautoComplete
                    if(self.options.allowAutoComplete && $.inArray(e.keyCode,$.keyutil.getKeyCodeArr())>-1){
                        self.blockKeyForAutoComplete = true;
                    }else{
                        self.blockKeyForAutoComplete = false;
                    }
                })
                .bind("keypress.wafPromptQuick", function(e) {
                    if(suppressKeyPress) {
                        suppressKeyPress = false;
                        e.preventDefault();
                    }
                })
                .bind("blur.wafPromptQuick", function(e){
                    if(self.xhr){
                        self.xhr.abort();
                    }
                });

                this._handleAutocomplete = function _handleAutocomplete(e) {
                    if(!self.options.allowAutoComplete) {
                        return;
                    }
                    if(self.blockKeyForAutoComplete){
                        return;
                    }
                    var val = self.element.val();
                    if(val.length < self.options.minlength) {
                        self._close();
                        return;
                    }
                    //
                    var multiple = self.options.isMulti;
                    if(!!multiple){
                        val = val.substring(val.lastIndexOf(",")+1);
                    }
                    clearTimeout(self.searching);
                    self.searching = setTimeout(function() {
                        if(self.term != val) {
                            self.term = val;
                            self.open(true);
                        }
                    }, self.options.delay);
                    //
                    self.blockKeyForAutoComplete = false;
                };

                if($.browser.msie) {
                    this.element.bind("keyup.wafPromptQuick", this._handleAutocomplete);
                } else {
                    //input
                    this.element.bind("input.wafPromptQuick", this._handleAutocomplete);
                }

                this._initSource();

                this.response = function() {
                    return self._response.apply(self, arguments);
                };
            },

            _isSearching: function() {
                return this.xhr && this.xhr.readyState != 4;
            },

            destroy: function() {
                this.element.removeClass(defaultClass);
                this._close();
                $.Widget.prototype.destroy.call(this);
            },

            widget: function() {
                return this.element;
            },

            open: function(input) {
                if(!this.hasOpen()) {
                    this._trigger('beforeOpen', 'beforeOpen', this.options);
                }
                this._search( !! input);
            },

            _setOption: function(key, value) {
                if(this.panel) {
                    if(key === "tagClass") {
                        this.panel.removeClass(this.options.tagClass).addClass(value);
                    } else if(key === "style") {
                        this.panel.attr(key, value);
                    }
                }
                $.Widget.prototype._setOption.apply(this, arguments);
            },

            _initSource: function() {
                var self = this;
                if(this.options.accessType == "remote") {
                    this.source = function(request, response) {
                        if(self.xhr) {
                            self.xhr.abort();
                        }
                        self._block(true);
                        var postData = {
                            "autoCompleteItem": self.options.autoCompleteItem,
                            "autoCompleteTerm": request.autoCompleteTerm,
                            "cu": self.options.cu,
                            "filteritem": self.options.filteritem || "",
                            "page": self.currentPage,
                            "query": self.options.query || "",
                            "rows": self.options.numberOfContent[0] * self.options.numberOfContent[1],
                            "searchTerm": request.searchTerm,
                            "sidx": self.options.sidx || "",
                            "sord": self.options.sord || ""
                        };
                        var ajaxParam = {
                            url: self.options.dataUrl,
                            async: true,
                            showBlock: false,
                            data: (self.options.serializePromptData&&$.isFunction(self.options.serializePromptData))?self.options.serializePromptData.call(self,postData):postData,
                            f7quickRequest: ++requestIndex,
                            success: function(data, status) {
                                // 
                                if(this.f7quickRequest === requestIndex) {
                                    response(data);
                                }
                            },
                            complete: function(jqXHR, textStatus) {
                                self._block(false);
                            },
                            beforeSend:function (xhr, settings) {
                                console.info(xhr);
                            }
                        };
                        self.xhr = self.options.ajaxType === "POST" ? $.doPost(ajaxParam) : $.doGet(ajaxParam);
                    };
                } else {
                    this.source = function(request, response) {
                        response(self._transform(self._query(request, this.options.data)));
                    };
                }
            },

            _delayClose: function(){
                this.delayClose = true;
            },

            _close: function() {
                this.element.wafPromptBox("setSuppressRefresh", false);
                if(this.xhr){
                    this.xhr.abort();
                }
                this._block(false);
                this.delayClose = false;
                this.currentPage = 0;
                this.currentSearchTerm = null;
                this.isSearch = null;
                this.term = null;
                if(this.panel) {
                    $(document).unbind("mousedown.wafPromptQuick");
                    this.subSearch = null;
                    this.panel.remove();
                    this.panel = null;
                    this.model = null;
                }
            },

            _block: function(isBlock){
                isBlock = !!isBlock;
                //inputloadding block
                this.element[isBlock ? 'addClass' : 'removeClass']("ui-f7-loading");
                if(this.panel){
                    //block
                    waf.block[isBlock ? 'show' : 'hide'](isBlock ? {target: this.panel} : this.panel);
                }
            },
            //classhover
            _refresh: function() {
                var self = this,
                    items = this.panel.find("td label:not(.ui-f7quick-item):not(.disselect)")
                        .addClass("ui-corner-all ui-f7quick-item")
                        .attr("tabindex", -1)
                        .hover(function(event) {
                            self._activate(event, $(this));
                        }, function() {
                            self._deactivate();
                        });
            },

            _select: function(event) {
                //this.element[0].ownerDocument.activeElement,elementdocumentactive
                if(this.element[0] !== this.element[0].ownerDocument.activeElement) {
                    this.element.focus();
                }

                var data = this.active.data(dataFlg);

                this._trigger('onselect', 'onselect', {
                    'data': data,
                    'selected': true
                });
                this.element.wafPromptBox("setValue", data);
                this.term = this.element.val();
                this._close();
            },

            _check: function(event) {
                var checkbox = $(this.active.children()[0]),
                    check = !checkbox.prop("checked"),
                    data = this.active.data(dataFlg);

                if(check) {
                    this._addData(data);
                } else {
                    this._removeData(data);
                }

                checkbox.prop("checked", check);

                this._trigger('onselect', 'onselect', {
                    'data': data,
                    'selected': check
                });
            },

            _activate: function(event, item) {
                this._deactivate();
                if(this._hasScroll()) {
                    var offset = item.offset().top - this.panel.offset().top,
                        scroll = this.panel.scrollTop(),
                        elementHeight = this.panel.height();
                    if(offset < 0) {
                        this.panel.scrollTop(scroll + offset);
                    } else if(offset >= elementHeight) {
                        this.panel.scrollTop(scroll + offset - elementHeight + item.height());
                    }
                }
                this.active = item.eq(0).addClass("ui-state-hover");
            },

            _deactivate: function() {
                if(!this.active) {
                    return;
                }

                this.active.removeClass("ui-state-hover");
                this.active = null;
            },

            _search: function(input) {
                input = !! input;
                var searchItem = {
                        autoCompleteTerm: "",
                        searchTerm: ""
                    };
                if(this.options.allowAutoComplete && input) {
                    searchItem.autoCompleteTerm = this.term;
                }

                this.currentSearchTerm = searchItem.searchTerm = this.subSearch && !this.subSearch.hasClass("placeholder") ? this.subSearch.val() : "";

                this.source(searchItem, this.response);
            },

            _response: function(content) {
                this._trigger('beforeProcessing', 'beforeProcessing', content);

                if(content) {
                    //autoChoosetruepanel
                    if(content.totalCount == 1 && this.options.autoChoose) {
                        var val = this.element.wafPromptBox("getValue");
                        if(this.options.isMulti){
                            val = val || [];
                            val.push(content.data[0]);
                        }else{
                            val = content.data[0];
                        }
                        this.element.wafPromptBox("setValue", val);
                        this._close();
                    } else {
                        this._suggest(content);
                    }
                } else {
                    this._close();
                }
            },
            _suggest: function(content) {
                var self = this,
                    f7value = this.element.wafPromptBox("getValue"),
                    frame = this.element.wafPromptBox("getFrame");

                this.element.wafPromptBox("setSuppressRefresh", true);

                if(!this.panel) {
                    if(this.options.isMulti) {
                        if($.isArray(f7value)) {
                            this.model = f7value.slice();
                        } else {
                            this.model = f7value ? [f7value] : [];
                        }
                    }
                    this.panel = $('<div class="' + panelClass + '"></div>')
                                    .attr('style', this.options.style)
                                    .addClass(this.options.tagClass)
                                    .css({
                                        'top': 0,
                                        'left': 0
                                    })
                                    .appendTo('body');

                    this.panel.bind("click.wafPromptQuick", function(e) {
                        if(self.delayClose) {
                            self._close();
                        }
                        if($(e.target).closest(".ui-f7quick-item").length
                                && !self.options.isMulti) {
                            self._select(e);
                        }
                        e.stopPropagation();
                    });

                    $(document).bind("mousedown.wafPromptQuick", function(event) {
                        var $target = $(event.target);
                        //frameinputpanel
                        if(!$target.closest(self.panel).length && !$target.closest(frame).length) {
                            self._close();
                        }
                    });
                }

                this._renderUI(content);
                //showposition
                this.panel.css("width", (this.options.width != null ? this.options.width : "auto"))
                        .zIndex(this.element.zIndex() + 100)
                        .show()
                        .position($.extend({
                            of: frame
                        }, this.options.position));
                this._trigger('onshow', 'onshow', this.panel);
                //
                if(this.isSearch) {
                    this.subSearch.focus().select();
                    this.isSearch = null;
                }
            },
            _move: function(direction, event) {
                var position = this._getPosition(this.active);
                switch(direction) {
                case "up":
                    if(position) {
                        if(position.row > 1) {
                            position.row--;
                        }
                    } else {
                        position = {
                            row: this.options.numberOfContent[0],
                            column: this.options.numberOfContent[1]
                        };
                    }
                    break;
                case "down":
                    if(position) {
                        if(position.row < this.options.numberOfContent[0]) {
                            position.row++;
                        }
                    } else {
                        position = {
                            row: 1,
                            column: 1
                        };
                    }
                    break;
                case "left":
                    if(position) {
                        if(position.column > 1) {
                            position.column--;
                        }
                    } else {
                        position = {
                            row: this.options.numberOfContent[0],
                            column: this.options.numberOfContent[1]
                        };
                    }
                    break;
                case "right":
                    if(position) {
                        if(position.column < this.options.numberOfContent[1]) {
                            position.column++;
                        }
                    } else {
                        position = {
                            row: 1,
                            column: 1
                        };
                    }
                    break;
                default:
                    break;
                }
                var next = this._getItem(position);
                if(next) {
                    this._activate(event, next);
                }
            },
            _getPosition: function(item) {
                if(!item) {
                    return null;
                }
                return {
                    row: item.attr("rowIndex"),
                    column: item.attr("colIndex")
                };
            },
            _getItem: function(position) {
                var $item = this.panel.find("label:not(.disselect)[rowIndex=" + position.row + "][colIndex=" + position.column + "]");
                if($item.length > 0) {
                    return $item.eq(0);
                }
                return null;
            },
            _nextPage: function(event) {
                if(this.currentPage < this.totalPage) {
                    this.currentPage++;
                    this._search();
                }
            },
            _previousPage: function(event) {
                if(this.currentPage > 1) {
                    this.currentPage--;
                    this._search();
                }
            },
            _renderUI: function(content) {
                this.panel.empty();

                this.totalPage = content.totalPage;
                this.currentPage = content.currentPage;

                this.panel.append(this._getHeader(content));
                this.panel.append(this._getContent(content));
                this.panel.append(this._getPager(content));

                if(this.options.isMulti) {
                    this.panel.append(this._getButtonPnl(content));
                }

                this._deactivate();
                this._refresh();
            },
            _getHeader: function(content) {
                var self = this,
                    $header = $('<div class="ui-f7quick-header ui-widget-header"></div>');

                this.subSearch = $('<input type="text">')
                        .appendTo($header)
                        .bind("keydown.wafPromptQuick", function(event) {
                            var keyCode = $.ui.keyCode;
                            switch(event.keyCode) {
                            case keyCode.ENTER:
                            case keyCode.NUMPAD_ENTER:
                                self.isSearch = true;
                                self._search();
                                event.preventDefault();
                                break;
                            }
                        });
                if(this.currentSearchTerm) this.subSearch.val(this.currentSearchTerm);
                this._addPlaceholder(this.subSearch, $.wafPromptQuick.defaults.searchInResultText);

                $('<button class="btn btn-b ui-f7quick-search">' + $.wafPromptQuick.button.search + '</button>')
                    .appendTo($header)
                    .bind("click", function(event) {
                        self.isSearch = true;
                        self._search();
                        event.preventDefault();
                    });

                return $header;
            },
            _getContent: function(content) {
                var self = this,
                    $content = $('<div class="ui-f7quick-content"></div>'),
                    $table = $('<table></table>').css({
                            width: "100%"
                        }).appendTo($content),
                    dataCopy = content.data.slice();

                for(i = 1; i <= this.options.numberOfContent[0]; i++) {
                    var $tr = $("<tr></tr>").appendTo($table);
                    for(j = 1; j <= this.options.numberOfContent[1]; j++) {
                        var $td = $("<td></td>").appendTo($tr),
                            $label = $("<label></label>")
                                .addClass("item").appendTo($td)
                                .attr({
                                rowIndex: i,
                                colIndex: j
                            }),
                            data = dataCopy.shift();

                        if(data) {
                            var displayText = this._formatDisplayItem(data);
                            if(this.options.isMulti) {
                                var uuid = "f7quick-chk-" + i + "-" + j + "-" + new Date().getTime();
                                $label.attr("for", uuid);
                                var chk = $('<input id="' + uuid + '" type="checkbox" class="ui-f7quick-checkbox"/>').change(function() {
                                    var data = $(this).parent().data(dataFlg);
                                    if(this.checked) {
                                        self._addData(data);
                                    } else {
                                        self._removeData(data);
                                    }

                                    self._trigger('onselect', 'onselect', {
                                        'data': data,
                                        'selected': this.checked
                                    });
                                    self.element.focus();
                                });
                                if(this._getIndexOf(data, this.model) != null) {
                                    chk.prop("checked", true);
                                }
                                $label.append(chk);
                            }
                            $label.append(displayText);
                            $label.attr("title", displayText);
                            $label.data(dataFlg, data);
                        } else {
                            //class
                            $label.addClass("disselect");
                        }
                    }
                }

                return $content;
            },
            _formatDisplayItem: function(data, meta) {
                var displayItem = this.options.displayItem,
                    value;

                text = $.wafutil.getValueByPath(data, displayItem);
                if($.type.isObject(text) && $.isEnumValue(text)) {
                    return text.alias || "";
                }
                if(waf.type.isBoolean(text)) {
                    return text ? $.wafPromptQuick.bool.yes : $.wafPromptQuick.bool.no;
                }
                return text;
            },
            _getPager: function(content) {
                var self = this,
                    totalCount = content.totalCount,
                    totalPage = content.totalPage,
                    $pager = $("<div class='ui-f7quick-pager'>"),
                    items = self.options.numberOfContent[0] * self.options.numberOfContent[1],
                    initRecord = 0,
                    lastRecord = 0;

                if(totalCount != 0) {
                    initRecord = (self.currentPage - 1) * items + 1;
                    if(self.currentPage < totalPage) {
                        lastRecord = (self.currentPage * items);
                    } else {
                        lastRecord = totalCount;
                    }
                }

                $("<table border='0' class='ui-f7quick-navTable'>"
                    +"<tbody>"
                        +"<td align='right'>"
                            +"<table border='0' class='ui-f7quick-pg-table' style='table-layout: auto;'>"
                            +"<tbody>"
                                +"<tr>"
                                    +"<td dir='ltr' class='ui-f7quick-navInfo'>"
                                    +self._renderPagerPage(self.currentPage, totalPage)
                                    +"</td>"
                                    +"<td class='ui-f7quick-pg-button ui-corner-all ui-state-disabled ui-f7quick-keynav-first'>"
                                        +"<span class='ui-icon ui-icon-seek-first'></span>"
                                    +"</td>"
                                    +"<td class='ui-f7quick-pg-button ui-corner-all ui-state-disabled ui-f7quick-keynav-prev'>"
                                        +"<span class='ui-icon ui-icon-seek-prev'></span>"
                                    +"</td>"
                                    +"<td class='ui-f7quick-pg-button ui-corner-all ui-f7quick-keynav-next'>"
                                        +"<span class='ui-icon ui-icon-seek-next'></span>"
                                    +"</td>"
                                    +"<td class='ui-f7quick-pg-button ui-corner-all ui-f7quick-keynav-last'>"
                                        +"<span class='ui-icon ui-icon-seek-end'></span>"
                                    +"</td>"
                                    +"<td class='ui-paging-info' style='text-align: right;' dir='ltr'>"
                                        + self._renderPagerView(initRecord, lastRecord, totalCount)
                                    +"</td>"
                                +"</tr>"
                            +"</tbody>"
                            +"</table>"
                        +"</td>"
                    +"</tr>"
                +"</tbody>"
                +"</table>").appendTo($pager);

                if(self.currentPage > 1) {
                    $('.ui-f7quick-keynav-first', $pager).removeClass("ui-state-disabled");
                    $('.ui-f7quick-keynav-prev', $pager).removeClass("ui-state-disabled");
                } else {
                    $('.ui-f7quick-keynav-first', $pager).addClass("ui-state-disabled");
                    $('.ui-f7quick-keynav-prev', $pager).addClass("ui-state-disabled");
                };
                if(self.currentPage == totalPage) {
                    $('.ui-f7quick-keynav-next', $pager).addClass("ui-state-disabled");
                    $('.ui-f7quick-keynav-last', $pager).addClass("ui-state-disabled");
                };

                $('.ui-f7quick-keynav-next', $pager).bind('click.wafPromptQuick', function() {
                    if(self.currentPage < totalPage) {
                        self.currentPage++;
                        self._search();
                    }
                });
                $('.ui-f7quick-keynav-prev', $pager).bind('click.wafPromptQuick', function() {
                    if(self.currentPage > 1) {
                        self.currentPage--;
                        self._search();
                    }
                });
                $('.ui-f7quick-keynav-last', $pager).bind('click.wafPromptQuick', function() {
                    if(totalPage > 1 && self.currentPage < totalPage) {
                        self.currentPage = totalPage;
                        self._search();
                    }
                });
                $('.ui-f7quick-keynav-first', $pager).bind('click.wafPromptQuick', function() {
                    if(totalPage > 1 && self.currentPage > 1) {
                        self.currentPage = 1;
                        self._search();
                    }
                });

                $('.ui-f7quick-pg-button', $pager).hover(function() {
                    if(!$(this).hasClass("ui-state-disabled")) {
                        $(this).addClass('ui-state-hover');
                    }
                }, function() {
                    if(!$(this).hasClass("ui-state-disabled")) {
                        $(this).removeClass('ui-state-hover');
                    }
                });

                $('.currentPage', $pager).keypress(function(e) {
                    var key = e.charCode ? e.charCode : e.keyCode ? e.keyCode : 0;
                    if(key == 13) {
                        if(!isNaN($(this).val()) && $(this).val() != 0) {
                            if($(this).val() > totalPage) {
                                self.currentPage = totalPage;
                            } else {
                                self.currentPage = $(this).val();
                            }
                            self._search();
                        }
                    }
                });

                return $pager;
            },
            _renderPagerPage: function(page, totalPage) {
                return this._format($.wafPromptQuick.defaults.pgtext, '<input type="text" size="1" class="currentPage" value="' + page + '"/>', totalPage);
            },
            _renderPagerView: function(initRecord, lastRecord, totalCount) {
                return this._format($.wafPromptQuick.defaults.recordtext, initRecord, lastRecord, totalCount);
            },
            _getButtonPnl: function(data) {
                var self = this,
                    $buttonPnl = $("<div class='ui-f7quick-buttonPanel'>");

                $('<button class="btn btn-b ui-f7quick-submit">' + $.wafPromptQuick.button.submit + '</button>').appendTo($buttonPnl).click(function(event) {
                    self.element.wafPromptBox("setValue", self.model);
                    //closepanelremovepanelclickbodydelayClosetrueclickpanelclickpanelclick
                    self._delayClose();
                });
                $('<button class="btn btn-b ui-f7quick-cancel">' + $.wafPromptQuick.button.cancel + '</button>').appendTo($buttonPnl).click(function(event) {
                    self._delayClose();
                });

                return $buttonPnl;
            },
            _format: function(format) {
                var args = $.makeArray(arguments).slice(1);
                if(format === undefined) {
                    format = "";
                }
                return format.replace(/\{(\d+)\}/g, function(m, i) {
                    return args[i];
                });
            },
            _hasScroll: function() {
                return this.panel.height() < this.panel[$.fn.prop ? "prop" : "attr"]("scrollHeight");
            },
            _addData: function(data) {
                this.model.push(data)
            },
            _removeData: function(data) {
                var index = this._getIndexOf(data, this.model);
                if(index != null) {
                    this.model.splice(index, 1);
                }
            },
            _getIndexOf: function(data, model) {
                var self = this,
                    index = null,
                    identification = self.element.wafPromptBox("option", "identification");

                $.each(model, function(idx, val) {
                    if(data[identification] == val[identification]) {
                        index = idx;
                    }
                });
                return index;
            },
            _addPlaceholder: function(input, ph) {
                if(this._isSupportPlaceHolder()) {
                    input.attr("placeholder", ph);
                } else {
                    if(input.val() === "") {
                        input.val(ph);
                        input.addClass("placeholder");
                    }

                    input.focus(function() {
                        if(input.hasClass("placeholder")) {
                            input.removeClass("placeholder");
                            input.val('');
                        }
                    });
                    input.blur(function() {
                        if(input.val() === "") {
                            input.val(ph);
                            input.addClass("placeholder");
                        }
                    });
                }
            },
            _isSupportPlaceHolder: function() {
                return !!('placeholder' in document.createElement('input'));
            },
            hasOpen: function() {
                return this.panel !== null;
            },
            _query: function(request, data) {
                var autoCompleteItem = this.options.autoCompleteItem,
                    autoCompleteTerm = request.autoCompleteTerm,
                    searchTerm = request.searchTerm,
                    sidx = this.options.sidx,
                    sord = this.options.sord

                    return $.f7QueryUtil.selectByAutoCompleteAndSearchCondition(data, autoCompleteItem, autoCompleteTerm,autoCompleteItem, searchTerm, sidx, sord)
            },
            //
            _transform: function(data) {
                var numberOfContent = this.options.numberOfContent,
                    rows = numberOfContent[0] * numberOfContent[1],
                    totalCount = data.length,
                    totalPage = Math.ceil(totalCount / rows),
                    currentPage = Math.min(Math.max(this.currentPage, 1), totalPage),
                    start = (currentPage - 1) * rows,
                    end = currentPage * rows;

                data = data.slice(start, end);

                return {
                    'data': data,
                    'currentPage': currentPage,
                    'totalCount': totalCount,
                    'totalPage': totalPage
                };
            }
        });

        $.wafPromptQuick = $.wafPromptQuick || {};
        $.extend($.wafPromptQuick, {
            createPromptQuickDOM: function(opts) {
                return null;
            },
            initPromptQuick: function(opts, el) {
                if(!$.wafutil.isViewOperateState(opts)) {
                    $.dynamicutil.addContextPath(opts, "dataUrl", "/component/F7Quick.do?method=initalize");
                    $("#" + opts.parentId).wafPromptQuick(opts);
                }
            },
            removePromptQuick: function(opts) {
                if(!$.wafutil.isViewOperateState(opts)) {
                    $("#" + opts.parentId).wafPromptQuick("destroy");
                }
            },
            modifyPromptQuick: function(opts) {
                if(!$.wafutil.isViewOperateState(opts)) {
                    $.dynamicutil.addContextPath(opts, "dataUrl", "/component/F7Quick.do?method=initalize");
                    $("#" + opts.parentId).wafPromptQuick('option', opts);
                }
            }
        });
        $(function() {
            if($.registerComponent)
                $.registerComponent("promptQuick", {
                    createDOMFun: $.wafPromptQuick.createPromptQuickDOM,
                    initFun: $.wafPromptQuick.initPromptQuick,
                    deleteFun: $.wafPromptQuick.removePromptQuick,
                    modifyFun: $.wafPromptQuick.modifyPromptQuick,
                    lazyInit:true
                });
        });


    }(jQuery));
//});
    /*******************************************************************************
     * jQuery UI PromptIframe
     *
     * @version 1.0
     * @author peng_zhou1
     * @Depends:
     *         jquery.ui.core.js
     *         jquery.ui.widget.js
     ******************************************************************************/
//mod.defineModule("promptIframe",["base","waf","promptBox","promptUtil","position","window"],function(){
    (function($, undefined) {

        var defaultClass = "ui-f7iframe",
            panelClass = "ui-f7iframe-panel ui-widget ui-widget-content ui-corner-all",
            iframeClass = "ui-f7iframe-iframe",
            FLOAT_TYPE = "float",
            WINDOW_TYPE = "window";

        $.widget("ui.wafPromptIframe", {
            options : {
                url : null,
                data : null,
                width : 400,
                height : 300,
                showType : WINDOW_TYPE,
                position : {
                    my : "left top",
                    at : "left bottom"
                },
                modal : true,
                draggable : true,
                resizable : true,
                closeOnEscape : true,
                title : "",
                beforeOpen: null,
                allowAutoComplete: false,
                minlength: 1,
                delay: 300
            },
            term: "",
            _create:function(){
                var self = this;

                if(this.element.hasClass(defaultClass))return;

                this.element.wafPromptBox('option', 'subWidgetName', 'wafPromptIframe');

                this.element.addClass(defaultClass);

                this.element.bind( "keydown.wafPromptIframe", function( event ) {
                    var keyCode = $.ui.keyCode,
                        isDisabled = self.element.wafPromptBox("option", "disabled"),
                        isReadonly = self.element.wafPromptBox("option", "readonly"),
                        isFloat = (FLOAT_TYPE == self.options.showType);

                    if (isDisabled || isReadonly || !isFloat) {
                        return;
                    }

                    if(event.keyCode == keyCode.ESCAPE && self.options.closeOnEscape){
                        self.close();
                    }
                });

                //
                this._handleAutocomplete = function(e) {
                    if(!self.options.allowAutoComplete) {
                        return;
                    }
                    var val = self.element.val();
                    if(val.length < self.options.minlength) {
                        self._close();
                        return;
                    }
                    clearTimeout(self.searching);
                    self.searching = setTimeout(function() {
                        if(self.term != val) {
                            self.term = val;
                            self.open(true);
                        }
                    }, self.options.delay);
                };

                if(FLOAT_TYPE == this.options.showType){//
                    if($.browser.msie) {
                        this.element.bind("keyup.wafPromptIframe", this._handleAutocomplete);
                    } else {
                        this.element.bind("input.wafPromptIframe", this._handleAutocomplete);
                    }
                }
            },

            destroy:function(){
                this.element.removeClass(defaultClass);
                this._close();
                $.Widget.prototype.destroy.call( this );
            },

            widget:function(){
                return this.element;
            },

            hasOpen: function() {
                return typeof this.panel !== "undefined" && this.panel !== null;
            },
            postDataToIFrame: function(iframeName, url, frame){

                //optData.autoCompleteTerm = this.term;

                $("<form method='POST' target='" + iframeName + "' action='" + url + "'></form>")
                    .insertAfter(frame)
                    .append($("<input type='hidden' name='params' value='" + this._encode($.toJSON(this.options.data)) + "'>"))
                    .append($("<input type='hidden' name='autoCompleteTerm' value='" + this.term + "'>"))
                    .bind("submit.wafPromptIframe", function (e) {
                        e.stopPropagation();
                    })
                    .submit()
                    .remove();
            },
            open: function(input){
                input = !!input;
                if(this.hasOpen()){
                    if(FLOAT_TYPE != this.options.showType){
                        return;
                    }
                    if(!this.options.allowAutoComplete){
                        return;
                    }
                }
                this.uuid = this.uuid || new Date().getTime();

                var self = this,
                    doc = this.element[ 0 ].ownerDocument,
                    iframeName = 'f7iframe-' + this.uuid,
                    iframe = $('<iframe marginheight="0" marginwidth="0" frameborder="0"  name="' + iframeName + '" class="' + iframeClass + '"></iframe>'),
                    url = this.options.url ? this.options.url + (this.options.url.indexOf("?") >= 0 ? "&" : "?") + PromptIframeMgr.targetFlg + '=' + this.uuid : "",
                    f7value = this.element.wafPromptBox("getValue"),
                    frame = this.element.wafPromptBox("getFrame");

                if(this.hasOpen() && (FLOAT_TYPE == this.options.showType) && this.options.allowAutoComplete) {
                    this.postDataToIFrame(iframeName, url, frame);
                    return;
                }

                if(!this.hasOpen()) {
                    this._trigger('beforeOpen', 'beforeOpen', this.options);
                }

                this.element.wafPromptBox("setSuppressRefresh", true);
                PromptIframeMgr.register(this.uuid, this.element);

                if(FLOAT_TYPE == this.options.showType){
                    this.panel = $('<div class="' + panelClass + '"></div>')
                        .css('top', 0)
                        .css('left', 0)
                        .appendTo($(".page_margins .page")[0] || "body")
                        .append(iframe)
                        .width(this.options.width)
                        .height(this.options.height)
                        .zIndex(this.element.zIndex() + 100)
                        .show()
                        .position($.extend({of: frame}, this.options.position));
                }else if(WINDOW_TYPE == this.options.showType){
                    this.panel = PromptIframeMgr.createPanel();
                    this.panel.addClass(panelClass)
                        .append(iframe)
                        .hide();
                    PromptIframeMgr.createWin({
                        target : this.panel,
                        openType : "div",
                        modal : this.options.modal,
                        width : this.options.width,
                        height : this.options.height,
                        draggable : this.options.draggable,
                        resizable : this.options.resizable,
                        closeOnEscape : this.options.closeOnEscape,
                        title : this.options.title,
                        close : function(event, ui){
                            if(PromptIframeMgr.canClose(self.uuid)){
                                self._close();
                                return true;
                            }
                            return false;
                        }
                    });
                    PromptIframeMgr.showWin(this.panel);
                }

                if(FLOAT_TYPE == this.options.showType){
                    this.panel.bind("click.wafPromptIframe", function( event ) {return false;});
                    $(document).bind("mousedown.wafPromptIframe", function(event){
                        var $target = $(event.target);
                        if($target.closest(self.panel).length == 0 && $target.closest(frame).length == 0){
                            self.close();
                        }
                    });
                }

                this.postDataToIFrame(iframeName, url, frame);
            },

            _encode: function(str) {
                if(str){
                    return $.wafutil.htmlEncode(str);
                }
                return "";
            },

            close: function(){
                if(!this.panel){
                    return;
                }
                if(PromptIframeMgr.canClose(this.uuid)){
                    if(FLOAT_TYPE == this.options.showType){
                        this._close();
                    }else if(WINDOW_TYPE == this.options.showType){
                        this.panel.dialog("close");
                    }
                }
            },

            _close: function(){
                if(this.panel){
                    if(FLOAT_TYPE == this.options.showType){
                        $(document).unbind("mousedown.wafPromptIframe");
                        this.panel.find('iframe').remove();
                        this.panel.remove();
                    }else if(WINDOW_TYPE == this.options.showType){
                        PromptIframeMgr.removePanel(this.panel);
                    }
                    this.panel = null;
                }
                if(this.uuid){
                    PromptIframeMgr.unRegister(this.uuid);
                    this.uuid = null;
                }
            },

            _setOption: function( key, value ) {
                $.Widget.prototype._setOption.apply( this, arguments );
            }
        });

        $.wafPromptIframe = $.wafPromptIframe || {};
        $.extend($.wafPromptIframe, {
            createPromptIframeDOM: function(opts){
                return null;
            },
            initPromptIframe: function(opts, el){
                if(!$.wafutil.isViewOperateState(opts)){
                    $.dynamicutil.addContextPath(opts, "url");
                    $("#" + opts.parentId).wafPromptIframe(opts);
                }
            },
            removePromptIframe: function(opts){
                if(!$.wafutil.isViewOperateState(opts)){
                    $("#" + opts.parentId).wafPromptIframe("destroy");
                }
            },
            modifyPromptIframe: function(opts){
                if(!$.wafutil.isViewOperateState(opts)){
                    $.dynamicutil.addContextPath(opts, "url");
                    $("#" + opts.parentId).wafPromptIframe('option', opts);
                }
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("promptIframe",{createDOMFun: $.wafPromptIframe.createPromptIframeDOM,
                                                   initFun: $.wafPromptIframe.initPromptIframe,
                                                   deleteFun: $.wafPromptIframe.removePromptIframe,
                                                   modifyFun: $.wafPromptIframe.modifyPromptIframe,
                                                   lazyInit:true});
        });
    }(jQuery));
//});
//mod.defineModule("promptTree",["base","waf","promptBox","promptUtil","block","tree","position","promptTree_i18n"],function(){
    (function($, undefined) {

        var requestIndex = 0,
            defaultClass = "ui-promptTree",
            panelClass = "ui-promptTree-panel ui-widget ui-widget-content ui-corner-all",
            dataFlg = "data.wafPromptTree",
            defaultFont = {
                color: "#333",
                "font-weight": "normal"
            },
            highLightFont = {
                color: "#A60000",
                "font-weight": "bold"
            };

        $.widget("ui.wafPromptTree", {
            options: {
                accessType: "remote",
                allowAutoComplete: false,
                autoChoose: true,
                autoCompleteItem: "name",
                beforeTreeInit: null,
                beforeOpen: null,
                cu: true,
                data: null,
                dataUrl: null,
                delay: 300,
                filteritem: null,
                height: null,
                isMulti: false,
                onshow: null,
                serializePromptData: null,
                leafOnly: true,
                minlength: 1,
                parentKey: "parent",
                position: {
                    my: "left top",
                    at: "left bottom"
                },
                query: null,
                search: function(tree, searchItem) {
                    this._updateNodes(false);
                    if(searchItem) {
                        this.highlightList = tree.wafTree('getNodesByParamFuzzy', 'name', searchItem);
                        this._updateNodes(true);
                    }
                },
                sidx: null,
                sord: null,
                style: null,
                tagClass: null,
                treeSettings: null,
                width: null
            },
            panel: null,
            toolbar: null,
            tree: null,
            model: null,
            highlightList: [],
            delayClose: false,
            blockKeyForAutoComplete:false,
            _create: function() {
                var self = this,
                    suppressKeyPress;

                if(this.element.hasClass(defaultClass)) return;

                this.element.wafPromptBox('option', 'subWidgetName', 'wafPromptTree');

                this.element.addClass(defaultClass);

                this._initByOptions("style", "tagClass", "width", "height");

                this.element.bind("keydown.wafPromptTree", function(event) {
                    var keyCode = $.ui.keyCode,
                        disabled = self.element.wafPromptBox("option", "disabled"),
                        readonly = self.element.wafPromptBox("option", "readonly");

                    if(disabled || readonly) {
                        return;
                    }
                    suppressKeyPress = false;

                    switch(event.keyCode) {
                        case keyCode.LEFT:
                            if(self.panel) {
                                self._move("left", event);
                                event.preventDefault();
                            }
                            break;
                        case keyCode.UP:
                            if(self.panel) {
                                self._move("up", event);
                                event.preventDefault();
                            }
                            break;
                        case keyCode.RIGHT:
                            if(self.panel) {
                                self._move("right", event);
                                event.preventDefault();
                            }
                            break;
                        case keyCode.DOWN:
                            if(self.panel) {
                                self._move("down", event);
                                event.preventDefault();
                            }
                            break;
                        case keyCode.SPACE:
                            if(self.panel && self.options.isMulti){
                                var node = self.tree.wafTree('getSelectedNodes')[0];
                                if(node){
                                    self.tree.wafTree('checkNode', node);
                                }
                                event.preventDefault();
                            }
                            break;
                        case keyCode.ENTER:
                        case keyCode.NUMPAD_ENTER:
                            if(self.panel){
                                if(self.options.isMulti){
                                    self._setMultiValue();
                                }else{
                                    // when menu is open and has focus
                                    var node = self.tree.wafTree('getSelectedNodes')[0];
                                    if (node) {
                                        suppressKeyPress = self._select(node);
                                        if(!suppressKeyPress){
                                            event.preventDefault();
                                            event.stopPropagation();
                                            break;
                                        }
                                    }
                                }
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        case keyCode.ESCAPE:
                        case keyCode.TAB:
                            if(self.panel) {
                                self._close();
                            }
                            break;
                        default:
                            break;
                    }

                    //autoCompleteautoComplete
                    if(self.options.allowAutoComplete && $.inArray(e.keyCode,$.keyutil.getKeyCodeArr())>-1){
                        self.blockKeyForAutoComplete = true;
                    }else{
                        self.blockKeyForAutoComplete = false;
                    }
                }).bind("keypress.wafPromptTree", function(event) {
                    if(suppressKeyPress) {
                        suppressKeyPress = false;
                        event.preventDefault();
                    }
                });

                this._handleAutocomplete = function _handleAutocomplete(e) {
                    if(!self.options.allowAutoComplete) {
                        return;
                    }
                    if(self.blockKeyForAutoComplete){
                        return;
                    }
                    var term = self.element.val();
                    if(term.length < self.options.minlength) {
                        self._close();
                        return;
                    }
                    //
                    var multiple = self.options.isMulti;
                    if(!!multiple){
                        term = term.substring(term.lastIndexOf(",")+1);
                    }
                    clearTimeout(self.searching);
                    self.searching = setTimeout(function() {
                        if(self.autoCompleteTerm != term) {
                            self.autoCompleteTerm = term;
                            self.open({
                                "autoCompleteItem": self.options.autoCompleteItem,
                                "autoCompleteTerm": term
                            });
                        }
                    }, self.options.delay);
                };

                if($.browser.msie) {
                    this.element.bind("keyup.wafPromptTree", this._handleAutocomplete);
                } else {
                    this.element.bind("input.wafPromptTree", this._handleAutocomplete);
                }
            },

            destroy: function() {
                this.element.removeClass(defaultClass);
                this._close();
                $.Widget.prototype.destroy.call(this);
            },

            widget: function() {
                return this.element;
            },

            open: function(searchParam) {
                if(!this.hasOpen()) {
                    this._trigger('beforeOpen', 'beforeOpen', this.options);
                }
                this._search(searchParam);
            },

            _setOption: function(key, value) {
                if(this.panel) {
                    if(key === "tagClass") {
                        this.panel.removeClass(this.options.tagClass).addClass(value);
                    } else if(key === "style") {
                        this.panel.attr(key, value);
                    } else if(key === "width" || key === "height") {
                        this.panel.css(key, value ? value : '');
                        if(key === "height") {
                            this._refreshHeight();
                        }
                    }
                }
                $.Widget.prototype._setOption.apply(this, arguments);
            },

            _delayClose: function() {
                this.delayClose = true;
            },

            _close: function() {
                this.element.wafPromptBox("setSuppressRefresh", false);
                this._block(false);
                this.delayClose = false;
                if(this.panel) {
                    $(document).unbind("mousedown.wafPromptTree");
                    this.panel.remove();
                    this.panel = null;
                    this.toolbar = null;
                    this.tree = null;
                    this.model = null;
                    this.searchParam = null;
                }
            },

            _suggest: function(isSearch) {
                this.element.wafPromptBox("setSuppressRefresh", true);

                var self = this,
                    frame = this.element.wafPromptBox("getFrame");
                this.model = this.element.wafPromptBox("getValue");
                if(!this.panel) {
                    this.panel = $('<div class="' + panelClass + '"></div>')
                                    .attr('style', this.options.style)
                                    .addClass(this.options.tagClass)
                                    .height(this.options.height)
                                    .width(this.options.width)
                                    .css('top', 0)
                                    .css('left', 0)
                                    .appendTo("body");
                    this.panel.bind("click.wafPromptTree", function(e) {
                        if(self.delayClose) {
                            self._close();
                        }
                        e.stopPropagation();
                    });
                    $(document).bind("mousedown.wafPromptTree", function(event) {
                        var $target = $(event.target);
                        if($target.closest(self.panel).length == 0 && $target.closest(frame).length == 0) {
                            self._close();
                        }
                    });
                }

                this._renderUI();

                this.panel.zIndex(this.element.zIndex() + 100)
                          .show()
                          .position($.extend({of: frame}, this.options.position));
                this._trigger('onshow', 'onshow', this.panel);

                this._initTree(isSearch);
            },

            _renderUI: function() {
                this._initMultiModel();
                this._createToolbar();
                this._createTree();
                this._createButtonPnl();
                this._refreshHeight();
            },

            _initMultiModel: function() {
                var f7value = this.element.wafPromptBox("getValue");
                if(this.options.isMulti && this.model == null) {
                    if($.isArray(f7value)) {
                        this.model = f7value.slice();
                    } else {
                        this.model = f7value ? [f7value] : [];
                    }
                }
            },

            _createToolbar: function() {
                if(this.panel.find(".ui-promptTree-toolbar").length) {
                    return;
                }
                var self = this,
                    toolbar = $('<div class="ui-promptTree-toolbar ui-widget-header"></div>').appendTo(this.panel),
                    searchInput = $('<input type="text" class="ui-promptTree-toolbar-input">')
                        .appendTo(toolbar)
                        .bind("keydown.wafPromptTree", function(e) {
                            var keyCode = $.ui.keyCode;
                            switch(e.keyCode) {
                                case keyCode.ENTER:
                                case keyCode.NUMPAD_ENTER:
                                    self._search({
                                        "searchItem": "name",
                                        "searchTerm": searchInput.val()
                                    });
                                    e.preventDefault();
                                    break;
                            }
                        });
                    button = $('<button class="btn ui-promptTree-toolbar-button">' + $.wafPromptTree.button.search + '</button>')
                        .appendTo(toolbar)
                        .bind("click", function(e){
                            self._search({
                                "searchItem": "name",
                                "searchTerm": searchInput.val()
                            });
                            e.preventDefault();
                        });

                this.toolbar = toolbar;
            },

            _createTree: function() {
                var id = this.element.wafPromptBox('option', 'id') + '_tree',
                    htmlStr = '<ul id="' + id + '" class="ui-promptTree-tree ztree"></ul>';

                if(this.panel.find(".ui-promptTree-tree").length) {
                    this.tree.replaceWith(htmlStr);
                    this.tree = this.panel.find("#" + id);
                } else {
                    this.tree = $(htmlStr).appendTo(this.panel);
                }
            },

            _initTree: function(isSearch) {
                var leafOnly = this.options.leafOnly,
                    settings = $.extend({
                        otherParam: {
                            "cu": this.options.cu,
                            "filteritem": this.options.filteritem || "",
                            "parentKey": this.options.parentKey || "",
                            "query": this.options.query || "",
                            "sidx": this.options.sidx || "",
                            "sord": this.options.sord || "",
                            "leafOnly": leafOnly,
                            "isSearch": isSearch
                        },
                        autoParam: ['id'],
                        fontCss: $.proxy(this._fontCss, this)
                    }, this.options.treeSettings || {}, {
                        onClick: $.proxy(this._onTreeClick, this),
                        beforeAsync: $.proxy(this._beforeAsync, this),
                        onAsyncSuccess: $.proxy(this._onAsyncSuccess, this),
                        onAsyncError: $.proxy(this._onAsyncError, this)
                    }),
                    options = {
                        setting: settings,
                        height: this.treeHeight
                    },
                    identification = this.element.wafPromptBox("option", "identification"),
                    isMulti = this.options.isMulti,
                    accessType = this.options.accessType,
                    self = this;

                if(isSearch && (options.setting.otherParam != null) && this.searchParam) {
                    $.extend(options.setting.otherParam, this.searchParam);
                }
                if(accessType == "remote") {
                    options.setting.url = this.options.dataUrl;
                } else {
                    options.data = this.options.data;
                    if(isMulti) {
                        var ids = $.map(self.model, function(v) {
                            return v[identification];
                        });
                        $.each(options.data, function(idx, value) {
                            value.checked = $.inArray(value[identification], ids) >= 0;
                        });
                    }
                }
                if(isMulti) {
                    options.setting.checkable = true;
                    this.tree.addClass('ui-promptTree-nopart');
                    if(!options.setting.chkboxType) {
                        options.setting.chkboxType = {
                            "Y": "",
                            "N": ""
                        };
                    }
                }

                var _dataFilter = options.setting.dataFilter;
                options.setting.dataFilter = function(treeId, pNode, cNodes) {
                    if(isMulti) {
                        var ids = $.map(self.model, function(v) {
                            return v[identification];
                        });
                        $.each(cNodes, function(idx, value) {
                            if(leafOnly) {
                                value.nocheck = value.isParent;
                            }
                            value.checked = $.inArray(value[identification], ids) >= 0;
                        });
                    }
                    if(_dataFilter) {
                        return _dataFilter.call(this, treeId, pNode, cNodes);
                    }
                    if(self.options.allowAutoComplete && self.options.autoChoose && isSearch && pNode == null){
                        var hitNodes = [];
                        self._findHitNodes(cNodes, hitNodes);
                        if(hitNodes.length == 1){
                            var val = self.element.wafPromptBox("getValue");
                            if(self.options.isMulti){
                                val = val || [];
                                val.push(hitNodes[0].data);
                            }else{
                                val = hitNodes[0].data;
                            }
                            this.element.wafPromptBox("setValue", val);
                            self._close();
                        }
                    }
                    return cNodes;
                };

                //
                if(self.options.serializePromptData&&$.isFunction(self.options.serializePromptData)){
                    var ret = self.options.serializePromptData.call(self,options.setting.otherParam);
                    if(ret&&$.type.isObject(ret)){
                        $.extend(options.setting.otherParam, ret);
                    }
                }

                this._trigger('beforeTreeInit', 'beforeTreeInit', {
                    'tree': this.tree,
                    'options': options
                });

                this.tree.wafTree(options);
            },

            _findHitNodes: function(nodes, hits){
                var self = this;
                $.each(nodes, function(idx, node){
                    if($.isArray(node.children) && node.children.length > 0){
                        self._findHitNodes(node.children, hits);
                    }
                    if(!!node.isHit){
                        hits.push(node);
                    }
                })
            },

            _createButtonPnl: function() {
                if(this.options.isMulti && !this.panel.find(".ui-promptTree-buttonPanel").length) {
                    var self = this,
                        buttonPnl = $("<div class='ui-promptTree-buttonPanel'>").appendTo(this.panel);

                    $('<button class="btn btn-b ui-promptTree-submit">' + $.wafPromptTree.button.submit + '</button>')
                        .appendTo(buttonPnl).click(function(event){
                            self._setMultiValue();
                            self._delayClose();
                    });
                    $('<button class="btn btn-b ui-promptTree-cancel">' + $.wafPromptTree.button.cancel + '</button>')
                        .appendTo(buttonPnl).click(function(event){
                        self._delayClose();
                    });

                    this.buttonPnl = buttonPnl;
                }
            },

            _setMultiValue: function(){
                var changeNodes = this.tree.wafTree('getChangeCheckedNodes'),
                    self = this;
                $.each(changeNodes, function(index, value) {
                    if(value.checked) {
                        self._addData(value.data);
                    } else {
                        self._removeData(value.data);
                    }
                });

                this.element.wafPromptBox('setValue', this.model);
            },

            _addData: function(data) {
                var index = this._getIndexOf(data, this.model);
                if(index == null) {
                    this.model.push(data)
                }
            },

            _removeData: function(data) {
                var index = this._getIndexOf(data, this.model);
                if(index != null) {
                    this.model.splice(index, 1);
                }
            },

            _getIndexOf: function(data, model) {
                var self = this,
                    index = null,
                    identification = self.element.wafPromptBox("option", "identification");

                $.each(model, function(idx, val) {
                    if(data[identification] == val[identification]) {
                        index = idx;
                    }
                });
                return index;
            },

            _refreshHeight: function() {
                this.treeHeight = this.panel.height() - this.toolbar.outerHeight();
                if(this.buttonPnl) {
                    this.treeHeight -= this.buttonPnl.outerHeight();
                }
            },

            _fontCss: function(treeId, treeNode) {
                return( !! treeNode.isHit) ? highLightFont : defaultFont;
            },

            _search: function(searchParam) {
                var isSearch = !! searchParam;
                if(isSearch) {
                    this.searchParam = $.extend({}, self.searchParam, searchParam);
                    var searchHandle = this.options.search;
                    if($.isFunction(searchHandle)) {
                        searchHandle.call(this, this.searchParam);
                    }
                }
                this._suggest(isSearch);
            },

            _updateNodes: function(highlight) {
                for(var i = 0, l = this.highlightList.length; i < l; i++) {
                    var node = this.highlightList[i];
                    node.highlight = highlight;
                    this.tree.wafTree("updateNode", node);
                }
            },

            _onTreeClick: function(event, treeId, treeNode, clickFlag) {
                if(this.options.treeSettings && this.options.treeSettings.onClick) {
                    this.options.treeSettings.onClick.call(this, event, treeId, treeNode, clickFlag);
                }
                if(!this.options.isMulti) {
                    this._select(treeNode);
                }
            },

            _select: function(node) {
                if((node.isParent && !this.options.leafOnly) || !node.isParent ) {
                    this.element.wafPromptBox("setValue", node.data);
                    this._delayClose();
                    //this._close();
                    return true;
                }
                return false;
            },

            _beforeAsync: function(treeId, treeNode){
                var retValue = true;
                if(this.options.treeSettings && this.options.treeSettings.beforeAsync) {
                    retValue = this.options.treeSettings.beforeAsync.call(this, treeId, treeNode);
                }
                if(retValue){
                    this._block(true);
                }
                return retValue;
            },

            _onAsyncSuccess: function(event, treeId, treeNode, msg){
                this._block(false);
                if(this.options.treeSettings && this.options.treeSettings.onAsyncSuccess) {
                    this.options.treeSettings.onAsyncSuccess.call(this, event, treeId, treeNode, msg);
                }
            },

            _onAsyncError: function(event, treeId, treeNode, XMLHttpRequest, textStatus, errorThrown){
                this._block(false);
                if(this.options.treeSettings && this.options.treeSettings.onAsyncError) {
                    this.options.treeSettings.onAsyncError.call(this, event, treeId, treeNode, XMLHttpRequest, textStatus, errorThrown);
                }
            },

            _block: function(isBlock){
                isBlock = !!isBlock;
                if(this.panel){
                    waf.block[isBlock ? 'show' : 'hide'](isBlock ? {target: this.panel} : this.panel);
                }
            },

            hasOpen: function() {
                return this.panel !== null;
            },

            _move: function(direction) {
                var nodes = this.tree.wafTree("getSelectedNodes"),
                    selectNode = nodes[0];;
                if(selectNode) {
                    var selectNode = nodes[0];
                    switch(direction) {
                    case "left":
                        if(selectNode.isParent && selectNode.open) {
                            //
                            this.tree.wafTree('expandNode', selectNode, false);
                        } else {
                            //
                            var pNode = selectNode.getParentNode();
                            if(pNode) this.tree.wafTree('selectNode', pNode);
                        }
                        break;
                    case "right":
                        if(selectNode.isParent) {
                            if(selectNode.children) {
                                if(selectNode.open) {
                                    //
                                    this.tree.wafTree('selectNode', selectNode.children[0]);
                                } else {
                                    //
                                    this.tree.wafTree('expandNode', selectNode, true);
                                }
                            } else {
                                //
                                this.tree.wafTree('reAsyncChildNodes', selectNode, 'refresh');
                            }
                        }
                        break;
                    case "up":
                        //windows explore
                        var node = selectNode.getPreNode();
                        if(node) {
                            //
                            this.tree.wafTree('selectNode', this._getLastNode(node));
                        } else {
                            //
                            var pNode = selectNode.getParentNode();
                            if(pNode) {
                                this.tree.wafTree('selectNode', pNode);
                            }
                        }
                        break;
                    case "down":
                        //
                        if(selectNode.isParent && selectNode.open && selectNode.children[0]) {
                            this.tree.wafTree('selectNode', selectNode.children[0]);
                        } else {
                            //
                            var node = selectNode.getNextNode();
                            if(node) {
                                this.tree.wafTree('selectNode', node);
                            } else {
                                //
                                var next = this._getFirstNextNode(selectNode);
                                if(next) {
                                    this.tree.wafTree('selectNode', next);
                                }
                            }
                        }
                        break;
                    }
                } else {
                    this.tree.wafTree('selectNode', this.tree.wafTree("getNodes")[0]);
                }
                this.element.focus();
            },

            _getFirstNextNode: function(node) {
                var pNode = node.getParentNode();
                if(pNode) {
                    var pNextNode = pNode.getNextNode();
                    if(pNextNode) {
                        return pNextNode;
                    } else {
                        return this._getFirstNextNode(pNode);
                    }
                }
                return null;
            },

            _getLastNode: function(node) {
                if(node.isParent && node.open) {
                    return this._getLastNode(node.children[node.children.length - 1]);
                }
                return node;
            }
        });

        $.wafPromptTree = $.wafPromptTree || {};
        $.extend($.wafPromptTree, {
            createPromptTreeDOM: function(opts) {
                return null;
            },
            initPromptTree: function(opts, el) {
                if(!$.wafutil.isViewOperateState(opts)) {
                    $.dynamicutil.addContextPath(opts, "dataUrl", "/component/promptTree.do?method=getTreeData");
                    $("#" + opts.parentId).wafPromptTree(opts);
                }
            },
            removePromptTree: function(opts) {
                if(!$.wafutil.isViewOperateState(opts)) {
                    $("#" + opts.parentId).wafPromptTree("destroy");
                }
            },
            modifyPromptTree: function(opts) {
                if(!$.wafutil.isViewOperateState(opts)) {
                    $.dynamicutil.addContextPath(opts, "dataUrl", "/component/promptTree.do?method=getTreeData");
                    $("#" + opts.parentId).wafPromptTree('option', opts);
                }
            }
        });
        $(function() {
            if ($.registerComponent)
                $.registerComponent("promptTree",{createDOMFun: $.wafPromptTree.createPromptTreeDOM,
                                                   initFun: $.wafPromptTree.initPromptTree,
                                                   deleteFun: $.wafPromptTree.removePromptTree,
                                                   modifyFun: $.wafPromptTree.modifyPromptTree});
        });
    }(jQuery));
//});
    /*******************************************************************************
     * jQuery UI PromptTable
     *
     * @version 1.0
     * @author peng_zhou1
     * @Depends:
     *         jquery.ui.core.js
     *         jquery.ui.widget.js
     ******************************************************************************/
//mod.defineModule("promptTable",["base","waf","grid","dataGrid","promptBox","block","position","promptUtil","promptTable_i18n"],function(){
    (function($, undefined) {

        var requestIndex = 0,
            defaultClass = "ui-promptTable",
            panelClass = "ui-promptTable-panel ui-widget ui-widget-content ui-corner-all",
            dataFlg = "data.promptTable";

        $.widget("ui.wafPromptTable", {
            options: {
                accessType: "remote",
                ajaxType: "POST",
                allowAutoComplete: false,
                alternate: true,
                autoChoose: true,
                autoCompleteItem: "name",
                beforeOpen: null,
                colModel: null,
                cu: true,
                data: null,
                url: null,
                delay: 300,
                filteritem: null,
                isMulti: false,
                height: null,
                minlength: 1,
                onshow: null,
                serializePromptData: null,
                position: {
                    my: "left top",
                    at: "left bottom"
                },
                query: null,
                rows: 10,
                rowsArray: null,
                shrinkToFit: false,
                sidx: null,
                sord: "asc",
                style: null,
                tagClass: null,
                width: null,
                defaultSearchItem: null,
                customizeSearchItems: [{
                    render: function() {
                        return "<option value='number+name'>" + $.wafPromptTable.defaults.numberOrName + "</option>";
                    },
                    localHandle: function(term, rec) {
                        rec = rec.contains('number', term).orContains('name', term);
                    },
                    remoteHandle: function(term, postData) {
                        postData.searchItem = "number+name";
                        postData.searchTerm = term;
                    }
                }]
            },
            source: null,
            panel: null,
            term: "",
            delayClose: false,
            active: 0,
            blockKeyForAutoComplete:false,
            _create: function() {
                var self = this,
                    suppressKeyPress;

                if(this.element.hasClass(defaultClass)) return;

                this.element.wafPromptBox('option', 'subWidgetName', 'wafPromptTable');

                this.element.addClass(defaultClass);

                this.options.rowsArray = this.options.rowsArray || [10, 20, 30];

                this.identification = this.element.wafPromptBox("option", "identification");

                this.element.bind("keydown.wafPromptTable", function(e) {
                    var keyCode = $.ui.keyCode,
                        disabled = self.element.wafPromptBox("option", "disabled"),
                        readonly = self.element.wafPromptBox("option", "readonly");

                    if(disabled || readonly) {
                        return;
                    }
                    suppressKeyPress = false;

                    switch(e.keyCode) {
                        case keyCode.PAGE_UP:
                            if(self.panel) {
                                self.table.loadPage("prev");
                                e.preventDefault();
                            }
                            break;
                        case keyCode.PAGE_DOWN:
                            if(self.panel) {
                                self.table.loadPage("next");
                                e.preventDefault();
                            }
                            break;
                        case keyCode.UP:
                            if(self.panel) {
                                var index = self.table.find('tr.jqgrow.ui-state-hover').index() - 1;
                                if(index <= 0) {
                                    index = self.table.dataGrid('getPageRowCount')
                                }
                                self.table.find('tr.jqgrow').removeClass('ui-state-hover');
                                self.table.find('tr.jqgrow').eq(--index).addClass('ui-state-hover');
                                e.preventDefault();
                            }
                            break;
                        case keyCode.DOWN:
                            if(self.panel) {
                                var index = self.table.find('tr.jqgrow.ui-state-hover').index();
                                if(index < 0 || index >= self.table.dataGrid('getPageRowCount')) {
                                    index = 0;
                                }
                                self.table.find('tr.jqgrow').removeClass('ui-state-hover');
                                self.table.find('tr.jqgrow').eq(index).addClass('ui-state-hover');
                                e.preventDefault();
                            }
                            break;
                        case keyCode.SPACE:
                            if(self.panel && self.options.isMulti) {
                                var index = self.table.find('tr.jqgrow.ui-state-hover').index();
                                    rowid = self.table.dataGrid('getRowId', index),
                                self.table.dataGrid('setSelection',  rowid, true);
                                e.preventDefault();
                            }
                            break;
                        case keyCode.ENTER:
                        case keyCode.NUMPAD_ENTER:
                            if(self.panel) {
                                if(self.options.isMulti) {
                                    self.element.wafPromptBox("setValue", self.model);
                                    self._close();
                                } else {
                                    var index = self.table.find('tr.jqgrow.ui-state-hover').index();
                                    if(index > 0){
                                        var rowid = self.table.dataGrid('getRowId', index),
                                            data = self.table.dataGrid('getRowRealData', rowid);

                                        self.element.wafPromptBox("setValue", data);
                                        self._close();
                                    }
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        case keyCode.ESCAPE:
                        case keyCode.TAB:
                            if(self.panel) {
                                self._close();
                            }
                            break;
                        default:
                            break;
                    }

                    //autoCompleteautoComplete
                    if(self.options.allowAutoComplete && $.inArray(e.keyCode,$.keyutil.getKeyCodeArr())>-1){
                        self.blockKeyForAutoComplete = true;
                    }else{
                        self.blockKeyForAutoComplete = false;
                    }
                }).bind("keypress.wafPromptTable", function(e) {
                    if(suppressKeyPress) {
                        suppressKeyPress = false;
                        e.preventDefault();
                    }
                });

                this._handleAutocomplete = function _handleAutocomplete(e) {
                    if(!self.options.allowAutoComplete) {
                        return;
                    }
                    if(self.blockKeyForAutoComplete){
                        return;
                    }
                    var val = self.element.val();
                    if(val.length < self.options.minlength) {
                        self._close();
                        return;
                    }
                    clearTimeout(self.searching);
                    self.searching = setTimeout(function() {
                        if(self.term != val) {
                            self._searchByTable(true);
                        }
                    }, self.options.delay);
                };

                if($.browser.msie) {
                    this.element.bind("keyup.wafPromptTable", this._handleAutocomplete);
                } else {
                    this.element.bind("input.wafPromptTable", this._handleAutocomplete);
                }
            },

            destroy: function() {
                this.element.removeClass(defaultClass);
                this._close();
                $.Widget.prototype.destroy.call(this);
            },

            _setOption: function(key, value) {
                if(this.panel) {
                    if(key === "tagClass") {
                        this.panel.removeClass(this.options.tagClass).addClass(value);
                    } else if(key === "style") {
                        this.panel.attr(key, value);
                    }
                }
                $.Widget.prototype._setOption.apply(this, arguments);
            },

            open: function() {
                if(!this.hasOpen()) {
                    this._trigger('beforeOpen', 'beforeOpen', this.options);
                }
                var self = this;
                if(this.options.accessType == "remote") {
                    if(self.xhr) {
                        self.xhr.abort();
                    }
                    self.element.addClass("ui-f7-loading");
                    var ajaxParam = {
                        url: self._getColModelUrl(),
                        async: true,
                        showBlock: false,
                        data: {
                            "query": self.options.query || ""
                        },
                        promptTableRequest: ++requestIndex,
                        success: function(colModel) {
                            if(this.promptTableRequest === requestIndex) {
                                self._renderTable(colModel);
                            }
                        },
                        complete: function(jqXHR, textStatus) {
                            self.element.removeClass("ui-f7-loading");
                        }
                    };
                    self.xhr = self.options.ajaxType === "POST" ? $.doPost(ajaxParam) : $.doGet(ajaxParam);
                } else {
                    this._renderTable(this.options.colModel);
                }
            },

            _setKey: function(model) {
                var self = this;
                $.each(model, function(i, v) {
                    if(v.name == self.identification) {
                        v.key = true;
                        return false;
                    }
                });
            },
            _renderTable: function(colModel) {
                var self = this,
                    frame = this.element.wafPromptBox("getFrame");

                this.element.wafPromptBox("setSuppressRefresh", true);
                this._setKey(colModel);
                this._initMultiModel();
                if(this.panel) {
                    this.panel.empty();
                } else {
                    this.panel = $('<div class="' + panelClass + '"></div>')
                        .attr('style', this.options.style)
                        .css({'top': 0, 'left': 0})
                        .addClass(this.options.tagClass)
                        .appendTo($(".page_margins .page")[0] || "body");
                    this.panel.bind("click.wafPromptTable", function(e) {
                        if(self.delayClose) {
                            self._close();
                        }
                        e.stopPropagation();
                    });
                    $(document).bind("mousedown.wafPromptTable", function(event) {
                        var $target = $(event.target);
                        if($target.closest(self.panel).length == 0 && $target.closest(frame).length == 0) {
                            self._close();
                        }
                    });
                }
                if(this.options.width != null) {
                    this.panel.width(this.options.width);
                }

                this._appendHeader(colModel);
                this._appendTable(colModel);
                this._appendButtonPnl(colModel);

                // autoChoose
                if(this.panel) {
                    this.panel.zIndex(this.element.zIndex() + 100).show().position($.extend({
                        of: frame
                    }, this.options.position));
                    this._trigger('onshow', 'onshow', this.panel);
                    this._searchByTable();
                    if(this.isSearch) {
                        this.subSearch.focus().select();
                        this.isSearch = null;
                    }
                }
            },
            _appendHeader: function(colModel) {
                var self = this,
                    $searcher = $("<div class='ui-promptTable-searcher ui-widget-header'></div>").appendTo(this.panel),
                    customizeSearchItems = this.options.customizeSearchItems,
                    defaultSearchItem = this.options.defaultSearchItem;

                // select
                this.searchColumn = $("<select class='ui-promptTable-searchColumn'></select>").appendTo($searcher);
                if($.isArray(customizeSearchItems)) {
                    $.each(customizeSearchItems, function(i, v) {
                        $(v.render())
                            .appendTo(self.searchColumn)
                            .data({
                                "localHandle": v.localHandle,
                                "remoteHandle": v.remoteHandle
                            });
                    });
                }
                for(var i = 0, length = colModel.length; i < length; i++) {
                    var col = colModel[i];
                    if(!col.hidden && col.filter) {
                        var selectOption = $("<option value='" + col.name + "'>" + col.label + "</option>").appendTo(this.searchColumn);
                        selectOption.data('col.wafPromptTable', col);
                    }
                }
                if(defaultSearchItem) {
                    this.searchColumn.find('[value="' + defaultSearchItem + '"]').attr("selected", true);
                }
                // 
                this.subSearch = $('<input type="text" class="ui-promptTable-searchInput">').appendTo($searcher).bind("keydown.wafPromptTable", function(event) {
                    var keyCode = $.ui.keyCode;
                    switch(event.keyCode) {
                    case keyCode.ENTER:
                    case keyCode.NUMPAD_ENTER:
                        self.isSearch = true;
                        self._searchByTable();
                        event.preventDefault();
                        break;
                    }
                });

                this._addPlaceholder(this.subSearch, $.wafPromptTable.defaults.searchInResultText);

                // 
                $('<button class="btn btn-b ui-promptTable-searchButton">' + $.wafPromptTable.button.search + '</button>').appendTo($searcher).bind("click.wafPromptTable", function(event) {
                    self.isSearch = true;
                    self._searchByTable();
                    event.preventDefault();
                });
            },

            _searchByTable: function(isAutoComplete) {
                isAutoComplete = !! isAutoComplete;
                if(isAutoComplete) {
                    if(this.element.val().length < this.options.minlength)
                        return;
                    if(this.subSearch)
                        this.subSearch.val(null);
                }

                this.searchParam = this._getSearchParam();

                if(this.table) {
                    if(this.options.accessType == "remote") {
                        var postData = this.table.dataGrid('option', 'postData');
                        postData = this._mergeCondition(postData);
                        this.table.dataGrid('option', 'postData', postData);
                        this.table.dataGrid('reloadGrid');
                    } else {
                        var data = this._getQueryData();
                        this.table.dataGrid('clearGridData');
                        this.table.dataGrid('setGridData', data, true);
                    }
                } else {
                    this.open();
                }
            },

            _getSearchParam: function() {
                var allowAutoComplete = this.options.allowAutoComplete,
                    searchParam = {};
                searchParam.autoCompleteItem = this.options.autoCompleteItem;
                //
                var multiple = this.options.isMulti;
                var val = this.element.val();
                if(!!multiple){
                    searchParam.autoCompleteTerm = allowAutoComplete ? val.substring(val.lastIndexOf(",")+1): null;
                }else{
                    searchParam.autoCompleteTerm = allowAutoComplete ? this.element.val() : null;
                }
                searchParam.searchItem = this.searchColumn ? this.searchColumn.val() : null;
                searchParam.searchTerm = this.subSearch ? this.subSearch.val() : null;
                searchParam.searchTerm = ($.wafPromptTable.defaults.searchInResultText == searchParam.searchTerm?null:searchParam.searchTerm);
                if(this.searchColumn && this.searchColumn.find(":selected").length) {
                    searchParam.searchLocalHandle = this.searchColumn.find(":selected").data("localHandle");
                    searchParam.searchRemoteHandle = this.searchColumn.find(":selected").data("remoteHandle");
                }
                return searchParam;
            },

            _query: function(searchParam, data) {
                var autoCompleteItem = searchParam.autoCompleteItem,
                    autoCompleteTerm = searchParam.autoCompleteTerm,
                    searchItem = searchParam.searchItem,
                    searchTerm = searchParam.searchTerm,
                    searchLocalHandle = searchParam.searchLocalHandle,
                    sidx = this.options.sidx,
                    sord = this.options.sord;


                return $.f7QueryUtil.selectByAutoCompleteAndSearchCondition(data, autoCompleteItem, autoCompleteTerm,autoCompleteItem, searchTerm, sidx, sord,searchLocalHandle);
            },

            _appendTable: function(colModel) {
                var height = this._getHeight(),
                    id = this.element.wafPromptBox('option', 'id'),
                    tableId = id + "_table",
                    pagerId = "pager" + tableId,
                    columnModelNames = $.map(colModel, function(elem, i) {
                        return elem.name;
                    }).join(","),
                    opts = {
                        _type_: "Grid",
                        colModel: colModel,
                        datatype: "json",
                        height: height || "auto",
                        id: tableId,
                        altRows: this.options.alternate,
                        mtype: this.options.ajaxType,
                        pager: '#' + pagerId,
                        pagerModel: "block",
                        pagerpos: "right",
                        queryPK: this.options.query,
                        rowList: this.options.rowsArray,
                        rowNum: this.options.rows,
                        url: this._getDataUrl(),
                        postData: {
                            'id': tableId,
                            'columnModel': columnModelNames,
                            'queryPK': this.options.query,
                            'cu': this.options.cu,
                            'filterItems':this.options.filteritem
                        },
                        shrinkToFit: this.options.shrinkToFit,
                        serializeGridData:this.options.serializePromptData?this.options.serializePromptData:null
                    },
                    self = this;

                this.table = $('<table id="' + tableId + '"></table>').appendTo(this.panel);
                this.pager = $('<div id="' + pagerId + '"></div>').appendTo(this.panel);

                opts.onSelectRow = function(rowid, status) {
                    var data = $(this).dataGrid('getRowRealData', rowid);
                    if(self.options.isMulti) {
                        if(status) {
                            self._addData(data);
                        } else {
                            self._removeData(data);
                        }
                    } else {
                        self.element.wafPromptBox("setValue", data);
                        self._delayClose();
                    }
                };
                opts.onPaging = function(pgButton) {
                    self.active = 0;
                }
                if(this.options.isMulti) {
                    var self = this;
                    opts.multiselect = true;
                    opts.loadComplete = function(data) {
                        var _table = this;
                        $.each(self.model, function(idx, ele) {
                            $(_table).dataGrid('setSelection', ele[self.identification], true);
                        });
                    };
                    opts.onSelectAll = function(rowids, status) {
                        var _table = this;
                        $.each(rowids, function(idx, ele) {
                            var data = $(_table).dataGrid('getRowRealData', ele);
                            if(status) {
                                self._addData(data);
                            } else {
                                self._removeData(data);
                            }
                        });
                    };
                }
                if(this.options.accessType == "remote") {
                    if(this.searchParam) {
                        opts.postData = this._mergeCondition(opts.postData);
                    }
                } else {
                    opts.datatype = "local";
                    opts.data = this._getQueryData();
                }
                if(this.options.sidx && this.options.sord) {
                    opts.sortname = this.options.sidx;
                    opts.sortorder = this.options.sord;
                }
                if(this.options.width == null) {
                    opts.autowidth = false;
                }
                opts.beforeProcessing = function(data, status, xhr) {
                    if(self.options.autoChoose && data.records === 1) {
                        waf.block.hide($(self.table).closest(".ui-jqgrid"));
                        var val = self.element.wafPromptBox("getValue");
                        if(self.options.isMulti){
                            val = val || [];
                            val.push(data.rows[0]);
                        }else{
                            val = data.rows[0];
                        }
                        self.element.wafPromptBox("setValue", val);
                        self._close();
                        return false;
                    }
                }
                this._trigger('beforeTableInit', 'beforeTableInit', opts);
                opts.loadInit=false;
                this.table.dataGrid(opts);
            },

            _mergeCondition: function(postData) {
                var searchTerm = this.searchParam.searchTerm || "",
                    searchRemoteHandle = this.searchParam.searchRemoteHandle;

                postData = postData || {};
                postData.autoCompleteItem = this.searchParam.autoCompleteItem || "";
                postData.autoCompleteTerm = this.searchParam.autoCompleteTerm || "";
                postData.filterItems = this.options.filteritem || "";
                if($.isFunction(searchRemoteHandle)) {
                    searchRemoteHandle.call(this, searchTerm, postData);
                }else{
                    postData.searchItem = this.searchParam.searchItem || "";
                    postData.searchTerm = this.searchParam.searchTerm || "";
                }
                return postData;
            },

            _getQueryData: function() {
                var data = this.options.data;
                if(this.searchParam) {
                    data = this._query(this.searchParam, data);
                }
                return data;
            },

            _getHeight: function() {
                if(this.options.height != null) {
                    return this.options.height - this.panel.find(".ui-promptTable-searcher").outerHeight();
                }
                return null;
            },

            _appendButtonPnl: function(data) {
                if(this.options.isMulti) {
                    var self = this,
                        $buttonPnl = $("<div class='ui-promptTable-buttonPanel'>").appendTo(this.panel);

                    $('<button class="btn btn-b ui-promptTable-submit">' + $.wafPromptTable.button.submit + '</button>').appendTo($buttonPnl).click(function(event) {
                        self.element.wafPromptBox("setValue", self.model);
                        self._delayClose();
                    });
                    $('<button class="btn btn-b ui-promptTable-cancel">' + $.wafPromptTable.button.cancel + '</button>').appendTo($buttonPnl).click(function(event) {
                        self._delayClose();
                    });
                }
            },

            _delayClose: function() {
                this.delayClose = true;
            },

            _close: function() {
                this.element.wafPromptBox("setSuppressRefresh", false);
                this.isSearch = null;
                this.searchParam = null;
                this.delayClose = false;
                this.active = 0;
                if(this.panel) {
                    $(document).unbind("mousedown.wafPromptTable");
                    this.subSearch = null;
                    this.panel.remove();
                    this.panel = null;
                    this.model = null;
                    this.table = null;
                }
                this.element.removeClass("ui-f7-loading");
            },

            _initMultiModel: function() {
                var f7value = this.element.wafPromptBox("getValue");
                if(this.options.isMulti && this.model == null) {
                    if($.isArray(f7value)) {
                        this.model = f7value.slice();
                    } else {
                        this.model = f7value ? [f7value] : [];
                    }
                }
            },

            widget: function() {
                return this.element;
            },
            _addData: function(data) {
                var index = this._getIndexOf(data, this.model);
                if(index == null) {
                    this.model.push(data)
                }
            },
            _removeData: function(data) {
                var index = this._getIndexOf(data, this.model);
                if(index != null) {
                    this.model.splice(index, 1);
                }
            },
            _getIndexOf: function(data, model) {
                var self = this,
                    index = null;

                $.each(model, function(idx, val) {
                    if(data[self.identification] == val[self.identification]) {
                        index = idx;
                    }
                });
                return index;
            },

            hasOpen: function() {
                return this.panel !== null;
            },
            _addPlaceholder: function(input, ph) {
                if(this._isSupportPlaceHolder()) {
                    input.attr("placeholder", ph);
                } else {
                    if(input.val() === "") {
                        input.val(ph);
                        input.addClass("placeholder");
                    }

                    input.focus(function() {
                        if(input.hasClass("placeholder")) {
                            input.removeClass("placeholder");
                            input.val('');
                        }
                    });
                    input.blur(function() {
                        if(input.val() === "") {
                            input.val(ph);
                            input.addClass("placeholder");
                        }
                    });
                }
            },
            _isSupportPlaceHolder: function() {
                return !!('placeholder' in document.createElement('input'));
            },

            _getColModelUrl: function() {
                return this.options.url + "?method=getColModel";
            },

            _getDataUrl: function() {
                return this.options.url + "?method=getGridData";
            }
        });

        $.wafPromptTable = $.wafPromptTable || {};
        $.extend($.wafPromptTable, {
            createPromptTableDOM: function(opts) {
                return null;
            },
            initPromptTable: function(opts, el) {
                if(!$.wafutil.isViewOperateState(opts)) {
                    $.dynamicutil.addContextPath(opts, "dataUrl", "/component/promptTable.do");
                    $("#" + opts.parentId).wafPromptTable(opts);
                }
            },
            removePromptTable: function(opts) {
                if(!$.wafutil.isViewOperateState(opts)) {
                    $("#" + opts.parentId).wafPromptTable("destroy");
                }
            },
            modifyPromptTable: function(opts) {
                if(!$.wafutil.isViewOperateState(opts)) {
                    $.dynamicutil.addContextPath(opts, "dataUrl", "/component/promptTable.do");
                    $("#" + opts.parentId).wafPromptTable('option', opts);
                }
            }
        });
        $(function() {
            if($.registerComponent)
                $.registerComponent("promptTable", {
                    createDOMFun: $.wafPromptTable.createPromptTableDOM,
                    initFun: $.wafPromptTable.initPromptTable,
                    deleteFun: $.wafPromptTable.removePromptTable,
                    modifyFun: $.wafPromptTable.modifyPromptTable,
                    lazyInit:true
                });
        });
    }(jQuery));
//});
/*
 * jquery.powerFloat.js
 * jQuery 
 * http://www.zhangxinxu.com/wordpress/?p=1328
 * by zhangxinxu  
 * 2010-12-06 v1.0.0	
 * 2010-12-30 v1.0.1	
 * 2011-01-03 v1.1.0	bug
 						
 * 2011-02-15 v1.1.1	
 * 2011-04-15 v1.2.0	selectIE			
 * 2011-09-13 v1.3.0 	hover
 */
 
(function($) {
	$.fn.powerFloat = function(options) {
		return $(this).each(function() {
			var s = $.extend({}, defaults, options || {});
			var init = function(pms, trigger) {
				if (o.target && o.target.css("display") !== "none") {
					o.targetHide();
				}		
				o.s = pms;
				o.trigger = trigger;				
			};
 
			switch (s.eventType) {
				case "hover": {
					$(this).hover(function() {
						init(s, $(this));
						var numShowDelay = parseInt(s.showDelay, 10), hoverTimer;	
						//hover
						if (numShowDelay) {
							if (hoverTimer) {
								clearTimeout(hoverTimer);
							}
							hoverTimer = setTimeout(function() {
								o.targetGet(options);
							}, numShowDelay);	
						} else {
							o.targetGet(options);	
						}
					}, function() {
						o.flagDisplay = false;
						o.targetHold(options);
						if (s.hoverHold) {
							setTimeout(function() {
								o.displayDetect();	
							}, 200);
						} else {
							o.displayDetect();
						}
					});
					if (s.hoverFollow) {
						//	
						$(this).mousemove(function(e) {
							o.cacheData.left = e.pageX;
							o.cacheData.top = e.pageY;
							o.targetGet(options);
							return false;
						});
					}
					break;	
				}
				case "click": {
					$(this).click(function(e) {
						if (o.flagDisplay && e.target === o.trigger.get(0)) {
							o.flagDisplay = false;	
							o.displayDetect();
						} else {
							init(s, $(this));		
							o.targetGet(options);
							
							if (!$(document).data("mouseupBind")) {
								$(document).bind("mouseup", function(e) {
									var flag = false;
									$(e.target).parents().each(function() {
										if (o.target && $(this).attr("id") == o.target.attr("id") ) {
											flag = true;
										}
									});		
									if (s.eventType === "click" && o.flagDisplay && e.target != o.trigger.get(0) && !flag) {
										o.flagDisplay = false;	
										o.displayDetect();
									}
									return false;
								}).data("mouseupBind", true);

                                $(document).bind("mousedown", function(event){
                                    o.flagDisplay = false;
                                    o.displayDetect();
                                });
							}
						}						
					});

					break;
				}
				case "focus": {
					$(this).focus(function() {
						var self = $(this);
						setTimeout(function() {
							init(s, self);
							o.targetGet(options);	
						}, 200);
					}).blur(function() {
						o.flagDisplay = false;
						setTimeout(function() {
							o.displayDetect();
						}, 190);
						
					});	
					break;
				}
				case "blur": {
					$(this).blur(function() {
						var self = $(this);
						setTimeout(function() {
							init(s, self);
							o.targetGet(options);	
						}, 200);
					}).focus(function() {
						o.flagDisplay = false;
						setTimeout(function() {
							o.displayDetect();
						}, 190);
						
					});	
					break;
				}
				default: {
					init(s, $(this));
					o.targetGet(options);
                    $(document).bind("mousedown", function(event){
                        o.flagDisplay = false;
                        o.displayDetect();
                    });
					//$(document).unbind("mouseup");
				}
			}
		});
	};
	
	var o = {
		targetGet: function(options) {
			//
			if (!this.trigger) { return this; }
			var attr = this.trigger.attr(this.s.targetAttr), target = this.s.target;
			if(target!=null && typeof target!='string'){
				if(!$.isFunction(target.parent) || target.parent().size()==0) { return this; }
				if(options && options.beforeTrigger && $.isFunction(options.beforeTrigger)){
					var opts = {};
					opts.powerFloat=this;
					opts=$.extend({},opts,options.beforeTriggerParam);
					if(options.beforeTrigger(opts)){
						return this;
					}
				}
			}
			switch (this.s.targetMode) {
				case "common": {
					if (target) {
						var type = typeof(target);
						if (type === "object") {
							if (target.size()) {
								o.target = target.eq(0);
							}
						} else if (type === "string") {
							if ($(target).size()) {
								o.target = $(target).eq(0);
							}	
						}
					} else {
						if (attr && $("#" + attr).size()) {
							o.target = $("#" + attr);
						}
					}
					if (o.target) {
						o.targetShow();
					} else {
						return this;	
					}
					
					break;
				}
				case "ajax": {
					//ajax
					var url = target || attr;
					this.targetProtect = false;
					
					if (/(\.jpg|\.png|\.gif|\.bmp|\.jpeg)$/i.test(url)) {
						if (o.cacheData[url]) {
							o.target = $(o.cacheData[url]);
							o.targetShow();
						} else {
							var tempImage = new Image();
							o.loading();
							tempImage.onload = function() {
								var w = tempImage.width, h = tempImage.height;
								var winw = $(window).width(), winh = $(window).height();
								var imgScale = w / h, winScale = winw / winh;
								if (imgScale > winScale) {
									//
									if (w > winw / 2) {
										w = winw / 2;
										h = w / imgScale;	
									}
								} else {
									//
									if (h > winh / 2) {
										h = winh / 2;
										w = h * imgScale;
									}
								}
								var imgHtml = '<img class="float_ajax_image" src="' + url + '" width="' + w + '" height = "' + h + '" />';
								o.cacheData[url] = imgHtml;
								o.target = $(imgHtml);
								o.targetShow();
							};
							tempImage.onerror = function() {
								o.target = $('<div class="float_ajax_error"></div>');
								o.targetShow();
							};
							tempImage.src = url;
						}
					} else {
						if (url) {
							if (o.cacheData[url]) {
								o.target = $('<div class="float_ajax_data">' + o.cacheData[url] + '</div>');
								o.targetShow();	
							} else {
								o.loading();
								$.ajax({
									url: url,
									success: function(data) {
										if (typeof(data) === "string") {
											o.target = $('<div class="float_ajax_data">' + data + '</div>');
											o.targetShow();
											o.cacheData[url] = data;
										}
									},
									error: function() {
										o.target = $('<div class="float_ajax_error"></div>');
										o.targetShow();
									}
								});
							}
						}
					}
					break;
				}
				case "list": {
					//
					var targetHtml = '<ul class="float_list_ul">',  arrLength;
					if ($.isArray(target) && (arrLength = target.length)) {
						$.each(target, function(i, obj) {
							var list = "", strClass = "", text, href;
							if (i === 0) {
								strClass = ' class="float_list_li_first"';
							}
							if (i === arrLength - 1) {
								strClass = ' class="float_list_li_last"';	
							}
							if (typeof(obj) === "object" && (text = obj.text.toString())) {
								if (href = (obj.href || "javascript:")) {
									list = '<a href="' + href + '" class="float_list_a">' + text + '</a>';	
								} else {
									list = text;	
								}
							} else if (typeof(obj) === "string" && obj) {
								list = obj;
							}
							if (list) {
								targetHtml += '<li' + strClass + '>' + list + '</li>';	
							}
						});
					} else {
						targetHtml += '<li class="float_list_null"></li>';	
					}
					targetHtml += '</ul>';
					o.target = $(targetHtml);
					this.targetProtect = false;	
					o.targetShow();	
					break;	
				}
				case "remind": {
					//
					var strRemind = target || attr;
					this.targetProtect = false;	
					if (typeof(strRemind) === "string") {
						o.target = $('<span>' + strRemind + '</span>');
						o.targetShow();	
					}
					break;
				}
				default: {
					var objOther = target || attr, type = typeof(objOther);
					if (objOther) {
						if (type === "string") {
							//
							if (/<.*>/.test(objOther)) {
								//
								o.target = $('<div>' + objOther + '</div>');
								this.targetProtect = false;
							} else if ($(objOther).size()) {
								o.target = $(objOther).eq(0);
								this.targetProtect = true;	
							} else if ($("#" + objOther).size()) {
								o.target = $("#" + objOther).eq(0);
								this.targetProtect = true;
							} else {
								o.target = $('<div>' + objOther + '</div>');
								this.targetProtect = false;		
							}
							o.targetShow();	
						} else if (type === "object") {
							if (!$.isArray(objOther) && objOther.size()) {
								o.target = objOther.eq(0);
								this.targetProtect = true;
								o.targetShow();	
							}
						}
					}
				}
			}
			return this;
		},
		container: function() {
			//()target
			var cont = this.s.container, mode = this.s.targetMode || "mode";
			if (mode === "ajax" || mode === "remind") {
				//
				this.s.sharpAngle = true;	
			} else {
				this.s.sharpAngle = false;
			}
			//
			if (this.s.reverseSharp) {
				this.s.sharpAngle = !this.s.sharpAngle;	
			}
			
			if (mode !== "common") {
				//common
				if (cont === null) {
					cont = "plugin";	
				} 
				if ( cont === "plugin" ) {
					if (!$("#floatBox_" + mode).size()) {
						$('<div id="floatBox_' + mode + '" class="float_' + mode + '_box"></div>').appendTo($("body")).hide();
					}
					cont = $("#floatBox_" + mode);	
				} 
				
				if (cont && typeof(cont) !== "string" && cont.size()) {
					if (this.targetProtect) {
						o.target.show().css("position", "static");
					}
					o.target = cont.empty().append(o.target);
				}
			}
			return this;
		},
		setWidth: function() {
			var w = this.s.width;
			if (w === "auto") {
				if (this.target.get(0).style.width) {
					this.target.css("width", "auto");	
				}
			} else if (w === "inherit") {
				this.target.width(this.trigger.width());
			} else {
				this.target.css("width", w);	
			}
			return this;
		},
		position: function() {
			var pos, tri_h = 0, tri_w = 0, cor_w = 0, cor_h = 0, tri_l, tri_t, tar_l, tar_t, cor_l, cor_t,
				tar_h = this.target.data("height"), tar_w = this.target.data("width"),
				st = $(window).scrollTop(),
				off_x = parseInt(this.s.offsets.x, 10) || 0, off_y = parseInt(this.s.offsets.y, 10) || 0,
				mousePos = this.cacheData;

			//
			if (!tar_h) {
				tar_h = this.target.outerHeight();
				if (this.s.hoverFollow) {
					this.target.data("height", tar_h);
				}
			}
			if (!tar_w) {
				tar_w = this.target.outerWidth();
				if (this.s.hoverFollow) {
					this.target.data("width", tar_w);
				}
			}
			
			pos = this.trigger.offset();
			tri_h = this.trigger.outerHeight();
			tri_w = this.trigger.outerWidth();
			tri_l = pos.left;
			tri_t = pos.top;
			
			var funMouseL = function() {
				if (tri_l < 0) {
					tri_l = 0;
				} else if (tri_l + tri_h > $(window).width()) {
					tri_l = $(window).width() = tri_h;	
				}
			}, funMouseT = function() {
				if (tri_t < 0) {
					tri_t = 0;
				} else if (tri_t + tri_h > $(document).height()) {
					tri_t = $(document).height() - tri_h;
				}
			};
			//
			if (this.s.hoverFollow && mousePos.left && mousePos.top) {
				if (this.s.hoverFollow === "x") {
					//
					tri_l = mousePos.left
					funMouseL();
				} else if (this.s.hoverFollow === "y") {
					//
					tri_t = mousePos.top;
					funMouseT();
				} else {
					tri_l = mousePos.left;
					tri_t = mousePos.top;
					funMouseL();
					funMouseT();
				}	
			}	
			
			
			var arrLegalPos = ["4-1", "1-4", "5-7", "2-3", "2-1", "6-8", "3-4", "4-3", "8-6", "1-2", "7-5", "3-2"],
				align = this.s.position, alignMatch = false, strDirect;
			$.each(arrLegalPos, function(i, n) {
				if (n === align) {
					alignMatch = true;	
					return;
				}
			});
			if (!alignMatch) {
				align = "4-1";
			}
			
			var funDirect = function(a) {
				var dir = "bottom";
				//
				switch (a) {
					case "1-4": case "5-7": case "2-3": {
						dir = "top";
						break;
					}
					case "2-1": case "6-8": case "3-4": {
						dir = "right";
						break;
					}
					case "1-2": case "8-6": case "4-3": {
						dir = "left";
						break;
					}
					case "4-1": case "7-5": case "3-2": {
						dir = "bottom";
						break;
					}
				}
				return dir;
			};
			
			//
			var funCenterJudge = function(a) {
				if (a === "5-7" || a === "6-8" || a === "8-6" || a === "7-5") {
					return true;
				}
				return false;
			};
			
			var funJudge = function(dir) {
				var totalHeight = 0, totalWidth = 0, flagCorner = (o.s.sharpAngle && o.corner) ? true: false;
				if (dir === "right") {
					totalWidth = tri_l + tri_w + tar_w + off_x;
					if (flagCorner) {
						totalWidth += o.corner.width();
					}	
					if (totalWidth > $(window).width()) {
						return false;	
					}
				} else if (dir === "bottom") {
					totalHeight = tri_t + tri_h + tar_h + off_y;
					if (flagCorner) {
						totalHeight += 	o.corner.height();
					}
					if (totalHeight > st + $(window).height()) {
						return false;	
					}
				} else if (dir === "top") {
					totalHeight = tar_h + off_y;
					if (flagCorner) {
						totalHeight += 	o.corner.height();
					}
					if (totalHeight > tri_t - st) {
						return false;	
					} 
				} else if (dir === "left") {
					totalWidth = tar_w + off_x;
					if (flagCorner) {
						totalWidth += o.corner.width();
					}
					if (totalWidth > tri_l) {
						return false;	
					}
				}
				return true;
			};
			//
			strDirect = funDirect(align);

			if (this.s.sharpAngle) {
				//
				this.createSharp(strDirect);
			}
			
			//
			if (this.s.edgeAdjust) {
				//
				if (funJudge(strDirect)) {
					//
					(function() {
						if (funCenterJudge(align)) { return; }
						var obj = {
							top: {
								right: "2-3",
								left: "1-4"	
							},
							right: {
								top: "2-1",
								bottom: "3-4"
							},
							bottom: {
								right: "3-2",
								left: "4-1"	
							},
							left: {
								top: "1-2",
								bottom: "4-3"	
							}
						};
						var o = obj[strDirect], name;
						if (o) {
							for (name in o) {
								if (!funJudge(name)) {
									align = o[name];
								}
							}
						}
					})();
				} else {
					//
					(function() {
						if (funCenterJudge(align)) { 
							var center = {
								"5-7": "7-5",
								"7-5": "5-7",
								"6-8": "8-6",
								"8-6": "6-8"
							};
							align = center[align];
						} else {
							var obj = {
								top: {
									left: "3-2",
									right: "4-1"	
								},
								right: {
									bottom: "1-2",
									top: "4-3"
								},
								bottom: {
									left: "2-3",
									right: "1-4"
								},
								left: {
									bottom: "2-1",
									top: "3-4"
								}
							};
							var o = obj[strDirect], arr = [];
							for (name in o) {
								arr.push(name);
							}
							if (funJudge(arr[0]) || !funJudge(arr[1])) {
								align = o[arr[0]];
							} else {
								align = o[arr[1]];	
							}
						}
					})();
				}
			}
			
			//
			var strNewDirect = funDirect(align), strFirst = align.split("-")[0];
			if (this.s.sharpAngle) {
				//
				this.createSharp(strNewDirect);
				cor_w = this.corner.width(), cor_h = this.corner.height();
			}

			//left, top
			if (this.s.hoverFollow) {
				//
				if (this.s.hoverFollow === "x") {
					//
					tar_l = tri_l + off_x;
					if (strFirst === "1" || strFirst === "8" || strFirst === "4" ) {
						//
						tar_l = tri_l - (tar_w - tri_w) / 2 + off_x;
					} else {
						//
						tar_l = tri_l - (tar_w - tri_w) + off_x;
					}
					
					//
					if (strFirst === "1" || strFirst === "5" || strFirst === "2" ) {
						tar_t = tri_t - off_y - tar_h - cor_h;
						//
						cor_t = tri_t - cor_h - off_y - 1;
						
					} else {
						//
						tar_t = tri_t + tri_h + off_y + cor_h;
						cor_t = tri_t + tri_h + off_y + 1;
					}
					cor_l = pos.left - (cor_w - tri_w) / 2;
				} else if (this.s.hoverFollow === "y") {
					//
					if (strFirst === "1" || strFirst === "5" || strFirst === "2" ) {
						//
						tar_t = tri_t - (tar_h - tri_h) / 2 + off_y;
					} else {
						//
						tar_t = tri_t - (tar_h - tri_h) + off_y;
					}
							
					if (strFirst === "1" || strFirst === "8" || strFirst === "4" ) {
						//
						tar_l = tri_l - tar_w - off_x - cor_w;
						cor_l = tri_l - cor_w - off_x - 1;
					} else {
						//
						tar_l = tri_l + tri_w - off_x + cor_w;
						cor_l = tri_l + tri_w + off_x + 1;
					}
					cor_t = pos.top - (cor_h - tri_h) / 2;
				} else {
					tar_l = tri_l + off_x;
					tar_t = tri_t + off_y;	
				}
				
			} else {
				switch (strNewDirect) {
					case "top": {
						tar_t = tri_t - off_y - tar_h - cor_h;
						if (strFirst == "1") {
							tar_l = tri_l - off_x;	
						} else if (strFirst === "5") {
							tar_l = tri_l - (tar_w - tri_w) / 2 - off_x;
						} else {
							tar_l = tri_l - (tar_w - tri_w) - off_x;
						}
						cor_t = tri_t - cor_h - off_y - 1;
						cor_l = tri_l - (cor_w - tri_w) / 2;
						break;
					}
					case "right": {
						tar_l = tri_l + tri_w + off_x + cor_w;
						if (strFirst == "2") {
							tar_t = tri_t + off_y;	
						} else if (strFirst === "6") {
							tar_t = tri_t - (tar_h - tri_h) / 2 + off_y;
						} else {
							tar_t = tri_t - (tar_h - tri_h) + off_y;
						}
						cor_l = tri_l + tri_w + off_x + 1;
						cor_t = tri_t - (cor_h - tri_h) / 2;
						break;
					}
					case "bottom": {
						tar_t = tri_t + tri_h + off_y + cor_h;
						if (strFirst == "4") {
							tar_l = tri_l + off_x;	
						} else if (strFirst === "7") {
							tar_l = tri_l - (tar_w - tri_w) / 2 + off_x;
						} else {
							tar_l = tri_l - (tar_w - tri_w) + off_x;
						}
						cor_t = tri_t + tri_h + off_y + 1;
						cor_l = tri_l - (cor_w - tri_w) / 2;
						break;
					}
					case "left": {
						tar_l = tri_l - tar_w - off_x - cor_w;
						if (strFirst == "2") {
							tar_t = tri_t - off_y;	
						} else if (strFirst === "6") {
							tar_t = tri_t - (tar_w - tri_w) / 2 - off_y;
						} else {
							tar_t = tri_t - (tar_h - tri_h) - off_y;
						}
						cor_l = tar_l + cor_w;
						cor_t = tri_t - (tar_w - cor_w) / 2;
						break;
					}
				}
			}
			//
			if (cor_h && cor_w && this.corner) {
				this.corner.css({
					left: cor_l,
					top: cor_t,
					zIndex: this.s.zIndex + 1	
				});
			}
            //add by jlg
            if(cor_l > (tar_l + tar_w)) {
                tar_l = tar_l +  tar_w/2 + (cor_l - (tar_l + tar_w));
            }
			//
			this.target.css({
				position: "absolute",
				left: tar_l,
				top: tar_t,
				zIndex: this.s.zIndex
			});
			return this;
		},
		createSharp: function(dir) {
			var bgColor, bdColor, color1 = "", color2 = "";
			var objReverse = {
				left: "right",
				right: "left",
				bottom: "top",
				top: "bottom"	
			}, dirReverse = objReverse[dir] || "top";
			
			if (this.target) {
				bgColor = this.target.css("background-color");
				if (parseInt(this.target.css("border-" + dirReverse + "-width")) > 0) {
					bdColor = this.target.css("border-" + dirReverse + "-color");
				} 
				
				if (bdColor &&  bdColor !== "transparent") {
					color1 = 'style="color:' + bdColor + ';"';
				} else {
					color1 = 'style="display:none;"';
				}
				if (bgColor && bgColor !== "transparent") {
					color2 = 'style="color:' + bgColor + ';"';	
				}else {
					color2 = 'style="display:none;"';
				}
			}
			
			var html = '<div id="floatCorner_' + dir + '" class="float_corner float_corner_' + dir + '">' +
					'<span class="corner corner_1" ' + color1 + '></span>' +
					'<span class="corner corner_2" ' + color2 + '></span>' +
				'</div>';
			if (!$("#floatCorner_" + dir).size()) {
				$("body").append($(html));	
			}
			this.corner = $("#floatCorner_" + dir);
			return this;
		},
		targetHold: function(options) {
			if (this.s.hoverHold) {
				if(options && options.beforeTrigger && $.isFunction(options.beforeTrigger)){
					var opts = {};
					opts.powerFloat=this;
					opts=$.extend({},opts,options.beforeTriggerParam);
					if(options.beforeTrigger(opts)){
						return this;
					}
				}
				
				if(this.target==null) return this;
				
				var delay = parseInt(this.s.hideDelay, 10) || 200;
				this.target.hover(function() {
					o.flagDisplay = true;
				}, function() {
					o.flagDisplay = false;
					//hover trigger
					setTimeout(function() {
						o.displayDetect();	
					}, delay);
				});
			}
			return this;
		},
		loading: function() {
			this.target = $('<div class="float_loading"></div>');
			this.targetShow();
			this.target.removeData("width").removeData("height");
			return this;
		},
		displayDetect: function() {
			//
			if (!this.flagDisplay) {
				this.targetHide();
			}
			return this;
		},
		targetShow: function() {
			o.cornerClear();
			this.flagDisplay = true;
			this.container().setWidth().position();
			this.target.show();
			if ($.isFunction(this.s.showCall)) {
				this.s.showCall.call(this.trigger, this.target);	
			}
			return this;
		},
		targetHide: function() {
			this.flagDisplay = false;
			this.targetClear();
			this.cornerClear();
			if ($.isFunction(this.s.hideCall)) {
				this.s.hideCall.call(this.trigger);	
			}
			this.target = null;
			this.trigger = null;
			this.s = {};
			this.targetProtect = false;
			return this;
		},
		targetClear: function() {
			if (this.target) {
				if (this.target.data("width")) {
					this.target.removeData("width").removeData("height");	
				}
				if (this.targetProtect) {
					//
					this.target.children().hide().appendTo($("body"));
				} 
				this.target.unbind().hide();
			}
		},
		cornerClear: function() {
			if (this.corner) {
				//remove
				this.corner.remove();
			}
		},
		target: null,
		trigger: null,
		s: {},
		cacheData: {},
		targetProtect: false
	};
	
	$.powerFloat = {};
	$.powerFloat.hide = function() {
		o.targetHide();	
	};
	
	var defaults  = {
		width: "auto", //inherit(px)
		offsets: {
			x: 0,
			y: 0	
		},
		zIndex: 999,
		
		eventType: "hover", //click, focus
		
		showDelay: 0, //hover
		hideDelay: 0, //
		
		hoverHold: true,
		hoverFollow: false, //truex, y
		
		targetMode: "common", //ajax, list, remind
		target: null, //targetnulltargetAttr
		targetAttr: "rel", //targettargetModelist
		
		container: null, //target"plugin"
		reverseSharp: false, //ajax, remindlist
		
		position: "4-1", //trigger-target
		edgeAdjust: true, //
		
		showCall: $.noop,
		hideCall: $.noop

	};
})(jQuery);
//mod.defineModule("textarea", ["base","waf"], function() {
    /*
     * author: Zhang Yanfang
     * date: 2012-2-3
     */

    (function ($, undefined) {
        $.wafTextarea = $.wafTextarea || {};
        $.widget("ui.wafTextarea", $.ui.wafctrl, {
            options:{
                cols: null,
                disabled: false,
                height: null,
                hidden: false,
                maxlength: null,
                onblur: null,
                onchange: null,
                onclick: null,
                ondblclick: null,
                onfocus: null,
                onkeydown: null,
                onkeypress: null,
                onkeyup: null,
                onmousedown: null,
                onmousemove: null,
                onmouseout: null,
                onmouseover: null,
                onmouseup: null,
                onselect: null,
                readonly: false,
                rows: null,
                style: null,
                tabindex: 0,
                tagClass: null,
                value: null,
                width: null
            },
            _create:function () {
                $.ui.wafctrl.prototype._create.apply(this, arguments);
                var self = this, text = this.element, o = this.options;
                this.dataFlag = "data.wafTextarea";
                this.initFlag = true;

                this._enter2tab();
                if (!text.data("domcreated")) {
                    text.attr("ctrlrole", "textarea").addClass("ui-textarea");
                    text.attr('data-domcreated', "true");
                }

                this._initByOptions("cols", "rows", "disabled", "readonly", "style", "tagClass", "maxlength",
                        "tabindex", "width", "height", "hidden", "onblur", "onchange", "onclick", "ondblclick",
                        "onfocus", "onkeydown", "onkeypress", "onkeyup", "onmousedown", "onmousemove",
                        "onmouseout", "onmouseover", "onmouseup", "onselect", "value");

                //onchange
                text.bind("focus.wafTextarea",
                        function () {
                            $.data(text[0], self.dataFlag, text.val());
                        })
                        .bind("change.wafTextarea", function () {
                    var oldValue = $.data(text[0], self.dataFlag),
                            value = text.val();
                    self._update(oldValue, value);
                });

                text.bind("keyup blur", function () {
                    self._checkLength();
                });
                // formreset, .
                $(text[0].form).bind('reset.wafTextarea', function () {
                    setTimeout($.proxy(self._reset, self), 10);
                });
                //
                this.setDefaultValue(o.value);
                //
                this._operateState();
            },
            _reset:function () {
                var el = this.element, id = el[0].id;
                el.val(this.defaultValue);
                this._setDisplayValue(this.defaultValue, false);
                $("#" + id + "_el").val(this.defaultValue);
            },
            setDefaultValue:function(val) {
                this.defaultValue = val;
            },
            _checkLength:function () {
                var text = this.element,
                        wordLength = text.attr("maxlength"),
                        textareaLength = text.val().length;
                if (wordLength - textareaLength < 0) {
                    var words = text.val().substr(0, wordLength);
                    text.val(words);
                    $("#" + text[0].id + "_el").val(words);
                }
            },
            _setOption:function (key, value) {
                if (value === undefined) {
                    return;
                }
                var text = this.element;
                if (key.substring(0, 2) == "on" && key != "onchange") {
                    var name = key.substring(2, key.length);
                    text.handleFunction(name + ".wafTextarea", value);
                } else if (key == "tagClass") {
                    text.removeClass(this.options.tagClass).addClass(value);
                } else if ((key == "height" || key == "width")) {
                    text.css(key, value);
                }
                else if (key == "value") {
                        var result = "";
                        if (value) {
                            var temp = value;
                            while (temp.indexOf(",,") != -1) {
                                var index = temp.indexOf(",,");
                                result = result + temp.substring(0, index) + "\r\n";
                                temp = temp.substring(index + 2);
                            }
                            result = result + temp;
                        }
                        value = result;
                        if (this.initFlag) {
                            text.val(value);
                            $("#" + text[0].id + "_el").val(value);
                            this._setDisplayValue(value);
                            this.initFlag = false;
                        } else {
                            var oldValue = text.val();
                            this._update(oldValue, value);
                        }
                    } else if (key == "hidden") {
                        text[value ? "hide" : "show"]();
                    }
                    else if (key != "onchange") {
                            text.attr(key, value);
                        }
                if (key === "disabled") {
                    this.widget()
                            [ value ? "addClass" : "removeClass"](
                            this.widgetBaseClass + "-disabled" + " " +
                            "ui-state-disabled")
                            .attr("aria-disabled", value);
                }
                if (key == "readonly") {
                    text.attr(key, value);
                    this.widget()
                            [ value ? "addClass" : "removeClass"](
                            "ui-state-readonly");
                }
                this.options[key] = value;
                return this;
            },
            getValue:function () {
                return this.element.val();
            },
            setValue:function (value) {
                var oldValue = this.element.val();
                this._update(oldValue, value);
            },
            remove:function () {
                var text = this.element,
                        script = text.next("script");
                script.remove();
                text.remove();
            },
            _enter2tab:function () {
                if ($.fn.enter2tab) {
                    this.element.enter2tab();
                }
            },
            _update:function (oldValue, value) {
                if (!value) value = "";
                if (!oldValue)  oldValue = "";
                if (oldValue != value && !this._trigger("onchange", "onchange", {"previous":oldValue, "current":value})) {
                    value = oldValue;
                }
                var el = this.element, id = el[0].id;
                el.val(value);
                $("#" + id + "_el").val(value);
                this._setDisplayValue(value ? $.wafutil.htmlEncode(value).replace(/\n/g, '<br>').replace(/[ ]/g, '&nbsp;') : '', true);
            },
            _trigger:function (type, event, data) {
                var callback = this.options[ type ];

                event = $.Event(event);
                event.type = type;
                data = data || {};
                if (event.originalEvent) {
                    for (var i = $.event.props.length, prop; i;) {
                        prop = $.event.props[ --i ];
                        event[ prop ] = event.originalEvent[ prop ];
                    }
                }
                this.element.trigger(event, data);
                return !( $.isFunction(callback) &&
                          callback.call(this.element[0], event, data) === false ||
                          event.isDefaultPrevented() );
            },
            _viewDisable: function(isDisable) {
                $.ui.wafctrl.prototype._viewDisable.apply(this, arguments);
                this.element.attr('disabled', isDisable);
            }
        });
        /*
         * Textarea
         * author:Zhang yanfang
         * 2012-11-15
         */
        $.extend($.wafTextarea, {
            createTextareaDOM:function (opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    var doms = [],
                            textarea = $("<textarea name='" + opts.name + "_el' id='" + opts.id + "' >"),
                            hidden = $("<input type='hidden' name='" + opts.name + "' id='" + opts.id + "_el'>"),
                            label = $("<label class='viewStatus' id='" + opts.id + "_view'></label>");
                    doms.push(textarea, hidden, label);
                    return doms;
                } else {
                    return obj;
                }
            },
            initTextarea:function (opts, el) {
                el=$.isArray(el)?el[0]:el;
                opts.displayField = "#" + opts.id + "_view";
                $(el).wafTextarea(opts);
                return el;
//                if (el && opts && el.length > 0) {
//                    if (opts.id) {
//                        el[0].attr("id", opts.id);
//                        el[1].attr("id", opts.id + "_el");
//                        el[2].attr("id", opts.id + "_view");
//                    }
//                    if (opts.name) {
//                        el[0].attr("name", opts.name + "_el");
//                        el[1].attr("name", opts.name);
//                    }
//                    var temp = {
//                        id:opts.id,
//                        name:opts.name
//                    };
//                    delete opts.id;
//                    delete opts.name;
//                    opts.displayField = "#" + temp.id + "_view";
//                    el[0].wafTextarea(opts);
//                    $.extend(opts, temp);
//                    return el[0];
//                }
            },
            removeTextarea:function (opts) {
                var textarea = $("#" + opts.id),
                        hidden = $("#" + opts.id + "_el");
                textarea.remove();
                if (hidden.length > 0) {
                    hidden.remove();
                }
            },
            modifyTextarea:function (opts) {
                var textarea = $("#" + opts.id),
                        temp = {
                            id:opts.id,
                            name:opts.name,
                            value:opts.value
                        };
                delete opts.id;
                delete opts.name;
                delete opts.value
                textarea.wafTextarea("option", opts);
                textarea.wafTextarea("setValue", temp.value);
                $.extend(opts, temp);
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("textarea", {createDOMFun:$.wafTextarea.createTextareaDOM, initFun:$.wafTextarea.initTextarea,
                    deleteFun:$.wafTextarea.removeTextarea, modifyFun:$.wafTextarea.modifyTextarea,lazyInit:true});
        });
    }(jQuery));
//});
//mod.defineModule("linkButton", ["base","waf"], function() {
    /*
     * author: Zhang Yanfang
     * date: 2012-2-3
     */

    (function ($, undefined) {
        $.wafLinkButton = $.wafLinkButton || {};
        $.widget("ui.wafLinkButton", {
            options:{
                caption:null,
                iconCls:null,
                text:true,
                style:null,
                tagClass:null,
                disabled:false,
                hidden:false,
                tabindex:0,
                onclick:null,
                position:null
            },
            _create:function () {
                var linkbutton = this.element,
                        o = this.options, self = this;
                if (!this.element.data('domcreated')) {
                    linkbutton.attr("ctrlrole", "linkButton").addClass("ui-linkbutton");
                    linkbutton.append("<span class='ui-lb-text'></span>");
                    linkbutton.attr("data-domcreated", "true");
                }
                if (!linkbutton.hasClass("ui-a-menuitem")) {
                    this._enter2tab();
                }
                this._setOptions(o);
                linkbutton.bind("click.wafLinkButton", function (event) {
                    if (!o.disabled) {
                        if (o["actionBinding"]) {
                            setTimeout(function () {
                                waf.proxyCall.call(this, o["actionBinding"], undefined, event);
                            }, 100);
                        } else if (o["onclick"]) {
                            var temp = o["onclick"];
                            setTimeout(function () {
                                if ($.isFunction(temp)) {
                                    self._trigger("onclick", event);
                                } else if ($.type.isString(temp)) {
                                    if (temp.indexOf("(") > -1) {
                                        eval(o["onclick"]);
                                    } else {
                                        var fun = eval(temp);
                                        if ($.isFunction(fun)) {
                                            o["onclick"] = fun;
                                            self._trigger("onclick", event);
                                        }
                                    }
                                }
                            }, 100);
                        }
                    }
                });
                if (!$.browser.msie) {
                    linkbutton.attr("href", "javascript:void(null)");
                }
            },
            _setOption:function (key, value) {
                if (value === undefined) {
                    return;
                }
                var linkbutton = this.element, o = this.options,
                        captionSpan = linkbutton.find("span.ui-lb-text");
                switch (key) {
                    case "iconCls":
                        var iconSpan = linkbutton.find("span.ui-lb-icon");
                        if (value == null || value.length == 0) {
                            if (iconSpan.length > 0) {
                                iconSpan.remove();
                            }
                        } else {
                            if (iconSpan.length == 0) {
                                iconSpan = $("<span class='ui-lb-icon'></span>");
                                linkbutton.prepend(iconSpan);
                            }
                            iconSpan.removeClass(o.iconCls).addClass(value);
                        }
                        break;
                    case "caption":
                        value && captionSpan.text(value);
                        break;
                    case "text":
                        captionSpan[value ? "show" : "hide"]();
                        break;
                    case "style":
                        value && linkbutton.attr(key, value);
                        break;
                    case "tagClass":
                        linkbutton.removeClass(o.tagClass).addClass(value);
                        break;
                    case "disabled":
                        linkbutton[value ? "addClass" : "removeClass"]("ui-lb-disabled ui-state-disabled");
                        break;
                    case "hidden":
                        linkbutton[value ? "hide" : "show"]();
                        break;
                    case "tabindex":
                        value && linkbutton.attr(key, value);
                        break;
                    case "position":
                        if (value) {
                            var li = this.element.parent("li");
                            if (value == "right") {
                                value = "pull-right";
                            } else if (value == "left") {
                                value = "pull-left";
                            } else {
                                value = null;
                            }
                            if (li.length > 0 && value != null && !li.hasClass(value)) {
                                li.addClass(value);
                            }
                        }
                        break;
                }
                this.options[key] = value;
            },
            _enter2tab:function () {
                if ($.fn.enter2tab) {
                    this.element.enter2tab();
                }
            }
        });

        /*linkbutton
         author: Zhang yanfang
         date:2012-11-28
         */
        $.extend($.wafLinkButton, {
            createLinkbuttonDOM:function (opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    var a = $("<a id='" + opts.id + "' ctrlrole='linkButton'></a>");
                    return a;
                }else{
                    return obj;
                }

            },
            initLinkbutton:function (opts, el) {
                if (el && opts) {
                    el.wafLinkButton(opts);
                    return el;
                }
            },
            modifyLinkbutton:function (opts) {
                var el = $("#" + opts.id);
                el.wafLinkButton("option", opts);
                return  el;
            },
            removeLinkbutton:function (opts) {
                var el = $("#" + opts.id);
                el.remove();
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("linkButton",
                {createDOMFun:$.wafLinkButton.createLinkbuttonDOM,
                    initFun:$.wafLinkButton.initLinkbutton,
                    deleteFun:$.wafLinkButton.removeLinkbutton,
                    modifyFun:$.wafLinkButton.modifyLinkbutton,lazyInit:true});
        });
    }(jQuery));
//});
//mod.defineModule("window",["base","waf","dialog","boxUtil","block","window_i18n"],function(){
/*
     * Depends:
     *	jquery.ui.core.js
     *	jquery.ui.widget.js
     *  jquery.ui.button.js
     *	jquery.ui.draggable.js
     *	jquery.ui.mouse.js
     *	jquery.ui.position.js
     *	jquery.ui.resizable.js
     */

    //var win_mgr_Map = new Map();
    //var win_msg_ccid = 0;
//    (function($,h,c){var a=$([]),e=$.resize=$.extend($.resize,{}),i,k="setTimeout",j="resize",d=j+"-special-event",b="delay",f="throttleWindow";e[b]=250;e[f]=true;$.event.special[j]={setup:function(){if(!e[f]&&this[k]){return false}var l=$(this);a=a.add(l);$.data(this,d,{w:l.width(),h:l.height()});if(a.length===1){g()}},teardown:function(){if(!e[f]&&this[k]){return false}var l=$(this);a=a.not(l);l.removeData(d);if(!a.length){clearTimeout(i)}},add:function(l){if(!e[f]&&this[k]){return false}var n;function m(s,o,p){var q=$(this),r=$.data(this,d);r.w=o!==c?o:q.width();r.h=p!==c?p:q.height();n.apply(this,arguments)}if($.isFunction(l)){n=l;return m}else{n=l.handler;l.handler=m}}};function g(){i=h[k](function(){a.each(function(){var n=$(this),m=n.width(),l=n.height(),o=$.data(this,d);if(m!==o.w||l!==o.h){n.trigger(j,[o.w=m,o.h=l])}});g()},e[b])}})(jQuery,this);

    (function ($, undefined) {
        $.fn.setReturnVal = function (value) {
            return this.dialog("option", "returnVal", value);
        }

        var widthVar = "resize$Width$WIN",
            heightVar = "resize$Height$WIN";

        $.windowMgr = $.windowMgr || {};
        $.extend($.windowMgr, {
            getTargetObj:function () {
                targetId = $.window.util.getUrlRequestParam("curWinTarget");
                var curTarget = null;
                //top.win_mgr_Map=undefined;
                if(targetId!=''){
                    curTarget = top.win_mgr_Map&&top.win_mgr_Map.get(targetId);
                }else if(top.win_mgr_Map){
                    try{
                        var size = top.win_mgr_Map.size();
                        if(size>0){
                            curTarget = top.win_mgr_Map.element(top.win_mgr_Map.size()-1).value;
                        }
                    }catch(e){
                        curTarget = null;
                    }
                }else{
                    curTarget = null;
                }
                 return curTarget;
    //            if (parent.waf && parent.waf.window && $.isFunction(parent.waf.window.doOpen)) {
    //                if (parent.win_mgr_Map && parent.win_mgr_Map.size() > 0) {
    //                	if(targetId!=''){
    //	                    curTarget = parent.win_mgr_Map.get(targetId);
    //	                    //parent.win_mgr_Map.remove(targetId);
    //                	}else{
    //                		curTarget = parent.win_mgr_Map.element(parent.win_mgr_Map.size()-1).value;
    //                	}
    //                	return curTarget;
    //                } else
    //                    return null;
    //            } else {
    //                if (win_mgr_Map && win_mgr_Map.length > 0) {
    //                	if(targetId!=''){
    //	                    var curTarget = win_mgr_Map.get(targetId);
    //                    //win_mgr_Map.remove(targetId);
    //                	}else{
    //                		curTarget = win_mgr_Map.element(win_mgr_Map.size()-1).value;
    //                	}
    //
    //                    return curTarget;
    //                } else
    //                    return null;
    //            }
            },
            triggerRetValCallBack:function(opts,target){
                if(target==undefined)
                    target = waf.windowMgr.getTargetObj();
                target.data('retValCallBack')(opts);
            },
            setReturnValFuncWhenClose:function(valueFunc,target,close){
                if(target==undefined){
                    target = waf.windowMgr.getTargetObj();
                    target.unbind( "dialogbeforeclose");
                    target.bind( "dialogbeforeclose", function(event, ui) {
                        waf.windowMgr.getTargetObj().dialog("option", "returnVal", valueFunc());
                        if(close!=undefined) return close;
                    });
                }else{
                    target.unbind( "dialogbeforeclose");
                    target.bind( "dialogbeforeclose", function(event, ui) {
                        target.dialog("option", "returnVal", value);
                        if(close!=undefined) return close;
                    });
                }
            },
            doBeforeClose:function(opts){
                if(opts.target==undefined)
                   var target = waf.windowMgr.getTargetObj();
                if(opts.closeWithConfirm){
                    target.dialog("option", "closeWithConfirm", '0');
                    //if(opts.closeWithConfirm.buttonCallBack.length>0){
                        target.unbind( "dialogbeforeclose");
                        var retFunc;
                        if(opts.valueFunc)
                           retFunc = function(){
                                waf.windowMgr.getTargetObj().dialog("option", "returnVal", opts.valueFunc());
                            }
                        var beforeCloseFunc = $.window.util.buildBeforeClose(opts,target,retFunc);
                        target.bind( "dialogbeforeclose", beforeCloseFunc);
                    //}
                }else{
                    setReturnValFuncWhenClose(opts.valueFunc,target);
                }
            }
        });

        $.window = $.window || {};
        $.extend($.window, {
            open:function (opts) {
                var curPageTargetID = $.window.util.getUrlRequestParam("curWinTarget");
                opts.curPageTargetID = curPageTargetID;
                if (opts.openFromParent && parent.waf && parent.waf.window && $.isFunction(parent.waf.window.doOpen)) {
                    //win_mgr_Map = parent.win_mgr_Map;
                    return parent.waf.window.doOpen(opts);
                } else
                    return waf.window.doOpen(opts);
            },
            getNewCid: function() {
                if(top.win_msg_ccid == null) {
                    top.win_msg_ccid = 1;
                } else {
                    top.win_msg_ccid++;
                }
                return top.win_msg_ccid;
            },
            createWin:function (opts) {
                //build options and merge max\min\help buttons
                var newOpts = $.window.util.buildOptions(opts),
                    cid = $.window.getNewCid(),
                    target = newOpts.target;

                if(!target) {
                    target = $.window.util.buildTarget(newOpts, cid);
                }
                target.addClass("ui-wafwin");

                $.window.util.transferEvent(target, newOpts);
                if(top.win_mgr_Map == null) {
                    top.win_mgr_Map = new Map();
                } else {
                    try {
                        top.win_mgr_Map.size();
                    } catch(e) {
                        top.win_mgr_Map = new Map();
                    }
                }

                top.win_mgr_Map.put(cid, target);
                target.data('curWinTarget.wafwin', cid);

                newOpts.autoOpen = false;
                //
                if(window.parent&&window.parent.jPortal){
                    newOpts.position = $.extend({
                        my: 'center',
                        at: 'center',
                        collision: 'fit',
                        of: window.parent,
                        // ensure that the titlebar is never outside the document
                        using: function(pos) {
                            var topOffset = $(this).css(pos).offset().top;
                            if (topOffset < 0) {
                                $(this).css('top', pos.top - topOffset);
                            }
                            try{
                                var width = $(window.parent.document.body).find("iframe[src*='easweb']").width();
                                if(!$.isNaN(width)){
                                    $(this).css("left",Math.round((width-$(this).width())/2));
                                }
                            }catch(e){}
                        }
                    },newOpts.position||{});
                }
                target.dialog(newOpts);

                target.dialog("option","maxHeight",($(document.body).height()-$.boxLayoutUtil.getBorderHeight($(target.parent()))));
                target.dialog("option","maxWidth",document.body.clientWidth);

                if(newOpts.closeWithConfirm){
                    target.dialog("option", "closeWithConfirm", '0');
                }

                if (!newOpts.target) {
                   $.window.util.loadPage(target, newOpts, cid);
                }

                if(newOpts.retValCallBack){
                    target.data('retValCallBack',newOpts.retValCallBack);
                }

                $.window.util.adjustAfterLoad(target, newOpts);

                //ieleft-14
                if(opts.autoMax && !opts.showTitleBar){
                    var ua = navigator.userAgent.toLowerCase();
                    if(ua.match(/msie ([\d.]+)/)){
                        var left = target.parent().css('left');
                        if(left && left.indexOf('px')>0){
                            left = left.substring(0,left.indexOf('px'));
                            if(left<0){
                                target.parent().css('left',0);
                                var width = target.parent().width();
                                target.parent().css('width',width+left);
                            }
                        }
                    }
                }

                return target;
            },
            showWin:function (target) {
                target.dialog('open');
                if(!$(target).hasClass("ui-f7iframe-panel")){
                    var text = ($.window&&$.window.loadding&&$.window.loadding.loadingText)?$.window.loadding.loadingText:"Try my best loadding!";
                    $.block.show({text:text,target:target,addClass:"iframeWin"});
                }
                $("#postForm").remove();

                return target;
            },
            doOpen:function (opts, curPageTargetID) {
                if(opts.onOpen && waf.isFunction(opts.onOpen))
                    opts.open=opts.onOpen;
                if(opts.onFocus && waf.isFunction(opts.onFocus))
                    opts.focus=opts.onFocus;
                if(opts.onDragStart && waf.isFunction(opts.onDragStart))
                    opts.dragStart=opts.onDragStart;
                if(opts.onDrag && waf.isFunction(opts.onDrag))
                    opts.drag=opts.onDrag;
                if(opts.onDragStop && waf.isFunction(opts.onDragStop))
                    opts.dragStop=opts.onDragStop;
                if(opts.onResizeStart && waf.isFunction(opts.onResizeStart))
                    opts.resizeStart=opts.onResizeStart;
                if(opts.onResize && waf.isFunction(opts.onResize))
                    opts.resize=opts.onResize;
                if(opts.onResizeStop && waf.isFunction(opts.onResizeStop))
                    opts.resizeStop=opts.onResizeStop;
                if(opts.onClose && waf.isFunction(opts.onClose))
                    opts.close=opts.onClose;
                if(opts.onBeforeClose && waf.isFunction(opts.onBeforeClose))
                    opts.beforeClose=opts.onBeforeClose;
                if(opts.onBeforeHide && waf.isFunction(opts.onBeforeHide))
                    opts.beforeHide=opts.onBeforeHide;

    //        	if(opts.position && typeof opts.position=='string' && opts.position.toLocaleLowerCase()=='center')	{
    //        		if($.browser.msie)
    //        			opts.position= { my: "center", at: "center", collision:"fit none" };
    //        		else
    //        			opts.position= { my: "center", at: "center", offset:[0, $(document.body).scrollTop()], collision:"fit none" };
    //        	}

                var target = waf.window.createWin(opts);
                return waf.window.showWin(target);

            },
            doResize:function(){
    //            var winsNum = top.win_mgr_Map.size();
    //            for(var i=0;i<winsNum;i++){
    //                var win = top.win_mgr_Map.element(i).value;
    //                var winNewWidth = $(window).width(), winNewHeight = $(window).height(), resizeTimeout;
    //	            var win$Width = $(win).data(widthVar) || -1, win$Height = $(win).data(heightVar) || -1;
    //	            alert("win$Width:"+win$Width + " winNewWidth:"+winNewWidth);
    //	            //alert("win$Height:"+win$Height + " winNewHeight:"+winNewHeight);
    //	            if (win$Width != winNewWidth || win$Height != winNewHeight) {
    //	                window.clearTimeout(resizeTimeout);
    //	                resizeTimeout = window.setTimeout(function(e){
    //                    if(win && win.dialog('option','autoMax')==true  && win.dialog('option','showTitleBar')==false){
    //                        var width = document.body.clientWidth-$.boxLayoutUtil.getBorderWidth(win.parent());
    //                        var height = $(document).height();
    //                        setTimeout(
    //                        	function(){
    //		                        win.parent().css("width",width).css("height",height);
    //		                        win.css("height",height);
    //		                        $(".ui-widget-overlay").css("width",width).css("height",$(document).height());
    //                        	},0);
    //                    }
    //                    $(document).focus();
    //					//,
    //        		    win.dialog("option","maxHeight",($(document).height()-$.boxLayoutUtil.getBorderHeight($(win.parent()))));
    //                    win.dialog("option","maxWidth",document.body.clientWidth);
    //                }, 10);
    //	            }
    //	            //Update the width and height
    //	            $(win).data(widthVar, winNewWidth);
    //	            $(win).data(heightVar, winNewHeight);


    //            }
            },
            max:function(target){
                $.window.util.doMaxWindow(target);
            },
            min:function(target){
                $.window.util.doMinWindow(target);
            },
            close:function (target) {
                //target = null;
                if (target) {
                    target.dialog('close');
                } else {
                    var target = waf.windowMgr.getTargetObj();
                    if(target) target.dialog('close');
                    //closeTargetArray();
                }
            },
            closeWithParam:function (value) {
                if (value) {
                    var target = waf.windowMgr.getTargetObj();
                    target.dialog("option", "returnVal", value);
                    target.dialog('close');
                } else {
                    //closeTargetArray();
                }
            },
            changeTitle:function (value,target) {
                if(target){
                    target.parent().find("span.ui-dialog-title").text(value);
                }else {
                    var target = waf.windowMgr.getTargetObj();
                    target.parent().find("span.ui-dialog-title").text(value);
                }
            },
            isOpen:function (target) {
                if (target){
                    if(target.dialog('isOpen')===true)
                        return true;
                    else
                        return false
                }else
                    return false;
            },
            destroy:function (target) {
                if (target)
                    target.dialog('destroy');
            },
            getOptionItem:function (target, optionName) {
                return target.dialog("option", optionName);
            },
            moveToTop:function (target) {
                if (target)
                    target.dialog("moveToTop");
            },
            hide:function (target) {
                if (target) {
                    target.parent().css('display','none');
                } else {
                    var target = waf.windowMgr.getTargetObj();
                    if(target) target.parent().css('display','none');
                }
                $.window.util.hideOverLay(true);
            },
            resume:function (target) {
                if (target) {
                    target.parent().css('display','block');
                } else {
                    var target = waf.windowMgr.getTargetObj();
                    if(target) target.parent().css('display','block');
                }
                $.window.util.hideOverLay(false);
            },
            hideWithParam:function (value) {
                if (value) {
                    var target = waf.windowMgr.getTargetObj();
                    target.dialog("option", "returnVal", value);
                    waf.window.hide(target);
                    target.trigger("dialogonbeforehide");
                    var beforeHideFunc = target.dialog("option", "beforeHide");
                    if ($.isFunction(beforeHideFunc)) {
                        $.window.util.triggerNewEvent("onBeforeHide", beforeHideFunc, target);
                    }
                } else {
                    //closeTargetArray();
                }
            }
        });

        $.window.util = $.window.util || {};
        $.extend($.window.util, {
            getUrlRequestParam:function (paras,url) {
                if(!url)  url = location.href;
                if (url != null && url.charAt(url.length - 1) == "#")
                    url = url.substring(0, url.length - 1);

                var paraString = url.substring(url.indexOf("?") + 1, url.length).split("&");
                var paraObj = {};
                for (i = 0; j = paraString[i]; i++) {
                    paraObj[j.substring(0, j.indexOf("=")).toLowerCase()] = j.substring(j.indexOf("=") + 1, j.length);
                }
                var returnValue = paraObj[paras.toLowerCase()];
                if (typeof(returnValue) == "undefined") {
                    return "";
                } else {
                    return returnValue;
                }
            },
            loadPage:function (target, newOpts, id) {
                var iframe = $('#' + 'iframe-' + id);
                if (!newOpts.data && newOpts.method.toLocaleUpperCase() == 'GET') {
                    iframe.attr("src", newOpts.url);
                    iframe.bind("load", (function () {
                        if (!iframe.data("havTriggerLoad")) {
                            $.window.util.calIframeScroll(newOpts, id);
                            if ($.isFunction(newOpts.onOpenCompleted)) {
                                $.window.util.triggerNewEvent("onOpenCompleted", newOpts.onOpenCompleted, target);
                            }
                            iframe.data("havTriggerLoad", true);
                        }
                        $.block.hide(iframe.parent());
                    }));
                }else{
                    if (newOpts.url) {
                        if (!newOpts.openType || newOpts.openType == 'div') {
                            target.load(
                                newOpts.url,
                                newOpts.data,
                                function () {
                                    target.trigger("dialogonopencompleted");
                                    if ($.isFunction(newOpts.onOpenCompleted)) {
                                        $.window.util.triggerNewEvent("onOpenCompleted", newOpts.onOpenCompleted, target);
                                    }
                                    $.block.hide($(target));
                                }
                            );
                        } else {
                            var helpHtml = "<form id='postForm' method='POST' target='iframe-" + id + "' action='" + newOpts.url + "'>" +
                                "<input id='hhh' type='hidden' name='params' value='" + $.toJSON(newOpts.data) + "'></form>"  //" + newOpts.data + "
                            $(helpHtml).appendTo(document.body);
                            iframe.bind("load", (function () {
                                if (!iframe.data("havTriggerLoad")) {
                                    $.window.util.calIframeScroll(newOpts, id);
                                    if($.isFunction(newOpts.onOpenCompleted)){
                                        $.window.util.triggerNewEvent("onOpenCompleted", newOpts.onOpenCompleted, target);
                                    }
                                    iframe.data("havTriggerLoad", true);
                                    $.block.hide(iframe.parent());
                                }
                            }));
                            $("#postForm").submit();

                        }
                    }
                }

                //-------------- add by vakin 20110818-------------------
                var $waterfall = $.window.util.addWaterfall(target);
                $waterfall.hide();
                var $headerBar = target.prev();
                $headerBar.bind('mousedown',function(){
                        //window.console.info.apply(window.console, ["mousedown"]);
                        $waterfall.show();
                });
                $headerBar.bind('mouseup',function(){
                        //window.console.info.apply(window.console, ["mouseup"]);
                        $waterfall.hide();
                });
            },
            calIframeScroll:function(opts,id){
                var iframe =  $('#' + 'iframe-' + id);
                var innerDocHeight = $(iframe[0].contentWindow.document.body).height();
                var winHeight = waf.window.defaults.maxHeight;
                if(!opts.autoMax) winHeight=opts.height;
                if(innerDocHeight>winHeight){
                    iframe.attr("scrolling","auto");
                }
            },
            triggerNewEvent:function (eventName, callback, target) {
                var event,
                data = {};
                event = $.Event(event);
                event.type = eventName;
                if(!event.target)  event.target = target[0];

                if (event.originalEvent) {
                    for (var i = $.event.props.length, prop; i;) {
                        prop = $.event.props[ --i ];
                        event[ prop ] = event.originalEvent[ prop ];
                    }
                }

                target.trigger(event, data);
                return !( $.isFunction(callback) &&
                    callback.call(target[0], event, data) === false ||
                    event.isDefaultPrevented() );
            },
            bindEvent:function (eventName, callback, target) {
                target.bind(eventName, callback);
            },
            transferEvent:function (target, newOpts) {
    //            if (outerCreateEvent != null) {
    //                target.bind("dialogcreate", outerCreateEvent);
    //            }
                if (newOpts.outerCloseEvent != null) {
                    target.bind("dialogclose", newOpts.outerCloseEvent);
                }

                var closeHandler = newOpts.beforeClose;
                if ($.isFunction(newOpts.beforeClose)) {
                    //var closeHandler = newOpts.beforeClose;
                    newOpts.beforeClose = function (event, ui) {
                        var curTarg = $(event.target);
                        var val = '';
                        if (curTarg) {
                            val = curTarg.dialog("option", "returnVal");
                        }
                        if (val != curTarg)
                            return closeHandler(event, ui, val);
                        else
                            return closeHandler(event, ui);
                    }
                }

                if ($.isFunction(newOpts.beforeHide)) {
                    var hideHandler = newOpts.beforeHide;
                    newOpts.beforeHide = function (event, ui) {
                        var curTarg = $(event.target);
                        var val = '';
                        if (curTarg) {
                            val = curTarg.dialog("option", "returnVal");
                        }
                        if (val != curTarg)
                            return hideHandler(event, ui, val);
                        else
                            return hideHandler(event, ui);
                    }
                }

                if(newOpts.closeWithConfirm){// && waf.isFunction(opts.onBeforeCloseWithConfirm
                    newOpts.beforeClose = $.window.util.buildBeforeClose(newOpts,target,closeHandler);
                }
            },
            buildBeforeClose:function(opts,target,closeHandler){
                return function(event,ui){
                    var mask = target.dialog("option", "closeWithConfirm");
                    if(mask && mask=='0'){
                        if(typeof opts.closeWithConfirm == 'string'){
                            waf.msgBox.showConfirm(opts.closeWithConfirm,function(){
                                    target.dialog("option", "closeWithConfirm", '1');
                                    target.dialog("close");
                            });
                        }else{
                            if(opts.closeWithConfirm.buttonCallBack && opts.closeWithConfirm.buttonCallBack.length>0){
                                waf.each(opts.closeWithConfirm.buttonCallBack, function(i,oriFunc){
                                      opts.closeWithConfirm.buttonCallBack[i] = function(){
                                        if(oriFunc(target)){
                                            target.dialog("option", "closeWithConfirm", '1');
                                            target.dialog("close");
                                        }else{
                                            target.dialog("option", "closeWithConfirm", '0');
                                        }
                                      }
                                  });
                                parent.waf.msgBox.showConfirm(opts.closeWithConfirm);
                            }
                        }
                        return false;
                    }else{
                        if(closeHandler && waf.isFunction(closeHandler))
                            return closeHandler(event,ui);
                    }
                }
            },
            buildOptions:function(opts){
                if (opts.showEffect) opts.show = opts.showEffect;
                if (opts.hideEffect){
                    if(opts.hideEffect=='none') opts.hide = null;
                    else opts.hide = opts.hideEffect;
                }else{
                    opts.hide=null;
                }

                if (opts.width && $.window.util.BASEisNotNum(opts.width) && opts.width.indexOf('%') > 0) opts.width = parseInt(window.screen.availWidth * parseInt(opts.width) / 100);
                if (opts.height && $.window.util.BASEisNotNum(opts.height) && opts.height.indexOf('%') > 0) opts.height = parseInt(window.screen.availHeight * parseInt(opts.height) / 100);
                opts.outerCloseEvent = opts.close;
                var newurl=waf.appendConversationToURL(opts.url);
                if(newurl)
                    opts.url = newurl;

                var openObj = $.window.util.getOpenObj();
                var newOpts = $.extend({}, waf.window.defaults, opts, openObj);
                return newOpts;
            },
            getOpenObj:function(){
                return {
                    create:function (event, ui) {
                        var $dialog = $(this);
                        var titleTxt = $(this.parentNode).find(".ui-dialog-title").text();
                        $(this.parentNode).find(".ui-dialog-title").replaceWith(' <span id="ui-dialog-title-' + this.id + '" class="ui-dialog-title ' + $dialog.dialog("option", "iconCls") + '">' + titleTxt + '</span>');

                        var newCtrl = '';


                        if ($dialog.dialog("option", "minMixBtn") == false) {
                            newCtrl += '<a id="a_close" class="ui-dialog-titlebar-close ui-corner-all" href="javascript:void(null)">' +
                                '<span class="ui-icon ui-icon-closethick ">close</span></a>'
                        } else {
                            newCtrl += '<a id="a_min"  role="button" class="waf-ui-dialog-titlebar-min ui-corner-all" href="javascript:void(null)">' +
                                '<span class="ui-icon ui-icon-minthick ">min</span></a>' +

                                '<a id="a_max" role="button" class="waf-ui-dialog-titlebar-max ui-corner-all" href="javascript:void(null)">' +
                                '<span class="ui-icon ui-icon-maxthick ">max</span></a>' +

                                '<a id="a_close" class="waf-dialog-titlebar-close waf-ui-dialog-titlebar-close ui-corner-all" href="javascript:void(null)">' +
                                '<span class="ui-icon ui-icon-closethick ">close</span></a>'
                        }
                        if ($.isFunction($dialog.dialog("option", "helper"))) {
                            newCtrl += '<a id="a_question" class="waf-ui-dialog-titlebar-help ui-corner-all" href="javascript:void(null)">' +
                                '<span class="ui-icon ui-icon-helpthick ">question</span></a>';
                        } else {
                            //newCtrl+='</p>';
                        }
                        var atext = $(this.parentNode).find(".ui-dialog-titlebar-close").replaceWith(newCtrl);

                        var as = $(this.parentNode).find("a");

                        as.each(function (i) {
                            if (!$.isFunction($dialog.dialog("option", "helper"))) {
    //							if (this.id == "a_max") {
    //								$(this).css('right','39px');
    //	                        } else if (this.id == "a_min") {
    //	                        	$(this).css('right','22px');
    //	                        } else if (this.id == "a_close") {
    //	                        	$(this).css('right','5px');
    //	                        }
                            }
                            ;

                            if($dialog.dialog("option", "hideCloseBtn")){
                                if (this.id == "a_max") {
                                    $(this).css('right','22px');
                                } else if (this.id == "a_min") {
                                    $(this).css('right','5px');
                                } else if (this.id == "a_close") {
                                    $(this).css('display','none');
                                }
                            }

                            $(this)
                                .attr('role', 'button')
                                .hover(
                                function () {
                                    $(this).addClass('ui-state-hover');
                                },
                                function () {
                                    $(this).removeClass('ui-state-hover');
                                }
                            )
                                .focus(function () {
                                    $(this).addClass('ui-state-focus');
                                })
                                .blur(function () {
                                    $(this).removeClass('ui-state-focus');
                                })
                                .click(function (event) {
                                    if (this.id == "a_max") {
    //                                    $.window.util.triggerNewEvent("onMax", $dialog.dialog("option", "onMax"), $dialog)
    //                                    $dialog.trigger("dialogmax");
                                        $.window.util.doMaxWindow($dialog);
                                        return false;
                                    } else if (this.id == "a_min") {
                                        $.window.util.triggerNewEvent("onMin", $dialog.dialog("option", "onMin"), $dialog)
                                        $dialog.trigger("dialogmin");
                                        $.window.util.doMinWindow($dialog);
                                        return false;
                                    } else if (this.id == "a_close") {
                                        $dialog.dialog("close");
                                        return false;
                                    } else if (this.id == "a_question") {
                                        //doShowHelper();
                                        $dialog.dialog("option", "helper")();
                                        return false;
                                    } else {
                                        alert("");
                                    }
                                })
                        })
                        $(document).unbind('keydown.dialog-overlay');
                        //$(this.parentNode)

                        $(document).bind('keydown', function (event) {
                            if (!event.isDefaultPrevented() && event.keyCode) {  //F3 event.ctrlKey
                                if (event.keyCode === 113) {
                                    $.window.util.doMinWindow($dialog);
                                } else if (event.keyCode === 114) {
                                    $.window.util.doMaxWindow($dialog);
                                } else if (event.keyCode === 115) {
                                    doShowHelper();
                                }
                                //event.preventDefault();
                            }
                        });
                    },
                    close:function (event, ui) {
                        //closeTargetArray($(this));  //??????????????
                        //winArray.pop();
                        //if (this.id.indexOf("autoDiv") >= 0 || this.id.indexOf("frameDiv-") >= 0) {
                        if ($(this).hasClass("ui-wafwin")) {
                            $(this).remove();
                            $("#postForm").remove();
                        }

                        //mapshowModual
                        var window_mgr_Map;
    //					if (parent.waf && parent.waf.window){
    //						window_mgr_Map=parent.win_mgr_Map;
    //					}else{
    //						window_mgr_Map=win_mgr_Map;
    //					}

    //					if (top.win_mgr_Map && top.win_mgr_Map.size() > 0) {
    //						var targetId = $.window.util.getUrlRequestParam("curWinTarget");
    //						if(targetId!=''){
    //							top.win_mgr_Map.remove(targetId);
    //						}else{
    //							top.win_mgr_Map.removeLastOne();
    //						}
    //					}
                    }
                }
            },
            buildTarget:function(newOpts,cid){
                var myForm = {};
                var target;
                if(newOpts.url && newOpts.url.indexOf("?")>=0)
                    newOpts.url = newOpts.url + '&curWinTarget=' + cid;
                else
                    newOpts.url = newOpts.url + '?curWinTarget=' + cid;

                if (!newOpts.openType || newOpts.openType == "div") {
                    target = $('<div id=\'autoDiv-' + cid + '\'>').appendTo(document.body);
                } else {
                    var helpHtml = "<div id='frameDiv-" + cid + "'>" +
                        "<iframe id='iframe-" + cid + "' name='iframe-" + cid + "'   width='100%' height='100%' frameborder='0'>" +
                        "</div>";
                    target = $(helpHtml).appendTo(document.body);
                }
                return target;
            },
            adjustAfterLoad:function(target,newOpts){
                if (newOpts.showTitleBar != undefined && !newOpts.showTitleBar)
                    $(target.parent()).find(".ui-dialog-titlebar").css('display', 'none');

                if(newOpts.style){
                    target.parent().css(newOpts.style);
                }

                if(newOpts.autoMax){
                    $.window.util.doMaxWindow(target);
                }



                target.dialog("option", "oriPosition",target.dialog("option", "position"));
                target.dialog("option", "oriWidth",target.dialog("option", "width"));
                target.dialog("option", "oriHeight",target.dialog("option", "height"));
            },
            doMaxWindow:function (win) {
                if(win.dialog("isLoadding", "max")==true) return false;
    //        	win.dialog( "option", "position", ["left", "top"] );
    //        	win.dialog( "option", "width", win.dialog("option", "maxWidth"));
    //        	win.dialog( "option", "height", win.dialog("option", "maxHeight"));
                if(win.dialog("option", "maxWidth")==win.dialog("option", "width") + $.boxLayoutUtil.getBorderWidth(win.parent())
                    && win.dialog("option", "maxHeight")==win.dialog("option", "height")){
                    win.dialog({
                        width:win.dialog("option", "oriWidth"),
                        height:win.dialog("option", "oriHeight")
                    });
                    win.dialog( "option", "position", win.dialog("option", "oriPosition"));
                }else{
                    var max_width = win.dialog("option", "maxWidth")-$.boxLayoutUtil.getBorderWidth(win.parent());
                    var max_heightd = win.dialog("option", "maxHeight");
                    win.dialog({
                        position:["left", "top"],
                        width:max_width,
                        height:max_heightd
                    });
                }

            },
            doMinWindow:function (win) {
                if(win.dialog("isLoadding", "min")==true) return false;
                win.dialog({
                    //position: mergeObj.position,
                    width:win.dialog("option", "minWidth"),
                    height:0//win.dialog( "option", "minHeight" )
                });
            },
            hideOverLay:function(isHide){
                var overDivs = $.ui.dialog.overlay.instances;
                var overDiv,fromParent=false;
                if(overDivs && overDivs.length>0){
                    overDiv = overDivs[overDivs.length-1];
                }else{
                    overDivs = parent.$.ui.dialog.overlay.instances;
                    if(overDivs && overDivs.length>0){
                        overDiv = overDivs[overDivs.length-1];
                        fromParent = true;
                    }
                }
                if(overDiv){
                    if(isHide){
                        overDiv.css('display','none');
                        if(!fromParent){
                            $([document, window]).unbind($.ui.dialog.overlay.events);
                        }else{
                            parent.$([parent.document, parent.window]).unbind(parent.$.ui.dialog.overlay.events);
                        }
                    }else{
                        overDiv.css('display','block');
                        if(!fromParent){
                            $(document).bind($.ui.dialog.overlay.events, function(event) {
                                if ($(event.target).zIndex() < $.ui.dialog.overlay.maxZ) {
                                    return false;
                                }
                            });
                        }else{
                            parent.$(document).bind(parent.$.ui.dialog.overlay.events, function(event) {
                                if ($(event.target).zIndex() < parent.$.ui.dialog.overlay.maxZ) {
                                    return false;
                                }
                            });
                        }
                    }
                }
                //overDiv = parent.$(".ui-widget-overlay");
            },
            BASEisNotNum:function (theNum) {
                //
                for (var i = 0; i < theNum.length; i++) {
                    oneNum = theNum.substring(i, i + 1);
                    if (oneNum < "0" || oneNum > "9")
                        return true;
                }
                return false;

            },
            //
            addWaterfall:function(outterDiv){
                var waterfall = $(document.createElement("div"));
                        waterfall.css( {
                            "height" : "100%",
                            "width" : "100%",
                            "filter" : "alpha(opacity = 50)",
                            "-moz-opacity" : "0.1",
                            "opacity" : "0.1",
                            "background-color" : "#fff",
                            "position" : "absolute",
                            "left" : "0px",
                            "top" : "0px",
                            "display":"none"
                        });
                        $(waterfall).appendTo(outterDiv);
                        $(waterfall).bind('click',function(){
                            $(this).hide();
                        });
                 return $(waterfall);
    }
        });

        waf.window.defaults = {
            minHeight:0,
            minWidth:250,
            height:'auto',
            width:300,
            method:'POST',
            modal:true,
            openType:'iframe',
            //position : 'center',
            autoOpen:true,
            closeOnEscape:true,
            single:true,
            title:'',
            show:null,
            hide:'slide',
            iconCls:"waf-ui-icon",
            minMixBtn:true,
            showTitleBar:true,
            openFromParent:false,
            autoMax:false,
            hideCloseBtn:false
        };


    }(jQuery));
//});


/**
 * @license jqGrid  4.3.3  - jQuery Grid
 * Copyright (c) 2008, Tony Tomov, tony@trirand.com
 * Dual licensed under the MIT and GPL licenses
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl-2.0.html
 * Date: 2012-05-31
 */

//mod.defineModule("gridbase", ["base","waf","jlinq","hogan","grid_i18n","block"],function(){
    (function ($) {
        "use strict";
        $.wafGrid = $.jgrid = $.jgrid || {};

        $.fn.jqGrid = function (pin) {
            if (typeof pin == 'string') {
                var fn = $.jgrid.getAccessor($.fn.jqGrid, pin);
                if (!fn) {
                    throw ("wafGrid - No such method: " + pin);
                }
                var args = $.makeArray(arguments).slice(1);
                return fn.apply(this, args);
            }
            return this.each(function () {
                if (this.grid) {
                    return;
                }
                if (this.tagName.toUpperCase() != 'TABLE') {
                    alert("Element is not a table");
                    return;
                }

                var p = $.extend(true, {
                    url:"",
                    height:150,
                    page:1,
                    rowNum:20,
                    rowTotal:null,
                    records:0,
                    pager:"",
                    pagerModel:"traditional",
                    pagerpos:'right',
                    pageTemplate:null,
                    pgbuttons:5,
                    pginput:true,
                    colModel:[],
                    rowList:[],
                    colNames:[],
                    sortorder:"asc",
                    sortname:"",
                    datatype:"xml",
                    mtype:"GET",
                    altRows:true,
                    selarrrow:[],
                    savedRow:[],
                    shrinkToFit:true,
                    xmlReader:{},
                    jsonReader:{},
                    subGrid:false,
                    subGridModel:[],
                    reccount:0,
                    lastpage:0,
                    lastsort:0,
                    selrow:null,
                    beforeSelectRow:null,
                    onSelectRow:null,
                    onSortCol:null,
                    ondblClickRow:null,
                    onRightClickRow:null,
                    onPaging:null,
                    onSelectAll:null,
                    loadComplete:null,
                    gridComplete:null,
                    loadError:null,
                    loadBeforeSend:null,
                    afterInsertRow:null,
                    beforeRequest:null,
                    beforeProcessing:null,
                    onHeaderClick:null,
                    viewrecords:false,
                    loadonce:false,
                    multiselect:false,
                    ctrlkey:false,
                    multiboxonly:false,
                    editurl:null,
                    search:false,
                    caption:"",
                    hidegrid:true,
                    hiddengrid:false,
                    postData:{},
                    userData:{},
                    treeGrid:false,
                    treeGridModel:'nested',
                    treeReader:{},
                    treeANode:-1,
                    ExpandColumn:null,
                    tree_root_level:0,
                    prmNames:{page:"page", rows:"rows", sort:"sidx", order:"sord", search:"_search", nd:"nd", id:"id", oper:"oper", editoper:"edit", addoper:"add", deloper:"del", subgridid:"id", npage:null, totalrows:"totalrows"},
                    forceFit:true, //modify by jlg
                    gridstate:"visible",
                    editable:null,
                    cellsubmit:"clientArray",
                    editModel:"cellEdit",
                    editModelOptions:{},
                    nv:0,
                    loadui:"enable",
                    toolbar:[false, ""],
                    scroll:false,
                    deselectAfterSort:true,
                    scrollrows:false,
                    autowidth:true, //modify by jlg
                    scrollOffset:18,
                    cellLayout:5,
                    subGridWidth:20,
                    multiselectWidth:20,
                    gridview:false,
                    rownumOption:{width:25},
                    rownumbers:true, //modify by jlg
                    recordpos:'center', //modify by jlg
                    footerrow:false,
                    userDataOnFooter:false,
                    hoverrows:true,
                    altclass:'ui-priority-secondary',
                    viewsortcols:[false, 'horizontal', true],
                    resizeclass:'',
                    autoencode:false,
                    remapColumns:[],
                    ajaxGridOptions:{},
                    direction:"ltr",
                    toppager:false,
                    headertitles:false,
                    scrollTimeout:40,
                    data:[],
                    _index:{},
                    grouping:false,
                    groupingView:{groupField:[], groupOrder:[], groupText:[], groupColumnShow:[], groupSummary:[], showSummaryOnHide:false, sortitems:[], sortnames:[], groupDataSorted:false, summary:[], summaryval:[], plusicon:'ui-icon-circlesmall-plus', minusicon:'ui-icon-circlesmall-minus'},
                    ignoreCase:false,
                    cmTemplate:{},
                    idPrefix:"",
                    loadInit:true,
                    saveWhenSubmit:true,
                    entryProp:"entrys",
                    tabindex:"0",
                    saveAllHidden:false,
                    filterEmptyRow:true,
                    keyOptions:{},
                    afterCreateGrid:null,
                    beforeReloadGrid:null,
                    tagClass:"",
                    style:"",
                    hidden:false,
                    autoSummary:true,
                    autoRowSpan:true,
                    breakLine:true,
                    customColModel:[],
                    defaultColModel:[],
                    gridConfig:false,
                    colGroup:{},
                    colGroupInfo:null
                }, $.jgrid.defaults, pin || {});
                var ts = this, grid = {
                    headers:[],
                    cols:[],
                    footers:[],
                    dragStart:function (i, x, y) {
                        this.resizing = { idx:i, startX:x.clientX, sOL:y[0]};
                        this.hDiv.style.cursor = "col-resize";
                        this.curGbox = $("#rs_m" + $.jgrid.jqID(p.id), "#gbox_" + $.jgrid.jqID(p.id));
                        this.curGbox.css({display:"block", left:y[0], top:y[1], height:y[2]});
                        $(ts).triggerHandler("jqGridResizeStart", [x, i]);
                        if ($.isFunction(p.resizeStart)) {
                            p.resizeStart.call(this, x, i);
                        }
                        document.onselectstart = function () {
                            return false;
                        };
                    },
                    dragMove:function (x) {
                        if (this.resizing) {
                            var diff = x.clientX - this.resizing.startX,
                                h = this.headers[this.resizing.idx],
                                newWidth = p.direction === "ltr" ? h.width + diff : h.width - diff, hn, nWn;
                            if (newWidth > 33) {
                                this.curGbox.css({left:this.resizing.sOL + diff});
                                if (p.forceFit === true) {
                                    hn = this.headers[this.resizing.idx + p.nv];
                                    nWn = p.direction === "ltr" ? hn.width - diff : hn.width + diff;
                                    if (nWn > 33) {
                                        h.newWidth = newWidth;
                                        hn.newWidth = nWn;
                                    }
                                } else {
                                    this.newWidth = p.direction === "ltr" ? p.tblwidth + diff : p.tblwidth - diff;
                                    h.newWidth = newWidth;
                                }
                            }
                        }
                    },
                    dragEnd:function () {
                        this.hDiv.style.cursor = "default";
                        if (this.resizing) {
                            var idx = this.resizing.idx,
                                nw = this.headers[idx].newWidth || this.headers[idx].width;
                            nw = parseInt(nw, 10);
                            this.resizing = false;
                            $("#rs_m" + $.jgrid.jqID(p.id)).css("display", "none");
                            p.colModel[idx].width = nw;
                            this.headers[idx].width = nw;
                            this.headers[idx].el.style.width = nw + "px";
                            this.cols[idx].style.width = nw + "px";
                            if (this.footers.length > 0) {
                                this.footers[idx].style.width = nw + "px";
                            }
                            if (p.forceFit === true) {
                                nw = this.headers[idx + p.nv].newWidth || this.headers[idx + p.nv].width;
                                this.headers[idx + p.nv].width = nw;
                                this.headers[idx + p.nv].el.style.width = nw + "px";
                                this.cols[idx + p.nv].style.width = nw + "px";
                                if (this.footers.length > 0) {
                                    this.footers[idx + p.nv].style.width = nw + "px";
                                }
                                p.colModel[idx + p.nv].width = nw;
                            } else {
                                p.tblwidth = this.newWidth || p.tblwidth;
                                $('table:first', this.bDiv).css("width", p.tblwidth + "px");
                                $('table:first', this.hDiv).css("width", p.tblwidth + "px");
                                this.hDiv.scrollLeft = this.bDiv.scrollLeft;
                                if (p.footerrow) {
                                    $('table:first', this.sDiv).css("width", p.tblwidth + "px");
                                    this.sDiv.scrollLeft = this.bDiv.scrollLeft;
                                }
                            }
                            $(ts).triggerHandler("jqGridResizeStop", [nw, idx]);

                            if ($.isFunction(p.resizeStop)) {
                                p.resizeStop.call(this, nw, idx);
                            }
                        }
                        this.curGbox = null;
                        document.onselectstart = function () {
                            return true;
                        };
                    },
                    populateVisible:function () {
                        if (grid.timer) {
                            clearTimeout(grid.timer);
                        }
                        grid.timer = null;
                        var dh = $(grid.bDiv).height();
                        if (!dh) {
                            return;
                        }
                        var table = $("table:first", grid.bDiv);
                        var rows, rh;
                        if (table[0].rows.length) {
                            try {
                                rows = table[0].rows[1];
                                rh = rows ? $(rows).outerHeight() || grid.prevRowHeight : grid.prevRowHeight;
                            } catch (pv) {
                                rh = grid.prevRowHeight;
                            }
                        }
                        if (!rh) {
                            return;
                        }
                        grid.prevRowHeight = rh;
                        var rn = p.rowNum;
                        var scrollTop = grid.scrollTop = grid.bDiv.scrollTop;
                        var ttop = Math.round(table.position().top) - scrollTop;
                        var tbot = ttop + table.height();
                        var div = rh * rn;
                        var page, npage, empty;
                        if (tbot < dh && ttop <= 0 &&
                            (p.lastpage === undefined || parseInt((tbot + scrollTop + div - 1) / div, 10) <= p.lastpage)) {
                            npage = parseInt((dh - tbot + div - 1) / div, 10);
                            if (tbot >= 0 || npage < 2 || p.scroll === true) {
                                page = Math.round((tbot + scrollTop) / div) + 1;
                                ttop = -1;
                            } else {
                                ttop = 1;
                            }
                        }
                        if (ttop > 0) {
                            page = parseInt(scrollTop / div, 10) + 1;
                            npage = parseInt((scrollTop + dh) / div, 10) + 2 - page;
                            empty = true;
                        }
                        if (npage) {
                            if (p.lastpage && page > p.lastpage || p.lastpage == 1 || (page === p.page && page === p.lastpage)) {
                                return;
                            }
                            if (grid.hDiv.loading) {
                                grid.timer = setTimeout(grid.populateVisible, p.scrollTimeout);
                            } else {
                                p.page = page;
                                if (empty) {
                                    grid.selectionPreserver(table[0]);
                                    grid.emptyRows(grid.bDiv, false, false);
                                }
                                grid.populate(npage);//add by jlg.savedRow.
                            }
                        }
                    },
                    scrollGrid:function (e) {
                        if (p.scroll) {
                            var scrollTop = grid.bDiv.scrollTop;
                            if (grid.scrollTop === undefined) {
                                grid.scrollTop = 0;
                            }
                            if (scrollTop != grid.scrollTop) {
                                grid.scrollTop = scrollTop;
                                if (grid.timer) {
                                    clearTimeout(grid.timer);
                                }
                                grid.timer = setTimeout(grid.populateVisible, p.scrollTimeout);
                            }
                        }
                        grid.hDiv.scrollLeft = grid.bDiv.scrollLeft;
                        if (p.footerrow) {
                            grid.sDiv.scrollLeft = grid.bDiv.scrollLeft;
                        }
                        if (e) {
                            e.stopPropagation();
                        }
                    },
                    selectionPreserver:function (ts) {
                        var p = ts.p,
                            sr = p.selrow, sra = p.selarrrow ? $.makeArray(p.selarrrow) : null,
                            left = ts.grid.bDiv.scrollLeft,
                            restoreSelection = function () {
                                var i;
                                p.selrow = null;
                                p.selarrrow = [];
                                if (p.multiselect && sra && sra.length > 0) {
                                    for (i = 0; i < sra.length; i++) {
                                        if (sra[i] != sr) {
                                            $(ts).jqGrid("setSelection", sra[i], false, null);
                                        }
                                    }
                                }
                                if (sr) {
                                    $(ts).jqGrid("setSelection", sr, false, null);
                                }
                                ts.grid.bDiv.scrollLeft = left;
                                $(ts).unbind('.selectionPreserver', restoreSelection);
                            };
                        $(ts).bind('jqGridGridComplete.selectionPreserver', restoreSelection);
                    }
                };
                this.p = p;
                this.p.id = this.id;
                this.p.useProp = !!$.fn.prop;
                var gv,eg,isMSIE = $.browser.msie ? true : false;
                var hg = (ts.p.caption && ts.p.hiddengrid === true) ? true : false;
                var dir = ts.p.direction;

                var intNum = function (val, defval) {
                    val = parseInt(val, 10);
                    if (isNaN(val)) {
                        return defval ? defval : 0;
                    }
                    else {
                        return val;
                    }
                },
                    formatCol = function (pos, rowInd, tv, rawObject, rowId, rdata) {
                        var cm = ts.p.colModel[pos],
                            ral = cm.align, result = "style=\"", clas = cm.classes, nm = cm.name, celp, acp = [];
                        if (ral) {
                            result += "text-align:" + ral + ";";
                        }
                        if (cm.hidden === true) {
                            result += "display:none;";
                        }
                        if (rowInd === 0) {
                            result += "width: " + grid.headers[pos].width + "px;"; //modify by jlg on 2013-6-5
                        } else if (cm.cellattr && $.isFunction(cm.cellattr)) {
                            celp = cm.cellattr.call(ts, rowId, tv, rawObject, cm, rdata);
                            if (celp && typeof(celp) === "string") {
                                celp = celp.replace(/style/i, 'style').replace(/title/i, 'title');
                                if (celp.indexOf('title') > -1) {
                                    cm.title = false;
                                }
                                if (celp.indexOf('class') > -1) {
                                    clas = undefined;
                                }
                                acp = celp.split("style");
                                if (acp.length === 2) {
                                    acp[1] = $.trim(acp[1].replace("=", ""));
                                    if (acp[1].indexOf("'") === 0 || acp[1].indexOf('"') === 0) {
                                        acp[1] = acp[1].substring(1);
                                    }
                                    result += acp[1].replace(/'/gi, '"');
                                } else {
                                    result += "\"";
                                }
                            }
                        }
                        if (!acp.length) {
                            acp[0] = "";
                            result += "\"";
                        }
                        result += (clas !== undefined ? (" class=\"" + clas + "\"") : "") + ((cm.title && tv) ? (" title=\"" + $.jgrid.stripHtml(tv) + "\"") : "");
                        result += " aria-describedby=\"" + ts.p.id + "_" + nm + "\"";
                        result += " oripos=\"" + pos + "\""; //add by jlg,posmouseover
                        return result + acp[0];
                    },
                    cellVal = function (val) {
                        return val === undefined || val === null || val === "" ? "&#160;" : (ts.p.autoencode ? $.jgrid.htmlEncode(val) : val + "");
                    },
                    formatter = function (rowId, cellval, colpos, rwdat, _act) {
                        var cm = ts.p.colModel[colpos], v;
                        var cellEditorConfig;
                        if (ts.p.cellEdit === true && $.isFunction(ts.p.formatCellEditor)) {
                            ts.p.formatCellEditor.call(ts, rowId, cm.name, cellval, colpos, rwdat);
                            cellEditorConfig = $(ts).jqGrid("getCellConfig", cm.name, rowId);
                        } else {
                            cellEditorConfig = $(ts).jqGrid("getCellConfig", cm.name, rowId);
                        }
                        if (typeof cm.formatter !== 'undefined' || (cellEditorConfig && cellEditorConfig.formatter)) {
                            var colModel = $.extend(true, {}, cm);
                            if (cellEditorConfig) {
                                $.extend(true, colModel, cellEditorConfig);
                            }
                            var opts = {rowId:rowId, colModel:colModel, gid:ts.p.id, pos:colpos };
                            if ($.isFunction(cm.formatter)) {
                                v = cm.formatter.call(ts, cellval, opts, rwdat, _act);
                            } else if ($.fmatter) {
                                var formatterStr = cm.formatter;
                                if (cellEditorConfig && cellEditorConfig.formatter) {
                                    formatterStr = cellEditorConfig.formatter;
                                }
                                v = $.fn.fmatter(formatterStr, cellval, opts, rwdat, _act, ts.p.id);//modify by jlg
                            } else {
                                v = cellVal(cellval);
                            }
                        } else {
                            v = cellVal(cellval);
                        }
                        return v;
                    },
                    addCell = function (rowId, cell, pos, irow, srvr) {
                        var v, prp, clazz = "";
                        v = formatter(rowId, cell, pos, srvr, 'add');
                        prp = formatCol(pos, irow, v, srvr, rowId, true);
                        clazz = formatClass(pos, irow, v, srvr, rowId);
                        return "<td role=\"gridcell\" " + clazz + " " + prp + ">" + v + "</td>";
                    },
                    formatClass = function(pos, irow, v, srvr, rowId){
                        return ts.p.colModel[pos].tagClass?"class='"+ts.p.colModel[pos].tagClass+"'" : "";
                    },
                    addMulti = function (rowid, pos, irow) {
                        var v = "<input role=\"checkbox\" type=\"checkbox\"" + " id=\"jqg_" + ts.p.id + "_" + rowid + "\" class=\"cbox\" name=\"jqg_" + ts.p.id + "_" + rowid + "\"/>",
                            prp = formatCol(pos, irow, '', null, rowid, true);
                        return "<td role=\"gridcell\" " + prp + ">" + v + "</td>";
                    },
                    addRowNum = function (pos, irow, pG, rN,rowId,srvr) {
                        var v = (parseInt(pG, 10) - 1) * parseInt(rN, 10) + 1 + irow,
                            v = formatter(rowId, v, pos, srvr, 'add'),
                            prp = formatCol(pos, irow, v, null, irow, true);
                        return "<td role=\"gridcell\" class=\"jqgrid-rownum\" " + prp + ">" + v + "</td>";
                    },
                    reader = function (datatype) {
                        var field, f = [], j = 0, i;
                        for (i = 0; i < ts.p.colModel.length; i++) {
                            field = ts.p.colModel[i];
                            if (field.name !== 'cb' && field.name !== 'subgrid' && field.name !== 'rn') {
                                f[j] = datatype == "local" ?
                                    field.name :
                                    ( (datatype == "xml" || datatype === "xmlstring") ? field.xmlmap || field.name : field.jsonmap || field.name );
                                j++;
                            }
                        }
                        return f;
                    },
                    orderedCols = function (offset) {
                        var order = ts.p.remapColumns;
                        if (!order || !order.length) {
                            order = $.map(ts.p.colModel, function (v, i) {
                                return i;
                            });
                        }
                        if (offset) {
                            order = $.map(order, function (v) {
                                return v < offset ? null : v - offset;
                            });
                        }
                        return order;
                    },
                    emptyRows = function (parent, scroll, locdata) {
                        if (ts.p.deepempty) {
                            $("#" + $.jgrid.jqID(ts.p.id) + " tbody:first tr:gt(0)").remove();
                        }
                        else {
                            var trf = $("#" + $.jgrid.jqID(ts.p.id) + " tbody:first tr:first")[0];
                            $("#" + $.jgrid.jqID(ts.p.id) + " tbody:first").empty().append(trf);
                        }
                        if (scroll && ts.p.scroll) {
                            $(">div:first", parent).css({height:"auto"}).children("div:first").css({height:0, display:"none"});
                            parent.scrollTop = 0;
                        }
                        if (locdata === true) {
                            if (ts.p.treeGrid === true) {
                                ts.p.data = [];
                                ts.p._index = {};
                            }
                        }
                    },
                    refreshIndex = function () {
                        var datalen = ts.p.data.length, idname, i, val,
                            ni = ts.p.rownumbers === true ? 1 : 0,
                            gi = ts.p.multiselect === true ? 1 : 0,
                            si = ts.p.subGrid === true ? 1 : 0;

                        if (ts.p.keyIndex === false || ts.p.loadonce === true) {
                            idname = ts.p.localReader.id;
                        } else {
                            idname = ts.p.colModel[ts.p.keyIndex + gi + si + ni].name;
                        }
                        for (i = 0; i < datalen; i++) {
                            val = $.jgrid.getAccessor(ts.p.data[i], idname);
                            ts.p._index[val] = i;
                        }
                    },
                    constructTr = function (id, hide, altClass, rd, cur) {
                        var tabindex = '-1', restAttr = '', attrName, style = hide ? 'display:none;' : '',
                            classes = 'ui-widget-content jqgrow ui-row-' + ts.p.direction + altClass + "",
                            rowAttrObj = $.isFunction(ts.p.rowattr) ? ts.p.rowattr.call(ts, rd, cur) : {};
                        if (!$.isEmptyObject(rowAttrObj)) {
                            if (rowAttrObj.hasOwnProperty("id")) {
                                id = rowAttrObj.id;
                                delete rowAttrObj.id;
                            }
                            if (rowAttrObj.hasOwnProperty("tabindex")) {
                                tabindex = rowAttrObj.tabindex;
                                delete rowAttrObj.tabindex;
                            }
                            if (rowAttrObj.hasOwnProperty("style")) {
                                style += rowAttrObj.style;
                                delete rowAttrObj.style;
                            }
                            if (rowAttrObj.hasOwnProperty("class")) {
                                classes += ' ' + rowAttrObj['class'];
                                delete rowAttrObj['class'];
                            }
                            // dot't allow to change role attribute
                            try {
                                delete rowAttrObj.role;
                            } catch (ra) {
                            }
                            for (attrName in rowAttrObj) {
                                if (rowAttrObj.hasOwnProperty(attrName)) {
                                    restAttr += ' ' + attrName + '=' + rowAttrObj[attrName];
                                }
                            }
                        }
                        return '<tr role="row" id="' + id + '" tabindex="' + tabindex + '" class="' + classes + '"' +
                            (style === '' ? '' : ' style="' + style + '"') + restAttr + '>';
                    },
                    needClear = function(){
                        return (ts.p.pagerModel =="traditional"||ts.p.pagerModel =="block") && !ts.p.scroll;
                    },
                    addJSONData = function (data, t, rcnt, more, adjust) {
                        var startReq = new Date();
                        if (data) {
//                        if (ts.p.treeANode === -1 && !ts.p.scroll) {
                            if (ts.p.treeANode === -1 && needClear()) {
                                emptyRows(t, false, true);
                                rcnt = 1;
                            } else {
                                rcnt = rcnt > 1 ? rcnt : 1;
                            }
                        } else {
                            return;
                        }

                        var dReader, locid = "_id_", frd, filterSpecialChar,
                            locdata = (ts.p.datatype != "local" && ts.p.loadonce) || ts.p.datatype == "jsonstring";
                        if (locdata) {
                            ts.p.data = [];
                            ts.p._index = {};
                            ts.p.localReader.id = locid;
                        }
                        ts.p.reccount = 0;
                        if (ts.p.datatype == "local") {
                            dReader = ts.p.localReader;
                            frd = 'local';
                        } else {
                            dReader = ts.p.jsonReader;
                            frd = 'json';
                        }
                        var ir = 0, v, i, j, f = [], F, cur, rp = (ts.p.autoRowSpan && ts.p.rowSpanCols &&  ts.p.rowSpanCols.length>0), gi = ts.p.multiselect ? 1 : 0, si = ts.p.subGrid ? 1 : 0, ni = ts.p.rownumbers === true ? 1 : 0, len, drows, idn, rd = {}, fpos, idr, rowData = [], cn = (ts.p.altRows === true) ? " " + ts.p.altclass : "", cn1, lp;
                        ts.p.page = $.jgrid.getAccessor(data, dReader.page) || 0;
                        lp = $.jgrid.getAccessor(data, dReader.total);
                        ts.p.lastpage = lp === undefined ? 1 : lp;
                        ts.p.records = $.jgrid.getAccessor(data, dReader.records) || 0;
                        ts.p.userData = $.jgrid.getAccessor(data, dReader.userdata) || {};
                        if (!dReader.repeatitems) {
                            F = f = reader(frd);
                        }
                        if (ts.p.keyIndex === false) {
                            idn = $.isFunction(dReader.id) ? dReader.id.call(ts, data) : dReader.id;
                        } else {
                            idn = ts.p.keyIndex;
                        }
                        if (f.length > 0 && !isNaN(idn)) {
                            if (ts.p.remapColumns && ts.p.remapColumns.length) {
                                idn = $.inArray(idn, ts.p.remapColumns);
                            }
                            idn = f[idn];
                        }
                        drows = $.jgrid.getAccessor(data, dReader.root);
                        if (!drows) {
                            drows = [];
                        }
                        len = drows.length;
                        i = 0;
                        if (len > 0 && ts.p.page <= 0) {
                            ts.p.page = 1;
                        }
                        var rn = parseInt(ts.p.rowNum, 10), br = ts.p.scroll ? $.jgrid.randId() : 1, altr;
                        if (adjust) {
                            rn *= adjust + 1;
                        }
                        var afterInsRow = $.isFunction(ts.p.afterInsertRow), grpdata = [], hiderow = ts.p.grouping && ts.p.groupingView.groupCollapse === true;
                        while (i < len) {
                            cur = drows[i];
                            idr = $.jgrid.getAccessor(cur, idn);
                            if (idr === undefined) {
                                idr = br + i;
                                if (f.length === 0) {
                                    if (dReader.cell) {
                                        var ccur = $.jgrid.getAccessor(cur, dReader.cell);
                                        idr = ccur !== undefined ? ccur[idn] || idr : idr;
                                        ccur = null;
                                    }
                                }
                            }
                            idr = ts.p.idPrefix + idr;
                            altr = rcnt === 1 ? 0 : rcnt;
                            cn1 = (altr + i) % 2 == 1 ? cn : '';
                            var iStartTrTag = rowData.length;
                            rowData.push("");
                            if (ni) {
//                            rowData.push(addRowNum(0, i, ts.p.page, ts.p.rowNum));
                                rowData.push(addRowNum(0, i, ts.p.page, ts.p.rowNum,idr,cur));
                            }
                            if (gi) {
                                rowData.push(addMulti(idr, ni, i));
                            }
                            if (si) {
                                rowData.push($(ts).jqGrid("addSubGridCell", gi + ni, i + rcnt));
                            }
                            if (dReader.repeatitems) {
                                if (dReader.cell) {
                                    cur = $.jgrid.getAccessor(cur, dReader.cell);
                                }
                                if (!F) {
                                    F = orderedCols(gi + si + ni);
                                }
                            }
                            //
                            for (j = 0; j < F.length; j++) {
                                v = $.jgrid.getAccessor(cur, F[j]);
                                v = $.jgrid.filterSpecialChar(ts.p.colModel[j + gi + si + ni], v);
                                rowData.push(addCell(idr, v, j + gi + si + ni, i + rcnt, cur));
                                rd[ts.p.colModel[j + gi + si + ni].name] = v;
                            }
                            rowData[iStartTrTag] = constructTr(idr, hiderow, cn1, rd, cur);
                            rowData.push("</tr>");
                            if (ts.p.grouping) {
                                grpdata = $(ts).jqGrid('groupingPrepare', rowData, grpdata, rd, i);
                                rowData = [];
                            }
                            //
                            if(rp){
                                $(ts).jqGrid('rowSpanPrepare', cur, drows, i, idr)
                            }
                            if (locdata || ts.p.treeGrid === true) {
                                rd[locid] = idr;
                                ts.p.data.push(rd);
                                ts.p._index[idr] = ts.p.data.length - 1;
                            }
                            if (ts.p.gridview === false) {
                                $("#" + $.jgrid.jqID(ts.p.id) + " tbody:first").append(rowData.join(''));
                                $(ts).triggerHandler("jqGridAfterInsertRow", [idr, rd, cur]);
                                if (afterInsRow) {
                                    ts.p.afterInsertRow.call(ts, idr, rd, cur);
                                }
                                rowData = [];//ari=0;
                            }
                            rd = {};
                            ir++;
                            i++;
                            //add by jlg.
                            var hasPager = (ts.p.pager && ts.p.pager.length > 0) || (ts.p.scroll === true);
                            if (ir == rn && hasPager) {
                                break;
                            }
                        }
                        if (ts.p.gridview === true) {
                            fpos = ts.p.treeANode > -1 ? ts.p.treeANode : 0;
                            if (ts.p.grouping) {
                                $(ts).jqGrid('groupingRender', grpdata, ts.p.colModel.length);
                                grpdata = null;
                            } else if (ts.p.treeGrid === true && fpos > 0) {
                                $(ts.rows[fpos]).after(rowData.join(''));
                            } else {
                                $("#" + $.jgrid.jqID(ts.p.id) + " tbody:first").append(rowData.join(''));
                            }
                        }
                        if (ts.p.subGrid === true) {
                            try {
                                $(ts).jqGrid("addSubGrid", gi + ni);
                            } catch (_) {
                            }
                        }
                        ts.p.totaltime = new Date() - startReq;
                        if (ir > 0) {
                            if (ts.p.records === 0) {
                                ts.p.records = len;
                            }
                        }
                        rowData = null;
                        if (ts.p.treeGrid === true) {
                            try {
                                $(ts).jqGrid("setTreeNode", fpos + 1, ir + fpos + 1);
                            } catch (e) {
                            }
                        }
                        if (!ts.p.treeGrid && !ts.p.scroll && ts.p.pagerModel!="scroll") {
                            ts.grid.bDiv.scrollTop = 0;
                        }
                        ts.p.reccount = ir;
                        ts.p.treeANode = -1;
                        if (ts.p.userDataOnFooter) {
                            $(ts).jqGrid("footerData", "set", ts.p.userData, true);
                        }
                        if (locdata) {
                            ts.p.records = len;
                            ts.p.lastpage = Math.ceil(len / rn);
                        }
                        if (!more) {
                            ts.updatepager(false, true);
                        }
                        if (locdata) {
                            while (ir < len && drows[ir]) {
                                cur = drows[ir];
                                idr = $.jgrid.getAccessor(cur, idn);
                                if (idr === undefined) {
                                    idr = br + ir;
                                    if (f.length === 0) {
                                        if (dReader.cell) {
                                            var ccur2 = $.jgrid.getAccessor(cur, dReader.cell);
                                            idr = ccur2[idn] || idr;
                                            ccur2 = null;
                                        }
                                    }
                                }
                                if (cur) {
                                    idr = ts.p.idPrefix + idr;
                                    if (dReader.repeatitems) {
                                        if (dReader.cell) {
                                            cur = $.jgrid.getAccessor(cur, dReader.cell);
                                        }
                                        if (!F) {
                                            F = orderedCols(gi + si + ni);
                                        }
                                    }

                                    for (j = 0; j < F.length; j++) {
                                        v = $.jgrid.getAccessor(cur, F[j]);
                                        rd[ts.p.colModel[j + gi + si + ni].name] = v;
                                    }
                                    rd[locid] = idr;
                                    ts.p.data.push(rd);
                                    ts.p._index[idr] = ts.p.data.length - 1;
                                    rd = {};
                                }
                                ir++;
                            }
                        }
                    },
                    addLocalData = function () {
                        var st, fndsort = false, cmtypes = {}, grtypes = [], grindexes = [], srcformat, sorttype, newformat;
                        if (!$.isArray(ts.p.data)) {
                            return;
                        }
                        var grpview = ts.p.grouping ? ts.p.groupingView : false, lengrp, gin;
                        $.each(ts.p.colModel, function () {
                            sorttype = this.sorttype || "text";
                            if (sorttype == "date" || sorttype == "datetime") {
                                if (this.formatter && typeof(this.formatter) === 'string' && this.formatter == 'date') {
                                    if (this.formatoptions && this.formatoptions.srcformat) {
                                        srcformat = this.formatoptions.srcformat;
                                    } else {
                                        srcformat = $.jgrid.formatter.date.srcformat;
                                    }
                                    if (this.formatoptions && this.formatoptions.newformat) {
                                        newformat = this.formatoptions.newformat;
                                    } else {
                                        newformat = $.jgrid.formatter.date.newformat;
                                    }
                                } else {
                                    srcformat = newformat = this.datefmt || "Y-m-d";
                                }
                                cmtypes[this.name] = {"stype":sorttype, "srcfmt":srcformat, "newfmt":newformat};
                            } else {
                                cmtypes[this.name] = {"stype":sorttype, "srcfmt":'', "newfmt":''};
                            }
                            if (ts.p.grouping) {
                                for (gin = 0, lengrp = grpview.groupField.length; gin < lengrp; gin++) {
                                    if (this.name == grpview.groupField[gin]) {
                                        var grindex = this.name;
                                        if (typeof this.index != 'undefined') {
                                            grindex = this.index;
                                        }
                                        grtypes[gin] = cmtypes[grindex];
                                        grindexes[gin] = grindex;
                                    }
                                }
                            }
                            if (!fndsort && (this.index == ts.p.sortname || this.name == ts.p.sortname)) {
                                st = this.name; // ???
                                fndsort = true;
                            }
                        });
                        if (ts.p.treeGrid) {
                            $(ts).jqGrid("SortTree", st, ts.p.sortorder, cmtypes[st].stype, cmtypes[st].srcfmt);
                            return;
                        }
                        var compareFnMap = {
                            'eq':function (queryObj) {
                                return queryObj.equals;
                            },
                            'ne':function (queryObj) {
                                return queryObj.notEquals;
                            },
                            'lt':function (queryObj) {
                                return queryObj.less;
                            },
                            'le':function (queryObj) {
                                return queryObj.lessOrEquals;
                            },
                            'gt':function (queryObj) {
                                return queryObj.greater;
                            },
                            'ge':function (queryObj) {
                                return queryObj.greaterOrEquals;
                            },
                            'cn':function (queryObj) {
                                return queryObj.contains;
                            },
                            'nc':function (queryObj, op) {
                                return op === "OR" ? queryObj.orNot().contains : queryObj.andNot().contains;
                            },
                            'bw':function (queryObj) {
                                return queryObj.startsWith;
                            },
                            'bn':function (queryObj, op) {
                                return op === "OR" ? queryObj.orNot().startsWith : queryObj.andNot().startsWith;
                            },
                            'en':function (queryObj, op) {
                                return op === "OR" ? queryObj.orNot().endsWith : queryObj.andNot().endsWith;
                            },
                            'ew':function (queryObj) {
                                return queryObj.endsWith;
                            },
                            'ni':function (queryObj, op) {
                                return op === "OR" ? queryObj.orNot().equals : queryObj.andNot().equals;
                            },
                            'in':function (queryObj) {
                                return queryObj.equals;
                            },
                            'nu':function (queryObj) {
                                return queryObj.isNull;
                            },
                            'nn':function (queryObj, op) {
                                return op === "OR" ? queryObj.orNot().isNull : queryObj.andNot().isNull;
                            }

                        },
                            query = $.jgrid.from(ts.p.data);
                        if (ts.p.ignoreCase) {
                            query = query.ignoreCase();
                        }
                        function tojLinq(group) {
                            var s = 0, index, gor, ror, opr, rule;
                            if (group.groups !== undefined) {
                                gor = group.groups.length && group.groupOp.toString().toUpperCase() === "OR";
                                if (gor) {
                                    query.orBegin();
                                }
                                for (index = 0; index < group.groups.length; index++) {
                                    if (s > 0 && gor) {
                                        query.or();
                                    }
                                    try {
                                        tojLinq(group.groups[index]);
                                    } catch (e) {
                                        alert(e);
                                    }
                                    s++;
                                }
                                if (gor) {
                                    query.orEnd();
                                }
                            }
                            if (group.rules !== undefined) {
                                if (s > 0) {
                                    var result = query.select();
                                    query = $.jgrid.from(result);
                                    if (ts.p.ignoreCase) {
                                        query = query.ignoreCase();
                                    }
                                }
                                try {
                                    ror = group.rules.length && group.groupOp.toString().toUpperCase() === "OR";
                                    if (ror) {
                                        query.orBegin();
                                    }
                                    for (index = 0; index < group.rules.length; index++) {
                                        rule = group.rules[index];
                                        opr = group.groupOp.toString().toUpperCase();
                                        if (compareFnMap[rule.op] && rule.field) {
                                            if (s > 0 && opr && opr === "OR") {
                                                query = query.or();
                                            }
                                            query = compareFnMap[rule.op](query, opr)(rule.field, rule.data, cmtypes[rule.field]);
                                        }
                                        s++;
                                    }
                                    if (ror) {
                                        query.orEnd();
                                    }
                                } catch (g) {
                                    alert(g);
                                }
                            }
                        }

                        if (ts.p.grouping) {
                            for (gin = 0; gin < lengrp; gin++) {
                                query.orderBy(grindexes[gin], grpview.groupOrder[gin], grtypes[gin].stype, grtypes[gin].srcfmt);
                            }
                            grpview.groupDataSorted = true;
                        }
                        if (st && ts.p.sortorder && fndsort) {
                            if (ts.p.sortorder.toUpperCase() == "DESC") {
                                query.orderBy(ts.p.sortname, "d", cmtypes[st].stype, cmtypes[st].srcfmt);
                            } else {
                                query.orderBy(ts.p.sortname, "a", cmtypes[st].stype, cmtypes[st].srcfmt);
                            }
                        }
                        var queryResults = query.select(),
                            recordsperpage = parseInt(ts.p.rowNum, 10),
                            total = queryResults.length,
                            page = parseInt(ts.p.page, 10),
                            retresult = {}, totalpages, hasPager = (ts.p.pager && ts.p.pager.length > 0) || (ts.p.scroll === true);
                        if (hasPager) {
                            totalpages = Math.ceil(total / recordsperpage);
                            queryResults = queryResults.slice((page - 1) * recordsperpage, page * recordsperpage);
                        } else {
                            totalpages = 1;
                        }
                        query = null;
                        cmtypes = null;
                        retresult[ts.p.localReader.total] = totalpages;
                        retresult[ts.p.localReader.page] = page;
                        retresult[ts.p.localReader.records] = total;
                        retresult[ts.p.localReader.root] = queryResults;
                        retresult[ts.p.localReader.userdata] = ts.p.userData;
                        queryResults = null;
                        return  retresult;
                    },
                    isInGrid = function(){
                        return ts.p.pagerpos === "left" || ts.p.pagerpos === "center" || ts.p.pagerpos === "right";
                    },
                    updatePagerTemplate = function(){
                        if(ts.p.pager){
                            var isGrid = isInGrid();
                            //pageTemplate
                            if(ts.p.pageTemplate && $.isArray(ts.p.pageTemplate) && ts.p.pageTemplate.length>0){
                                var len = ts.p.pageTemplate.length,tmp,fun,template,posContainer,
                                    container = $(ts.p.pager),te = $.wafutil.getTemplateEngine();
                                for(var i=0;i<len;i++) {
                                    tmp = ts.p.pageTemplate[i];
                                    for(var pos in tmp){
                                        //temp.pos
                                        if((pos=="right"||pos=="center"||pos=="left")){
                                            posContainer = $("td" + ts.p.pager + "_" + pos, container);
                                            posContainer.css("display","table-cell");
                                        }else{
                                            posContainer = $("#"+pos);
                                        }
                                        posContainer = (pos=="right"||pos=="center"||pos=="left")?$("td" + ts.p.pager + "_" + pos, container):$("#"+pos);
                                        posContainer.empty();
                                        template = tmp[pos];
                                        if(template){
                                            if(template.indexOf("#")==0||template.indexOf(".")==0){template = $(template).html();}
                                            fun = te.compile(template);
                                            template = te.render(fun,{page:ts.p.page,lastpage:ts.p.lastpage,records:ts.p.records,rowNum:ts.p.rowNum});
                                            posContainer.append(template);
                                        }
                                    }
                                }
                                te = null;
                                fun= null;
                                container=null;
                                posContainer=null;
                            }
                        }

                    },
                    updateTranPager = function(rn){
                        var cp, last, base, from, to, tot, fmt, pgboxes = "", sppg,
                            tspg = ts.p.pager ? "_" + $.jgrid.jqID(ts.p.pager.substr(1)) : "",
                            tspg_t = ts.p.toppager ? "_" + ts.p.toppager.substr(1) : "";
                        pgboxes = ts.p.pager ? ts.p.pager : "";
                        pgboxes += ts.p.toppager ? (pgboxes ? "," + ts.p.toppager : ts.p.toppager) : "";
                        if (pgboxes) {
                            fmt = $.jgrid.formatter.integer || {};
                            cp = intNum(ts.p.page);
                            last = intNum(ts.p.lastpage);
                            $(".selbox", pgboxes)[ ts.p.useProp ? 'prop' : 'attr' ]("disabled", false);
                            if (ts.p.pginput === true) {
                                $('.ui-pg-input', pgboxes).val(ts.p.page);
                                sppg = ts.p.toppager ? '#sp_1' + tspg + ",#sp_1" + tspg_t : '#sp_1' + tspg;
                                $(sppg).html($.fmatter ? $.fmatter.util.NumberFormat(ts.p.lastpage, fmt) : ts.p.lastpage);
                            }
                            if (ts.p.viewrecords) {
                                if (ts.p.reccount === 0) {
                                    $(".ui-paging-info", pgboxes).html(ts.p.emptyrecords);
                                } else {
                                    from = base + 1;
                                    tot = ts.p.records;
                                    if ($.fmatter) {
                                        from = $.fmatter.util.NumberFormat(from, fmt);
                                        to = $.fmatter.util.NumberFormat(to, fmt);
                                        tot = $.fmatter.util.NumberFormat(tot, fmt);
                                    }
                                    $(".ui-paging-info", pgboxes).html($.wafutil.format(ts.p.recordtext, from, to, tot));
                                }
                            }
                            //
                            if (cp <= 0) {
                                cp = last = 0;
                            }
                            if (cp == 1 || cp === 0) {
                                $("#first" + tspg + ", #prev" + tspg).addClass('ui-state-disabled').removeClass('ui-state-hover');
                                if (ts.p.toppager) {
                                    $("#first_t" + tspg_t + ", #prev_t" + tspg_t).addClass('ui-state-disabled').removeClass('ui-state-hover');
                                }
                            } else {
                                $("#first" + tspg + ", #prev" + tspg).removeClass('ui-state-disabled');
                                if (ts.p.toppager) {
                                    $("#first_t" + tspg_t + ", #prev_t" + tspg_t).removeClass('ui-state-disabled');
                                }
                            }
                            if (cp == last || cp === 0) {
                                $("#next" + tspg + ", #last" + tspg).addClass('ui-state-disabled').removeClass('ui-state-hover');
                                if (ts.p.toppager) {
                                    $("#next_t" + tspg_t + ", #last_t" + tspg_t).addClass('ui-state-disabled').removeClass('ui-state-hover');
                                }
                            } else {
                                $("#next" + tspg + ", #last" + tspg).removeClass('ui-state-disabled');
                                if (ts.p.toppager) {
                                    $("#next_t" + tspg_t + ", #last_t" + tspg_t).removeClass('ui-state-disabled');
                                }
                            }
                        }
                    },
                    updateVirtualPager = function(rn){
                        var cp, last, base, from, to, tot, fmt, pgboxes = "", sppg,
                            tspg = ts.p.pager ? "_" + $.jgrid.jqID(ts.p.pager.substr(1)) : "",
                            tspg_t = ts.p.toppager ? "_" + ts.p.toppager.substr(1) : "";
                        base = parseInt(ts.p.page, 10) - 1;
                        if (base < 0) {
                            base = 0;
                        }
                        base = base * parseInt(ts.p.rowNum, 10);
                        to = base + ts.p.reccount;
                        if (ts.p.scroll) {
                            var rows = $("tbody:first > tr:gt(0)", ts.grid.bDiv);
                            base = to - rows.length;
                            ts.p.reccount = rows.length;
                            var rh = rows.outerHeight() || ts.grid.prevRowHeight;
                            if (rh) {
                                var top = base * rh;
                                var height = parseInt(ts.p.records, 10) * rh;
                                $(">div:first", ts.grid.bDiv).css({height:height}).children("div:first").css({height:top, display:top ? "" : "none"});
                            }
                        }
                    },
                    getShowPage = function(currentPage,total){
                        var ret = [],index,buttons = ts.p.pgbuttons,avg=Math.round(buttons/2)-1,i;
                        $(ts.p.pager).find(".pn").each(function(i){
                            if($(this).hasClass("active")){
                                index = i+1;
                            }
                        });
                        if(currentPage==1||currentPage<=avg){
                            for(i=0;i<total && ret.length<buttons;i++){
                                ret.push(i+1);
                            }
                        }else{
                            if((currentPage)>avg){
                                //avg
                                for(i=1;i<=avg;i++){
                                    ret.push(currentPage-i);
                                }
                                ret.reverse();
                            }
                            if((total-currentPage)>avg){
                                //avg
                                for(i=0;i<=avg;i++){
                                    ret.push(currentPage+i);
                                }
                            }else{
                                for(i=currentPage;i<=total;i++){
                                    ret.push(i);
                                }
                                if(ret.length<buttons){
                                    //currentPagebuttons-ret.legnth
                                    i = ret[0];
                                    for(;(ret.length<buttons) && i>1;i--){
                                        ret.splice(0,0,(i-1));
                                    }
                                }
                            }
                        }
                        return ret;
                    },
                    updateBlockPager = function(rn,cp,last,container){
                        var range = getShowPage(ts.p.page,last),
                            fp = false,lp=false,active,
                            previous = container.find(".prev").parent("li");
                        container.find(".pn,.omit").remove();
                        if($.inArray(1,range)==-1){
                            previous = $("<li><span  class='ui-pg-button pn first'>"+1+"</span></li>").insertAfter(previous);
                            previous = $("<li><span  class='ui-pg-button omit'>...</span></li>").insertAfter(previous);
                        }
                        for(var i=0;i<range.length;i++){
                            if(range[i]==ts.p.page) {
                                active="active"
                            }else{
                                active = "";
                            }
                            previous = $("<li><span  class='ui-pg-button pn "+active+"'>"+range[i]+"</span></li>").insertAfter(previous);
                        }
                        if($.inArray(last,range)==-1){
                            previous = $("<li><span  class='ui-pg-button omit'>...</span></li>").insertAfter(previous);
                            previous = $("<li><span  class='ui-pg-button pn last'>"+last+"</span></li>").insertAfter(previous);
                        }
                        if(cp==1 || cp === 0) {
                            $(".prev",container).hide();
                        } else {
                            $(".prev",container).show();
                        }
                        if(cp==last || cp === 0) {
                            $(".next",container).hide();
                        } else {
                            $(".next",container).show();
                        }
                    },
                    updateRowNum = function(rn){
                        //rowNumber
                        var base = parseInt(ts.p.page, 10) - 1;
                        if (base < 0) {
                            base = 0;
                        }
                        base = base * parseInt(ts.p.rowNum, 10);
                        if (rn === true && ts.p.rownumbers === true) {
                            $("td.jqgrid-rownum", ts.rows).each(function (i) {
                                $(this).html(base + 1 + i);
                            });
                        }
                    },
                    updateEditStatus = function(){
                        if(ts.p.cellEdit){
                            ts.p.savedRow = [];
                            ts.p.iCol = undefined;
                            ts.p.iRow = undefined;
                        }
                    },
                    updatepager = function (rn, dnd) {
                        var cp = intNum(ts.p.page,1),
                            last = intNum(ts.p.lastpage,1),
                            container,timer;
                        if(isInGrid()){
                            container = $(ts.p.pager);
                        }else{
                            container = ts.p.pagerpos.indexOf("#")==0?$(ts.p.pagerpos):$("#"+ts.p.pagerpos);
                        }
                        if(cp<=0) {cp = last = 0;}
                        switch(ts.p.pagerModel){
                            case "traditional":
                                updateTranPager(rn);
                                break;
                            case "block":
                                updateBlockPager(rn,cp,last,container);
                                break;
                            case "more":
                                if(cp==last || cp==0){
                                    $(container).hide();
                                }else{
                                    $(container).show();
                                }
                                break;
                            case "scroll":
                                if(cp==last || cp==0){
                                    $(container).addClass("noMore").append($.jgrid.pager.noMoreDataText);
                                    window.clearTimeout(timer);
                                    timer = window.setTimeout(function(){container.hide();},3000);
                                }
                                break;
                            case "virtual":
                                updateVirtualPager(rn);
                                break;
                        }
                        updatePagerTemplate();
                        updateRowNum(rn);
                        updateEditStatus();
                        if (dnd && ts.p.jqgdnd) {
                            $(ts).jqGrid('gridDnD', 'updateDnD');
                        }
                        $(ts).triggerHandler("jqGridGridComplete");
                        if ($.isFunction(ts.p.gridComplete)) {
                            ts.p.gridComplete.call(ts);
                        }
                        $(ts).triggerHandler("jqGridAfterGridComplete");
                    },
                    beginReq = function () {
                        ts.grid.hDiv.loading = true;
                        if (ts.p.hiddengrid) {
                            return;
                        }
                        switch (ts.p.loadui) {
                            case "disable":
                                break;
                            case "enable":
                            case "block":
                                waf.block.show({target:$(ts).closest(".ui-jqgrid"),vPos:$(ts.grid.hDiv).height(),text:$.jgrid.defaults.loadtext});
                                break;
                        }
                    },
                    endReq = function () {
                        ts.grid.hDiv.loading = false;
                        switch (ts.p.loadui) {
                            case "disable":
                                break;
                            case "enable":
                            case "block":
                                waf.block.hide($(ts).closest(".ui-jqgrid"));
                                break;
                        }
                        //add by jlg.
                        if ($.isFunction(ts.p._endReq)) {
                            ts.p._endReq.call(ts);
                        }
                    },
                    populate = function (npage) {
                        if (!ts.grid.hDiv.loading) {
                            var pvis = ts.p.scroll && npage === false,
                                prm = {}, dt, dstr, pN = ts.p.prmNames;
                            if (ts.p.page <= 0) {
                                ts.p.page = 1;
                            }
                            if (pN.search !== null) {
                                prm[pN.search] = ts.p.search;
                            }
                            if (pN.nd !== null) {
                                prm[pN.nd] = new Date().getTime();
                            }
                            if (pN.rows !== null) {
                                prm[pN.rows] = ts.p.rowNum;
                            }
                            if (pN.page !== null) {
                                prm[pN.page] = ts.p.page;
                            }
                            if (pN.sort !== null) {
                                prm[pN.sort] = ts.p.sortname;
                            }
                            if (pN.order !== null) {
                                prm[pN.order] = ts.p.sortorder;
                            }
                            if (ts.p.rowTotal !== null && pN.totalrows !== null) {
                                prm[pN.totalrows] = ts.p.rowTotal;
                            }
                            //ts.p.pagerincludePager=false
                            prm["includePager"] = (ts.p.pager && ts.p.pager.length > 0) || (ts.p.scroll === true);
                            var lcf = $.isFunction(ts.p.loadComplete), lc = lcf ? ts.p.loadComplete : null;
                            var adjust = 0;
                            npage = npage || 1;
                            if (npage > 1) {
                                if (pN.npage !== null) {
                                    prm[pN.npage] = npage;
                                    adjust = npage - 1;
                                    npage = 1;
                                } else {
                                    lc = function (req) {
                                        ts.p.page++;
                                        ts.grid.hDiv.loading = false;
                                        if (lcf) {
                                            ts.p.loadComplete.call(ts, req);
                                        }
                                        populate(npage - 1);
                                    };
                                }
                            } else if (pN.npage !== null) {
                                delete ts.p.postData[pN.npage];
                            }
                            if (ts.p.grouping) {
                                $(ts).jqGrid('groupingSetup');
                                if (ts.p.groupingView.groupDataSorted === true) {
                                    prm[pN.sort] = ts.p.groupingView.groupField[0] + " " + ts.p.groupingView.groupOrder[0] + ", " + prm[pN.sort];
                                }
                            }
                            $.extend(ts.p.postData, prm);
                            var rcnt = !ts.p.scroll ? 1 : ts.rows.length - 1;
                            var bfr = $(ts).triggerHandler("jqGridBeforeRequest");
                            if (bfr === false || bfr === 'stop') {
                                return;
                            }
                            if ($.isFunction(ts.p.datatype)) {
                                ts.p.datatype.call(ts, ts.p.postData, "load_" + ts.p.id);
                                return;
                            }
                            else if ($.isFunction(ts.p.beforeRequest)) {
                                bfr = ts.p.beforeRequest.call(ts);
                                if (bfr === undefined) {
                                    bfr = true;
                                }
                                if (bfr === false) {
                                    return;
                                }
                            }
                            dt = ts.p.datatype.toLowerCase();
                            //add by jlg.
                            if (ts.p.loadInit === false || ts.p.loadInit === "false") {
                                $(ts).jqGrid("showNoRecords");
                                $("#pager" + ts.p.id).hide();
                                return;
                            }
                            //noRecordstr,
                            $("tr.norecord", ts).remove();
                            //end by jlg
                            switch (dt) {
                                case "json":
                                case "jsonp":
                                case "xml":
                                case "script":
                                    $.ajax($.extend({
                                        url:ts.p.url,
                                        type:ts.p.mtype,
                                        dataType:dt,
                                        data:$.isFunction(ts.p.serializeGridData) ? ts.p.serializeGridData.call(ts, ts.p.postData) : ts.p.postData,
                                        success:function (data, st, xhr) {
                                            if ($.isFunction(ts.p.beforeProcessing)) {
                                                if (ts.p.beforeProcessing.call(ts, data, st, xhr) === false) {
                                                    endReq();
                                                    return;
                                                }
                                            }
                                            addJSONData(data, ts.grid.bDiv, rcnt, npage > 1, adjust);
                                            $(ts).triggerHandler("jqGridLoadComplete", [data]);
                                            if (lc) {
                                                lc.call(ts, data);
                                            }
                                            $(ts).triggerHandler("jqGridAfterLoadComplete", [data]);
                                            if (pvis) {
                                                ts.grid.populateVisible();
                                            }
                                            if (ts.p.loadonce || ts.p.treeGrid) {
                                                ts.p.datatype = "local";
                                            }
                                            data = null;
                                            if (npage === 1) {
                                                endReq();
                                            }
                                        },
                                        error:function (xhr, st, err) {
                                            if ($.isFunction(ts.p.loadError)) {
                                                ts.p.loadError.call(ts, xhr, st, err);
                                            }
                                            if (npage === 1) {
                                                endReq();
                                            }
                                            xhr = null;
                                        },
                                        beforeSend:function (xhr, settings) {
                                            var gotoreq = true;
                                            if ($.isFunction(ts.p.loadBeforeSend)) {
                                                gotoreq = ts.p.loadBeforeSend.call(ts, xhr, settings);
                                            }
                                            if (gotoreq === undefined) {
                                                gotoreq = true;
                                            }
                                            if (gotoreq === false) {
                                                return false;
                                            } else {
                                                beginReq();
                                            }
                                        }
                                    }, $.jgrid.ajaxOptions, ts.p.ajaxGridOptions));
                                    break;
                                case "local":
                                case "clientside":
                                    beginReq();
                                    ts.p.datatype = "local";
                                    var req = addLocalData();
                                    if ($.isFunction(ts.p.beforeProcessing)) {
                                        if (ts.p.beforeProcessing.call(ts, req) === false) {
                                            endReq();
                                            return;
                                        }
                                    }
                                    addJSONData(req, ts.grid.bDiv, rcnt, npage > 1, adjust);
                                    $(ts).triggerHandler("jqGridLoadComplete", [req]);
                                    if (lc) {
                                        lc.call(ts, req);
                                    }
                                    $(ts).triggerHandler("jqGridAfterLoadComplete", [req]);
                                    if (pvis) {
                                        ts.grid.populateVisible();
                                    }
                                    endReq();
                                    break;
                            }
                        }
                    },
                    setHeadCheckBox = function (checked) {
                        $('#cb_' + $.jgrid.jqID(ts.p.id), ts.grid.hDiv)[ts.p.useProp ? 'prop' : 'attr']("checked", checked);
                        var fid = ts.p.frozenColumns ? ts.p.id + "_frozen" : "";
                        if (fid) {
                            $('#cb_' + $.jgrid.jqID(ts.p.id), ts.grid.fhDiv)[ts.p.useProp ? 'prop' : 'attr']("checked", checked);
                        }
                    },
                    clearVals = function(onpaging){
                        var ret;
                        if ($.isFunction(ts.p.onPaging)) {
                            ret = ts.p.onPaging.call(ts, onpaging);
                        }
                        ts.p.selrow = null;
                        if (ts.p.multiselect) {
                            ts.p.selarrrow = [];
                            setHeadCheckBox(false);
                        }
                        ts.p.savedRow = [];
                        if (ret == 'stop') {
                            return false;
                        }
                        return true;
                    },
                    loadPage = function(e,callback){
                        if (ts.p.beforeReloadGrid) {
                            var ret = ts.p.beforeReloadGrid.call(ts, ts);
                            if (undefined != ret && ret == false) {
                                if(callback&&$.isFunction(callback)) callback.call(ts);
                                return false;
                            }
                        }
                        var load = false,cp = intNum(ts.p.page, 1),
                            last = intNum(ts.p.lastpage, 1),fp = true, pp = true, np = true, lp = true;
                        if (last === 0 || last === 1) {fp = false;pp = false;np = false;lp = false;}
                        else if (last > 1 && cp >= 1) {
                            if (cp === 1) {fp = false;pp = false;}
                            else if (cp === last) {np = false;lp = false;}
                        } else if (last > 1 && cp === 0) {
                            np = false;lp = false;cp = last - 1;
                        }
                        if (($(e.target).hasClass("first") || ($.type.isString(e) && e=="first")) && fp) {ts.p.page = 1;load = true;}
                        if (($(e.target).hasClass("prev") || ($.type.isString(e) && e=="prev")) && pp) {ts.p.page = (cp - 1);load = true;}
                        if (($(e.target).hasClass("next") || ($.type.isString(e) && e=="next")) && np) {ts.p.page = (cp + 1);load = true;}
                        if (($(e.target).hasClass("last") || ($.type.isString(e) && e=="last")) && lp) {ts.p.page = last;load = true;}
                        if($(e.target).hasClass("ui-pg-input")){ts.p.page = ($(e.target).val() > 0) ? $(e.target).val() : ts.p.page;load=true;}
                        if($(e.target).hasClass("ui-pg-selbox")){
                            ts.p.page = Math.round(ts.p.rowNum * (ts.p.page - 1) / e.target.value - 0.5) + 1;
                            ts.p.rowNum = e.target.value;
                            if (ts.p.pager) {
                                $('.ui-pg-selbox', ts.p.pager).val(e.target.value);
                            }
                            if (ts.p.toppager) {
                                $('.ui-pg-selbox', ts.p.toppager).val(e.target.value);
                            }
                            load=true;
                        }else if( $(e.target).hasClass("pn")) {
                            $(".pager",ts.p.pager).find(".pn").removeClass("active");
                            ts.p.page=parseInt($(e.target).text());
                            $(e.target).addClass("active");
                            load = true;
                        }
                        if(load){
                            if (!clearVals('user')) {
                                return false;
                            }
                            populate();
                        }
                    },
                    createTranPager = function(container, inGrid){
                        var str = "",i,pgid = ts.p.pager.substr(1);
                        if(!ts.p.domcreated){
                            inGrid?$(ts.p.pager).addClass("ui-tran-pager"):$(container).addClass("ui-tran-pager");
                            if (ts.p.rowList.length > 0) {
                                str += $.jgrid.pager.rowListCaption + "";
                                str += "<select class='ui-pg-selbox' role='listbox'>";
                                var find = false;
                                for (i = 0; i < ts.p.rowList.length; i++) {
                                    str += "<option role=\"option\" value=\"" + ts.p.rowList[i] + "\"" + ((ts.p.rowNum == ts.p.rowList[i]) ? " selected=\"selected\"" : "") + ">" + ts.p.rowList[i] + "</option>";
                                    //rowNum.
                                    if (ts.p.rowList[i] == ts.p.rowNum) {
                                        find = true;
                                    }
                                }
                                if (!find) {
                                    ts.p.rowNum = ts.p.rowList[0];
                                }
                                str += "</select>";
                            }
                            var pgtext = $.wafutil.format(ts.p.pgtext || "", "<input class='ui-pg-input' type='text' size='2' maxlength='7' value='0' role='textbox'/>", "<span id='sp_1_" + $.jgrid.jqID(pgid) + "'></span>");
                            var te = $.wafutil.getTemplateEngine();
                            var fun = te.compile(pc_t);
                            var elem = te.render(fun,{direction:ts.p.direction,pgtext:pgtext,pgselect:str,id:ts.p.id,fc:$.jgrid.pageNav.first,pc:$.jgrid.pageNav.prev,nc:$.jgrid.pageNav.next,lc:$.jgrid.pageNav.end});
                            $(container).append(elem);
                        }

                        $('.ui-pg-selbox', container).bind('change', function (e) {
                            loadPage(e,function(){e.target.value = ts.p.rowNum;});
                            return false;
                        });
                        //
                        $(".ui-pg-button", container).hover(function () {
                            if ($(this).hasClass('ui-state-disabled')) {
                                this.style.cursor = 'default';
                            } else {
                                $(this).addClass('ui-state-hover');
                                this.style.cursor = 'pointer';
                            }
                        }, function () {
                            if (!$(this).hasClass('ui-state-disabled')) {
                                $(this).removeClass('ui-state-hover');
                                this.style.cursor = "default";
                            }
                        });
                        var tp = "_" + pgid;
                        $("#first" + $.jgrid.jqID(tp) + ", #prev" + $.jgrid.jqID(tp) + ", #next" + $.jgrid.jqID(tp) + ", #last" + $.jgrid.jqID(tp)).click(function (e) {
                            loadPage(e);
                            return false;
                        });
                        if (ts.p.pginput === true) {
                            $('input.ui-pg-input',container).keypress(function (e) {
                                var key = e.charCode ? e.charCode : e.keyCode ? e.keyCode : 0;
                                if (key == 13) {
                                    loadPage(e,function(){$(e.target).val(ts.p.page);})
                                    return false;
                                }
                                return this;
                            });
                        }
                    },
                    createBlockPager = function(container, inGrid){
                        if(!ts.p.domcreated){
                            inGrid?$(ts.p.pager).addClass("ui-block-pager"):$(container).addClass("ui-block-pager");
                            var ul = $("<ul class='pager'></ul>").appendTo(container),
                                previous = $("<li><span  class='ui-pg-button prev'>"+$.jgrid.pager.prePageText+"</span></li>").appendTo(ul),
                                next = $("<li><span  class='ui-pg-button next'>"+$.jgrid.pager.nextPageText+"</span></li>").appendTo(ul);
                        }
                        //f7livedocumentf7clickdocumentlivedelegant
                        container.undelegate('.ui-pg-button','click');
                        container.delegate('.ui-pg-button','click',function(e){
                                loadPage(e);
                                return false;
                            }
                        );
                    },
                    createMorePage = function(container, inGrid){
                        if(!ts.p.domcreated){
                            inGrid?$(ts.p.pager).addClass("ui-more-pager"):$(container).addClass("ui-more-pager");
                            var moreSpan =
                                $("<a class='more next' href='javascript:void(null)'>"+$.jgrid.pager.moreButtonText+"</a>")
                                    .appendTo(container);
                        }
                        moreSpan.unbind("click").bind("click",function(e){
                            loadPage(e);
                            return false;
                        });
                    },
                    createScrollPage = function(container, inGrid){
                        $(ts.p.pager).addClass("ui-scroll-pager");
                        var target = ts.p.scrollTarget||$(ts).closest(".ui-jqgrid-bdiv");
                        $(target).unbind("scroll");
                        $(target).scroll(function(){
                            var timer,
                                rh = $(target)[0].scrollHeight,
                                ch = $(target).height(),
                                offset = ts.p.offset||10,
                                scrollTop = $(target).scrollTop(),
                                span = rh - ch - offset;
                            if(span<scrollTop && ts.p.page<ts.p.lastpage){
                                window.clearTimeout(timer);
                                window.setTimeout(loadPage("next"),500);
                            }
                        })
                    },
                    createVirtualPager = function(container, inGrid){
                        var str = "",i,pgid = ts.p.pager.substr(1),tp = "_" + pgid;
                        inGrid?$(ts.p.pager).addClass("ui-virtual-pager"):$(container).addClass("ui-virtual-pager");
                    },
                    setPager = function (pgid, inGrid) {
                        switch(ts.p.pagerModel){
                            case "traditional":
                                createTranPager(pgid, inGrid);
                                break;
                            case "block":
                                //
                                createBlockPager(pgid, inGrid);
                                break;
                            case "more":
                                createMorePage(pgid,inGrid);
                                break;
                            case "scroll":
                                createScrollPage(pgid,inGrid);
                                break;
                            case "virtual":
                                createVirtualPager(pgid,inGrid);
                                break;
                        }
                    },
                    sortData = function (index, idxcol, reload, sor) {
                        if (!ts.p.colModel[idxcol].sortable) {
                            return;
                        }
                        //add by jlg. start
                        if (ts.p.beforeReloadGrid) {
                            var ret = ts.p.beforeReloadGrid.call(ts, ts);
                            if (undefined != ret && ret == false) return;
                        }
                        //end
                        var so;
                        if (ts.p.savedRow.length > 0) {
                            return;
                        }
                        if (!reload) {
                            if (ts.p.lastsort == idxcol) {
                                if (ts.p.sortorder == 'asc') {
                                    ts.p.sortorder = 'desc';
                                } else if (ts.p.sortorder == 'desc') {
                                    ts.p.sortorder = 'asc';
                                }
                            } else {
                                ts.p.sortorder = ts.p.colModel[idxcol].firstsortorder || 'asc';
                            }
                            ts.p.page = 1;
                        }
                        if (sor) {
                            if (ts.p.lastsort == idxcol && ts.p.sortorder == sor && !reload) {
                                return;
                            }
                            else {
                                ts.p.sortorder = sor;
                            }
                        }
                        var previousSelectedTh = ts.grid.headers[ts.p.lastsort].el, newSelectedTh = ts.grid.headers[idxcol].el;

                        $("span.ui-grid-ico-sort", previousSelectedTh).addClass('ui-state-disabled');
                        $(previousSelectedTh).attr("aria-selected", "false");
                        $("span.ui-icon-" + ts.p.sortorder, newSelectedTh).removeClass('ui-state-disabled');
                        $(newSelectedTh).attr("aria-selected", "true");

                        if (!ts.p.viewsortcols[0]) {
                            if (ts.p.lastsort != idxcol) {
                                $("span.s-ico", previousSelectedTh).hide();
                                $("span.s-ico", newSelectedTh).show();
                            }
                        }
                        index = index.substring(5 + ts.p.id.length + 1); // bad to be changed!?!
                        ts.p.sortname = ts.p.colModel[idxcol].index || index;
                        so = ts.p.sortorder;
                        if ($(ts).triggerHandler("jqGridSortCol", [index, idxcol, so]) === 'stop') {
                            ts.p.lastsort = idxcol;
                            return;
                        }
                        if ($.isFunction(ts.p.onSortCol)) {
                            if (ts.p.onSortCol.call(ts, index, idxcol, so) == 'stop') {
                                ts.p.lastsort = idxcol;
                                return;
                            }
                        }
                        if (ts.p.datatype == "local") {
                            if (ts.p.deselectAfterSort) {
                                $(ts).jqGrid("resetSelection");
                            }
                        } else {
                            ts.p.selrow = null;
                            if (ts.p.multiselect) {
                                setHeadCheckBox(false);
                            }
                            ts.p.selarrrow = [];
                            ts.p.savedRow = [];
                        }
                        if (ts.p.scroll) {
                            var sscroll = ts.grid.bDiv.scrollLeft;
                            emptyRows(ts.grid.bDiv, true, false);
                            ts.grid.hDiv.scrollLeft = sscroll;
                        }
                        if (ts.p.subGrid && ts.p.datatype == 'local') {
                            $("td.sgexpanded", "#" + $.jgrid.jqID(ts.p.id)).each(function () {
                                $(this).trigger("click");
                            });
                        }
                        populate();
                        ts.p.lastsort = idxcol;
                        if (ts.p.sortname != index && idxcol) {
                            ts.p.lastsort = idxcol;
                        }
                        //start add by jlg
                        $("div span.s-ico", newSelectedTh).show();
                        if (ts.p.sortorder === "asc") {
                            $("span.ui-icon-desc", newSelectedTh).css("display", "none").css("margin-left", 0);
                        } else {
                            $("span.ui-icon-asc", newSelectedTh).css("display", "none").css("margin-left", 0);
                        }
                        $("span.ui-icon-" + ts.p.sortorder, newSelectedTh).css("display", "inline-block");
                        //end add by jlg
                        //td
                        if (ts.p.frozenColumns === true) {
                            $.jgrid.copyFrozenHeader(ts);
                        }
                    },
                    setColWidth = function () {
                        var initwidth = 0, brd = $.jgrid.cellWidth(ts) ? 0 : intNum(ts.p.cellLayout, 0), vc = 0, lvc, scw = intNum(ts.p.scrollOffset, 0), cw, hs = false, aw, gw = 0,
                            cl = 0, cr;
                        $.each(ts.p.colModel, function () {
                            if (typeof this.hidden === 'undefined') {
                                this.hidden = false;
                            }
                            this.widthOrg = cw = intNum(this.width, 0);
                            if (this.hidden === false) {
                                initwidth += cw + brd;
                                if (this.fixed) {
                                    gw += cw + brd;
                                } else {
                                    vc++;
                                }
                                cl++;
                            }
                        });
                        if (isNaN(ts.p.width)||ts.p.width==0) {
                            ts.p.width = grid.width = initwidth;
                        }
                        else {
                            grid.width = ts.p.width;
                        }
                        ts.p.tblwidth = initwidth;
                        if (ts.p.shrinkToFit === false && ts.p.forceFit === true) {
                            ts.p.forceFit = false;
                        }
                        if (ts.p.shrinkToFit === true && vc > 0) {
                            aw = grid.width - brd * vc - gw;
                            if (!isNaN(ts.p.height)) {
                                aw -= scw;
                                hs = true;
                            }
                            initwidth = 0;
                            $.each(ts.p.colModel, function (i) {
                                if (this.hidden === false && !this.fixed) {
                                    cw = Math.round(aw * this.width / (ts.p.tblwidth - brd * vc - gw));
                                    this.width = cw;
                                    initwidth += cw;
                                    lvc = i;
                                }
                            });
                            cr = 0;
                            if (hs) {
                                if (grid.width - gw - (initwidth + brd * vc) !== scw) {
                                    cr = grid.width - gw - (initwidth + brd * vc) - scw;
                                }
                            } else if (!hs && Math.abs(grid.width - gw - (initwidth + brd * vc)) !== 1) {
                                cr = grid.width - gw - (initwidth + brd * vc);
                            }
                            ts.p.colModel[lvc].width += cr;
                            ts.p.tblwidth = initwidth + cr + brd * vc + gw;
                            if (ts.p.tblwidth > ts.p.width) {
                                ts.p.colModel[lvc].width -= (ts.p.tblwidth - parseInt(ts.p.width, 10));
                                ts.p.tblwidth = ts.p.width;
                            }
                        }
                    },
                    nextVisible = function (iCol) {
                        var ret = iCol, j = iCol, i;
                        for (i = iCol + 1; i < ts.p.colModel.length; i++) {
                            if (ts.p.colModel[i].hidden !== true) {
                                j = i;
                                break;
                            }
                        }
                        return j - ret;
                    },
                    getOffset = function (iCol) {
                        var i, ret = {}, brd1 = $.jgrid.cellWidth(ts) ? 0 : ts.p.cellLayout;
                        ret[0] = ret[1] = ret[2] = 0;
                        for (i = 0; i <= iCol; i++) {
                            if (ts.p.colModel[i].hidden === false) {
                                ret[0] += ts.p.colModel[i].width + brd1;
                            }
                        }
                        if (ts.p.direction == "rtl") {
                            ret[0] = ts.p.width - ret[0];
                        }
                        ret[0] = ret[0] - ts.grid.bDiv.scrollLeft;
                        if ($(ts.grid.cDiv).is(":visible")) {
                            ret[1] += $(ts.grid.cDiv).height() + parseInt($(ts.grid.cDiv).css("padding-top"), 10) + parseInt($(ts.grid.cDiv).css("padding-bottom"), 10);
                        }
                        if (ts.p.toolbar[0] === true && (ts.p.toolbar[1] == 'top' || ts.p.toolbar[1] == 'both')) {
                            ret[1] += $(ts.grid.uDiv).height() + parseInt($(ts.grid.uDiv).css("border-top-width"), 10) + parseInt($(ts.grid.uDiv).css("border-bottom-width"), 10);
                        }
                        if (ts.p.toppager) {
                            ret[1] += $(ts.grid.topDiv).height() + parseInt($(ts.grid.topDiv).css("border-bottom-width"), 10);
                        }
                        ret[2] += $(ts.grid.bDiv).height() + $(ts.grid.hDiv).height();
                        return ret;
                    },
                    getColumnHeaderIndex = function (th) {
                        var i, headers = ts.grid.headers, ci = $.jgrid.getCellIndex(th);
                        for (i = 0; i < headers.length; i++) {
                            if (th === headers[i].el) {
                                ci = i;
                                break;
                            }
                        }
                        return ci;
                    },
                    findKeyIndex = function () {
                        ts.p.keyIndex = false;
                        for (var i = 0; i < ts.p.colModel.length; i++) {
                            ts.p.colModel[i] = $.extend(true, {}, ts.p.cmTemplate, ts.p.colModel[i].template || {}, ts.p.colModel[i]);
                            if (ts.p.keyIndex === false && ts.p.colModel[i].key === true) {
                                ts.p.keyIndex = i;
                            }
                        }
                    },
                    initGrouping = function () {
                        if (ts.p.grouping === true) {
                            ts.p.scroll = false;
                            ts.p.rownumbers = false;
                            //ts.p.subGrid = false; expiremental
                            ts.p.treeGrid = false;
                            ts.p.gridview = true;
                        }
                    },
                    initTreeGrid = function () {
                        if (ts.p.treeGrid === true) {
                            try {
                                $(ts).jqGrid("setTreeGrid");
                            } catch (_) {
                            }
                            if (ts.p.datatype != "local") {
                                ts.p.localReader = {id:"_id_"};
                            }
                        }
                    },
                    initSubGrid = function () {
                        if (ts.p.subGrid) {
                            try {
                                $(ts).jqGrid("setSubGrid");
                            } catch (s) {
                            }
                        }
                    },
                    initColModel = function () {
                        if (ts.p.colNames.length === 0) {
                            var cm;
                            for (var i = 0; i < ts.p.colModel.length; i++) {
                                cm = ts.p.colModel[i];
                                ts.p.colNames[i] = ts.p.colModel[i].label || ts.p.colModel[i].name;
                                if($.type.isEmpty(cm.formatter) && cm.customformatter){
                                    cm.formatter =  cm.customformatter;
                                }
                                if($.type.isEmpty(cm.unformat) && cm.customunformatter){
                                    cm.unformat =  cm.customunformatter;
                                }
                            }
                        }
                        if (ts.p.colNames.length !== ts.p.colModel.length) {
                            alert($.jgrid.errors.model);
                            return;
                        }
                        if (ts.p.multiselect) {
                            ts.p.colNames.unshift("<input role='checkbox' id='cb_" + ts.p.id + "' class='cbox' type='checkbox'/>");
                            ts.p.colModel.unshift({name:'cb', width:$.jgrid.cellWidth(ts) ? ts.p.multiselectWidth + ts.p.cellLayout : ts.p.multiselectWidth, sortable:false, resizable:false, hidedlg:true, search:false, align:'center', fixed:true});
                        }
                        if (ts.p.rownumbers) {
                            ts.p.colNames.unshift("");
                            ts.p.colModel.unshift($.extend({name:'rn', sortable:false, resizable:false, hidedlg:true, search:false, align:'center', fixed:true},ts.p.rownumOption));
                        }
                    },
                    initMultiSelect = function () {
                        if (ts.p.multiselect) {
                            var emp = [], chk;
                            $('#cb_' + $.jgrid.jqID(ts.p.id), grid.hDiv).bind('click', function () {
                                ts.p.selarrrow = [];
                                var froz = ts.p.frozenColumns === true ? ts.p.id + "_frozen" : "";
                                if (this.checked) {
                                    $(ts.rows).each(function (i) {
                                        if (i > 0) {
                                            if (!$(this).hasClass("ui-subgrid") && !$(this).hasClass("jqgroup") && !$(this).hasClass('ui-state-disabled')) {
                                                $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + $.jgrid.jqID(this.id))[ts.p.useProp ? 'prop' : 'attr']("checked", true);
                                                $(this).addClass("ui-state-highlight").attr("aria-selected", "true");
                                                ts.p.selarrrow.push(this.id);
                                                ts.p.selrow = this.id;
                                                if (froz) {
                                                    $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + $.jgrid.jqID(this.id), ts.grid.fbDiv)[ts.p.useProp ? 'prop' : 'attr']("checked", true);
                                                    $("#" + $.jgrid.jqID(this.id), ts.grid.fbDiv).addClass("ui-state-highlight");
                                                }
                                            }
                                        }
                                    });
                                    chk = true;
                                    emp = [];
                                }
                                else {
                                    $(ts.rows).each(function (i) {
                                        if (i > 0) {
                                            if (!$(this).hasClass("ui-subgrid") && !$(this).hasClass('ui-state-disabled')) {
                                                $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + $.jgrid.jqID(this.id))[ts.p.useProp ? 'prop' : 'attr']("checked", false);
                                                $(this).removeClass("ui-state-highlight").attr("aria-selected", "false");
                                                emp.push(this.id);
                                                if (froz) {
                                                    $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + $.jgrid.jqID(this.id), ts.grid.fbDiv)[ts.p.useProp ? 'prop' : 'attr']("checked", false);
                                                    $("#" + $.jgrid.jqID(this.id), ts.grid.fbDiv).removeClass("ui-state-highlight");
                                                }
                                            }
                                        }
                                    });
                                    ts.p.selrow = null;
                                    chk = false;
                                }
                                $(ts).triggerHandler("jqGridSelectAll", [chk ? ts.p.selarrrow : emp, chk]);
                                if ($.isFunction(ts.p.onSelectAll)) {
                                    ts.p.onSelectAll.call(ts, chk ? ts.p.selarrrow : emp, chk);
                                }
                            });
                        }
                    },
                    initReader = function () {
                        ts.p.jsonReader = $.extend(true, {
                            root:"rows",
                            page:"page",
                            total:"total",
                            records:"records",
                            repeatitems:false, //modiby by jlg
                            cell:"cell",
                            id:"id",
                            userdata:"userdata",
                            subgrid:{root:"rows", repeatitems:false, cell:"cell"} //modiby by jlg
                        }, ts.p.jsonReader);
                        ts.p.localReader = $.extend(true, {
                            root:"rows",
                            page:"page",
                            total:"total",
                            records:"records",
                            repeatitems:false,
                            cell:"cell",
                            id:"id",
                            userdata:"userdata",
                            subgrid:{root:"rows", repeatitems:false, cell:"cell"}  //modiby by jlg
                        }, ts.p.localReader);
                    },
                    initScroll = function () {
                        if (ts.p.scroll) {
//                        ts.p.pgbuttons = false;
                            ts.p.pginput = false;
                            ts.p.rowList = [];
                            ts.p.scroll=1;
                        }
                    },
                    initData = function () {
                        if (ts.p.data.length) {
                            refreshIndex();
                        }
                    },
                    initColResize = function () {
                        if (ts.p.shrinkToFit === true && ts.p.forceFit === true) {
                            for (var i = ts.p.colModel.length - 1; i >= 0; i--) {
                                if (!ts.p.colModel[i].hidden) {
                                    ts.p.colModel[i].resizable = false;
                                    break;
                                }
                            }
                        }
                    },
                    createHeader = function () {
                        if(!ts.p.domcreated){
                            //theade
                            var thead = "<thead><tr class='ui-jqgrid-labels' role='rowheader'>",
                                tdc, idn, w, res, sort,td, ptr, tbody, dir=ts.p.direction,imgs, iac = "", idc = "";
                            if (ts.p.viewsortcols[1] == 'horizontal') {
                                iac = " ui-i-asc";
                                idc = " ui-i-desc";
                            }
                            tdc = isMSIE ? "class='ui-th-div-ie'" : "";
                            imgs = "<span class='s-ico' style='display:none'><span sort='asc' class='ui-grid-ico-sort ui-icon-asc" + iac + " ui-state-disabled ui-icon ui-icon-triangle-1-n ui-sort-" + dir + "'></span>";
                            imgs += "<span sort='desc' class='ui-grid-ico-sort ui-icon-desc" + idc + " ui-state-disabled ui-icon ui-icon-triangle-1-s ui-sort-" + dir + "'></span></span>";

                            for (var i = 0; i < ts.p.colNames.length; i++) {
                                var tooltip = ts.p.headertitles ? (" title=\"" + $.jgrid.stripHtml(ts.p.colNames[i]) + "\"") : "";
                                thead += "<th id='" + ts.p.id + "_" + ts.p.colModel[i].name + "' role='columnheader' class='ui-state-default ui-th-column ui-th-" + dir + "'" + tooltip + ">";
                                idn = ts.p.colModel[i].index || ts.p.colModel[i].name;
                                thead += "<div id='jqgh_" + ts.p.id + "_" + ts.p.colModel[i].name + "' " + tdc + ">" + ts.p.colNames[i];
                                if (!ts.p.colModel[i].width) {
                                    ts.p.colModel[i].width = 150;
                                }
                                else {
                                    ts.p.colModel[i].width = parseInt(ts.p.colModel[i].width, 10);
                                }
                                if (typeof(ts.p.colModel[i].title) !== "boolean") {
                                    ts.p.colModel[i].title = true;
                                }
                                if (idn == ts.p.sortname) {
                                    ts.p.lastsort = i;
                                }
                                thead += imgs + "</div></th>";
                            }
                            thead += "</tr></thead>";
                            $("table",grid.hDiv).css("width",ts.p.tblwidth+"px").append(thead);
                            imgs = null;
                            thead = null;
                        }

                        //
                        $("thead tr:first th", grid.hDiv).hover(function () {
                            $(this).addClass('ui-state-hover');
                        }, function () {
                            $(this).removeClass('ui-state-hover');
                        });
                        $(grid.hDiv).mousemove(function (e) {
                            if (grid.resizing) {
                                grid.dragMove(e);
                                return false;
                            }
                        });
                        $(".ui-jqgrid-labels", grid.hDiv).bind("selectstart", function () {
                            return false;
                        });
                    } ,
                    calcWidth = function () {
                        if (ts.p.autowidth === true) {
                            var pw = $(eg).innerWidth();
                            ts.p.width = pw > 0 ? pw : 'nw';
                        }
                        setColWidth();
                        $(eg).css("width", grid.width + "px");
                        $(gv).css("width", grid.width + "px");
                    },
                    initFooter = function () {
                        var thead = $("thead:first", $("table",grid.hDiv)).get(0);
                        var thr = $("tr:first", thead),allth = $("th", thr);
                        ts.p.disableClick = false;

                        //create footer dom
                        if(!ts.p.domcreated){
                            //create footer dom
                            var tfoot = "",res,firstr = "<tr class='jqgfirstrow' role='row' style='height:auto'>";
                            if (ts.p.footerrow) {
                                tfoot += "<table role='grid' style='width:" + ts.p.tblwidth + "px' class='ui-jqgrid-ftable' cellspacing='0' cellpadding='0' border='0'><tbody><tr role='row' class='ui-widget-content footrow footrow-" + dir + "'>";
                            }
                            allth.each(function (j) {
                                var w = ts.p.colModel[j].width;
                                if (typeof ts.p.colModel[j].resizable === 'undefined') {
                                    ts.p.colModel[j].resizable = true;
                                }
                                if (ts.p.colModel[j].resizable) {
                                    res = document.createElement("span");
                                    $(res).html("&#160;").addClass('ui-jqgrid-resize ui-jqgrid-resize-' + ts.p.direction);
                                    if (!$.browser.opera) {
                                        $(res).css("cursor", "col-resize");
                                    }
                                    $(this).addClass(ts.p.resizeclass);
                                } else {
                                    res = "";
                                }
                                $(this).css("width", w + "px").prepend(res);
                                var hdcol = "";
                                if (ts.p.colModel[j].hidden) {
                                    $(this).css("display", "none");
                                    hdcol = "display:none;";
                                }
                                firstr += "<td role='gridcell' style='height:0px;width:" + w + "px;" + hdcol + "'></td>";
                                grid.headers[j] = { width:w, el:this };
                                var sort = ts.p.colModel[j].sortable;
                                if (typeof sort !== 'boolean') {
                                    ts.p.colModel[j].sortable = true;
                                    sort = true;
                                }
                                var nm = ts.p.colModel[j].name;
                                if (!(nm == 'cb' || nm == 'subgrid' || nm == 'rn')) {
                                    if (ts.p.viewsortcols[2] && sort) { //add by jlg.truecss
                                        $(">div", this).addClass('ui-jqgrid-sortable');
                                    }
                                }
                                if (sort) {
                                    //modiby by jlg.
                                    if (ts.p.viewsortcols[0]) {
                                        $("div span.s-ico", this).show();
                                        if (j == ts.p.lastsort) {
                                            $("div span.ui-icon-" + ts.p.sortorder, this).removeClass("ui-state-disabled");
                                            //add by jlg
                                            if (ts.p.sortorder === "asc") {
                                                $("span.ui-icon-desc", this).css("display", "none").css("margin-left", 0);
                                            } else {
                                                $("span.ui-icon-asc", this).css("display", "none").css("margin-left", 0);
                                            }
                                        }
                                    }
                                    else if (j == ts.p.lastsort) {
                                        $("div span.s-ico", this).show();
                                        $("div span.ui-icon-" + ts.p.sortorder, this).removeClass("ui-state-disabled");
                                        //add by jlg
                                        if (ts.p.sortorder === "asc") {
                                            $("span.ui-icon-desc", this).css("display", "none").css("margin-left", 0);
                                        } else {
                                            $("span.ui-icon-asc", this).css("display", "none").css("margin-left", 0);
                                        }
                                    }
                                }
                                if (ts.p.footerrow) {
                                    tfoot += "<td role='gridcell' " + formatCol(j, 0, '', null, '', false) + ">&#160;</td>";
                                }
                            });

                            if (ts.p.footerrow) {
                                tfoot += "</tr></tbody></table>";
                            }
                            firstr += "</tr>";
                            $(ts).append(firstr);
                            firstr = null;

                            if (ts.p.footerrow) {
                                grid.sDiv = $("<div class='ui-jqgrid-sdiv'></div>")[0];
                                var hb = $("<div class='ui-jqgrid-hbox" + (dir == "rtl" ? "-rtl" : "") + "'></div>");
                                $(grid.sDiv).append(hb).insertAfter(grid.bDiv).width(grid.width);
                                $(hb).append(tfoot);
                                grid.footers = $(".ui-jqgrid-ftable", grid.sDiv)[0].rows[0].cells;
                                if (ts.p.rownumbers) {
                                    grid.footers[0].className = 'jqgrid-rownum';
                                }
                                if (hg) {
                                    $(grid.sDiv).hide();
                                }
                            }
                        }else{
                            allth.each(function (j) {
                                var w = ts.p.colModel[j].width;
                                if (typeof ts.p.colModel[j].resizable === 'undefined') {
                                    ts.p.colModel[j].resizable = true;
                                }
                                grid.sDiv = $(gv).find(".ui-jqgrid-sdiv");
                                $(grid.sDiv).width(grid.width);
                                grid.headers[j] = { width:w, el:this };
                                var sort = ts.p.colModel[j].sortable;
                                if (typeof sort !== 'boolean') {
                                    ts.p.colModel[j].sortable = true;
                                }
                            });
                            if (ts.p.footerrow) {
                                grid.footers = $(".ui-jqgrid-ftable", grid.sDiv)[0].rows[0].cells;
                                $(grid.sDiv).width(grid.width);
                                if (ts.p.rownumbers) {
                                    grid.footers[0].className = 'jqgrid-rownum';
                                }
                                if (hg) {
                                    $(grid.sDiv).hide();
                                }
                            }
                        }

                        //bind events
                        allth.mousedown(
                            function (e) {
                                if ($(e.target).closest("th>span.ui-jqgrid-resize").length != 1) {
                                    return;
                                }
                                var ci = getColumnHeaderIndex(this);
                                if (ts.p.forceFit === true) {
                                    ts.p.nv = nextVisible(ci);
                                }
                                grid.dragStart(ci, e, getOffset(ci));
                                return false;
                            }).click(function (e) {
                                if(!$(e.target).hasClass("ui-jqgrid-sortable")) return;
                                if (ts.p.disableClick) {
                                    ts.p.disableClick = false;
                                    return false;
                                }
                                var s = "th>div.ui-jqgrid-sortable", r, d;
                                if (!ts.p.viewsortcols[2]) {
                                    s = "th>div>span>span.ui-grid-ico-sort";
                                }
                                var t = $(e.target).closest(s);
                                if (t.length != 1) {
                                    return;
                                }
                                var ci = getColumnHeaderIndex(this);
                                if (!ts.p.viewsortcols[2]) {
                                    r = true;
                                    d = t.attr("sort");
                                }
                                sortData($('div', this)[0].id, ci, r, d);
                                return false;
                            });
                        if (ts.p.sortable && $.fn.sortable) {
                            try {
                                $(ts).jqGrid("sortableColumns", thr);
                            } catch (e) {
                            }
                        }

                    },
                    initPager = function () {
                        if (ts.p.pager) {
                            // TBD -- escape ts.p.pager here?
                            if (typeof ts.p.pager == "string") {
                                if (ts.p.pager.substr(0, 1) != "#") {
                                    ts.p.pager = "#" + ts.p.pager;
                                }
                            }
                            else {
                                ts.p.pager = "#" + $(ts.p.pager).attr("id");
                            }
                            var container,inGrid=true;
                            //pagerpos
                            if(isInGrid()){
                                $(ts.p.pager).css({width:grid.width + "px"}).appendTo(eg)
                                    .addClass('ui-state-default ui-jqgrid-pager ui-corner-bottom')
                                    .attr("dir",ts.p.direction);
                                if(!ts.p.domcreated){
                                    var te = $.wafutil.getTemplateEngine();
                                    var fun = te.compile(pv_t);
                                    $(ts.p.pager).append(te.render(fun,{id:ts.p.id}));
                                    te = null;
                                    fun = null;
                                }
                                container = $("td" + ts.p.pager + "_" + ts.p.pagerpos, ts.p.pager);
                                container.css("display","table-cell");
                            }else{
                                container = $(ts.p.pagerpos);
                                inGrid=false;
                            }
                            setPager(container, inGrid);
                        }
                    },
                    initEditable = function () {
                        var ptr;
                        if ((ts.p.cellEdit === false) && ts.p.hoverrows === true) {
                            $(ts).bind('mouseover',
                                function (e) {
                                    $(ts.rows).removeClass("ui-state-hover");
                                    ptr = $(e.target).closest("tr.jqgrow");
                                    if ($(ptr).attr("class") !== "ui-subgrid") {
                                        $(ptr).addClass("ui-state-hover");
                                    }
                                    //add by jlg.
                                    //$("td[rowspan]",ptr[0]).css("background-color","#fff");
                                }).bind('mouseout', function (e) {
                                    ptr = $(e.target).closest("tr.jqgrow");
                                    $(ptr).removeClass("ui-state-hover");
                                });
                        }
                        //
                        if(ts.p.cellEdit){
                            //
                            $(ts).wafGrid(ts.p.editModel+"SetUp");
                        }
                    },
                    createBTable = function () {
                        if(!ts.p.domcreated){
                            $(ts).addClass('ui-jqgrid-btable');
                            $("table",grid.hDiv).addClass('ui-jqgrid-htable');
                            if (isMSIE) {
                                if (String(ts.p.height).toLowerCase() === "auto") {
                                    ts.p.height = "100%";
                                }
                            }
                            if(isNaN(ts.p.height)){
                                eg.addClass("autoHeight").removeClass("fixHeight");
                            }else{
                                eg.addClass("fixHeight").removeClass("autoHeight");
                            }
                            $(grid.bDiv).css({ height:ts.p.height + (isNaN(ts.p.height) ? "" : "px"), width:(grid.width) + "px"}).scroll(grid.scrollGrid);
                            $("table:first", grid.bDiv).css({width:ts.p.tblwidth + "px"});
                        }

                        $(grid.bDiv).scroll(grid.scrollGrid);
                        if (isMSIE) {
                            if ($("tbody", ts).size() == 2) {
                                $("tbody:gt(0)", ts).remove();
                            }
                            if (ts.p.multikey) {
                                $(grid.bDiv).bind("selectstart", function () {
                                    return false;
                                });
                            }
                        } else {
                            if (ts.p.multikey) {
                                $(grid.bDiv).bind("mousedown", function () {
                                    return false;
                                });
                            }
                        }
                        if (hg) {
                            $(grid.bDiv).hide();
                        }
                    },
                    bindEvents = function () {
                        var ri, ci, tdHtml, td, ptr;
                        $(ts).click(
                            function (e) {
                                td = e.target;
                                ptr = $(td, ts.rows).closest("tr.jqgrow");
                                if ($(ptr).length === 0 || ptr[0].className.indexOf('ui-state-disabled') > -1 || ($(td, ts).closest("table.ui-jqgrid-btable").attr('id') || '').replace("_frozen", "") !== ts.id) {
                                    return ts;
                                }
                                var scb = $(td).hasClass("cbox"),
                                    cSel = $(ts).triggerHandler("jqGridBeforeSelectRow", [ptr[0].id, e]);
                                cSel = (cSel === false || cSel === 'stop') ? false : true;
                                if (cSel && $.isFunction(ts.p.beforeSelectRow)) {
                                    cSel = ts.p.beforeSelectRow.call(ts, ptr[0].id, e);
                                }
                                if (undefined === cSel) cSel = true;//add by jlg.
                                if (td.tagName == 'A' || ((td.tagName == 'INPUT' || td.tagName == 'TEXTAREA' || td.tagName == 'OPTION' || td.tagName == 'SELECT' ) && !scb)) {
                                    return;
                                }
                                if (cSel === true) {
                                    ri = ptr[0].id;
                                    ci = $.jgrid.getCellIndex(td);
                                    tdHtml = $(td).closest("td,th").html();
                                    $(ts).triggerHandler("jqGridCellSelect", [ri, ci, tdHtml, e]);
                                    if ($.isFunction(ts.p.onCellSelect)) {
                                        ts.p.onCellSelect.call(ts, ri, ci, tdHtml, e);
                                    }
                                    if ($.jgrid.canEdit(ts)) {
                                        if (ts.p.multiselect && scb) {
                                            $(ts).jqGrid("setSelection", ri, true, e);
                                        } else {
                                            ri = ptr[0].rowIndex;
                                            try {
                                                $(ts).jqGrid("editCell", ri, ci, true);
                                            } catch (_) {
                                            }
                                        }
                                    } else if (!ts.p.multikey) {
                                        if (ts.p.multiselect && ts.p.multiboxonly) {
                                            if (scb) {
                                                $(ts).jqGrid("setSelection", ri, true, e);
                                            }
                                            else {
                                                var frz = ts.p.frozenColumns ? ts.p.id + "_frozen" : "";
                                                $(ts.p.selarrrow).each(function (i, n) {
                                                    var ind = ts.rows.namedItem(n);
                                                    $(ind).removeClass("ui-state-highlight");
                                                    $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + $.jgrid.jqID(n))[ts.p.useProp ? 'prop' : 'attr']("checked", false);
                                                    if (frz) {
                                                        $("#" + $.jgrid.jqID(n), "#" + $.jgrid.jqID(frz)).removeClass("ui-state-highlight");
                                                        $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + $.jgrid.jqID(n), "#" + $.jgrid.jqID(frz))[ts.p.useProp ? 'prop' : 'attr']("checked", false);
                                                    }
                                                });
                                                ts.p.selarrrow = [];
                                                $(ts).jqGrid("setSelection", ri, true, e);
                                            }
                                        } else {
                                            $(ts).jqGrid("setSelection", ri, true, e);
                                        }
                                    } else {
                                        if (e[ts.p.multikey]) {
                                            $(ts).jqGrid("setSelection", ri, true, e);
                                        } else{
                                            var frz = ts.p.frozenColumns ? ts.p.id + "_frozen" : "";
                                            $(ts.p.selarrrow).each(function (i, n) {
                                                var ind = ts.rows.namedItem(n);
                                                $(ind).removeClass("ui-state-highlight");
                                                $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + $.jgrid.jqID(n))[ts.p.useProp ? 'prop' : 'attr']("checked", false);
                                                if (frz) {
                                                    $("#" + $.jgrid.jqID(n), "#" + $.jgrid.jqID(frz)).removeClass("ui-state-highlight");
                                                    $("#jqg_" + $.jgrid.jqID(ts.p.id) + "_" + $.jgrid.jqID(n), "#" + $.jgrid.jqID(frz))[ts.p.useProp ? 'prop' : 'attr']("checked", false);
                                                }
                                            });
                                            ts.p.selarrrow = [];
                                            $(ts).jqGrid("setSelection", ri, true, e);
                                        }
                                    }
                                }
                            }).bind('reloadGrid', function (e, opts) {
                                //add by jlg. start
                                if (ts.p.beforeReloadGrid) {
                                    var ret = ts.p.beforeReloadGrid.call(ts, ts);
                                    if (undefined != ret && ret == false) return false;
                                }
                                //end
                                if (ts.p.treeGrid === true) {
                                    ts.p.datatype = ts.p.treedatatype;
                                }
                                if (opts && opts.current) {
                                    ts.grid.selectionPreserver(ts);
                                }
                                if (ts.p.datatype == "local") {
                                    $(ts).jqGrid("resetSelection");
                                    if (ts.p.data.length) {
                                        refreshIndex();
                                    }
                                }
                                else if (!ts.p.treeGrid) {
                                    ts.p.selrow = null;
                                    if (ts.p.multiselect) {
                                        ts.p.selarrrow = [];
                                        setHeadCheckBox(false);
                                    }
                                    ts.p.savedRow = [];
                                }
                                if (ts.p.scroll) {
                                    emptyRows(ts.grid.bDiv, true, false);
                                }
                                if (opts && opts.page) {
                                    var page = opts.page;
                                    if (page > ts.p.lastpage) {
                                        page = ts.p.lastpage;
                                    }
                                    if (page < 1) {
                                        page = 1;
                                    }
                                    ts.p.page = page;
                                    if (ts.grid.prevRowHeight) {
                                        ts.grid.bDiv.scrollTop = (page - 1) * ts.grid.prevRowHeight * ts.p.rowNum;
                                    } else {
                                        ts.grid.bDiv.scrollTop = 0;
                                    }
                                }
                                if (ts.grid.prevRowHeight && ts.p.scroll) {
                                    delete ts.p.lastpage;
                                    ts.grid.populateVisible();
                                } else {
                                    ts.grid.populate();
                                }
                                return false;
                            })
                            .dblclick(function (e) {
                                if (ts.p && ts.p.ondblClickRow) {
                                    td = e.target;
                                    ptr = $(td, ts.rows).closest("tr.jqgrow");
                                    if ($(ptr).length === 0) {
                                        return;
                                    }
                                    ri = ptr[0].rowIndex;
                                    ci = $.jgrid.getCellIndex(td);
                                    $(ts).triggerHandler("jqGridDblClickRow", [$(ptr).attr("id"), ri, ci, e]);
                                    if ($.isFunction(ts.p.ondblClickRow)) {
                                        ts.p.ondblClickRow.call(ts, $(ptr).attr("id"), ri, ci, e);
                                    }
                                }
                            })
                            .bind('contextmenu', function (e) {
                                if (ts.p && ts.p.onRightClickRow) {
                                    td = e.target;
                                    ptr = $(td, ts.rows).closest("tr.jqgrow");
                                    if ($(ptr).length === 0) {
                                        return;
                                    }
                                    if (!ts.p.multiselect) {
                                        $(ts).jqGrid("setSelection", ptr[0].id, true, e);
                                    }
                                    ri = ptr[0].rowIndex;
                                    ci = $.jgrid.getCellIndex(td);
                                    $(ts).triggerHandler("jqGridRightClickRow", [$(ptr).attr("id"), ri, ci, e]);
                                    if ($.isFunction(ts.p.onRightClickRow)) {
                                        ts.p.onRightClickRow.call(ts, $(ptr).attr("id"), ri, ci, e);
                                    }
                                }
                            });
                        initMultiSelect();
                        $(document).mouseup(function () {
                            if (grid.resizing) {
                                grid.dragEnd();
                                return false;
                            }
                            return true;
                        });
                    },
                    finishDOM = function () {
                        ts.formatCol = formatCol;
                        ts.sortData = sortData;
                        ts.setPager = setPager;
                        ts.updatepager = updatepager;
                        ts.refreshIndex = refreshIndex;
                        ts.setHeadCheckBox = setHeadCheckBox;
                        ts.constructTr = constructTr;
                        ts.addCell = addCell;
                        ts.addMulti = addMulti;
                        ts.addRowNum = addRowNum;
                        ts.setColWidth = setColWidth;
                        ts.loadPage = loadPage;
                        ts.reader = reader;
                        ts.initPager = initPager;
                        ts.formatter = function (rowId, cellval, colpos, rwdat, act) {
                            return formatter(rowId, cellval, colpos, rwdat, act);
                        };
                        $.extend(grid, {populate:populate, emptyRows:emptyRows});
                        ts.grid = grid;
                        ts.addJSONData = function (d) {
                            addJSONData(d, ts.grid.bDiv);
                        };
                        ts.grid.cols = ts.rows[0].cells;
                        ts.p.hiddengrid = false;
                        //
                        $(ts).jqGrid("initDOM");
                        $(ts).jqGrid('rowSpanSetup');
                        $(ts).jqGrid('destroyFrozenColumns');
                        $(ts).jqGrid('setFrozenColumns');
                        $(ts).attr("data-domcreated","true");
                    },
                    buildElement = function(){
                        if(!$(ts).data("domcreated")){
                            var te = $.wafutil.getTemplateEngine();
                            var tmpFun = te.compile(g_T);
                            var dom = te.render(tmpFun,{id:ts.id,direction:ts.p.direction,loadingText:ts.p.loadtext});
                            $(dom).insertAfter(ts);
                            $(ts).detach();
                            $(".ui-jqgrid-bdiv>div",$("#gbox_"+ts.id)).append(ts);
                            te = null;
                            tmpFun = null;
                            $(ts).attr("data-domcreated","true");
                        }else{
                            ts.p.domcreated=true;
                        }
                        $(ts).attr({tabindex:ts.p.tabindex,cellspacing:"0",cellpadding:"0",border:"0","role":"grid","aria-multiselectable":!!ts.p.multiselect,"aria-labelledby":"gbox_"+ts.id});
                        eg = $("#gbox_"+ts.id);
                        gv = $(".ui-jqgrid-view",eg);
                        grid.hDiv = $(".ui-jqgrid-hdiv",gv)[0];
                        grid.bDiv = $(".ui-jqgrid-bdiv",gv)[0];
                        grid.cDiv = $(".ui-jqgrid-titlebar",gv)[0];
                    },
                    initCustomColumn = function () {
                        if (ts.p.gridConfig === true) {
                            if( ts.p.customColModel.length > 0){
                                if(typeof(ts.p.customColModel) === "string"){
                                    ts.p.customColModel = JSON.parse(ts.p.customColModel);
                                }
                                if(ts.p.defaultColModel.length == 0){
                                    ts.p.defaultColModel = $.extend(true,[], ts.p.colModel);
                                }
                                ts.p.colNames = [];
                                var customColModelName = new Array();
                                var mergeColMode = new Array();
                                for(var j=0,length=ts.p.customColModel.length; j<length;j++){
                                    customColModelName.push(ts.p.customColModel[j].name);
                                }
                                for(var i = 0,length=ts.p.colModel.length;i<length;i++){
                                    var flag = false;
                                    for(var j = 0,_length=customColModelName.length;j<_length;j++){
                                        if(customColModelName[j] == ts.p.colModel[i].name){
                                            flag = true;
                                            break;
                                        }
                                    }
                                    if(flag == false){
                                        mergeColMode.push(ts.p.colModel[i]);

                                    }
                                }
                                for(var j = 0,length=customColModelName.length; j<length ;j++){
                                    for(var i = 0,_length=ts.p.colModel.length;i<_length;i++){
                                        if(ts.p.colModel[i].name === customColModelName[j]){
                                            mergeColMode.push($.extend(true,{}, ts.p.colModel[i], ts.p.customColModel[j]));
                                        }
                                    }
                                }
                                ts.p.colModel = mergeColMode;
                            }
                        }
                    } ,
                    initGridConfigEvent = function () {
                        if (ts.p.gridConfig === true) {
                            $('#' + p.id + '_rn', grid.hDiv).append('<img class="gridConfig">')
                            $('.gridConfig', grid.hDiv).bind("click", function () {
                                var winProperties = {
                                    OpenType:"iframe",
                                    method:'POST',
                                    modal:true,
                                    openFromParent:false,
                                    position:'center',
                                    showTitleBar:true,
                                    autoMax:false,
                                    width:640,
                                    height:405,
                                    minHeight:305,
                                    minWidth:540,
                                    iconCls:"ui-icon-winIcon",
                                    draggable:true,
                                    resizable:false,
                                    //hideCloseBtn:true,
                                    //showEffect:"slide",
                                    hideEffect:"slide"
                                };
                                winProperties.url = waf.getContextPath() + "/webframework/dynamic/webGridConfigPage.do?method=initalize&gridID=" + ts.p.id;
                                winProperties.title = "";
                                winProperties.close = function (event, ui) {
                                }
                                winProperties.onOpenCompleted = function (event, ui) {
                                    waf(window).unbind("resize", waf.window.doResize);
                                    waf(window).bind("resize", waf.window.doResize);
                                }
                                waf.window.open(winProperties);
                            });
                        }
                    } ,
                    initColGroupInfo = function (){
                        if(ts.p.colGroupInfo != null){
                            var colGroupInfo = $("<div class='right' id='"+ts.p.id+"_colGroup'>");
                            var colGroup = new String('{');
                            if(typeof(ts.p.colGroupInfo) === "string"){
                                ts.p.colGroupInfo = JSON.parse(ts.p.colGroupInfo);
                            }
                            for(p in ts.p.colGroupInfo){
                                colGroupInfo.append("<a href='javascript:void(null)' "+"id='"+p+"' "
                                    +"class='"+p+" pgbuttons'>"+ts.p.colGroupInfo[p]+"</a>");
                                colGroup = colGroup.concat('"'+p+'":[],');
                            }
                            colGroupInfo.append("</div>");
                            $(colGroupInfo).insertBefore(eg);


                            colGroup = colGroup.substring(0,colGroup.length-1);
                            colGroup = colGroup.concat('}');
                            ts.p.colGroup = JSON.parse(colGroup);

                            for(var i = 0,length=ts.p.colModel.length;i<length;i++){
                                if(ts.p.colModel[i].colGroupId != null && !ts.p.colModel[i].frozen){
                                    ts.p.colGroup[ts.p.colModel[i].colGroupId].push(ts.p.colModel[i].name);
                                }
                            }

                            $("a[class*='pgbuttons']",$("#"+ts.p.id+"_colGroup")).click(function(e){
                                var hideColumns = [],showColumns = [];
                                for(p in ts.p.colGroup){
                                    if(p == e.target.id){
                                        showColumns = showColumns.concat(ts.p.colGroup[p]);
                                    }else{
                                        hideColumns = hideColumns.concat(ts.p.colGroup[p]);
                                    }
                                }
                                $(".pgbuttons").removeClass("active");
                                $(e.target).addClass("active");
                                $(ts).wafGrid("hideColumn",hideColumns);
                                $(ts).wafGrid("showColumn",showColumns);
                                $.jgrid.adjustFrozenColumnWidth(ts);
                            })
                        }
                    } ,
                    initP = function () {
                        ts.p.direction = $.trim(ts.p.direction.toLowerCase());
                        if ($.inArray(ts.p.direction, ["ltr", "rtl"]) == -1) {
                            ts.p.direction = "ltr";
                        }
                        var dir = ts.p.direction, isMSIE = $.browser.msie ? true : false;
                        ts.p.sortorder = ts.p.sortorder.toLowerCase();
                        if(ts.p.ctrlkey) ts.p.multikey = "ctrlKey";
                        if ($.inArray(ts.p.multikey, ["shiftKey", "altKey", "ctrlKey"]) == -1) {
                            ts.p.multikey = false;
                        }
                        ts.p.cellEdit = ts.p.editable==true?true:false;
                        findKeyIndex();
                        //
                        initGrouping();
                        //
                        initTreeGrid();
                        //
                        initSubGrid();
                        initCustomColumn();
                        initColModel();
                        initReader();
                        initScroll();
                        initData();
                        initColResize();
                    };
                //p
                initP();
                //elements
                buildElement();
                //
                calcWidth();
                //Header
                createHeader();
                initColGroupInfo();
                initFooter();
                initPager();
                createBTable();
                bindEvents();
                initEditable();
                finishDOM();
                populate();
                initGridConfigEvent();
                //
                $(ts).jqGrid("initFinish");
                //end by jlg
                $(window).unload(function () {
                    ts = null;
                });
            });
        };
        $.fn.wafGrid = $.fn.jqGrid;

        $.extend($.jgrid, {
            version:"4.3.3",
            htmlDecode:function (value) {
                return $.wafutil.htmlDecode(value);
            },
            htmlEncode:function (value) {
                return $.wafutil.htmlEncode(value);
            },
            format:function (format) { //jqgformat
                var args = $.makeArray(arguments).slice(1);
                if (format === undefined) {
                    format = "";
                }
                return format.replace(/\{(\d+)\}/g, function (m, i) {
                    return args[i];
                });
            },
            getCellIndex:function (cell) {
                var c = $(cell);
                if (c.is('tr')) {
                    return -1;
                }
                c = (!c.is('td') && !c.is('th') ? c.closest("td,th") : c)[0];
                if ($.browser.msie) {
                    return $.inArray(c, c.parentNode.cells);
                }
                return c.cellIndex;
            },
            stripHtml:function (v) {
                v = v + "";
                if (v.indexOf("function") > -1) return "";
                var regexp = /<("[^"]*"|'[^']*'|[^'">])*>/gi;
                if (v) {
                    v = v.replace(regexp, "");
                    return (v && v !== '&nbsp;' && v !== '&#160;') ? v.replace(/\"/g, "'") : "";
                } else {
                    return v;
                }
            },
            stripPref:function (pref, id) {
                var obj = $.type(pref);
                if (obj == "string" || obj == "number") {
                    pref = String(pref);
                    id = pref !== "" ? String(id).replace(String(pref), "") : id;
                }
                return id;
            },
            jqID:function (sid) {
                return String(sid).replace(/[!"#$%&'()*+,.\/:;<=>?@\[\\\]\^`{|}~]/g, "\\$&");
            },
            guid:1,
            uidPref:'jqg',
            randId:function (prefix) {
                return (prefix ? prefix : $.jgrid.uidPref) + ($.jgrid.guid++);
            },
            getAccessor:function (obj, expr) {
                return $.wafutil.getAccessor(obj,expr);
            },
            cellWidth:function (ts) {
                //
                var ret = ts && ts.p && ts.p.cellwidth;
                if (ret == undefined) {
                    var $testDiv = $("<div class='ui-jqgrid' style='left:10000px'><table class='ui-jqgrid-btable' style='width:5px;'><tr class='jqgrow'><td style='width:5px;'></td></tr></table></div>"),
                        testCell = $testDiv.appendTo("body")
                            .find("td")
                            .width();
                    $testDiv.remove();
                    ret = (testCell !== 5);
                    if (ts && ts.p) ts.p.cellwidth = ret;
                }
                return ret;
            },
            ajaxOptions:{},
            from:function (source) {
                // Original Author Hugo Bonacci
                // License MIT http://jlinq.codeplex.com/license
                return $.wafutil.getQueryObject(source);
            },
            extend:function (methods) {
                $.extend($.fn.jqGrid, methods);
                if (!this.no_legacy_api) {
                    $.fn.extend(methods);
                }
            },
            canEdit:function(ts){
                return ts && ts.p && ts.p.cellEdit && (ts.p.editModel === "cellEdit" || ts.p.floatCellEdit==true);
            },
            getKeyName:function(ts){
                var idn,dReader,frd,f;
                if (ts.p.datatype == "local") {
                    dReader = ts.p.localReader;
                    frd = 'local';
                } else {
                    dReader = ts.p.jsonReader;
                    frd = 'json';
                }
                f = ts.reader("json");
                if (ts.p.keyIndex === false) {
                    idn = $.isFunction(dReader.id) ? dReader.id.call(ts, data) : dReader.id;
                } else {
                    idn = ts.p.keyIndex;
                }
                if (f.length > 0 && !isNaN(idn)) {
                    if (ts.p.remapColumns && ts.p.remapColumns.length) {
                        idn = $.inArray(idn, ts.p.remapColumns);
                    }
                    idn = f[idn];
                }
                return idn;
            },
            //colcolid-1
            getIndex:function(col,ts){
                var pos = -1;
                if($.isNaN(col)) {
                    $(ts.p.colModel).each(function(i){
                        if (this.name == col) {
                            pos = i;
                            return false;
                        }
                    });
                } else {pos = parseInt(col,10);}
                return pos;
            },
            //:rn,cb,subgrid
            isFixedCol:function(nm){
                return "rn"===nm || "cb"===nm || "subgrid"===nm;
            },
            getSortNamePos:function(sortName,ts){
                for(var i =0; i<ts.p.colModel.length;i++){
                    if(sortName === ts.p.colModel[i].name || sortName === ts.p.colModel[i].index){
                        return i;
                    }
                }
                return -1;
            },
            getTdValue:function($t,rowId,pos,td,mthd){
                var val;
                if(td.length>0){
                    if (!mthd) {
                        mthd = 'all'; // mthd==all or dirty
                    }
                    if ((mthd == 'dirty'&&$(td).hasClass('dirty-cell'))||(mthd == 'all')) {
                        if ($t.p.treeGrid === true && nm == $t.p.ExpandColumn) {
                            val = $.jgrid.htmlDecode($("span:first", td).html());
                        }else{
                            val = $.unformat.call($t,td[0],{rowId:rowId, colModel:$t.p.colModel[pos],gid:$t.p.id},pos);
                        }
                    }
                }
                return val;
            }
        });

        var g_T =
            "<div class='ui-jqgrid ui-widget ui-widget-content ui-corner-all' id='gbox_{{id}}' dir='{{direction}}'>" +
                "    <div class='ui-widget-overlay jqgrid-overlay' id='lui_{{id}}'></div>" +
                "    <div class='ui-jqgrid-view' id='gview_{{id}}'>" +
                "        <div class='ui-jqgrid-titlebar ui-widget-header ui-corner-top ui-helper-clearfix' style='display: none; '>" +
                "            <a role='link' href='javascript:void(0)' class='ui-jqgrid-titlebar-close HeaderButton' style='right:0'>" +
                "              <span class='ui-icon ui-icon-circle-triangle-n'></span>" +
                "            </a>" +
                "            <span class='ui-jqgrid-title'></span>" +
                "        </div>" +
                "        <div class='ui-state-default ui-jqgrid-hdiv'>" +
                "            <div class='ui-jqgrid-hbox'>" +
                "               <table  role='grid' aria-labelledby='gbox_{{id}}' cellspacing='0' cellpadding='0' border='0'></table>" +
                "            </div>" +
                "        </div>" +
                "        <div class='ui-jqgrid-bdiv'>" +
                "            <div style='position:relative;'>" +
                "                <div></div>  "+
                "            </div>" +
                "        </div>" +
                "    </div>" +
                "    <div class='ui-jqgrid-resize-mark' id='rs_m{{id}}'>&nbsp;</div>" +
                "</div>";
        var pv_t ="    <div id='pg_pager{{id}}' class='ui-pager-control' role='group'>" +
            "              <table cellspacing='0' cellpadding='0' border='0' class='ui-pg-table' style='width:100%;table-layout:auto;height:100%;' role='row'>" +
            "                <tbody>" +
            "                  <tr>" +
            "                    <td id='pager{{id}}_left' align='left' style=''></td>" +
            "                    <td id='pager{{id}}_center' align='center'  style=''></td>" +
            "                    <td id='pager{{id}}_right' align='right'  style=''></td>" +
            "                  </tr>" +
            "                </tbody>" +
            "             </table>" +
            "          </div>";
        var pc_t = "<table cellspacing='0' cellpadding='0' border='0' style='table-layout:auto;' class='ui-pg-table'>" +
            "          <tbody>" +
            "             <tr>" +
            "                <td dir='{{direction}}'>" +
            "                   {{{pgtext}}}" +
            "                </td>" +
            "                <td id='first_pager{{id}}' class='ui-pg-button ui-corner-all first' title='{{fc}}'>" +
            "                    <span class='ui-icon ui-icon-seek-first first'></span>" +
            "                </td>" +
            "                <td id='prev_pager{{id}}' class='ui-pg-button ui-corner-all prev' title='{{pc}}'>" +
            "                    <span class='ui-icon ui-icon-seek-prev prev'></span>" +
            "                </td>" +
            "                <td id='next_pager{{id}}' class='ui-pg-button ui-corner-all next' title='{{nc}}'>" +
            "                    <span class='ui-icon ui-icon-seek-next next'></span>" +
            "                </td>" +
            "                <td id='last_pager{{id}}' class='ui-pg-button ui-corner-all last' title='{{lc}}'>" +
            "                    <span class='ui-icon ui-icon-seek-end last'></span>" +
            "                </td>" +
            "                <td dir='{{direction}}'>" +
            "                    {{{pgselect}}}" +
            "                </td>" +
            "          </tr>" +
            "        </tbody>" +
            "    </table>";
    })(jQuery);
//});


/**
 * User: jinglg
 * Date: 11-12-26
 * Time: 11:40
 * To change this template use File | Settings | File Templates.
 * Group Merge.
 */
//mod.defineModule("grid", ["base","waf","grid_i18n","gridbase","boxUtil"],function(){
    (function ($) {
        $.jgrid = $.jgrid || {};
        //
        $.jgrid.extend({
            option:function (key, value) {
                var options = key;

                if (arguments.length === 0) {
                    return null;
                }

                if (typeof key === "string") {
                    if (value === undefined) {
                        return this.jqGrid("getGridParam", key);
                    } else {
                        options = {};
                        options[key] = value;
                        this.jqGrid("setGridParam", options);
                    }
                } else {
                    this.jqGrid("setGridParam", options);
                }
                return this;
            },
            setGridParam:function (newParams) {
                return this.each(function () {
                    var ts = this;
                    if (this.grid && typeof(newParams) === 'object') {
                        $.extend(true, this.p, newParams);
                    }
                    for (var key in newParams) {
                        if (key === "ondblClickRow") {
                            $(this).unbind("dblclick");
                            $(this).dblclick(function (e) {
                                var td = e.target;
                                var ptr = $(td, this.rows).closest("tr.jqgrow");
                                if ($(ptr).length === 0) {
                                    return false;
                                }
                                var ri = ptr[0].rowIndex;
                                var ci = $.jgrid.getCellIndex(td);
                                ts.p.ondblClickRow.call(this, $(ptr).attr("id"), ri, ci, e);
                                return false;
                            });
                        }
                        if (key === "onRightClickRow") {
                            $(this).unbind("contextmenu");
                            $(this).bind('contextmenu', function (e) {
                                var td = e.target;
                                var ptr = $(td, this.rows).closest("tr.jqgrow");
                                if ($(ptr).length === 0) {
                                    return false;
                                }
                                if (!ts.p.multiselect) {
                                    $(this).jqGrid("setSelection", ptr[0].id, true);
                                }
                                var ri = ptr[0].rowIndex;
                                var ci = $.jgrid.getCellIndex(td);
                                ts.p.onRightClickRow.call(this, $(ptr).attr("id"), ri, ci, e);
                                return false;
                            });
                        }
                        if (key === "rowNum") {
                            if ($('.ui-pg-selbox', "#pager" + this.p.id).length > 0) {
                                $('.ui-pg-selbox', "#pager" + this.p.id)[0].value = this.p.rowNum;
                                $('.ui-pg-selbox', "#pager" + this.p.id).trigger("change");
                            }
                        }
                        if(key === "hidden"){
                            if(newParams[key] === true){
                                $(ts).closest(".ui-jqgrid").hide();
                            }else{
                                $(ts).closest(".ui-jqgrid").show();
                            }
                        }
                        if(key === "editable"){
                            ts.p.cellEdit=newParams[key];
                        }
                        //tagClassstyle
                        if(key === "tagClass"){
                            if(""===newParams[key]){
                                //tagClass
                                $(ts).closest(".ui-jqgrid").attr("class","ui-jqgrid ui-widget ui-widget-content ui-corner-all");
                            }else{
                                $(ts).closest(".ui-jqgrid").addClass(newParams[key]);
                            }
                        }
                        if(key==="style"){
                            $(ts).closest(".ui-jqgrid").attr("style",newParams[key]);
                        }
                        //breakLine
                        if(key==="breakLine"){
                            if(newParams[key]){
                                $(ts).removeClass("noBreakLine");
                            }else{
                                $(ts).addClass("noBreakLine");
                            }
                        }
                        //autowidth
                        if(key==="autowidth"){
                            if(newParams[key]){
                                var newWidth = $(ts).wafGrid("getGridParentWidth");
                                $(ts).wafGrid("setGridWidth",newWidth,ts.p.shrinkToFit);
                            }else{
                                var newWidth = $(ts).wafGrid("getOriginalWidth");
                                $(ts).wafGrid("setGridWidth",newWidth,ts.p.shrinkToFit);
                            }
                        }
                        //height
                        if(key==="height"){
                            $(ts).wafGrid("setGridHeight",newParams[key]);
                        }
                        //width
                        if(key==="width"){
                            if("auto"===newParams[key]){
                                if(ts.p.autowidth){
                                    var newWidth = $(ts).wafGrid("getGridParentWidth");
                                    $(ts).wafGrid("setGridWidth",newWidth,ts.p.shrinkToFit);
                                }else{
                                    var newWidth = $(ts).wafGrid("getOriginalWidth");
                                    $(ts).wafGrid("setGridWidth",newWidth,ts.p.shrinkToFit);
                                }
                            }else{
                                $(ts).wafGrid("setGridWidth",newParams[key],ts.p.shrinkToFit);
                            }
                        }
                        //multiSelect
                        if(key==="multiselect"){
                            var oldValue = !newParams[key];
                            ts.p.multiselect =oldValue;
                            $(ts).wafGrid("removeSelect");
                            ts.p.multiselect =newParams[key];
                            if(newParams[key]){
                                $(ts).wafGrid("addCbColumn");
                            }else{
                                $(ts).wafGrid("removeCbColumn");
                            }
                        }
                        //rownumbers
                        if(key==="rownumbers"){
                            if(newParams[key]){
                                $(ts).wafGrid("addRnColumn");
                            }else{
                                $(ts).wafGrid("removeRnColumn");
                            }
                        }
                        //shrinkToFit
                        if(key==="shrinkToFit"){
                            $(ts).wafGrid("fitWidth");
                        }
                        //footerrow
                        if(key==="footerrow"){
                            if(newParams[key]){
                                var	tfoot = "",thead = $("thead:first",ts).get(0),thr = $("tr:first",thead);
                                tfoot += "<table role='grid' style='width:"+ts.p.tblwidth+"px' class='ui-jqgrid-ftable' cellspacing='0' cellpadding='0' border='0'><tbody><tr role='row' class='ui-widget-content footrow footrow-"+ts.p.direction+"'>";

                                $("th",thr).each(function ( j ) {
                                    tfoot += "<td role='gridcell' "+ts.formatCol(j,0,'', null, '', false)+">&#160;</td>";
                                });
                                tfoot += "</tr></tbody></table>";
                                ts.grid.sDiv = $("<div class='ui-jqgrid-sdiv'></div>")[0];

                                var hb = $("<div class='ui-jqgrid-hbox"+(ts.p.direction=="rtl"?"-rtl":"")+"'></div>");
                                $(ts.grid.sDiv).append(hb).appendTo($("#gview_"+ts.p.id)).width(ts.grid.width);
                                $(hb).append(tfoot);
                                ts.grid.footers = $(".ui-jqgrid-ftable",ts.grid.sDiv)[0].rows[0].cells;
                                if(ts.p.rownumbers) { ts.grid.footers[0].className = 'ui-state-default jqgrid-rownum'; }
                            }else{
                                $("#gview_"+ts.p.id).find("div.ui-jqgrid-sdiv").remove();
                                delete ts.grid.footers;
                            }
                        }
                        //entrys
                        if(key==="entrys"){
                            delete ts.p.entrys;
                            if(newParams[key]==null){
                                delete ts.p.data;
                            }else{
                                if($.isArray(newParams[key])){
                                    ts.p.data = newParams[key];
                                }
                            }
                        }
                    }
                });
            },
            getGridParam:function (pName) {
                var $t = this[0];
                if (!$t || !$t.grid) {
                    return;
                }
                if (!pName) {
                    return $t.p;
                }
                else {
                    return typeof($t.p[pName]) != "undefined" ? $t.p[pName] : null;
                }
            },

            findParentForm:function (formId) {
                var form = null, $t = this[0];
                if (formId && formId != null) {
                    form = $(formId);
                }
                if (form == null) {
                    //form
                    var parent = $("#gbox_" + $t.p.id).parent();
                    var tagName = parent[0].tagName.toUpperCase();
                    while (tagName != "BODY" && form == null) {
                        if ("FORM" === parent.get(0).tagName.toUpperCase()) {
                            form = parent;
                            break;
                        } else {
                            parent = parent.parent();
                            tagName = parent[0].tagName.toUpperCase();
                        }
                    }
                }
                return form;
            },
            initForm:function (formId) {
                this.each(function () {
                    var $t = this, form = $($t).jqGrid("findParentForm");
                    if (form) {
                        if ($t.p.cellEdit) {
                            var grids = form.data("grids") || [];
                            grids.push($t.p.id);
                            $(form).data("grids", grids);
                        }
                        form.bind("onSubmit", function (cur, data) {
                            var grids = $(this).data("grids");
                            if (grids) {
                                for (var index = 0; index < grids.length; index++) {
                                    var id = grids[index];
                                    var t = $("#" + id)[0];
                                    var saveWhenSubmit = t.p.saveWhenSubmit;
                                    var saveAllHidden = t.p.saveAllHidden;
                                    var entryProp = t.p.entryProp;
                                    var filterEmptyRow = t.p.filterEmptyRow;
                                    if (saveWhenSubmit) {
                                        var rows = t.rows;
                                        var datas = [];
                                        var styleClass = entryProp + "_" + t.p.id;
                                        //$("."+styleClass).remove();
                                        for (var i = 0; i < rows.length; i++) {
                                            var rowId = $(rows[i]).attr("id");
                                            if (rowId) {
                                                var res = $(t).jqGrid("getRowRealData", rowId);
                                                //
                                                if (filterEmptyRow && $(rows[i]).hasClass("jqgrid-new-row")) {
                                                    if ($("td.dirty-cell", $(rows[i])).length == 0) {
                                                        continue;
                                                    }
                                                }
                                                if (saveAllHidden) {
                                                    for (var column in res) {
                                                        var hiddenId = t.p.id + "_" + column + "_" + i;
                                                        var tmp = $("#" + hiddenId);
                                                        if (tmp.length == 0) {
                                                            tmp = document.createElement("input");
                                                        } else {
                                                            tmp = tmp[0];
                                                        }
                                                        tmp.type = "hidden";
                                                        tmp.id = hiddenId;
                                                        tmp.name = (entryProp + "[" + i + "]." + column);
                                                        if (typeof res[column] === "object") {
                                                            tmp.value = waf.toJSONString(res[column]);
                                                        } else {
                                                            tmp.value = res[column];
                                                        }
                                                        $(tmp).addClass(styleClass);
                                                        $(this).append(tmp);
                                                    }
                                                } else {
                                                    datas.push(res);
                                                }
                                            }
                                        }
                                        if (!saveAllHidden) {
                                            var hidden = $("#" + entryProp);
                                            if (hidden.length == 0) {
                                                var hidden = document.createElement("input");
                                                hidden.type = "hidden";
                                                hidden.id = entryProp;
                                                $(this).append(hidden);
                                            }
                                            $(hidden).attr("value", waf.toJSONString(datas));
                                            $(hidden).attr("name", entryProp);
                                            $(hidden).addClass("tmphidden");
                                        }
                                    }
                                }
                            }
                        });
                    }
                });
            },

            getGridConfig:function () {
                return this[0].p;
            },
            gridRestore:function (p) {
                if (p != undefined && p.colModel != undefined && p.colModel.length > 0) {
                    if (p.colModel.length > 0 && p.colModel[0].name == "rn") {
                        p.colModel.splice(0, 1);
                        p.colNames.splice(0, 1);
                    }
                    if (p.colModel.length > 0 && p.colModel[0].name == "cb") {
                        p.colModel.splice(0, 1);
                        p.colNames.splice(0, 1);
                    }
                    if (p.colModel.length > 0 && p.colModel[0].name == "subgrid") {
                        p.colModel.splice(0, 1);
                        p.colNames.splice(0, 1);
                    }
                    $("#" + p.id).jqGrid(p);
                }
            },
            gridDestroy:function () {
                return this.each(function () {
                    if (this.grid) {
                        if (this.p.pager) { // if not part of grid
                            $(this.p.pager).remove();
                        }
                        try {
                            $("#gbox_" + $.jgrid.jqID(this.id)).remove();
                        } catch (_) {
                        }
                    }
                });
            },
            gridUnload:function () {
                return this.each(function () {
                    if (!this.grid) {
                        return;
                    }
                    var defgrid = {id:$(this).attr('id'), cl:$(this).attr('class')};
                    if (this.p.pager) {
                        $(this.p.pager).empty().removeClass("ui-state-default ui-jqgrid-pager corner-bottom");
                    }
                    var newtable = document.createElement('table');
                    $(newtable).attr({id:defgrid.id});
                    newtable.className = defgrid.cl;
                    var gid = $.jgrid.jqID(this.id);
                    $(newtable).removeClass("ui-jqgrid-btable");
                    if ($(this.p.pager).parents("#gbox_" + gid).length === 1) {
                        $(newtable).insertBefore("#gbox_" + gid).show();
                        $(this.p.pager).insertBefore("#gbox_" + gid);
                    } else {
                        $(newtable).insertBefore("#gbox_" + gid).show();
                    }
                    $("#gbox_" + gid).remove();
                });
            },

            reloadGrid:function () {
                return $(this).trigger("reloadGrid");
            },
            setGridData:function(data,reload){
                this.each(function(){
                    if(this.p.datatype==undefined||this.p.datatype === "local"){
                        if ($.isArray(data)) {
                            this.p.data = data;
                            if(reload==undefined||reload==true){
                                $(this).trigger("reloadGrid");
                            }
                        }
                    }
                })
            },
            getGridData:function(){
                return $(this).wafGrid("getAllRowData");
            },
            clearGridData:function (clearfooter) {
                return this.each(function () {
                    var $t = this;
                    if (!$t.grid) {
                        return;
                    }
                    if (typeof clearfooter != 'boolean') {
                        clearfooter = false;
                    }
                    if ($t.p.deepempty) {
                        $("#" + $.jgrid.jqID($t.p.id) + " tbody:first tr:gt(0)").remove();
                    }
                    else {
                        var trf = $("#" + $.jgrid.jqID($t.p.id) + " tbody:first tr:first")[0];
                        $("#" + $.jgrid.jqID($t.p.id) + " tbody:first").empty().append(trf);
                    }
                    if ($t.p.footerrow && clearfooter) {
                        $(".ui-jqgrid-ftable td", $t.grid.sDiv).html("&#160;");
                    }
                    $t.p.selrow = null;
                    $t.p.selarrrow = [];
                    $t.p.savedRow = [];
                    $t.p.records = 0;
                    $t.p.page = 1;
                    $t.p.lastpage = 0;
                    $t.p.reccount = 0;
                    $t.p.data = [];
                    $t.p._index = {};
                    $t.p.iCol = undefined;
                    $t.p.iRow = undefined;
                    $t.updatepager(true, false);
                    //footrow
                    $($t).jqGrid("adjustFootRowTopBorder");
                });
            },

            adjustWidthInTab:function () {
                this.each(function () {
                    var id = this.p.id, datagrid = $("#" + id + "_outer");
                    var grid = $("#" + id).closest(".ui-jqgrid").eq(0);
                    if (datagrid.length <= 0) {
                        datagrid = grid;
                    }
                    var newWidth = $(this).wafGrid("getGridParentWidth");
                    var wid = $.boxLayoutUtil.getBorderWidth(grid) + $.boxLayoutUtil.getMarginWidth(grid) + $.boxLayoutUtil.getPaddingWidth(grid);
                    $("#" + id).wafGrid("setGridWidth", newWidth - wid, this.p.shrinkToFit);
                })
            },
            initFinish:function () {
                this.each(function () {
                    var ts = this;
                    //add by jlg,loadOnInittrue
                    if (!ts.p.loadInit) {
                        $(ts).jqGrid("setGridParam", {loadInit:true});
                    }
                    if (ts.p.cellEdit) {
                        $(ts).jqGrid("initForm", null);
                        //Model
                        $(ts).attr("entryProp",ts.p.entryProp);
                        if($.fn.enter2tab) $(ts).enter2tab();
                    }
                    $(ts).keydown(function (e) {
                        if (e.keyCode == 13 && !e.ctrlKey && !e.shiftKey) {
                            if(e.target.tagName ==="TABLE"){
                                if ($(ts).find("tr.norecord").length > 0) {
                                    $(ts).jqGrid("addRow");
                                } else {
                                    $(ts).jqGrid("nextCell", 0, 0);
                                }
                            }
                        }
                    });
                    $(ts).focus(function () {
                        if (ts.p.cellEdit) {
                            $(ts).closest(".ui-jqgrid").eq(0).addClass("ui-grid-focus");
                        }
                    });
                    $(ts).blur(function () {
                        if (ts.p.cellEdit) {
                            $(ts).closest(".ui-jqgrid").eq(0).removeClass("ui-grid-focus");
                        }
                    });

                    //jqGridGridComplete
                    $(ts).bind("jqGridGridComplete", function () {
                        $(ts).jqGrid("showNoRecords");
                        //noborderborderRightborder-bottom
                        var rows = ts.rows;
                        var len = rows.length-1;
                        if(len&&len%2==1&&!$(ts).hasClass("border")&&!$(ts).hasClass("borderBottom")){
                            $(ts.rows[len]).addClass("lasttr");
                        }else{
                            $(ts.rows[len]).removeClass("lasttr");
                        }
                        if(ts.p.grouping){
                            var arr = $(".jqfoot").prev(".jqgrow");
                            for(var i=0;i<arr.length;i++){
                                if(parseInt($("td:last-child",arr[i]).css("border-bottom-width"))==0){
                                    $(arr[i]).addClass("lasttr");
                                    break;
                                }
                            }
                        }
                    });
                })
            },
            //invoke when grid dom has been created and before request data.
            initDOM:function () {
                this.each(function(){
                    var ts = this;
                    $(ts).attr("ctrlrole", ts.p.cellEdit?"editGrid":"grid");
                    if(ts.p.afterCreateGrid) {ts.p.afterCreateGrid.call(ts,ts);}
                    $(ts).triggerHandler("jqGridAfterCreateGrid", ts);
                    //endReq
                    this.p._endReq = function () {
                        //
                        $(this).jqGrid("gridColSpan");
                        //
                        var rp = (ts.p.autoRowSpan && ts.p.rowSpanCols &&  ts.p.rowSpanCols.length>0);
                        if(rp){
                            $(this).jqGrid("gridRowSpan");
                        }
                        //
                        $(this).jqGrid("showNoRecords");
                        if (ts.p.cellEdit) {
                            ts.p.havedDelRowKey = [];
                        }
                        //sort
                        //
                        var previousSelectedTh = ts.grid.headers[ts.p.lastsort].el;
                        $("span.ui-grid-ico-sort",previousSelectedTh).addClass('ui-state-disabled');
                        $(previousSelectedTh).attr("aria-selected","false");
                        $("span.s-ico",previousSelectedTh).hide();
                        //
                        if(ts.p.sortname){
                            var idx = $.jgrid.getSortNamePos(ts.p.sortname,ts);
                            if(idx>-1){
                                var colModel = ts.p.colModel[idx];
                                var newSelectedTh = ts.grid.headers[idx].el;
                                if(newSelectedTh&&colModel.sortable){
                                    ts.p.lastsort = idx;
                                    $("span.ui-icon-"+ts.p.sortorder,newSelectedTh).removeClass('ui-state-disabled');
                                    $(newSelectedTh).attr("aria-selected","true");
                                    $("span.s-ico",newSelectedTh).show();
                                    if(ts.p.sortorder==="asc"){
                                        $("span.ui-icon-desc",newSelectedTh).css("display","none").css("margin-left",0);
                                    }else{
                                        $("span.ui-icon-asc",newSelectedTh).css("display","none").css("margin-left",0);
                                    }
                                    $("span.ui-icon-"+ts.p.sortorder,newSelectedTh).css("display","inline-block");
                                }
                            }
                        }
                        //footrow
                        $(this).jqGrid("adjustFootRowTopBorder");
                    }
                    //tagClassstyle
                    if(ts.p.tagClass && ts.p.tagClass.length>0){
                        $(ts).closest(".ui-jqgrid").addClass(ts.p.tagClass);
                    }
                    if(ts.p.style && ts.p.style.length>0){
                        $(ts).closest(".ui-jqgrid").attr("style",ts.p.style);
                    }
                    //hidden
                    if(ts.p.hidden && ts.p.hidden === true){
                        $(ts).closest(".ui-jqgrid").hide();
                    }
                    //breakLine
                    if(!ts.p.breakLine){
                        $(ts).addClass("noBreakLine");
                    }
                    //
                    if(ts.p.multikey){
                        $(ts).wafGrid("hideColumn","cb");
                    }
                    //jqGridGridLoadComplete
                    $(ts).bind("jqGridLoadComplete",function(events,datas){
                        if(ts.p.footerrow && ts.p.autoSummary && !ts.p.userDataOnFooter){
                            var params = {isFormat:true};
                            if(datas && datas.rows.length>0){
                                params.datas = datas.rows;
                            }
                            $(ts).jqGrid("calcFooterData",params);
                        }
                    })
                });
            },
            adjustFootRowTopBorder:function(){
                this.each(function(){
                    var ts = this;
                    //footrow
                    if(ts.p.footerrow){
                        var bH = $(ts.grid.bDiv).height();
                        var tH = $(ts).height();
                        if(tH<bH || $("tr",ts).hasClass("norecord")){
                            $(".footrow td",ts.grid.sDiv).addClass("topBorder");
                        }else{
                            $(".footrow td",ts.grid.sDiv).removeClass("topBorder");
                        }
                    }
                })
            },
            showNoRecords:function () {
                this.each(function () {
                    //add by jlg.
                    if ($(this).find("tr.jqgrow").length == 0) {
                        if ($(this).find("tr.norecord").length == 0) {
                            var rowData = [];
                            rowData.push("<tr role=\"row\" class= \"norecord\">");
                            rowData.push("<td style='text-align:center' colspan='" + this.p.colModel.length + "'>" + $.jgrid.noquerydata.info + "</td>");
                            rowData.push("</tr>");
                            $("#" + $.jgrid.jqID(this.p.id) + " tbody:first").append(rowData.join(''));
                            $("#pager" + this.p.id).hide();
                            rowData = [];
                        }else{
                            $(this).find("tr.norecord").find("td").attr("colspan",this.p.colModel.length);
                        }
                    } else {
                        $(this).find("tr.norecord").remove();
                        if (this.p.pager && this.p.pager.length>0)
                            $("#pager" + this.p.id).show();
                        else
                            $("#pager" + this.p.id).hide();
                    }
                });
            },
            resizeGrid:function (p) {
                this.each(function () {
                    if (this.p.autowidth === true) {
                        var newWidth = $(this).wafGrid("getGridParentWidth");
                        $(this).jqGrid("setGridWidth",newWidth);
                    }
                });
            },
            setCaption:function (newcap) {
                return this.each(function () {
                    this.p.caption = newcap;
                    $("span.ui-jqgrid-title, span.ui-jqgrid-title-rtl", this.grid.cDiv).html(newcap);
                    $(this.grid.cDiv).show();
                });
            },

            footerData:function (action, data, format) {
                var nm, success = false, res = {}, title;

                function isEmpty(obj) {
                    for (var i in obj) {
                        if (obj.hasOwnProperty(i)) {
                            return false;
                        }
                    }
                    return true;
                }

                if (typeof(action) == "undefined") {
                    action = "get";
                }
                if (typeof(format) != "boolean") {
                    format = true;
                }
                action = action.toLowerCase();
                this.each(function () {
                    var t = this, vl,v;
                    if (!t.grid || !t.p.footerrow) {
                        return false;
                    }
                    if (action == "set") {
                        if (isEmpty(data)) {
                            return false;
                        }
                    }
                    success = true;
                    $(this.p.colModel).each(function (i) {
                        nm = this.name;
                        if (action == "set") {
                            var val = $.jgrid.getAccessor(data,nm);
                            if (val !== undefined) {
                                v = $.jgrid.filterSpecialChar(this,val);
                                vl = format ? t.formatter("", v, i, data, 'edit') : v;
                                if(vl){
                                    if(this.summaryTpl && val!=undefined && val!=null){
                                        vl = $.jgrid.format(this.summaryTpl,vl,this.label);
                                    }
                                    title = this.title ? {"title":$.jgrid.stripHtml(vl)} : {};
                                    $("tr.footrow td:eq(" + i + ")", t.grid.sDiv).html(vl).attr(title).data("footData",val);
                                    success = true;
                                }
                            }
                        } else if (action == "get") {
                            if(format){
                                res[nm] = $("tr.footrow td:eq(" + i + ")", t.grid.sDiv).data("footData");
                            }else{
                                res[nm] = $("tr.footrow td:eq(" + i + ")", t.grid.sDiv).html();
                            }
                        }
                    });
                });
                return action == "get" ? res : success;
            },
            //footer.
            setFooterData:function (data, isFormat) {
                return $(this).jqGrid("footerData", "set", data, isFormat);
            },
            getFooterData:function (isFormat) {
                return $(this).jqGrid("footerData", "get",isFormat);
            },
            getKeyIndex:function(){
                var ts = this[0];
                if($.type.isNumber(ts.p.keyIndex)){
                    var ni = ts.p.rownumbers === true ? 1 : 0;
                    var gi = ts.p.multiselect === true ? 1 : 0;
                    var si = ts.p.subGrid === true ? 1 : 0;
                    return ts.p.keyIndex+ni+gi+si;
                }
                return ts.p.keyIndex;
            },
            calcFooterData : function (p) {
                var ret = [], val, sum=0, min, max, v;
                var config = {
                    isFormat:true,
                    colName:null,
                    datas:undefined
                };
                p = $.extend(config,p);

                this.each(function(){
                    if(!this.grid) {return;}
                    var $t=this,footerData={},collen =$t.p.colModel.length,cm,nm,summaryType,customCalcFun,ln=0,i=0,ret=[],fromData=p.datas&&!$t.p.scroll,count;
                    if(fromData) {
                        ln = p.datas.length;
                        count = ln;
                    }else{
                        ln = $t.rows.length;
                        count = ln-1;
                    }
                    var keyIndex = $($t).wafGrid("getKeyIndex");
                    keyIndex=keyIndex?$t.p.colModel[keyIndex].name:"id";

                    for(var pos=0;pos<collen;pos++){
                        cm = $t.p.colModel[pos];
                        nm = cm.name;
                        if(p.colName!=null && nm!=p.colName) continue;
                        if(cm.summaryTpl){
                            footerData[nm] = cm.summaryTpl;
                        }
                        customCalcFun = cm.customSummaryType;
                        summaryType = cm.summaryType;
                        if(summaryType||customCalcFun){
                            if (ln && ln>0){
                                var loop = customCalcFun || (summaryType && summaryType!="count");
                                while(i<ln && loop){
                                    if(fromData){
                                        val = $.jgrid.getAccessor(p.datas[i],nm);
                                    }else{
                                        if($($t.rows[i]).hasClass('jqgrow')) {
                                            try {
                                                val = $.unformat.call($t,$t.rows[i].cells[pos],{rowId:$t.rows[i].id, colModel:$t.p.colModel[pos],gid:$t.p.id},pos);
                                            } catch (e) {
                                                val = $.jgrid.htmlDecode($t.rows[i].cells[pos].innerHTML);
                                            }
                                        }else{
                                            i++;
                                            continue;
                                        }
                                    }

                                    if(!customCalcFun) {
                                        if($.isNaN(val)) val="0";
                                        v = parseFloat(val);
                                        sum += v;
                                        if(max==undefined || min==undefined) {
                                            min = v;
                                            max = v;
                                        } else {
                                            min = Math.min(min, v);
                                            max = Math.max(max, v);
                                        }
                                    }else {
                                        ret.push( {id:(p.datas?$.jgrid.getAccessor(p.datas[i],keyIndex):$t.rows[i].id),value:val} );
                                    }
                                    i++;
                                }
                                if(summaryType) {
                                    switch(summaryType.toLowerCase()){
                                        case 'sum': ret =sum; break;
                                        case 'avg': ret = sum/count; break;
                                        case 'count': ret = count; break;
                                        case 'min': ret = min; break;
                                        case 'max': ret = max; break;
                                    }
                                }else if(customCalcFun && $.isFunction(customCalcFun)){
                                    ret = customCalcFun.call($t,cm,ret);
                                }
                                footerData[nm] = ret;
                                //
                                i = 0,sum=0,min=undefined,max=undefined,val=undefined,ret=[];
                            }
                        }
                    }
                    $(this).wafGrid("setFooterData",footerData,p.isFormat);
                });
            },

            setGridWidth:function (nwidth, shrink) {
                if(!$.isNaN(nwidth) && nwidth<=0) return;
                return this.each(function () {
                    if (!this.grid) {
                        return;
                    }
                    if($(this).is(":hidden")) return;
                    var $t = this, cw,
                        initwidth = 0, brd = $.jgrid.cellWidth($t) ? 0 : $t.p.cellLayout, lvc, vc = 0, hs = false, scw = $t.p.scrollOffset, aw, gw = 0,
                        cl = 0, cr;
                    if (typeof shrink != 'boolean') {
                        shrink = $t.p.shrinkToFit;
                    }
                    if (isNaN(nwidth)) {
                        return;
                    }
                    else {
                        nwidth = parseInt(nwidth, 10);
                        $t.grid.width = $t.p.width = nwidth;
                    }
                    $("#gbox_" + $.jgrid.jqID($t.p.id)).css("width", nwidth + "px");
                    $("#gview_" + $.jgrid.jqID($t.p.id)).css("width", nwidth + "px");
                    $($t.grid.bDiv).css("width", nwidth + "px");
                    $($t.grid.hDiv).css("width", nwidth + "px");
                    if ($t.p.pager) {
                        $($t.p.pager).css("width", nwidth + "px");
                    }
                    if ($t.p.toppager) {
                        $($t.p.toppager).css("width", nwidth + "px");
                    }
                    if ($t.p.toolbar[0] === true) {
                        $($t.grid.uDiv).css("width", nwidth + "px");
                        if ($t.p.toolbar[1] == "both") {
                            $($t.grid.ubDiv).css("width", nwidth + "px");
                        }
                    }
                    if ($t.p.footerrow) {
                        $($t.grid.sDiv).css("width", nwidth + "px");
                    }
                    if (shrink === false && $t.p.forceFit === true) {
                        $t.p.forceFit = false;
                    }
                    if (shrink === true) {
                        $.each($t.p.colModel, function () {
                            if (this.hidden === false) {
                                cw = this.widthOrg ? this.widthOrg : parseInt(this.width, 10);
                                initwidth += cw + brd;
                                if (this.fixed) {
                                    gw += cw + brd;
                                } else {
                                    vc++;
                                }
                                cl++;
                            }
                        });
                        if (vc === 0) {
                            return;
                        }
                        $t.p.tblwidth = initwidth;
                        aw = nwidth - brd * vc - gw;
                        if (!isNaN($t.p.height)) {
                            hs = true;
                            aw -= scw;
                        }
                        initwidth = 0;
                        var cle = $t.grid.cols.length > 0;
                        $.each($t.p.colModel, function (i) {
                            if (this.hidden === false && !this.fixed) {
                                cw = this.widthOrg ? this.widthOrg : parseInt(this.width, 10);
                                cw = Math.round(aw * cw / ($t.p.tblwidth - brd * vc - gw));
                                if (cw < 0) {
                                    return;
                                }
                                this.width = cw;
                                initwidth += cw;
                                $t.grid.headers[i].width = cw;
                                $t.grid.headers[i].el.style.width = cw + "px";
                                if ($t.p.footerrow) {
                                    $t.grid.footers[i].style.width = cw + "px";
                                }
                                if (cle) {
                                    $t.grid.cols[i].style.width = cw + "px";
                                }
                                lvc = i;
                            }
                        });

                        if (!lvc) {
                            return;
                        }

                        cr = 0;
                        if (hs) {
                            if (nwidth - gw - (initwidth + brd * vc) !== scw) {
                                cr = nwidth - gw - (initwidth + brd * vc) - scw;
                            }
                        } else if (Math.abs(nwidth - gw - (initwidth + brd * vc)) !== 1) {
                            cr = nwidth - gw - (initwidth + brd * vc);
                        }
                        $t.p.colModel[lvc].width += cr;
                        $t.p.tblwidth = initwidth + cr + brd * vc + gw;
                        if ($t.p.tblwidth > nwidth) {
                            var delta = $t.p.tblwidth - parseInt(nwidth, 10);
                            $t.p.tblwidth = nwidth;
                            cw = $t.p.colModel[lvc].width = $t.p.colModel[lvc].width - delta;
                        } else {
                            cw = $t.p.colModel[lvc].width;
                        }
                        $t.grid.headers[lvc].width = cw;
                        $t.grid.headers[lvc].el.style.width = cw + "px";
                        if (cle) {
                            $t.grid.cols[lvc].style.width = cw + "px";
                        }
                        if ($t.p.footerrow) {
                            $t.grid.footers[lvc].style.width = cw + "px";
                        }
                    }
                    if ($t.p.tblwidth) {
                        $('table:first', $t.grid.bDiv).css("width", $t.p.tblwidth + "px");
                        $('table:first', $t.grid.hDiv).css("width", $t.p.tblwidth + "px");
                        $t.grid.hDiv.scrollLeft = $t.grid.bDiv.scrollLeft;
                        if ($t.p.footerrow) {
                            $('table:first', $t.grid.sDiv).css("width", $t.p.tblwidth + "px");
                        }
                    }
                });
            },
            setGridHeight:function (nh) {
                return this.each(function () {
                    var $t = this;
                    if (!$t.grid) {
                        return;
                    }
                    var bDiv = $($t.grid.bDiv);
                    bDiv.css({height:nh + (isNaN(nh) ? "" : "px")});
                    if ($t.p.frozenColumns === true) {
                        //follow the original set height to use 16, better scrollbar width detection
                        $('#' + $.jgrid.jqID($t.p.id) + "_frozen").parent().height(bDiv.height() - 16);
                    }
                    $t.p.height = nh;
                    if ($t.p.scroll) {
                        $t.grid.populateVisible();
                    }
                    //footrow
                    $($t).jqGrid("adjustFootRowTopBorder");
                });
            },
            //
            getOriginalWidth:function(){
                var ret = 0;
                function intNum (val,defval) {
                    val = parseInt(val,10);
                    if (isNaN(val)) { return defval ? defval : 0;}
                    else {return val;}
                }
                this.each(function(){
                    var ts = this,cw,initwidth=0,brd=$.jgrid.cellWidth(ts)? 0: intNum(ts.p.cellLayout,0);
                    $.each(ts.p.colModel, function() {
                        if(typeof this.hidden === 'undefined') {this.hidden=false;}
                        cw = intNum(this.widthOrg,0);
                        if(this.hidden===false){
                            initwidth += cw+brd;
                        }
                    });
                    ret = initwidth;
                })
                return ret;
            },
            fitWidth:function(){
                this.each(function(){
                    var ts = this;
                    //hiddenwidth0
                    if($(ts).is(":hidden")) return;
                    //
                    $.each(ts.p.colModel, function() {
                        if(this.widthOrg) this.width = this.widthOrg;
                    });
                    //
                    ts.setColWidth();
                    //
                    var nw;
                    $.each(ts.p.colModel, function(j) {
                        nw = this.width;
                        ts.grid.headers[j].width = nw;
                        ts.grid.headers[j].el.style.width = nw + "px";
                        ts.grid.cols[j].style.width = nw+"px";
                        if(ts.grid.footers.length>0) {ts.grid.footers[j].style.width = nw+"px";}
                    });
                    $(ts).css("width",ts.p.tblwidth);
                    var parent = $(ts).closest(".ui-jqgrid-view");
                    $("table.ui-jqgrid-htable",parent).css("width",ts.p.tblwidth);
                })
            },
            getGridParentWidth:function(){
                if(this.length<=0) return 0;
                var ts = this[0];
                var parent = $(ts).closest(".ui-jqgrid").parent();
                //sectiontdtable
                if(parent.is("td") && parent.attr("rowspan")=="1" && parent.attr("colspan")=="1"){
                    parent = parent.closest('.commontable');
                    parent = parent.parent();
                }
                var id="tmp_"+ts.p.id,eg = $("<div id='"+id+"' class='ui-jqgrid ui-widget ui-widget-content ui-corner-all'></div>").appendTo(parent);
                var newWidth = $(eg).innerWidth();
                $("#"+id,parent).remove();
                return newWidth;
            },

            destroyGroupHeader:function (nullHeader) {
                if (typeof(nullHeader) == 'undefined') {
                    nullHeader = true;
                }
                return this.each(function () {
                    var $t = this, $tr, i, l, headers, $th, $resizing, grid = $t.grid,
                        thead = $("table.ui-jqgrid-htable thead", grid.hDiv), cm = $t.p.colModel, hc;
                    if (!grid) {
                        return;
                    }

                    $(this).unbind('.setGroupHeaders');
                    $tr = $("<tr>", {role:"rowheader"}).addClass("ui-jqgrid-labels");
                    headers = grid.headers;
                    for (i = 0, l = headers.length; i < l; i++) {
                        hc = cm[i].hidden ? "none" : "";
                        $th = $(headers[i].el)
                            .width(headers[i].width)
                            .css('display', hc);
                        try {
                            $th.removeAttr("rowSpan");
                        } catch (rs) {
                            //IE 6/7
                            $th.attr("rowSpan", 1);
                        }
                        $tr.append($th);
                        $resizing = $th.children("span.ui-jqgrid-resize");
                        if ($resizing.length > 0) {// resizable column
                            $resizing[0].style.height = "";
                        }
                        $th.children("div")[0].style.top = "";
                    }
                    $(thead).children('tr.ui-jqgrid-labels').remove();
                    $(thead).prepend($tr);
                    //add by jlg
                    $("tr.jqg-first-row-header", thead).remove();

                    if (nullHeader === true) {
                        $($t).jqGrid('setGridParam', { 'groupHeader':null});
                    }
                });
            },
            setGroupHeaders:function (o) {
                o = $.extend({
                    useColSpanStyle:false,
                    groupHeaders:[]
                }, o || {});
                return this.each(function () {
                    this.p.groupHeader = o;
                    var ts = this,
                        i, cmi, skip = 0, $tr, $colHeader, th, $th, thStyle,
                        iCol,
                        cghi,
                        //startColumnName,
                        numberOfColumns,
                        titleText,
                        cVisibleColumns,
                        colModel = ts.p.colModel,
                        cml = colModel.length,
                        ths = ts.grid.headers,
                        $htable = $("table.ui-jqgrid-htable", ts.grid.hDiv),
                        $trLabels = $htable.children("thead").children("tr.ui-jqgrid-labels:last").addClass("jqg-second-row-header"),
                        $thead = $htable.children("thead"),
                        $theadInTable,
                        $firstHeaderRow = $htable.find(".jqg-first-row-header");
                    if ($firstHeaderRow.html() === null) {
                        $firstHeaderRow = $('<tr>', {role:"row", "aria-hidden":"true"}).addClass("jqg-first-row-header").css("height", "auto");
                    } else {
                        $firstHeaderRow.empty();
                    }
                    var $firstRow,
                        inColumnHeader = function (text, columnHeaders) {
                            var i = 0, length = columnHeaders.length;
                            for (; i < length; i++) {
                                if (columnHeaders[i].startColumnName === text) {
                                    return i;
                                }
                            }
                            return -1;
                        };

                    $(ts).prepend($thead);
                    $tr = $('<tr>', {role:"rowheader"}).addClass("ui-jqgrid-labels jqg-third-row-header");
                    for (i = 0; i < cml; i++) {
                        th = ths[i].el;
                        $th = $(th);
                        cmi = colModel[i];
                        // build the next cell for the first header row
                        thStyle = { height:'0px', width:ths[i].width + 'px', display:(cmi.hidden ? 'none' : '')};
                        $("<th>", {role:'gridcell'}).css(thStyle).addClass("ui-first-th-" + ts.p.direction).appendTo($firstHeaderRow);

                        //th.style.width = ""; // remove unneeded style,modify on 2013-6-8
                        iCol = inColumnHeader(cmi.name, o.groupHeaders);
                        if (iCol >= 0) {
                            cghi = o.groupHeaders[iCol];
                            numberOfColumns = cghi.numberOfColumns;
                            titleText = cghi.titleText;

                            // caclulate the number of visible columns from the next numberOfColumns columns
                            for (cVisibleColumns = 0, iCol = 0; iCol < numberOfColumns && (i + iCol < cml); iCol++) {
                                if (!colModel[i + iCol].hidden) {
                                    cVisibleColumns++;
                                }
                            }

                            // The next numberOfColumns headers will be moved in the next row
                            // in the current row will be placed the new column header with the titleText.
                            // The text will be over the cVisibleColumns columns
                            $colHeader = $('<th>').attr({role:"columnheader"})
                                .addClass("ui-state-default ui-th-column-header ui-th-" + ts.p.direction)
                                .css({'height':'22px', 'border-top':'0px none'})
                                .html(titleText);
                            if (cVisibleColumns > 0) {
                                $colHeader.attr("colspan", String(cVisibleColumns));
                            }
                            if (ts.p.headertitles) {
                                $colHeader.attr("title", $colHeader.text());
                            }
                            // hide if not a visible cols
                            if (cVisibleColumns === 0) {
                                $colHeader.hide();
                            }

                            $th.before($colHeader); // insert new column header before the current
                            $tr.append(th);         // move the current header in the next row

                            // set the coumter of headers which will be moved in the next row
                            skip = numberOfColumns - 1;
                        } else {
                            if (skip === 0) {
                                if (o.useColSpanStyle) {
                                    // expand the header height to two rows
                                    $th.attr("rowspan", "2");
                                } else {
                                    $('<th>', {role:"columnheader"})
                                        .addClass("ui-state-default ui-th-column-header ui-th-" + ts.p.direction)
                                        .css({"display":cmi.hidden ? 'none' : '', 'border-top':'0px none'})
                                        .insertBefore($th);
                                    $tr.append(th);
                                }
                            } else {
                                // move the header to the next row
                                //$th.css({"padding-top": "2px", height: "19px"});
                                $tr.append(th);
                                skip--;
                            }
                        }
                    }
                    $theadInTable = $(ts).children("thead");
                    $theadInTable.prepend($firstHeaderRow);
                    $tr.insertAfter($trLabels);
                    $htable.append($theadInTable);

                    if (o.useColSpanStyle) {
                        // Increase the height of resizing span of visible headers
                        $htable.find("span.ui-jqgrid-resize").each(function () {
                            var $parent = $(this).parent();
                            if ($parent.is(":visible")) {
                                this.style.cssText = 'height: ' + $parent.height() + 'px !important; cursor: col-resize;';
                            }
                        });

                        // Set position of the sortable div (the main lable)
                        // with the column header text to the middle of the cell.
                        // One should not do this for hidden headers.
                        $htable.find("div.ui-jqgrid-sortable").each(function () {
                            var $ts = $(this), $parent = $ts.parent();
                            if ($parent.is(":visible") && $parent.is(":has(span.ui-jqgrid-resize)")) {
                                $ts.css('top', ($parent.height() - $ts.outerHeight()) / 2 + 'px');
                            }
                        });
                    }

                    $firstRow = $theadInTable.find("tr.jqg-first-row-header");
                    $(ts).bind('jqGridResizeStop.setGroupHeaders', function (e, nw, idx) {
                        $firstRow.find('th').eq(idx).width(nw);
                    });
                });
            } ,
            getGroupHeadersConfig:function(){
                if(this.length>0){
                    var ts = this[0];
                    return ts.p.groupHeader;
                }
            },
            setGroupHeaderProp:function(index,propName,value){
                this.each(function(){
                    var ts =this,options={};
                    if($.type.isObject(propName)){
                        options = propName;
                    }else{
                        options[propName] = value;
                    }
                    var headconfig = ts.p.groupHeader;
                    if(headconfig){
                        waf(ts).wafGrid("destroyGroupHeader");
                        if(options.useColSpanStyle!=undefined){
                            headconfig.useColSpanStyle = options.useColSpanStyle;
                        }
                        if(options.startColumnName || options.numberOfColumns || options.titleText){
                            var heads = headconfig.groupHeaders;
                            if(heads.length>0){
                                $.extend(heads[index],options);
                            }
                        }
                        waf(ts).wafGrid("setGroupHeaders",headconfig);
                    }
                })
            },
            getGroupHeaderProp:function(propName){
                var config = this.wafGrid("getGroupHeadersConfig");
                if(config){
                    return typeof(config[propName]) != "undefined" ? config[propName] : null;
                }
            },


            getDataGroupConfig:function(){
                if(this.length>0){
                    var ts = this[0];
                    return ts.p.groupingView;
                }
            },
            setDataGroup:function(options,loaddata){
                this.each(function(){
                    var ts = this,id=ts.p.id;
                    //
                    $(ts).wafGrid("groupingRemove");
                    $(ts).wafGrid("option","rownumbers",false);
                    //
                    ts.p.scroll = false;
                    ts.p.rownumbers = false;
                    ts.p.treeGrid = false;
                    ts.p.gridview = true;
                    ts.p.grouping=options["grouping"]||true;

                    var newConfig = {};
                    $.each(options,function(key,value){
                        if("groupCollapse"===key || "showSummaryOnHide"===key){
                            newConfig[key] = value;
                        }else if("groupOrder"===key || "groupField"===key || "groupSummary"===key || "groupColumnShow"===key || "groupText"===key){
                            newConfig[key] = [value];
                        }
                    });
                    $.extend(ts.p.groupingView, newConfig);
                    if(loaddata==undefined || loaddata==true){
                        $(ts).wafGrid("reloadGrid");
                    }
                })
            },
            destroyDataGroup:function(){
                $(this).wafGrid("groupingRemove")
            },
            setDataGroupProp:function(propName,value,loaddata){
                this.each(function(){
                    var ts = this,id=ts.p.id,options={};
                    if($.type.isObject(propName)){
                        options = propName;
                    }else{
                        options[propName] = value;
                    }
                    $(ts).wafGrid("setDataGroup",options,loaddata);
                })
            },
            getDataGroupProp:function(propName){
                var config = this.jqGrid("getDataGroupConfig");
                if(config){
                    return typeof(config[propName]) != "undefined" ? config[propName] : null;
                }
            },

            createPager:function(options,loaddata){
                this.each(function(){
                    var ts = this,id=ts.p.id;
                    var pager = $("#pager"+id);
                    if(pager.length==0) {
                        //
                        if (this.grid && typeof(options) === 'object') {
                            $.extend(true, ts.p, options);
                        }
                        pager = $("<div></div>");
                        pager.attr("id","pager"+id);
                        ts.p.pager = "#pager"+id;
                        var eg = $(ts).closest("div.ui-jqgrid");
                        $(pager).css({width: ts.grid.width+"px"}).appendTo(eg)
                            .addClass('ui-state-default ui-jqgrid-pager ui-corner-bottom');

                        ts.initPager();

                        if(loaddata==undefined || loaddata) {
                            $(ts).wafGrid("reloadGrid");
                        }
                    }
                })
            },
            deletePager:function(){
                this.each(function(){
                    var ts = this,id=ts.p.id;
                    waf("#pager"+id).remove();
                    delete ts.p.pager;
                })
            },
            setPagerProp:function(propName,value,loaddata){
                this.each(function(){
                    var ts = this,id=ts.p.id,options={},rebuild=false;
                    if($.type.isObject(propName)){
                        options = propName;
                    }else{
                        options[propName] = value;
                    }
                    $.each(options, function (key, value) {
                        if("id"!==key && "parentId"!==key){
                            $(ts).wafGrid("option",key,value);
                            //
                            if("rowList"===key){
                                rebuild = true;
                                //
                                ts.p[key]=value;
                            }
                        }
                    });
                    if(rebuild){
                        var pc = {rowNum:ts.p.rowNum,page:ts.p.page,rowList:ts.p.rowList};
                        $(ts).wafGrid("deletePager");
                        $(ts).wafGrid("createPager",pc);
                    }
                    if(loaddata==undefined || loaddata) {
                        $(ts).wafGrid("reloadGrid");
                    }
                })
            },
            getPagerProp:function(propName){
                return $(this).wafGrid("option",propName);
            },
            loadPage:function(e){
                this.each(function(){
                    var ts = this;
                    ts.loadPage(e);
                })
            },
            isLoading:function(){
                if(this.length>0){
                    var ts = this[0];
                    return ts.grid.hDiv.loading;
                }
                return false;
            }
        });

        //
        $.jgrid.extend({
            addRow:function (p, record) {
                p = $.extend(true, {
                    rowID:"new_row",
                    data:{},
                    position:"last",
                    useDefValues:true,
                    useFormatter:null,
                    src:null,
                    addRowParams:{extraparam:{}},
                    afterAddRow:null,
                    autoFocus:true,
                    autoFillSelect:true
                }, p || {});
                this.each(function () {
                    if (!this.grid) {
                        return;
                    }
                    function findNextId(ts) {
                        var maxId = 0;
                        $("#" + $(ts)[0].p.id + " tr").each(function () {
                            var id = $(this).attr("id");
                            try {
                                id = parseInt(id);
                                if (id > maxId) {
                                    maxId = id;
                                }
                            } catch (e) {
                            }
                        });
                        maxId = parseInt(maxId) + 1;
                        return maxId;
                    }

                    if (undefined == record) record = true;
                    var $t = this;
                    //add by jlg.
                    $($t).jqGrid("editStop");
                    //rowId
                    if (p.rowID === "new_row") {
                        p.rowID = findNextId($t);
                    }
                    //datanull
                    if (p.data == null) p.data = {};
                    //
                    var tmp = $.extend({}, p.data);
                    if (p.useDefValues === true) {
                        $($t.p.colModel).each(function (i) {
                            if (this.editoptions && this.editoptions.defaultValue) {
                                var opt = this.editoptions.defaultValue,
                                    tmp = $.isFunction(opt) ? opt.call($t) : opt;
                                p.data[this.name] = tmp;
                            } else if (this.edittype && "wafselect" === this.edittype && p.autoFillSelect) {
                                this.autoFillSelect = true;
                                if (!(p.data && p.data[this.name])) {
                                    //select.
                                    if (this.editoptions && this.editoptions.enumSource && this.editoptions.enumSource.length > 0) {
                                        var tmp, option = this.editoptions.enumSource[0];
                                        if (option.childs && option.childs.length > 0) {
                                            tmp = option.childs[0].value;
                                        } else {
                                            tmp = this.editoptions.enumSource[0].value;
                                        }
                                        p.data[this.name] = tmp;
                                    }
                                }
                            }
                        });
                    }
                    $($t).jqGrid('addRowData', p.rowID, p.data, p.position, p.src);
                    $("#" + $.jgrid.jqID(p.rowID), "#" + $.jgrid.jqID($t.p.id)).addClass("jqgrid-new-row");
                    if ($t.p.cellEdit === true && record === true && !$.isEmptyObject(p.data)) {
                        $("#" + $.jgrid.jqID(p.rowID), "#" + $.jgrid.jqID($t.p.id)).addClass("edited");
                        $("#" + $.jgrid.jqID(p.rowID), "#" + $.jgrid.jqID($t.p.id)).find("td").each(function (i) {
                            var nm = $t.p.colModel[i].name;
                            var config = waf("#" + $t.p.id).jqGrid("getCellConfig", nm, $.jgrid.jqID(p.rowID));
                            if ($.jgrid.getAccessor(tmp,nm) != undefined) {
                                $(this).addClass("dirty-cell");
                            }
                        });
                    }
                    //autoFocus
                    var condition = (p.useFormatter != null && !p.useFormatter) || (p.useFormatter == null && p.autoFocus);
                    if (condition && $t.p.cellEdit === true) {
                        var opers = $t.p.prmNames,
                            oper = opers.oper;
                        p.addRowParams.extraparam[oper] = opers.addoper;
                        //Cell.TODO:
                        //$($t).jqGrid('removeSelect');
                        //$($t).jqGrid('setSelection', p.rowID);
                        var iCol = 0, nm;
                        for (var i = 0; i < $t.p.colModel.length; i++) {
                            nm = $t.p.colModel[i];
                            if (nm.name !== 'cb' && nm.name !== 'subgrid') {
                                if (nm.editable && nm.editoptions) {//add by jlg.
                                    iCol = i;
                                    break;
                                }
                            }
                        }
                        var rowInd = $t.rows.namedItem(p.rowID);
                        if (rowInd) {
                            $($t).jqGrid('editCell', rowInd.rowIndex, iCol, true);
                        }
                    }
                    if ($.isFunction(p.afterAddRow)) {
                        p.afterAddRow.call(this, $t, $t.p.colModel, p.rowID);
                    }
                });
                return p.rowID+"";
            },
            delRow:function (rowid, p) {
                p = $.extend(true, {
                    beforeDelRow:null,
                    afterDelRow:null
                }, p || {});
                var success = false, rowInd, ia, ri, keyValue, delObject;
                this.each(function () {
                    var $t = this;
                    rowInd = $t.rows.namedItem(rowid);
                    if (!rowInd) {
                        return false;
                    }
                    else {
                        ri = rowInd.rowIndex;
                        if ($.isFunction(p.beforeDelRow)) {
                            var bfr = p.beforeDelRow.call(this, rowid, $t, $t.p.colModel);
                            if (bfr === undefined) {
                                bfr = true;
                            }
                            if (bfr === false) {
                                return;
                            }
                        }
                        $("td", rowInd).each(function (i) {
                            var nm = $t.p.colModel[i];
                            if (nm.name !== 'cb' && nm.name !== 'subgrid') {
                                if (nm.key && nm.key === true) {
                                    keyValue = $.unformat(this, {rowId:rowInd.id, colModel:$t.p.colModel[i], gid:$($t).attr("id")}, i);
                                }
                            }
                        });
                        delObject = $("#" + $t.p.id).jqGrid("getRowRealData", rowid);
                        $(rowInd).remove();
                        $t.p.records--;
                        $t.p.reccount--;
                        $t.updatepager(true, false);
                        success = true;
                        if ($t.p.multiselect) {
                            ia = $.inArray(rowid, $t.p.selarrrow);
                            if (ia != -1) {
                                $t.p.selarrrow.splice(ia, 1);
                            }
                        }
                        if (rowid == $t.p.selrow) {
                            $t.p.selrow = null;
                        }
                        if($t.p.cellEdit){
                            if ($t.p.iRow == ri) {
                                $t.p.savedRow = [];
                                $t.p.iCol = undefined;
                                $t.p.iRow = undefined;
                            }
                        }
                    }
                    if ($t.p.datatype == 'local') {
                        var pos = $t.p._index[rowid];
                        if (typeof(pos) != 'undefined') {
                            $t.p.data.splice(pos, 1);
                            $t.refreshIndex();
                        }
                    }
                    if ($t.p.altRows === true && success) {
                        var cn = $t.p.altclass;
                        $($t.rows).each(function (i) {
                            if (i % 2 == 1) {
                                $(this).addClass(cn);
                            }
                            else {
                                $(this).removeClass(cn);
                            }
                        });
                    }
                    if (success) {
                        if ($.isFunction(p.afterDelRow)) {
                            p.afterDelRow.call(this, $t, $t.p.colModel,delObject);
                        }
                        var havedDelRowKey = $t.p.havedDelRowKey || [];
                        havedDelRowKey.push(delObject);
                        $t.p.havedDelRowKey = havedDelRowKey;
                    }
                });
                return success;
            },

            setSelection:function (selection, onsr, e) {
                return this.each(function () {
                    var $t = this, stat, pt, ner, ia, tpsr, fid;
                    if (selection === undefined) {
                        return;
                    }
                    onsr = onsr === false ? false : true;
                    pt = $t.rows.namedItem(selection + "");
                    if (!pt || !pt.className || pt.className.indexOf('ui-state-disabled') > -1) {
                        return;
                    }
                    function scrGrid(iR) {
                        var ch = $($t.grid.bDiv)[0].clientHeight,
                            st = $($t.grid.bDiv)[0].scrollTop,
                            rpos = $t.rows[iR].offsetTop,
                            rh = $t.rows[iR].clientHeight;
                        if (rpos + rh >= ch + st) {
                            $($t.grid.bDiv)[0].scrollTop = rpos - (ch + st) + rh + st;
                        }
                        else if (rpos < ch + st) {
                            if (rpos < st) {
                                $($t.grid.bDiv)[0].scrollTop = rpos;
                            }
                        }
                    }

                    if ($t.p.scrollrows === true) {
                        ner = $t.rows.namedItem(selection).rowIndex;
                        if (ner >= 0) {
                            scrGrid(ner);
                        }
                    }
                    if ($t.p.frozenColumns === true) {
                        fid = $t.p.id + "_frozen";
                    }
                    if (!$t.p.multiselect) {
                        if (pt.className !== "ui-subgrid") {
                            if ($t.p.selrow != pt.id) {
                                $($t.rows.namedItem($t.p.selrow)).removeClass("ui-state-highlight").attr({"aria-selected":"false", "tabindex":"-1"});
                                $(pt).addClass("ui-state-highlight").attr({"aria-selected":"true", "tabindex":"0"});//.focus();
                                if (fid) {
                                    $("#" + $.jgrid.jqID($t.p.selrow), "#" + $.jgrid.jqID(fid)).removeClass("ui-state-highlight");
                                    $("#" + $.jgrid.jqID(selection), "#" + $.jgrid.jqID(fid)).addClass("ui-state-highlight");
                                }
                                stat = true;
                            } else {
                                stat = false;
                            }
                            $t.p.selrow = pt.id;
                            $($t).triggerHandler("jqGridSelectRow", [pt.id, stat, e]);
                            if ($t.p.onSelectRow && onsr) {
                                $t.p.onSelectRow.call($t, pt.id, stat, e);
                            }
                        }
                    } else {
                        //unselect selectall checkbox when deselecting a specific row
                        $t.setHeadCheckBox(false);
                        $t.p.selrow = pt.id;
                        ia = $.inArray($t.p.selrow, $t.p.selarrrow);
                        if (ia === -1) {
                            if (pt.className !== "ui-subgrid") {
                                $(pt).addClass("ui-state-highlight").attr("aria-selected", "true");
                            }
                            stat = true;
                            $t.p.selarrrow.push($t.p.selrow);
                        } else {
                            if (pt.className !== "ui-subgrid") {
                                $(pt).removeClass("ui-state-highlight").attr("aria-selected", "false");
                            }
                            stat = false;
                            $t.p.selarrrow.splice(ia, 1);
                            tpsr = $t.p.selarrrow[0];
                            $t.p.selrow = (tpsr === undefined) ? null : tpsr;
                        }
                        $("#jqg_" + $.jgrid.jqID($t.p.id) + "_" + $.jgrid.jqID(pt.id))[$t.p.useProp ? 'prop' : 'attr']("checked", stat);
                        if (fid) {
                            if (ia === -1) {
                                $("#" + $.jgrid.jqID(selection), "#" + $.jgrid.jqID(fid)).addClass("ui-state-highlight");
                            } else {
                                $("#" + $.jgrid.jqID(selection), "#" + $.jgrid.jqID(fid)).removeClass("ui-state-highlight");
                            }
                            $("#jqg_" + $.jgrid.jqID($t.p.id) + "_" + $.jgrid.jqID(selection), "#" + $.jgrid.jqID(fid))[$t.p.useProp ? 'prop' : 'attr']("checked", stat);
                        }
                        $($t).triggerHandler("jqGridSelectRow", [pt.id, stat, e]);
                        if ($t.p.onSelectRow && onsr) {
                            $t.p.onSelectRow.call($t, pt.id, stat, e);
                        }
                    }
                });
            },
            resetSelection:function (rowid) {
                return this.each(function () {
                    var t = this, ind, sr, fid;
                    if (t.p.frozenColumns === true) {
                        fid = t.p.id + "_frozen";
                    }
                    if (typeof(rowid) !== "undefined") {
                        sr = rowid === t.p.selrow ? t.p.selrow : rowid;
                        $("#" + $.jgrid.jqID(t.p.id) + " tbody:first tr#" + $.jgrid.jqID(sr)).removeClass("ui-state-highlight").attr("aria-selected", "false");
                        if (fid) {
                            $("#" + $.jgrid.jqID(sr), "#" + $.jgrid.jqID(fid)).removeClass("ui-state-highlight");
                        }
                        if (t.p.multiselect) {
                            $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(sr), "#" + $.jgrid.jqID(t.p.id))[t.p.useProp ? 'prop' : 'attr']("checked", false);
                            if (fid) {
                                $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(sr), "#" + $.jgrid.jqID(fid))[t.p.useProp ? 'prop' : 'attr']("checked", false);
                            }
                            t.setHeadCheckBox(false);
                        }
                        sr = null;
                    } else if (!t.p.multiselect) {
                        if (t.p.selrow) {
                            $("#" + $.jgrid.jqID(t.p.id) + " tbody:first tr#" + $.jgrid.jqID(t.p.selrow)).removeClass("ui-state-highlight").attr("aria-selected", "false");
                            if (fid) {
                                $("#" + $.jgrid.jqID(t.p.selrow), "#" + $.jgrid.jqID(fid)).removeClass("ui-state-highlight");
                            }
                            t.p.selrow = null;
                        }
                    } else {
                        $(t.p.selarrrow).each(function (i, n) {
                            ind = t.rows.namedItem(n);
                            $(ind).removeClass("ui-state-highlight").attr("aria-selected", "false");
                            $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(n))[t.p.useProp ? 'prop' : 'attr']("checked", false);
                            if (fid) {
                                $("#" + $.jgrid.jqID(n), "#" + $.jgrid.jqID(fid)).removeClass("ui-state-highlight");
                                $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(n), "#" + $.jgrid.jqID(fid))[t.p.useProp ? 'prop' : 'attr']("checked", false);
                            }
                        });
                        t.setHeadCheckBox(false);
                        t.p.selarrrow = [];
                    }
                    if (t.p.cellEdit === true) {
                        if (parseInt(t.p.iCol, 10) >= 0 && parseInt(t.p.iRow, 10) >= 0) {
                            $("td:eq(" + t.p.iCol + ")", t.rows[t.p.iRow]).removeClass("edit-cell ui-state-highlight");
                            $(t.rows[t.p.iRow]).removeClass("selected-row ui-state-hover");
                        }
                    }
                    t.p.savedRow = [];
                });
            },
            removeSelect:function (rowId) {
                var t = this[0], ind, one = rowId != undefined;
                var froz = t.p.frozenColumns === true ? t.p.id + "_frozen" : "";
                if (t.p.multiselect) {
                    $(t.p.selarrrow).each(function (i, n) {
                        ind = t.rows.namedItem(n);
                        if (one) {
                            if (rowId === n) {
                                $(ind).removeClass("ui-state-highlight").attr("aria-selected", "false");
                                $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(n))[t.p.useProp ? 'prop' : 'attr']("checked", false);
                                if (froz) {
                                    var ft = $("#" + froz);
                                    var froind = ft[0].rows.namedItem(n);
                                    $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(froind.id), t.grid.fbDiv)[t.p.useProp ? 'prop' : 'attr']("checked", false);
                                    $("#" + $.jgrid.jqID(t.p.id), t.grid.fbDiv).removeClass("ui-state-highlight");
                                    $(froind).removeClass("ui-state-highlight");
                                    $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(froind.id), ft)[t.p.useProp ? 'prop' : 'attr']("checked", false);
                                }
                                t.p.selarrrow.splice(i, 1);
                                return;
                            }
                        } else {
                            $(ind).removeClass("ui-state-highlight").attr("aria-selected", "false");
                            $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(n))[t.p.useProp ? 'prop' : 'attr']("checked", false);
                            if (froz) {
                                var ft = $("#" + froz);
                                var froind = ft[0].rows.namedItem(n);
                                $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(n), t.grid.fbDiv)[t.p.useProp ? 'prop' : 'attr']("checked", false);
                                $("#" + $.jgrid.jqID(t.p.id), t.grid.fbDiv).removeClass("ui-state-highlight");
                                $(froind).removeClass("ui-state-highlight");
                                $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(n), ft)[t.p.useProp ? 'prop' : 'attr']("checked", false);
                            }
                            t.p.selarrrow.splice(0, 1);
                        }
                    });
                } else {
                    ind = t.rows.namedItem(t.p.selrow);
                    $(ind).removeClass("ui-state-highlight").attr("aria-selected", "false");
                    $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(t.p.selrow))[t.p.useProp ? 'prop' : 'attr']("checked", false);
                    if (froz) {
                        var ft = $("#" + froz);
                        var froind = ft[0].rows.namedItem(t.p.selrow);
                        $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(t.p.selrow), t.grid.fbDiv)[t.p.useProp ? 'prop' : 'attr']("checked", false);
                        $("#" + $.jgrid.jqID(t.p.id), t.grid.fbDiv).removeClass("ui-state-highlight");
                        $(froind).removeClass("ui-state-highlight");
                        $("#jqg_" + $.jgrid.jqID(t.p.id) + "_" + $.jgrid.jqID(t.p.selrow), ft)[t.p.useProp ? 'prop' : 'attr']("checked", false);
                    }
                    t.p.selrow = null;
                }
            },

            setRowStyle:function (rowId, style) {
                this.each(function () {
                    var $t = this, row;
                    row = $t.rows.namedItem(rowId);
                    $(row).attr("style", style);
                    var froz = $t.p.frozenColumns === true ? $t.p.id + "_frozen" : "";
                    if (froz) {
                        var ft = $("#" + froz);
                        var froind = ft[0].rows.namedItem(rowId);
                        $(froind).attr("style", style);
                    }
                });
            },
            setRowData:function (rowid, data, cssp, record) {
                var nm, success = true, title, realCol, tmp, td, oldValue, colspans = [], tmp1, list, count = 0;
                if (undefined == record) record = true;
                this.each(function () {
                    if (!this.grid) {
                        return false;
                    }
                    var t = this, vl, ind, cp = typeof cssp, lcdata = {}, editable = t.p.cellEdit && record, v;
                    ind = t.rows.namedItem(rowid);
                    if (!ind) {
                        return false;
                    }
                    if (data) {
                        try {
                            $(this.p.colModel).each(function (i) {
                                nm = this.name;
                                if ($.jgrid.getAccessor(data,nm)!== undefined) {
                                    lcdata[nm] = $.jgrid.getAccessor(data,nm);
                                    $.jgrid.setCellValue(t, rowid, i, $.jgrid.getAccessor(data,nm), record, data);
                                }
                            });
                            //TODO:DELETE UPDATING LOCAL DATA
                        } catch (e) {
                            success = false;
                        }
                    }
                    if (success) {
                        if (cp === 'string') {
                            $(ind).addClass(cssp);
                        } else if (cp === 'object') {
                            $(ind).css(cssp);
                        }
                        $(t).triggerHandler("jqGridAfterGridComplete");
                    }
                });
                return success;
            },
            getRowIndex:function (rowid) {
                return $(this).wafGrid("getInd", rowid, false);
            },

            getRowObject:function (rowid) {
                var ret = false;
                this.each(function () {
                    ret = this.rows.namedItem(rowid);
                });
                return ret;
            },
            getRowRealData:function (rowid) {
                //add by jlg.
                //add by jlg.
                $(this).jqGrid("editStop");
                return $(this).jqGrid("getRowData", rowid);
            },
            getAllRowData:function () {
                var ret = [], ts = this[0], ids;
                ids = $(this).jqGrid("getDataIDs");
                if (ids && $.isArray(ids) && ids.length > 0) {
                    for (var i = 0; i < ids.length; i++) {
                        var rowData = $(this).jqGrid("getRowRealData", ids[i]);
                        ret.push(rowData);
                    }
                }
                return ret;
            },
            getDataIDs:function () {
                var ids = [], i = 0, len, j = 0;
                this.each(function () {
                    len = this.rows.length;
                    if (len && len > 0) {
                        while (i < len) {
                            if ($(this.rows[i]).hasClass('jqgrow')) {
                                ids[j] = this.rows[i].id;
                                j++;
                            }
                            i++;
                        }
                    }
                });
                return ids;
            },

            getRowId:function (rowIndex) {
                var id;
                this.each(function () {
                    if (this.rows.length > 1) {
                        id = this.rows[rowIndex].id
                    }
                });
                return id;
            },

            addLocalRowData:function (data, pos, src) {
                this.each(function () {
                    if ($.isArray(data)) {
                        if (data.length > 0) {
                            var idn = "id";
                            for (i = 0; i < this.p.colModel.length; i++) {
                                if (this.p.colModel[i].key === true) {
                                    idn = this.p.colModel[i].name;
                                    break;
                                }
                            }
                            for (var i = 0; i < data.length; i++) {
                                waf(this).wafGrid('addRowData', (data[i][idn] ? data[i][idn] : (i + 1)), data[i], pos, src);
                            }
                        }
                    }
                    $(this).jqGrid("showNoRecords");
                })
            },
            addRowData:function (rowid, rdata, pos, src) {
                if (!pos) {
                    pos = "last";
                }
                var success = false, nm, row, gi, si, ni, sind, i, v, prp = "", aradd, cnm, cn, data, cm, id;
                if (rdata) {
                    if ($.isArray(rdata)) {
                        aradd = true;
                        pos = "last";
                        cnm = rowid;
                    } else {
                        rdata = [rdata];
                        aradd = false;
                    }
                    this.each(function () {
                        var t = this, datalen = rdata.length;
                        ni = t.p.rownumbers === true ? 1 : 0;
                        gi = t.p.multiselect === true ? 1 : 0;
                        si = t.p.subGrid === true ? 1 : 0;
                        if (!aradd) {
                            if (typeof(rowid) != 'undefined') {
                                rowid = rowid + "";
                            }
                            else {
                                rowid = $.jgrid.randId();
                                if (t.p.keyIndex !== false) {
                                    cnm = t.p.colModel[t.p.keyIndex + gi + si + ni].name;
                                    if (typeof rdata[0][cnm] != "undefined") {
                                        rowid = rdata[0][cnm];
                                    }
                                }
                            }
                        }
                        cn = t.p.altclass;
                        var k = 0, cna = "", lcdata = {},
                            air = $.isFunction(t.p.afterInsertRow) ? true : false;
                        while (k < datalen) {
                            data = rdata[k];
                            row = [];
                            if (aradd) {
                                try {
                                    rowid = data[cnm];
                                }
                                catch (e) {
                                    rowid = $.jgrid.randId();
                                }
                                cna = t.p.altRows === true ? (t.rows.length - 1) % 2 === 0 ? cn : "" : "";
                            }
                            id = rowid;
                            rowid = t.p.idPrefix + rowid;
                            if (ni) {
                                prp = t.formatCol(0, 1, '', null, rowid, true);
                                row[row.length] = "<td role=\"gridcell\" class=\"ui-state-default jqgrid-rownum\" " + prp + ">0</td>";
                            }
                            if (gi) {
                                v = "<input role=\"checkbox\" type=\"checkbox\"" + " id=\"jqg_" + t.p.id + "_" + rowid + "\" class=\"cbox\"/>";
                                prp = t.formatCol(ni, 1, '', null, rowid, true);
                                row[row.length] = "<td role=\"gridcell\" " + prp + ">" + v + "</td>";
                            }
                            if (si) {
                                row[row.length] = $(t).jqGrid("addSubGridCell", gi + ni, 1);
                            }
                            for (i = gi + si + ni; i < t.p.colModel.length; i++) {
                                cm = t.p.colModel[i];
                                nm = cm.name;
                                lcdata[nm] = $.jgrid.getAccessor(data,nm);
                                v = $.jgrid.filterSpecialChar(cm, $.jgrid.getAccessor(data, nm));
                                v = t.formatter(rowid, v, i, data, 'edit');
                                prp = t.formatCol(i, 1, v, data, rowid, true);
                                row[row.length] = "<td role=\"gridcell\" " + prp + ">" + v + "</td>";
                            }
                            row.unshift(t.constructTr(rowid, false, cna, lcdata, lcdata));
                            row[row.length] = "</tr>";
                            if (t.rows.length === 0) {
                                $("table:first", t.grid.bDiv).append(row.join(''));
                            } else {
                                switch (pos) {
                                    case 'last':
                                        $(t.rows[t.rows.length - 1]).after(row.join(''));
                                        sind = t.rows.length - 1;
                                        break;
                                    case 'first':
                                        $(t.rows[0]).after(row.join(''));
                                        sind = 1;
                                        break;
                                    case 'after':
                                        sind = t.rows.namedItem(src);
                                        if (sind) {
                                            if ($(t.rows[sind.rowIndex + 1]).hasClass("ui-subgrid")) {
                                                $(t.rows[sind.rowIndex + 1]).after(row);
                                            }
                                            else {
                                                $(sind).after(row.join(''));
                                            }
                                        }
                                        sind++;
                                        break;
                                    case 'before':
                                        sind = t.rows.namedItem(src);
                                        if (sind) {
                                            $(sind).before(row.join(''));
                                            sind = sind.rowIndex;
                                        }
                                        sind--;
                                        break;
                                }
                            }
                            if (t.p.subGrid === true) {
                                $(t).jqGrid("addSubGrid", gi + ni, sind);
                            }
                            t.p.records++;
                            t.p.reccount++;
                            $(t).triggerHandler("jqGridAfterInsertRow", [rowid, data, data]);
                            if (air) {
                                t.p.afterInsertRow.call(t, rowid, data, data);
                            }
                            k++;
                            //TODO:DELETE UPDATING LOCAL DATA
                        }
                        if (t.p.altRows === true && !aradd) {
                            if (pos == "last") {
                                if ((t.rows.length - 1) % 2 == 1) {
                                    $(t.rows[t.rows.length - 1]).addClass(cn);
                                }
                            } else {
                                $(t.rows).each(function (i) {
                                    if (i % 2 == 1) {
                                        $(this).addClass(cn);
                                    }
                                    else {
                                        $(this).removeClass(cn);
                                    }
                                });
                            }
                        }
                        t.updatepager(true, true);
                        success = true;
                    });
                }
                return success;
            },
            getRowData:function (rowid) {
                var res = {};
                this.each(function () {
                    var $t = this, nm, ind;
                    ind = $t.rows.namedItem(rowid);
                    if (!ind) {
                        return res;
                    }
                    if ($(ind).hasClass('jqgrow')) {
                        for (var i = 0; i < $t.p.colModel.length; i++) {
                            nm = $t.p.colModel[i].name;
                            if (!$.jgrid.isFixedCol(nm)) {
                                res[nm] = $.jgrid.getCellValue($t, rowid, i);
                            }
                        }
                    }
                });
                return res;
            },
            delRowData:function (rowid) {
                return $(this).wafGrid("delRow", rowid, {});
            },
            getInd:function (rowid, rc) {
                var ret = false, rw;
                this.each(function () {
                    rw = this.rows.namedItem(rowid);
                    if (rw) {
                        ret = rc === true ? rw : rw.rowIndex;
                    }
                });
                return ret;
            },

            getSelectedRow:function () {
                return $(this).jqGrid('option', 'selrow');
            },
            getSelectedRows:function () {
                var ts = this[0];
                if (ts.p.multiselect) {
                    return $(this).jqGrid('option', 'selarrrow');
                } else {
                    return $.makeArray($(this).jqGrid('option', 'selrow'));
                }
            },
            getRowCount:function () {
                return $(this).jqGrid("option", "records");
            },
            getPageRowCount:function () {
                var ts = this[0];
                if ($("tr.jqgfirstrow", ts).length > 0) {
                    return ts.rows.length - 1;
                } else {
                    return ts.rows.length;
                }

            },

            //
            moveRowUp:function (rowid) {
                this.each(function () {
                    var $t = this, row, prev, orn, nrn;
                    if ($.jgrid.hasRowSpan($t)) return;
                    row = $t.rows.namedItem(rowid);
                    prev = $(row).prev("tr.jqgrow");
                    if (prev.length > 0) {
                        $(row).insertBefore(prev);
                        if ($t.p.rownumbers === true) {
                            orn = $(this).wafGrid("getCell", rowid, "rn");
                            nrn = $(this).wafGrid("getCell", prev[0].id, "rn");
                            $(this).wafGrid("setCell", rowid, "rn", nrn);
                            $(this).wafGrid("setCell", prev[0].id, "rn", orn);
                        }
                        $($t).triggerHandler("jqGridAfterGridComplete");
                    }
                });
            },
            //
            moveRowDown:function (rowid) {
                this.each(function () {
                    var $t = this, row, next, orn, nrn;
                    if ($.jgrid.hasRowSpan($t)) return;
                    row = $t.rows.namedItem(rowid);
                    next = $(row).next("tr.jqgrow");
                    if (next.length > 0) {
                        $(row).insertAfter(next);
                        if ($t.p.rownumbers === true) {
                            orn = $(this).wafGrid("getCell", rowid, "rn");
                            nrn = $(this).wafGrid("getCell", next[0].id, "rn");
                            $(this).wafGrid("setCell", rowid, "rn", nrn);
                            $(this).wafGrid("setCell", next[0].id, "rn", orn);
                        }
                        $($t).triggerHandler("jqGridAfterGridComplete");
                    }
                });
            },
            //rowidindex/
            moveRow:function (rowid, index) {
                this.each(function () {
                    var $t = this, row, next, orn, nrn;
                    if ($.jgrid.hasRowSpan($t)) return;
                    row = $t.rows.namedItem(rowid);
                    if (index == 0) index = 1;
                    if (index > $t.rows.length) index = $t.rows.length - 1;
                    next = $t.rows[index];
                    if (next && next.tagName === "TR" && row.rowIndex != index) {
                        $(row).insertBefore(next);
                    } else {
                        $(row).insertAfter($t.rows[$t.rows.length - 1]);
                    }
                    if ($t.p.rownumbers === true) {
                        $("td.jqgrid-rownum", $t.rows).each(function (i) {
                            $(this).html(1 + i);
                        });
                    }
                    $($t).triggerHandler("jqGridAfterGridComplete");
                });
            },
            ///
            swapRow:function (srcRowid, destRowid) {
                this.each(function () {
                    var $t = this, srcrow, destrow, orn, nrn;
                    if ($.jgrid.hasRowSpan($t)) return;
                    srcrow = $t.rows.namedItem(srcRowid);
                    destrow = $t.rows.namedItem(destRowid);
                    if (srcrow && destrow) {
                        if ($t.p.rownumbers === true) {
                            orn = $(this).wafGrid("getCell", srcRowid, "rn");
                            nrn = $(this).wafGrid("getCell", destRowid, "rn");
                            $(this).wafGrid("setCell", srcRowid, "rn", nrn);
                            $(this).wafGrid("setCell", destRowid, "rn", orn);
                        }
                        //srcPreRow
                        var first = false, same = false, reverse = false;
                        var srcNearRow = $(srcrow).prev("tr.jqgrow");
                        if (srcNearRow.length <= 0) {
                            first = true;
                            srcNearRow = $(srcrow).next("tr.jqgrow");
                            same = srcNearRow[0].id === destrow.id;
                        } else {
                            same = srcNearRow[0].id === destrow.id;
                            if (!same) {
                                var nextRow = $(srcrow).next("tr.jqgrow");
                                if (nextRow.length > 0) same = nextRow[0].id === destrow.id;
                            } else {
                                reverse = true;
                            }
                        }
                        if (same) {
                            if (reverse) {
                                $(srcrow).insertBefore($(destrow));
                            } else {
                                $(srcrow).insertAfter($(destrow));
                            }
                        } else {
                            //srcrowdestrow
                            $(srcrow).insertBefore($(destrow));
                            //destrowsrcPreRow
                            if (!first) {
                                $(destrow).insertAfter($(srcNearRow));
                            } else {
                                $(destrow).insertBefore($(srcNearRow));
                            }
                        }
                        $($t).triggerHandler("jqGridAfterGridComplete");
                    }
                });
            }
        });

        //
        $.jgrid.extend({
            optionColumn:function (col, obj) {

                if (arguments.length === 0) {
                    return null;
                }

                if (obj === undefined) {
                    //col
                    return this.jqGrid("getColProp", col);
                } else {
                    if (typeof obj === "object") {
                        this.jqGrid("setColProp", col, obj);
                    }
                }
                return this;
            },
            getColumnConfig:function(colName){
                return $(this).wafGrid("optionColumn",colName);
            },
            setColumnConfig:function(colName,config){
                return $(this).wafGrid("optionColumn",colName,config);
            },
            getAllColumn:function(){
                var $t = this[0];
                return $t.p.colModel;
            },

            setColumnProp:function(colName,propName,value){
                this.each(function(){
                    var ts = this;
                    if("name" !== propName){
                        var ind = $.jgrid.getIndex(colName,ts);
                        if(ind>-1){
                            var options = {};
                            if($.type.isObject(propName)){
                                options = propName;
                            }else{
                                options[propName] = value;
                            }
                            if(options["customformatter"]){
                                options["formatter"] = options["customformatter"];
                                delete options["customformatter"];
                            }
                            if(options["customunformatter"]){
                                options["unformat"] = options["customunformatter"];
                                delete options["customunformatter"];
                            }
                            if(options["sortable"]!=undefined){
                                var selectedTh = ts.grid.headers[ind].el;
                                if(!options["sortable"]){
                                    $("div.ui-jqgrid-sortable",selectedTh).css("cursor","default");
                                }else{
                                    $("div.ui-jqgrid-sortable",selectedTh).css("cursor","pointer");
                                }
                                if(ind===ts.p.lastsort){
                                    $("span.s-ico",selectedTh).hide();
                                }
                            }
                            if(options["width"]!=undefined){
                                options["widthOrg"] = options["width"];
                            }
                            $.extend(ts.p.colModel[ind],options);
                            if($.inArray(propName,$.jgrid.getCellConfigItem()) > -1){
                                //cellcellcolumn
                                var cellEditorConfig = $(this).data("cellEditorConfig"),config;
                                if(cellEditorConfig){
                                    for(var p in cellEditorConfig){
                                        config = cellEditorConfig[p];
                                        $.extend(config,options);
//                                    config[propName] = value;
                                    }
                                }
                            }
                        }
                    }
                });
            },
            getColumnProp:function(colName,propName){
                var ts = this[0];
                var ind = $.jgrid.getIndex(colName,ts);
                if(ind>-1){
                    if(propName==="customformatter"){
                        propName = "formatter";
                        var tmp = ts.p.colModel[ind][propName];
                        if(tmp && $.isFunction(tmp)){
                            return tmp;
                        }else{
                            return undefined;
                        }
                    }else if(propName==="customunformatter"){
                        propName = "unformat";
                        var tmp = ts.p.colModel[ind][propName];
                        if(tmp && $.isFunction(tmp)){
                            return tmp;
                        }else{
                            return undefined;
                        }
                    }else{
                        return ts.p.colModel[ind][propName];
                    }

                }
            },

            getColProp : function(colname){
                var ret ={}, $t = this[0];
                if ( !$t.grid ) { return false; }
                var cM = $t.p.colModel;
                for ( var i =0;i<cM.length;i++ ) {
                    if ( cM[i].name == colname ) {
                        ret = cM[i];
                        break;
                    }
                }
                return ret;
            },
            setColProp : function(colname, obj){
                //do not set width will not work
                return this.each(function(){
                    if ( this.grid ) {
                        if ( obj ) {
                            var cM = this.p.colModel;
                            for ( var i =0;i<cM.length;i++ ) {
                                if ( cM[i].name == colname ) {
                                    $.extend(this.p.colModel[i],obj);
                                    break;
                                }
                            }
                        }
                    }
                });
            },

            getColumnName:function(colIndex){
                var $t = this[0];
                if($.isNaN(colIndex)) return;
                if(colIndex>0 && colIndex<$t.p.colModel.length){
                    return $t.p.colModel[colIndex].name;
                }
            },
            removeAllColumn:function () {
                //
                this.each(function () {
                    var p = $.extend(true, {}, this.p);
                    p.colModel = [];
                    p.colNames = [];
                    p.loadInit = false;
                    $(this).jqGrid("gridUnload");
                    $("#" + p.id).wafGrid(p);
                })
            },

            showColumn:function(colname,rebuildWidth){
                return this.each(function(){
                    //colNamecolspanrowspanshowColumn
                    if( typeof colname === 'string') {colname=[colname];}
                    for(var i=0;i<colname.length;i++){
                        if($.jgrid.colInSpan(this,colname[i])) return;
                    }
                    $(this).jqGrid("showHideCol",colname,"");
                    if(rebuildWidth==undefined || rebuildWidth==true){
                        var newWidth = $(this).wafGrid("getGridParentWidth");
                        $(this).jqGrid("setGridWidth",newWidth);
                    }
                });
            },
            hideColumn:function(colname,rebuildWidth){
                return this.each(function(){
                    if( typeof colname === 'string') {colname=[colname];}
                    for(var i=0;i<colname.length;i++){
                        if($.jgrid.colInSpan(this,colname[i])) return;
                    }
                    $(this).jqGrid("showHideCol",colname,"none");
                    if(rebuildWidth==undefined || rebuildWidth==true){
                        var newWidth = $(this).wafGrid("getGridParentWidth");
                        $(this).jqGrid("setGridWidth",newWidth);
                    }
                });
            },
            hideCol : function (colname) {
                return this.each(function(){$(this).jqGrid("showHideCol",colname,"none");});
            },
            showCol : function(colname) {
                return this.each(function(){$(this).jqGrid("showHideCol",colname,"");});
            },
            showHideCol : function(colname,show) {
                return this.each(function() {
                    var $t = this, fndh=false, brd=$.jgrid.cellWidth($t)? 0: $t.p.cellLayout, cw, realCol, tmp;
                    if (!$t.grid ) {return;}
                    if( typeof colname === 'string') {colname=[colname];}
                    show = show != "none" ? "" : "none";
                    var sw = show === "" ? true :false,
                        gh = $t.p.groupHeader && (typeof $t.p.groupHeader === 'object' || $.isFunction($t.p.groupHeader) );
                    if(gh) { $($t).jqGrid('destroyGroupHeader', false); }
                    $(this.p.colModel).each(function(i) {
                        if ($.inArray(this.name,colname) !== -1 && this.hidden === sw) {
                            if($t.p.frozenColumns === true && this.frozen === true) {
                                return true;
                            }
                            $("tr",$t.grid.hDiv).each(function(){
                                $(this.cells[i]).css("display", show);
                            });
                            $($t.rows).each(function(){
                                if (!$(this).hasClass("jqgroup")) {
                                    //cellIndex
                                    realCol = i ;
                                    if($.jgrid.hasColSpan($t)){
                                        realCol = $.jgrid.getRealColIndex($t,this.id,realCol);
                                    }
                                    $(this.cells[realCol]).css("display", show);
                                }
                            });
                            if($t.p.footerrow) { $("tr.footrow td:eq("+i+")", $t.grid.sDiv).css("display", show); }
                            cw = this.widthOrg? this.widthOrg: parseInt(this.width,10);
                            if(show === "none") {$t.p.tblwidth -= cw+brd;} else {$t.p.tblwidth += cw+brd;}
                            this.hidden = !sw;
                            //fndh=true;
                            $($t).triggerHandler("jqGridShowHideCol", [sw,this.name,i]);
                        }
                    });
                    if(fndh===true) {
                        //$($t).jqGrid("setGridWidth",$t.p.shrinkToFit === true ? $t.p.tblwidth : $t.p.width );
                    }
                    if( gh )  {
                        $($t).jqGrid('setGroupHeaders',$t.p.groupHeader);
                    }
                });
            },



            addColumn:function (config, index, loaddata) {
                if(config.name =="rn" || config.name =="cb" ||config.name =="subgrid") return;
                $(this).wafGrid("addInnerColumn",config,index,loaddata);
            },
            addInnerColumn:function (config, index, loaddata) {
                config = $.extend({
                    align:"center",
                    formatoptions:null,
                    formatter:null,
                    frozen:false,
                    hidden:false,
                    index:null,
                    key:false,
                    label:"new column",
                    name:"newcolumn",
                    sortable:false,
                    sorttype:"asc",
                    width:null,
                    rowspan:false,
                    cellattr:null,
                    fixed:false,
                    editable:false,
                    resizable:true,
                    group:null
                }, config || {});
                this.each(function () {

                    var ts = this;
                    if($.isNaN(index)){
                        index = ts.p.colModel.length;
                    }

                    //
                    if(ts.p.frozenColumns && (ts.p.colModel[index]&&ts.p.colModel[index].frozen)){
                        return;
                    }

                    var hdcol = "";
                    if( config.hidden ) {
                        hdcol = "display:none;";
                    }

                    function resortRows(parent, clobj,data,ts) {
                        $(">tr"+(clobj||""), parent).each(function() {
                            var row = this,rowId = row.id,iRow=row.rowIndex,td;
                            if($(this).hasClass("jqgfirstrow")){
                                td = "<td role='gridcell' style='height:0px;width:"+config.width+"px;"+hdcol+"'></td>";
                            }else{
                                if("cb"===config.name){
                                    td = ts.addMulti(rowId,index,iRow);
                                }else if("rn"===config.name){
                                    td = ts.addRowNum(index,iRow-1,ts.p.page,ts.p.rowNum,rowId,data);
                                }else{
                                    td = ts.addCell(rowId,"",index,iRow,{});
                                }
                            }
                            var target = $("td",this).eq(index);
                            if(target && target.length>0){
                                $(td).insertBefore($(target));
                            }else{
                                row.appendChild($(td)[0]);
                            }
                        });
                    }

                    function getColumnHeaderIndex(th) {
                        var i, headers = ts.grid.headers, ci = $.jgrid.getCellIndex(th);
                        for (i = 0; i < headers.length; i++) {
                            if (th === headers[i].el) {
                                ci = i;
                                break;
                            }
                        }
                        return ci;
                    }

                    function nextVisible(iCol) {
                        var ret = iCol, j=iCol, i;
                        for (i = iCol+1;i<ts.p.colModel.length;i++){
                            if(ts.p.colModel[i].hidden !== true ) {
                                j=i; break;
                            }
                        }
                        return j-ret;
                    }

                    function getOffset(iCol) {
                        var i, ret = {}, brd1 = $.jgrid.cellWidth(ts) ? 0 : ts.p.cellLayout;
                        ret[0] =  ret[1] = ret[2] = 0;
                        for(i=0;i<=iCol;i++){
                            if(ts.p.colModel[i].hidden === false ) {
                                ret[0] += ts.p.colModel[i].width+brd1;
                            }
                        }
                        if(ts.p.direction=="rtl") { ret[0] = ts.p.width - ret[0]; }
                        ret[0] = ret[0] - ts.grid.bDiv.scrollLeft;
                        if($(ts.grid.cDiv).is(":visible")) {ret[1] += $(ts.grid.cDiv).height() +parseInt($(ts.grid.cDiv).css("padding-top"),10)+parseInt($(ts.grid.cDiv).css("padding-bottom"),10);}
                        if(ts.p.toolbar[0]===true && (ts.p.toolbar[1]=='top' || ts.p.toolbar[1]=='both')) {ret[1] += $(ts.grid.uDiv).height()+parseInt($(ts.grid.uDiv).css("border-top-width"),10)+parseInt($(ts.grid.uDiv).css("border-bottom-width"),10);}
                        if(ts.p.toppager) {ret[1] += $(ts.grid.topDiv).height()+parseInt($(ts.grid.topDiv).css("border-bottom-width"),10);}
                        ret[2] += $(ts.grid.bDiv).height() + $(ts.grid.hDiv).height();
                        return ret;
                    }


                    ts.p.colNames.splice(index,0,config.label);
                    if(config.widthOrg == undefined) config.widthOrg = config.width;
                    ts.p.colModel.splice(index,0,config);

                    var newheader = {width:config.width};
                    var isMSIE = $.browser.msie ? true:false;
                    if(ts.p.viewsortcols[1] == 'horizontal') {var iac=" ui-i-asc";var idc=" ui-i-desc";}
                    var tdc = isMSIE ?  "class='ui-th-div-ie'" :"";
                    var tooltip = ts.p.headertitles ? (" title=\""+$.jgrid.stripHtml(ts.p.colNames[index])+"\"") :"";
                    var th = "<th id='"+ts.p.id+"_"+config.name+"' role='columnheader' class='ui-state-default ui-th-column ui-th-"+ts.p.direction+"'"+ tooltip+">";
                    th+= "<div id='jqgh_"+ts.p.id+"_"+config.name+"' "+tdc+">"+ts.p.colNames[index];
                    var imgs = "<span class='s-ico' style='display:none'><span sort='asc' class='ui-grid-ico-sort ui-icon-asc"+iac+" ui-state-disabled ui-icon ui-icon-triangle-1-n ui-sort-"+ts.p.direction+"'></span>";
                    imgs += "<span sort='desc' class='ui-grid-ico-sort ui-icon-desc"+idc+" ui-state-disabled ui-icon ui-icon-triangle-1-s ui-sort-"+ts.p.direction+"'></span></span>";
                    th += imgs+"</div></th>";
                    var thobject = $(th)[0];
                    newheader.el = thobject;
                    ts.grid.headers.splice(index,0,newheader);

                    var res="",brd = $.jgrid.cellWidth(ts) ? 0 : parseInt(ts.p.cellLayout);
                    $(">tr", $("thead:first", ts.grid.hDiv)).each(function(){
                        var target = $("th.ui-th-column",this).eq(index);
                        if(target && target.length>0){
                            $(thobject).insertBefore($(target));
                        }else{
                            this.appendChild(thobject);
                        }

                        if(config.resizable){
                            res = document.createElement("span");
                            $(res).html("&#160;").addClass('ui-jqgrid-resize ui-jqgrid-resize-'+ts.p.direction);
                            if(!$.browser.opera) { $(res).css("cursor","col-resize"); }
                            $(thobject).addClass(ts.p.resizeclass);
                        } else {
                            res = "";
                        }
                        $(thobject).css("width",config.width+"px").prepend(res);
                        ts.p.tblwidth = ts.p.tblwidth + config.width + brd;
                        if( config.hidden ) {
                            $(thobject).css("display","none");
                        }

                        if( !(config.name == 'cb' || config.name=='subgrid' || config.name=='rn') ) {
                            if(ts.p.viewsortcols[2] && config.sortable){ //add by jlg.truecss
                                $(">div",thobject).addClass('ui-jqgrid-sortable');
                            }
                        }
                        if(config.sortable) {
                            //modiby by jlg.
                            if(ts.p.viewsortcols[0]) {
                                $("div span.s-ico",thobject).show();
                                if(index==ts.p.lastsort){
                                    $("div span.ui-icon-"+ts.p.sortorder,thobject).removeClass("ui-state-disabled");
                                    //add by jlg
                                    if(ts.p.sortorder==="asc"){
                                        $("span.ui-icon-desc",thobject).css("display","none").css("margin-left",0);
                                    }else{
                                        $("span.ui-icon-asc",thobject).css("display","none").css("margin-left",0);
                                    }
                                }}
                            else if( index == ts.p.lastsort) {
                                $("div span.s-ico",thobject).show();
                                $("div span.ui-icon-"+ts.p.sortorder,thobject).removeClass("ui-state-disabled");
                                //add by jlg
                                if(ts.p.sortorder==="asc"){
                                    $("span.ui-icon-desc",thobject).css("display","none").css("margin-left",0);
                                }else{
                                    $("span.ui-icon-asc",thobject).css("display","none").css("margin-left",0);
                                }
                            }
                        }

                        ts.grid.headers[index] = { width: config.width, el: thobject };

                        $(thobject).mousedown(function(e) {
                            if ($(e.target).closest("th>span.ui-jqgrid-resize").length != 1) { return; }
                            var ci = getColumnHeaderIndex(this);
                            if(ts.p.forceFit===true) {ts.p.nv= nextVisible(ci);}
                            ts.grid.dragStart(ci, e, getOffset(ci));
                            return false;
                        }).click(function(e) {
                                if (ts.p.disableClick) {
                                    ts.p.disableClick = false;
                                    return false;
                                }
                                var s = "th>div.ui-jqgrid-sortable",r,d;
                                if (!ts.p.viewsortcols[2]) { s = "th>div>span>span.ui-grid-ico-sort"; }
                                var t = $(e.target).closest(s);
                                if (t.length != 1) { return; }
                                var ci = getColumnHeaderIndex(this);
                                if (!ts.p.viewsortcols[2]) { r=true;d=t.attr("sort"); }
                                ts.sortData( $('div',this)[0].id, ci, r, d);
                                return false;
                            })
                    });

                    resortRows($("#"+$.jgrid.jqID(ts.p.id)+" tbody:first"), ".jqgfirstrow, tr.jqgrow, tr.jqfoot",{},ts);

                    if (ts.p.footerrow) {
                        resortRows($("tbody:first", ts.grid.sDiv),"",{},ts);
                    }
                    //
                    $(ts).jqGrid("setGridWidth",ts.p.width,ts.p.shrinkToFit);
                    if(loaddata){
                        $(ts).jqGrid("reloadGrid");
                    }
                })
            },
            //
            deleteColumn:function(colName,loaddata){
                if(colName =="rn" || colName =="cb" ||colName =="subgrid") return;
                return $(this).wafGrid("removeInnerColumn",colName,loaddata);
            },
            removeColumn:function (colName, loaddata) {
                if(colName =="rn" || colName =="cb" ||colName =="subgrid") return;
                return $(this).wafGrid("removeInnerColumn",colName,loaddata);
            },
            removeInnerColumn:function (colName, loaddata) {
                //
                this.each(function () {
                    var ts = this,index = $.jgrid.getIndex(colName,ts);
                    if(index==-1) return;
                    function resortRows(parent, clobj,index) {
                        $(">tr"+(clobj||""), parent).each(function() {
                            var target = $("td",this).eq(index);
                            if(target && target.length>0){
                                $(target).remove();
                            }
                        });
                    }

                    ts.p.colNames.splice(index,1);
                    ts.p.colModel.splice(index,1);
                    ts.grid.headers.splice(index,1);

                    $(">tr", $("thead:first", ts.grid.hDiv)).each(function(){
                        var target = $("th.ui-th-column",this).eq(index);
                        if(target && target.length>0){
                            $(target).remove();
                        }
                    });

                    resortRows($("#"+$.jgrid.jqID(ts.p.id)+" tbody:first"), ".jqgfirstrow, tr.jqgrow, tr.jqfoot",index);

                    if (ts.p.footerrow) {
                        resortRows($("tbody:first", ts.grid.sDiv),"",index);
                    }
                    //
                    $(ts).jqGrid("setGridWidth",ts.p.width);
                    if(loaddata){
                        $(ts).jqGrid("reloadGrid");
                    }
                    $(ts).triggerHandler("jqGridAfterGridComplete");
                })
            },
            setLabel : function(colname, nData, prop, attrp ){
                return this.each(function(){
                    var $t = this, pos=-1;
                    if(!$t.grid) {return;}
                    if(typeof(colname) != "undefined") {
                        $($t.p.colModel).each(function(i){
                            if (this.name == colname) {
                                pos = i;return false;
                            }
                        });
                    } else { return; }
                    if(pos>=0) {
                        var thecol = $("tr.ui-jqgrid-labels th:eq("+pos+")",$t.grid.hDiv);
                        if (nData){
                            var ico = $(".s-ico",thecol);
                            $("[id^=jqgh_]",thecol).empty().html(nData).append(ico);
                            $t.p.colNames[pos] = nData;
                        }
                        if (prop) {
                            if(typeof prop === 'string') {$(thecol).addClass(prop);} else {$(thecol).css(prop);}
                        }
                        if(typeof attrp === 'object') {$(thecol).attr(attrp);}
                        //,
                        if($t.p.frozenColumns){
                            var superGrid=$($t).closest(".ui-jqgrid");
                            thecol = $(".frozen-div tr.ui-jqgrid-labels th:eq("+pos+")",superGrid);
                            if (nData){
                                ico = $(".s-ico",thecol);
                                $("[id^=jqgh_]",thecol).empty().html(nData).append(ico);
                            }
                            if (prop) {
                                if(typeof prop === 'string') {$(thecol).addClass(prop);} else {$(thecol).css(prop);}
                            }
                            if(typeof attrp === 'object') {$(thecol).attr(attrp);}

                            //top
                            var top = $t.p.caption ? $($t.grid.cDiv).outerHeight() : 0,
                                hth = $(".ui-jqgrid-htable","#gview_"+$.jgrid.jqID($t.p.id)).height();
                            //headers
                            if($t.p.toppager) {
                                top = top + $($t.grid.topDiv).outerHeight();
                            }
                            if($t.p.toolbar[0] === true) {
                                if($t.p.toolbar[1] != "bottom") {
                                    top = top + $($t.grid.uDiv).outerHeight();
                                }
                            }
                            $($t.grid.fhDiv).css("top",top).css("height",hth);
                            $($t.grid.fbDiv).css("top",(parseInt(top,10)+parseInt(hth,10) + 1));
                            $($t).triggerHandler("jqGridAfterGridComplete");
                        }
                    }
                });
            },

            getCol : function (col, obj, mathopr) {
                var ret = [], val, sum=0, min, max, v;
                obj = typeof (obj) != 'boolean' ? false : obj;
                if(typeof mathopr == 'undefined') { mathopr = false; }
                this.each(function(){
                    var $t=this, pos=-1;
                    if(!$t.grid) {return;}
                    if(isNaN(col)) {
                        $($t.p.colModel).each(function(i){
                            if (this.name === col) {
                                pos = i;return false;
                            }
                        });
                    } else {pos = parseInt(col,10);}
                    if(pos>=0) {
                        var ln = $t.rows.length, i =0;
                        if (ln && ln>0){
                            while(i<ln){
                                if($($t.rows[i]).hasClass('jqgrow')) {
                                    val = $.jgrid.getCellValue($t,$t.rows[i].id,pos);
                                    if(mathopr) {
                                        if($.isNaN(val)) val="0";
                                        v = parseFloat(val);
                                        sum += v;
                                        if(i===0) {
                                            min = v;
                                            max = v;
                                        } else {
                                            min = Math.min(min, v);
                                            max = Math.max(max, v);
                                        }
                                    }
                                    else if(obj) { ret.push( {id:$t.rows[i].id,value:val} ); }
                                    else { ret.push( val ); }
                                }
                                i++;
                            }
                            if(mathopr) {
                                switch(mathopr.toLowerCase()){
                                    case 'sum': ret =sum; break;
                                    case 'avg': ret = sum/ln; break;
                                    case 'count': ret = ln; break;
                                    case 'min': ret = min; break;
                                    case 'max': ret = max; break;
                                }
                            }
                        }
                    }
                });
                return ret;
            },
            getColValue:function(col, obj, mathopr){
                return $(this).jqGrid("getCol",col, obj, mathopr);
            },
            sortGrid : function(colname,sor){
                return this.each(function(){
                    var $t=this,idx=-1,reload = false;//add by jlg.
                    if ( !$t.grid ) { return;}
                    if ( !colname ) { colname = $t.p.sortname; }
                    for ( var i=0;i<$t.p.colModel.length;i++ ) {
                        if ( $t.p.colModel[i].index == colname || $t.p.colModel[i].name==colname ) {
                            idx = i;
                            break;
                        }
                    }
                    if ( idx!=-1 ){
                        var sort = $t.p.colModel[idx].sortable;
                        if ( typeof sort !== 'boolean' ) { sort =  true; }
                        if ( typeof reload !=='boolean' ) { reload = false; }
                        if ( sort ) { $t.sortData("jqgh_"+$t.p.id+"_" + colname, idx, reload, sor); }
                    }
                });
            },



            setColumnStyle:function(colname,style,footer,callback){
                this.each(function(){
                    var ts = this,colIndex,realCol,td,tmpInd,tmp;
                    realCol = colIndex = $.jgrid.getIndex(colname,ts);
                    $(("tr.jqgrow, tr.jqfoot"), $("#"+$.jgrid.jqID(ts.p.id)+" tbody:first")).each(function(){
                        if(callback&&$.isFunction(callback)){
                            var tmp = callback.call(ts,this.id,colIndex,ts.p.colModel[colIndex]);
                            if(tmp) style = tmp;
                        }
                        tmpInd = this;
                        //
                        if (!$(this).hasClass("jqgroup")) {
                            if($.jgrid.hasColSpan(ts)){
                                tmp = $.jgrid.getCellModel(this.id,realCol,ts);
                                if(tmp.isReal){
                                    td = $("td:eq("+tmp.newCellIndex+")",this);
                                }else{
                                    tmpInd = ts.rows.namedItem(tmp.newRowId);
                                    td = $("td:eq("+tmp.newCellIndex+")",tmpInd);
                                }
                                realCol = $.jgrid.getNoSpanRealColIndex(ts,this.id,realCol);
                            }else{
                                td = $("td:eq("+realCol+")",this);
                            }
                        }else{
                            td = $("td:eq("+realCol+")",this);
                        }
                        $(td).attr("style",style);
                        //realCol
                        realCol = colIndex;
                    });
                    if(footer){
                        $("tr.footrow", ts.grid.sDiv).each(function(){
                            $("td:eq("+colIndex+")",this).attr("style",style);
                        });
                    }
                    //
                    if(ts.p.frozenColumns && ts.p.colModel[colIndex] && ts.p.colModel[colIndex].frozen){
                        $(("tr.jqgrow, tr.jqfoot"), $("#"+$.jgrid.jqID(ts.p.id)+"_frozen"+" tbody:first")).each(function(){
                            if(callback&&$.isFunction(callback)){
                                var tmp = callback.call(ts,this.id,colIndex,ts.p.colModel[colIndex]);
                                if(tmp) style = tmp;
                            }
                            $("td:eq("+colIndex+")",this).attr("style",style);
                        });
                    }
                });
            },
            addCbColumn:function(){
                this.each(function(){
                    var ts = this,find=false;
                    for(var i=0;i<ts.p.colModel.length;i++){
                        if("cb"===ts.p.colModel[i].name) find = true;
                    }
                    if(!find){
                        var config = {label:"<input role='checkbox' id='cb_"+ts.p.id+"' class='cbox' type='checkbox'/>",name:'cb',width:$.jgrid.cellWidth(ts) ? ts.p.multiselectWidth+ts.p.cellLayout : ts.p.multiselectWidth,sortable:false,resizable:false,hidedlg:true,search:false,align:'center',fixed:true};
                        var index = ts.p.rownumbers?1:0;
                        $(ts).wafGrid("addInnerColumn",config,index,false);
                    }
                });
            },
            removeCbColumn:function(){
                this.each(function(){
                    //
                    var ts = this,find=false;
                    for(var i=0;i<ts.p.colModel.length;i++){
                        if("cb"===ts.p.colModel[i].name) find = true;
                    }
                    if(find){
                        $(this).wafGrid("removeInnerColumn","cb",false);
                    }
                })
            },
            removeRnColumn:function(){
                this.each(function(){
                    //RowNum
                    var ts = this,find=false;
                    for(var i=0;i<ts.p.colModel.length;i++){
                        if("rn"===ts.p.colModel[i].name) find = true;
                    }
                    if(find){
                        $(this).wafGrid("removeInnerColumn","rn",false);
                    }
                })
            },
            addRnColumn:function(){
                this.each(function(){
                    var ts = this,find=false;
                    for(var i=0;i<ts.p.colModel.length;i++){
                        if("rn"===ts.p.colModel[i].name) find = true;
                    }
                    if(!find){
                        var config = $.extend({name:'rn', sortable:false, resizable:false, hidedlg:true, search:false, align:'center', fixed:true},ts.p.rownumOption);
                        $(ts).wafGrid("addInnerColumn",config,0,false);
                    }
                });
            },
            getColIndex:function(colName){
                if(this.length>0){
                    var ts = this[0];
                    return $.jgrid.getIndex(colName,ts);
                }
            } ,

            swapColumns:function(srcColName,destColName){
                if(srcColName && (srcColName=="rn" || srcColName=="cb"||srcColName=="subgrid")) return;
                if(destColName && (destColName=="rn" || destColName=="cb"||destColName=="subgrid")) return;
                this.each(function(){
                    var $t = this,srcIndex,destIndex,arr=new Array();
                    if($.jgrid.hasColSpan($t)) return;
                    srcIndex = $.jgrid.getIndex(srcColName,$t);
                    destIndex = $.jgrid.getIndex(destColName,$t);
                    for(var i =0; i<$t.p.colModel.length;i++){
                        arr[i] = i;
                    }
                    arr[srcIndex] = destIndex;
                    arr[destIndex] = srcIndex;
                    $(this).jqGrid("remapColumns",arr,true,false);
                });
            },
            moveColumn:function(srcColName,pos){
                this.each(function(){
                    var $t = this,srcIndex,destIndex,arr=new Array(),nm,nt,forward;
                    if($.jgrid.hasColSpan($t)) return;
                    srcIndex = $.jgrid.getIndex(srcColName,$t);
                    //
                    if($t.p.frozenColumns && ($t.p.colModel[srcIndex].frozen||$t.p.colModel[pos].frozen)){
                        return;
                    }
                    if($t.p.colModel[pos]){
                        nm = $t.p.colModel[pos].name;
                    }
                    if(nm && nm != "cb" && nm !="rn" && nm !="subgrid"){
                        if(srcIndex!=pos){
                            //
                            if(srcIndex<pos){
                                nt = srcIndex+1;
                                forward = true;
                            }else{
                                nt = pos - 1;
                                forward = false;
                            }
                            for(var i =0; i<$t.p.colModel.length;i++){
                                if(forward){
                                    if(i>Math.abs(srcIndex) && i<=Math.abs(pos)){
                                        arr[i-1] = i;
                                    }else{
                                        arr[i] = i;
                                    }
                                }else{
                                    if(i>=Math.abs(pos) && i<=Math.abs(srcIndex)){
                                        if(i<($t.p.colModel.length-1)){
                                            arr[i+1] = i;
                                        }
                                    }else{
                                        arr[i] = i;
                                    }
                                }
                            }
                            arr[pos] = srcIndex;
//                        alert(arr.toString());
                            $(this).jqGrid("remapColumns",arr,true,false);
                        }
                    }
                });
            },
            moveColumnForward:function(colName){
                this.each(function(){
                    var $t =this;
                    var srcIndex = $.jgrid.getIndex(colName,$t);
                    if(srcIndex>0){
                        return $(this).jqGrid("moveColumn",colName,srcIndex-1);
                    }
                })
            },
            moveColumnBack:function(colName){
                this.each(function(){
                    var $t =this;
                    var srcIndex = $.jgrid.getIndex(colName,$t);
                    if(srcIndex<($t.p.colModel.length-1)){
                        return $(this).jqGrid("moveColumn",colName,srcIndex+1);
                    }
                })
            },
            remapColumns : function(permutation, updateCells, keepHeader){
                function resortArray(a) {
                    var ac;
                    if (a.length) {
                        ac = $.makeArray(a);
                    } else {
                        ac = $.extend({}, a);
                    }
                    $.each(permutation, function(i) {
                        a[i] = ac[this];
                    });
                }
                function resortRows(parent, clobj) {
                    $(">tr"+(clobj||""), parent).each(function() {
                        var row = this;
                        var elems = $.makeArray(row.cells);
                        $.each(permutation, function() {
                            var e = elems[this];
                            if (e) {
                                row.appendChild(e);
                            }
                        });
                    });
                }
                var ts = this.get(0);
                resortArray(ts.p.colModel);
                resortArray(ts.p.colNames);
                resortArray(ts.grid.headers);
                resortRows($("thead:first", ts.grid.hDiv), keepHeader && ":not(.ui-jqgrid-labels)");
                if (updateCells) {
                    resortRows($("#"+$.jgrid.jqID(ts.p.id)+" tbody:first"), ".jqgfirstrow, tr.jqgrow, tr.jqfoot");
                }
                if (ts.p.footerrow) {
                    resortRows($("tbody:first", ts.grid.sDiv));
                }
                if (ts.p.remapColumns) {
                    if (!ts.p.remapColumns.length){
                        ts.p.remapColumns = $.makeArray(permutation);
                    } else {
                        resortArray(ts.p.remapColumns);
                    }
                }
                ts.p.lastsort = $.inArray(ts.p.lastsort, permutation);
                if(ts.p.treeGrid) { ts.p.expColInd = $.inArray(ts.p.expColInd, permutation); }
                $(ts).triggerHandler("jqGridRemapColumns", [permutation, updateCells, keepHeader]);
            }
        });

        //
        $.jgrid.extend({
            setCell : function(rowid,col,nData,cssp,attrp,forceupd,record) {
                return this.each(function(){
                    var $t = this, pos =-1;
                    if(!$t.grid) {return;}
                    pos = $.jgrid.getIndex(col, $t);
                    if(pos>=0) {
                        var ind = $t.rows.namedItem(rowid),nm=$t.p.colModel[pos].name;
                        if (ind){
                            if(nData !== "" || forceupd === true) {
                                if(undefined == record) record = true;
                                if($.jgrid.isFixedCol(nm)){
                                    record = false;
                                }
                                $.jgrid.setCellValue($t,rowid,pos,nData,record,cssp,attrp);
                            }
                        }
                    }
                });
            },
            getCell : function(rowid,col) {
                var ret = false;
                this.each(function(){
                    var $t=this, pos=-1;
                    if(!$t.grid) {return;}
                    pos = $.jgrid.getIndex(col, $t);
                    if(pos>=0) {
                        ret = $.jgrid.getCellValue($t,rowid,pos);
                        //TODO:DELETE UPDATING LOCAL DATA
                    }
                });
                return ret;
            },
            getCellObject:function (rowid, col) {
                var ret = false;
                this.each(function () {
                    var $t = this, pos = -1;
                    if (!$t.grid) {
                        return;
                    }
                    pos = $.jgrid.getIndex(col, $t);
                    if (pos >= 0) {
                        var ind = $t.rows.namedItem(rowid);
                        //
                        if($.jgrid.hasSpan($t)){
                            ret = $.jgrid.getParentTd(pos,ind);
                            if(ret) ret = $(ret);
                        }else{
                            ret = $(ind).find("td:eq(" + pos + ")");
                        }
                    }
                });
                return ret;
            },
            setCellStyle:function(rowid,col,style){
                this.each(function () {
                    var $t = this;
                    if (!$t.grid) {
                        return;
                    }
                    col = $.jgrid.getIndex(col, $t);
                    if(col>=0){
                        var cellObject = $(this).wafGrid("getCellObject",rowid,col);
                        if(cellObject && cellObject!=false && (cellObject[0].tagName === "TD" || cellObject[0].tagName === "TH")){
                            cellObject.attr("style",style);
                        }
                        //style
                        $.jgrid.setFrozenCellStyle($t,rowid,col,style);
                    }
                });
            },
            getCellConfig:function(colName,rowId){
                //
                var col = (undefined === rowId || null === rowId), ret = this.wafGrid("optionColumn", colName);
                if (rowId) {
                    var keyStr = rowId + "-" + colName,
                        cellEditorConfig = this.data("cellEditorConfig") || {};
                    var tmp = cellEditorConfig[keyStr];
                    if (tmp) {
                        ret = $.extend(true,{},ret,tmp);
                    }
                }
                return $.extend(true, {}, ret);
            }
        });

        //
        $.fn.fmatter = function (formatType, cellval, opts, rwd, act, gid) {
            // build main options before element iteration
            var v = cellval;
            opts = $.extend({}, $.jgrid.formatter, opts);
            if(formatType==undefined || formatType==null) formatType = "defaultFormatter";
            try {
                var type = eval("cellformatter." + formatType);
                var formattor = new type($("#"+gid)[0], opts);
                v = formattor.format(cellval, rwd);
            } catch (fe) {
            }
            return v;
        };
        //
        $.unformat = function (cellval, opr, pos, cnt) {
            // specific for jqGrid only
            var ret, formatType = opr.colModel.formatter,
                op = opr.colModel.formatoptions || {}, sep,
                re = /([\.\*\_\'\(\)\{\}\+\?\\])/g,
                unformatFunc = opr.colModel.unformat || ($.fn.fmatter[formatType] && $.fn.fmatter[formatType].unformat),
                options = $.extend(true, {}, opr,{pos:pos});
            var cellEditConfig = $("#" + options.gid).jqGrid("getCellConfig",  options.colModel.name,options.rowId);
            if (cellEditConfig) {
                formatType = cellEditConfig.formatter;
                if (cellEditConfig.formatter) {
                    options.colModel.formatter = formatType;
                }
                if (cellEditConfig.editoptions) {
                    options.colModel.editoptions = cellEditConfig.editoptions;
                }
                if (cellEditConfig.formatoptions) {
                    options.colModel.formatoptions = cellEditConfig.formatoptions;
                }
            }
            if (typeof unformatFunc !== 'undefined' && $.isFunction(unformatFunc)) {
                ret = unformatFunc.call(this, $(cellval).text(), options, cellval);
            } else if (!$.type.isUndefined(formatType) && $.type.isString(formatType)) {
                var type = eval("cellformatter." + formatType);
                var formattor = new type($("#" + options.gid)[0], options);
                ret = formattor.unformat(cellval, options.rowId);
            } else {
                ret = $.jgrid.htmlDecode($(cellval).html());
            }
            return ret;
        };
        waf.defineCustomeClass("cellformatter.defaultFormatter", null, {
            table:null,
            opts:null,
            gid:null,
            constructor:function (table, opts) {
                this.table = table;
                this.opts = opts;
                this.gid = table.p.id;
            },
            format:function (cellval, rwd) {
                return ($.type.isValue(cellval) && cellval !== "" ) ? cellval : this.opts.defaultValue ? this.opts.defaultValue : "&#160;";
            },
            unformat:function (cell, rowId) {
                return $(cell).text();
            }
        });
        //email
        waf.defineCustomeClass("cellformatter.email", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                if (!$.type.isEmpty(cellval)) {
                    return "<a href=\"mailto:" + cellval + "\">" + cellval + "</a>";
                } else {
                    return cellformatter.defaultFormatter.prototype.format.call(this, cellval, rwd);
                }
            }
        });
        //checkbox
        waf.defineCustomeClass("cellformatter.checkbox", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                var op = $.extend({}, this.opts.checkbox), ds,values,onclick,value;
                if (this.opts.colModel !== undefined && !$.type.isUndefined(this.opts.colModel.formatoptions)) {
                    op = $.extend({}, op, this.opts.colModel.formatoptions);
                }
                //checkboxcheckbox formatterclick
                if(this.opts.colModel && this.opts.colModel.edittype==="wafcheckbox" && this.opts.colModel.editoptions &&
                    this.opts.colModel.editoptions.inputJson && this.opts.colModel.editoptions.inputJson.onclick){
                    onclick = this.opts.colModel.editoptions.inputJson.onclick;
                }
                var id = "chk_"+this.gid + "_" + $.wafutil.replaceAll(this.opts.colModel.name,".","-") + "_"+ $.wafutil.replaceSpecialChar(this.opts.rowId,"");
                if (op.disabled === true) {
                    ds = "disabled=\"disabled\"";
                } else {
                    ds = "";
                    //
                    if(waf.getUrlParams){
                        if($.wafutil.isViewOperateState()){
                            ds = "disabled=\"disabled\"";
                        }
                    }
                }
                if ($.type.isEmpty(cellval) || $.type.isUndefined(cellval)) {
                    cellval = cellformatter.defaultFormatter.prototype.format.call(this, cellval, rwd);
                }
                cellval = cellval + "";
                cellval = cellval.toLowerCase();
                var bchk = cellval.search(/(false|0|no|off)/i) < 0 ? " checked='checked' " : "";
                if($(this.table)[0].p.cellEdit){
                    values = (this.opts.colModel.formatoptions && this.opts.colModel.formatoptions.value) ? this.opts.colModel.formatoptions.value : "1:0";
                    value = values.substring(0,values.indexOf(":"));
                }
                //onclick
                var self = this.table;
                $(self).undelegate("#"+id,"click");
                $(self).delegate("#"+id,"click",function(e){
                    //editCellcheckbox
                    var newValue,oldValue;
                    var td = $(e.target).closest("td",self);
                    var parent = td.parent("tr",self);
                    if(td.length>0 && parent.length>0){
                        var iCol = td[0].cellIndex;
                        var iRow = parent[0].rowIndex;
                        var canEdit = true,old;
                        if (self.p.savedRow.length > 0) {
                            old = self.p.savedRow[0];
                            if(old && iRow == old.id && iCol == old.ic){
                                canEdit = false;
                            }
                        }
                        if(canEdit){
                            $(self).jqGrid("editCell",iRow,iCol,true);
                            //check
                            if (self.p.savedRow.length > 0) {
                                old = self.p.savedRow[0];
                                if(old && iRow == old.id && iCol == old.ic){
                                    //
                                    if(values){
                                        values = values.split(":");
                                    }else{
                                        values = ["1","0"];
                                    }
                                    if(values[0] === old.v){
                                        self.p.savedRow[0].v = values[1];
                                    }else{
                                        self.p.savedRow[0].v = values[0];
                                    }
                                }
                                if(onclick && $.isFunction(onclick)){
                                    onclick.call(self,e,{value:value,checked:$(this)[0].checked,label:""});
                                }
                            }

                        }
                    }
                });
                return "<input id='"+id+"' type=\"checkbox\" " + bchk + " value=\"" + value + "\" offval=\"no\" " + ds + "/>";
            },
            unformat:function(cell,rowId){
                var cbv = (this.opts.colModel.formatoptions && this.opts.colModel.formatoptions.value) ? this.opts.colModel.formatoptions.value.split(":") : ["1","0"];
                var ret = $('input',cell).is(":checked") ? cbv[0] : cbv[1];
                return ret;
            }
        });
        //
        waf.defineCustomeClass("cellformatter.showlink", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                var op = {baseLinkUrl:this.opts.baseLinkUrl, showAction:this.opts.showAction, addParam:this.opts.addParam || "", target:this.opts.target, idName:this.opts.idName},
                    target = "", idUrl;
                if (this.opts.colModel !== undefined && !$.type.isUndefined(this.opts.colModel.formatoptions)) {
                    op = $.extend({}, op, this.opts.colModel.formatoptions);
                }
                if (op.target) {
                    target = 'target=' + op.target;
                }
                //add by jlg.
                if (op.baseLinkUrl === "#") {
                    idUrl = "#";
                } else if (op.baseLinkUrl.indexOf("javascript:") > -1) {
                    idUrl = op.baseLinkUrl;
                } else {
                    idUrl = op.baseLinkUrl + op.showAction + '?' + op.idName + '=' + this.opts.rowId + op.addParam;
                }
                var click = "";
                if (op.onclick) {
                    idUrl = "javascript:void(null)";
                    click = "jQuery.fn.fmatter.rowoperations('" + this.opts.rowId + "','" + this.gid + "','" + op.addParam + "'," + this.opts.pos + "," + op.onclick + ");";
                }
                if ($.type.isString(cellval) || $.type.isNumber(cellval)) {        //add this one even if its blank string
                    if (click != "") {
                        return "<a " + target + " href=\"" + idUrl + "\" onclick=\"" + click + "\" >" + cellval + "</a>";
                    } else {
                        return "<a " + target + " href=\"" + idUrl + "\">" + cellval + "</a>";
                    }
                } else {
                    return cellformatter.defaultFormatter.prototype.format.call(this, cellval, rwd);
                }
            }
        });
        //integer
        waf.defineCustomeClass("cellformatter.integer", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                var op = $.extend({}, this.opts.integer);
                if (this.opts.colModel !== undefined && !$.type.isUndefined(this.opts.colModel.formatoptions)) {
                    op = $.extend({}, op, this.opts.colModel.formatoptions);
                }
                if ($.type.isEmpty(cellval)) {
                    return op.defaultValue;
                }
                return $.fmatter.util.NumberFormat(cellval, op);
            },
            unformat:function(cell,rowId){
                var op =this.opts.colModel.formatoptions || {},tmp = $.jgrid.formatter || {};
                op = $.extend({},tmp.integer,op);
                var re = /([\.\*\_\'\(\)\{\}\+\?\\])/g;
                var sep = op.thousandsSeparator.replace(re,"\\$1");
                var stripTag = new RegExp(sep, "g");
                var ret = $(cell).text().replace(stripTag,'');
                return ret;
            }
        });
        //number
        waf.defineCustomeClass("cellformatter.number", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                var op = $.extend({}, this.opts.number);
                if (this.opts.colModel !== undefined && !$.type.isUndefined(this.opts.colModel.formatoptions)) {
                    op = $.extend({}, op, this.opts.colModel.formatoptions);
                }
                if ($.type.isEmpty(cellval)) {
                    return op.defaultValue;
                }
                return $.fmatter.util.NumberFormat(cellval, op);
            },
            unformat:function(cell,rowId){
                var op =this.opts.colModel.formatoptions || {},tmp = $.jgrid.formatter || {};
                op = $.extend({},tmp.number,op);
                var re = /([\.\*\_\'\(\)\{\}\+\?\\])/g;
                var sep = op.thousandsSeparator.replace(re,"\\$1");
                var stripTag = new RegExp(sep, "g");
                var ret = $(cell).text().replace(stripTag,"").replace(op.decimalSeparator,'.');
                return ret;
            }
        });
        //currency
        waf.defineCustomeClass("cellformatter.currency", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                var op = $.extend({}, this.opts.currency);
                if (this.opts.colModel !== undefined && !$.type.isUndefined(this.opts.colModel.formatoptions)) {
                    op = $.extend({}, op, this.opts.colModel.formatoptions);
                }
                if ($.type.isEmpty(cellval)) {
                    return op.defaultValue;
                }
                return $.fmatter.util.NumberFormat(cellval, op);
            },
            unformat:function(cell,rowId){
                var op =this.opts.colModel.formatoptions || {},tmp = $.jgrid.formatter || {};
                op = $.extend({},tmp.currency,op);
                var re = /([\.\*\_\'\(\)\{\}\+\?\\])/g;
                var sep = op.thousandsSeparator.replace(re,"\\$1");
                var stripTag = new RegExp(sep, "g");
                var ret = $(cell).text();
                if (op.prefix && op.prefix.length) {
                    ret = ret.substr(op.prefix.length);
                }
                if (op.suffix && op.suffix.length) {
                    ret = ret.substr(0, ret.length - op.suffix.length);
                }
                ret = ret.replace(stripTag,'').replace(op.decimalSeparator,'.');
                return ret;
            }
        });
        //date
        waf.defineCustomeClass("cellformatter.date", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                var op = $.extend({}, this.opts.date);
                if (this.opts.colModel !== undefined && !$.type.isUndefined(this.opts.colModel.formatoptions)) {
                    op = $.extend({}, op, this.opts.colModel.formatoptions);
                }
                if (!$.type.isEmpty(cellval)) {
                    return  $.fmatter.util.DateFormat(op.srcformat, cellval, op.newformat, op);
                } else {
                    return cellformatter.defaultFormatter.prototype.format.call(this, cellval, rwd);
                }
            },
            unformat:function (cell, rowId) {
                var op = $.jgrid.formatter.date || {};
                if (!$.type.isUndefined(this.opts.colModel.formatoptions)) {
                    op = $.extend({}, op, this.opts.colModel.formatoptions);
                }
                var cellval = $(cell).text();
                if (!$.type.isEmpty(cellval)) {
                    return  $.fmatter.util.DateFormat(op.newformat, cellval, op.srcformat, op);
                } else {
                    return cellformatter.defaultFormatter.prototype.format.call(this, cellval, undefined);
                }
            }
        });
        //wafcheckboxcellvaltrue,false1,0,add by jlg.
        waf.defineCustomeClass("cellformatter.wafcheckbox", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                if ($.type.isUndefined(cellval) || cellval === null) return "";
                if($.type.isObject(cellval) && cellval.isenum){
                    cellval = cellval.value;
                }
                cellval = cellval + "";
                var ret = cellval;
                var oBoolean = {"1":$.jgrid.booleanCaption.yes, "0":$.jgrid.booleanCaption.no};
                if (!$.type.isUndefined(this.opts.colModel.formatoptions) && this.opts.colModel.formatoptions!=null && !$.type.isUndefined(this.opts.colModel.formatoptions.value)) {
                    oBoolean = this.opts.colModel.formatoptions.value;
                } else if (!$.type.isUndefined(this.opts.colModel.editoptions) && this.opts.colModel.editoptions!=null && !$.type.isUndefined(this.opts.colModel.editoptions.value)) {
                    oBoolean = this.opts.colModel.editoptions.value;
                }
                if (cellval === "undefined" || $.type.isUndefined(cellval) || cellval === null) {
                    cellval = (this.opts.colModel.editoptions && this.opts.colModel.editoptions.defaultValue) || "0";
                }
                if (oBoolean) {
                    if (cellval === "true") {
                        cellval = "1";
                        ret = oBoolean[cellval];
                    } else if (cellval === "false") {
                        cellval = "0";
                        ret = oBoolean[cellval];
                    } else {
                        var temp = cellval.split(",");
                        ret = "";
                        for (var i = 0; i < temp.length; i++) {
                            if (temp[i].length > 0) {
                                ret = ret + oBoolean[temp[i]] + ",";
                            }
                        }
                        if (ret.length > 0) {
                            ret = ret.substring(0, ret.length - 1);
                        }

                    }

                }
                return cellval === "" ? cellformatter.defaultFormatter.prototype.format.call(this, cellval, rwd) : ret;
            },
            unformat:function (cell, rowId) {
                var cellval = $(cell).text();
                var ret;
                var oBoolean = {"1":$.jgrid.booleanCaption.yes, "0":$.jgrid.booleanCaption.no};
                //
                if (cellval == undefined || cellval === "" || $.trim(cellval) === "" || cellval == null || cellval === "null" || cellval === "undefined") {
                    cellval = $.jgrid.booleanCaption.no;
                }
                if (!$.type.isUndefined(this.opts.colModel.formatoptions) && this.opts.colModel.formatoptions!=null && !$.type.isUndefined(this.opts.colModel.formatoptions.value)) {
                    oBoolean = this.opts.colModel.formatoptions.value;
                    //
                    if (cellval == undefined || cellval === "" || $.trim(cellval) === "" || cellval == null || cellval === "null" || cellval === "undefined") {
                        cellval = this.opts.colModel.formatoptions.defaultValue;
                    }
                } else if (!$.type.isUndefined(this.opts.colModel.editoptions) && this.opts.colModel.editoptions!=null && !$.type.isUndefined(this.opts.colModel.editoptions.value)) {
                    oBoolean = this.opts.colModel.editoptions.value;
                    //
                    if (cellval == undefined || cellval === "" || $.trim(cellval) === "" || cellval == null || cellval === "null" || cellval === "undefined") {
                        cellval = this.opts.colModel.editoptions.defaultValue;
                    }
                }
                if (oBoolean) {
                    if (cellval === "true") cellval = "1";
                    if (cellval === "false") cellval = "0";
                    for (var tmp in oBoolean) {
                        var caption = oBoolean[tmp];
                        if (cellval === caption) {
                            ret = tmp;
                            break;
                        }
                    }
                }
                //checkboxnull,'',undefined
                return $.fmatter.util.filterNull(ret);
            }
        });
        waf.defineCustomeClass("cellformatter.wafboolean", cellformatter.wafcheckbox,{});
        //
        waf.defineCustomeClass("cellformatter.wafselect", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                if ($.type.isUndefined(cellval) || cellval === null) return "";
                if (typeof cellval === "object" && waf.isEnumValue(cellval)) {
                    cellval = cellval.value;
                }
                // jqGrid specific,cellval
                cellval = cellval + "";
                //oSelect.formatoptions.value,[{alias:'xxxx',value:1},{alias:'yyyy',value:2}]
                var oSelect = false, ret = [], msl = false;
                if (!$.type.isUndefined(this.opts.colModel.formatoptions) && this.opts.colModel.formatoptions!=null) {
                    oSelect = this.opts.colModel.formatoptions.enumSource;
                    if (this.opts.colModel.formatoptions.multiple) {
                        msl = this.opts.colModel.formatoptions.multiple;
                    }
                } else if (!$.type.isUndefined(this.opts.colModel.editoptions) && this.opts.colModel.editoptions!=null) {
                    oSelect = this.opts.colModel.editoptions.enumSource;
                    if (this.opts.colModel.editoptions.multiple) {
                        msl = this.opts.colModel.editoptions.multiple;
                    }
                    if (undefined == oSelect || oSelect === null) {
                        var self = this;
                        if (this.opts.colModel.editoptions.urlSource && this.opts.colModel.editoptions.urlSource != null) {
                            $.ajax({
                                type:"get",
                                url:this.opts.colModel.editoptions.urlSource,
                                async:false,
                                success:function (data) {
                                    //options.colModel.editoptions.enumSource = data;
                                    $(self.table).wafGrid("setCellEditorAllConfig", self.opts.colModel.name, "enumSource", data,"select");
                                    oSelect = data;
                                },
                                dataType:"json"
                            });
                        }
                    }
                }
                if (oSelect) {
                    var scell = [], sv,all=new Array();
                    if (msl) {
                        scell = cellval.split(",");
                        scell = $.map(scell, function (n) {
                            return $.trim(n);
                        });    //.
                    }
                    if ($.type.isObject(oSelect)) {
                        //oSelect
                        $(oSelect).each(function (i) {
                            if(this.childs && this.childs.length>0){
                                $(this.childs).each(function(j){
                                    all.push(this);
                                });
                            }else{
                                all.push(this);
                            }
                        });
                        oSelect = all;
                        // this is quicker
                        var tmp;
                        if (msl) {
                            ret = jQuery.map(scell, function (value, i) {
                                if ($.isArray(oSelect)) {
                                    tmp = $.map(oSelect, function (n, i) {
                                        //.
                                        if (n) {
                                            if (typeof n.value === "number") {
                                                if (parseInt(value) === n.value) {
                                                    return n.alias;
                                                }
                                            } else {
                                                if (value === n.value) {
                                                    return n.alias;
                                                }
                                            }
                                        }
                                    });
                                }
                                return tmp;
                            });
                        } else {
                            if ($.isArray(oSelect)) {
                                var n;
                                for (var i = 0; i < oSelect.length; i++) {
                                    n = oSelect[i];
                                    if (n) {
                                        //.
                                        if (typeof n.value === "number") {
                                            if (parseInt(cellval) === n.value) {
                                                ret.push(n.alias);
                                                break;
                                            }
                                        } else {
                                            if (cellval === n.value) {
                                                ret.push(n.alias);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                cellval = ret.join(", ");
                return  cellval === "" ? cellformatter.defaultFormatter.prototype.format.call(this, cellval, rwd) : cellval;
            },
            unformat:function (cellval, rowId) {
                var ret = [], value;
                var cell = $(cellval).text();
                //    if (cnt === true) {
                //        return cell;
                //    }
                var oSelect = false, msl = false;
                if (!$.type.isUndefined(this.opts.colModel.formatoptions) && this.opts.colModel.formatoptions!=null) {
                    oSelect = this.opts.colModel.formatoptions.enumSource;
                    if (this.opts.colModel.formatoptions.multiple) {
                        msl = this.opts.colModel.formatoptions.multiple;
                    }
                } else if (!$.type.isUndefined(this.opts.colModel.editoptions) && this.opts.colModel.editoptions!=null  ) {
                    oSelect = this.opts.colModel.editoptions.enumSource;
                    if (this.opts.colModel.editoptions.multiple) {
                        msl = this.opts.colModel.editoptions.multiple;
                    }
                    if (undefined == oSelect || oSelect === null) {
                        var self = this;
                        if (this.opts.colModel.editoptions.urlSource && this.opts.colModel.editoptions.urlSource != null) {
                            $.ajax({
                                type:"get",
                                url:self.opts.colModel.editoptions.urlSource,
                                async:false,
                                success:function (data) {
                                    //options.colModel.editoptions.enumSource = data;
                                    $(self.table).wafGrid("setCellEditorAllConfig", self.opts.colModel.name, "enumSource", data,"select");
                                    oSelect = data;
                                },
                                dataType:"json"
                            });
                        }
                    }
                }
                if (oSelect) {
                    var scell = [], sv, tmp;
                    if (msl) {
                        scell = cell.split(",");
                        scell = $.map(scell, function (n) {
                            return $.trim(n);
                        });
                        if ($.type.isObject(oSelect) || $.isArray(oSelect)) {
                            ret = jQuery.map(scell, function (value, i) {
                                tmp = $.map(oSelect, function (n, val) {
                                    //.
                                    if (n && n.alias === value) {
                                        return n.value;
                                    }
                                });
                                return tmp;
                            });
                        }
                    } else {
                        if ($.type.isObject(oSelect) || $.isArray(oSelect)) {
                            if (!msl) {
                                scell[0] = cell;
                            }
                            ret = jQuery.map(scell, function (n) {
                                var rv;
                                $.each(oSelect, function (i, val) {
                                    if (val && val.alias === n) {
                                        rv = val.value;
                                        return false;
                                    }
                                });
                                if (typeof(rv) != 'undefined') {
                                    return rv;
                                }
                            });
                            //ret
//                        if (ret && ret.length == 0 && this.opts.colModel.autoFillSelect) {
//                            ret.push(oSelect[0].value);
//                        }
                        }
                    }
                    value = ret.join(", ");
                } else {
                    value = cell || "";
                }
                return $.fmatter.util.filterNull(value);
            }
        });
        //
        waf.defineCustomeClass("cellformatter.wafenum", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                if ($.type.isUndefined(cellval) || cellval === null) return "";
                if (typeof cellval === "object") {
                    //
                    var storeValue = $(this.table).data("storeValue") || {};
                    storeValue[this.opts.colModel.name + "-" + this.opts.rowId] = cellval;
                    $(this.table).data("storeValue", storeValue);
                    return cellval.alias;
                } else {
                    var select = new cellformatter.wafselect(this.table, this.opts);
                    return select.format(cellval, rwd);
                }
            },
            unformat:function (cellval, rowId) {
                var ret;
                var storeValue = $(this.table).data("storeValue");
                if (storeValue) {
                    ret = storeValue[this.opts.colModel.name + "-" + this.opts.rowId];
                }
                if (!ret) {
                    var select = new cellformatter.wafselect(this.table, this.opts);
                    return select.unformat(cellval, rowId);
                } else {
                    return ret.value;
                }
            }
        });
        //jsonhdd
        waf.defineCustomeClass("cellformatter.json", cellformatter.defaultFormatter, {
            format:function (cellvalue, rwd) {
                if($.type.isObject(cellvalue)){
                    var storeValue = $(this.table).data("storeValue") || {};
                    storeValue[this.opts.colModel.name + "-" + this.opts.rowId] = cellvalue;
                    $(this.table).data("storeValue", storeValue);
                }
                return "";
            },
            unformat:function (cell, rowId) {
                //unformat
                var storeValue = $(this.table).data("storeValue") || {};
                return storeValue[this.opts.colModel.name + "-" + this.opts.rowId];
            }
        });
        //operations
        var formatRowIndex = 0;
        waf.defineCustomeClass("cellformatter.operations", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                var op, str = "", rowid = this.opts.rowId;
                if (!$.type.isUndefined(this.opts.colModel.formatoptions)) {
                    op = this.opts.colModel.formatoptions;
                }
                var pre = this.gid + "_" + this.opts.pos + "_" + formatRowIndex, self = this;
                if ($.isArray(op)) {
                    $.each(op, function (index, value) {
                        var elem = document.createElement("a"),
                            linkjson = value.linkJson,
                            visible = value.visible,
                            onclick = linkjson?linkjson.onclick:null,
                            mbid = "mb_" + pre + "_" + linkjson.id;

                        elem.ctrlrole = "linkButton";
                        var newid = linkjson.id + "_" + pre;
                        var id = "#" + newid;

                        if (visible && visible === true) {
                            var tmp = {};
                            $.extend(tmp, linkjson);
                            tmp.id = newid;
                            $(elem).wafLinkButton(tmp);
                            if (value.actionBindingName) {
                                onclick = "'" + value.actionBindingName + "'";
                            }
                        }
                        var ocl = "onclick=jQuery.fn.fmatter.linkoperations('" + rowid + "','" + self.gid + "','" + linkjson.id + "'," + self.opts.pos + "," + onclick + ",'" + mbid + "');";
                        str = str + "<span id='" + mbid + "' style='display:inline-block;margin-left:3px;' class='ui-pg-div ui-inline-operators' " + ocl + ">" + ($(elem).outerHTML()) + "</span>";
                    });
                }
                formatRowIndex = formatRowIndex + 1;
                return str;
            },
            unformat:function(cell,rowId){
                return undefined;
            }
        });
        //menuoperations
        waf.defineCustomeClass("cellformatter.menuoperations", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                var op, str = "", rowid = this.opts.rowId;
                if (!$.type.isUndefined(this.opts.colModel.formatoptions)) {
                    op = this.opts.colModel.formatoptions;
                }
                var id = this.gid + "_" + this.opts.pos + "_" + rowid, self = this;
                if ($.isArray(op)) {
                    $.each(op, function (index, value) {
                        var elem = document.createElement("a"),
                            linkjson = value.linkJson,
                            visible = value.visible,
                            onclick = linkjson?linkjson.onclick:null,
                            menuid = "ul_" + self.gid + "_" + self.opts.colModel.name + "_" + linkjson.id,
                            mbid = "mb_" + id + "_" + linkjson.id;

                        elem.ctrlrole = "menuButton";

                        if (visible && visible === true) {
                            var tmp = {};
                            $.extend(tmp, linkjson);
                            $(elem).wafMenuButton(tmp);
                            if (value.actionBindingName) {
                                onclick = "'" + value.actionBindingName + "'";
                            }

                            //
                            $(elem).children("span.ui-lb-text").after("<span class='ui-menubtn-right icondefault ui-icon-triangle-1-s'></span>");
                            //menu
                            if (linkjson.menuWidth) {
                                $("#" + menuid).width(linkjson.menuWidth);
                            }
                            $("#" + menuid).css({"position":"absolute", "z-index":999}).menu({
                                select:function (event, ui) {
                                    if (ui.item) {
                                        var link = ui.item.children("a:first");
                                        if (link.children("span.ui-icon").length == 0 && !link.hasClass("ui-lb-disabled")) {
                                            link.parents("ul.ui-menu-ul").hide();
                                        }
                                    }
                                }
                            });
                        }
                        //onclickmenubutton
                        var ocl = "jQuery.fn.fmatter.rowmenuoperations('" + mbid + "','" + menuid + "','" + rowid + "','" + self.gid + "','" + linkjson.id + "'," + self.opts.pos + "," + null + ",true);";
                        if (onclick && onclick != null) {
                            var onclk = "jQuery.fn.fmatter.rowmenuoperations('" + mbid + "','" + menuid + "','" + rowid + "','" + self.gid + "','" + linkjson.id + "'," + self.opts.pos + "," + onclick + ",false);";
                            $(elem).children("span.ui-lb-text").attr("onclick", onclk);
                            $(elem).children("span.ui-menubtn-right").attr("onclick", ocl);
                        } else {
                            $(elem).attr("onclick", ocl).css("display", "inline-block");
                        }
                        var alink = ($(elem).outerHTML());
                        str = str + "<span id='" + mbid + "' style='display:inline-block;margin-left:3px;' class='ui-pg-div ui-inline-operators'>" + (alink) + "</span>";
                    });
                }
                return str;
            },
            unformat:function(cell,rowId){
                return undefined;
            }
        });
        //showlink
        $.fn.fmatter.rowoperations = function (rid, gid, act, pos, fun) {
            $("#"+gid).wafGrid("setSelection",rid);
            if (fun && $.isFunction(fun)) {
                fun.apply(null, arguments);
            } else if (typeof fun === "string") {
                var method = function () {
                    waf.proxyCall(fun, undefined, rid, gid, act, pos);
                }
                method.apply(null, arguments);
            }
            $("#"+gid).wafGrid("removeSelect",rid);
        }
        //linkbutton
        $.fn.fmatter.linkoperations = function (rid, gid, act, pos, fun, mbid) {
            var disabled = $("#" + mbid).children("a.ui-linkbutton").hasClass("ui-lb-disabled");
            if (!disabled) {
                $("#"+gid).wafGrid("setSelection",rid);
                if (fun && $.isFunction(fun)) {
                    fun.apply(null, arguments);
                } else if (typeof fun === "string") {
                    var method = function () {
                        waf.proxyCall(fun, undefined, rid, gid, act, pos);
                    }
                    method.apply(null, arguments);
                }
                $("#"+gid).wafGrid("removeSelect",rid);
            }
        }
        //menubutton
        $.fn.fmatter.rowmenuoperations = function (mbid, menuid, rid, gid, act, pos, fun, openMenu) {
            if (openMenu) {
                var disabled = $("#" + mbid).children("a.ui-linkbutton").hasClass("ui-lb-disabled");
                if (!disabled) {
                    var menu = $("#" + menuid);
                    //menu
                    menu.popup("destroy");
                    //
                    menu.popup({
                        trigger:$("#" + mbid)
                    });
                    //open
                    window.setTimeout(function () {
                        $("#" + mbid).trigger("clickopen");
                    }, 10);
                }
            } else {
                var disabled = $("#" + mbid).children("a.ui-linkbutton").hasClass("ui-lb-disabled");
                if (!disabled) {
                    $("#"+gid).wafGrid("setSelection",rid);
                    if (fun && $.isFunction(fun)) {
                        fun.apply(null, arguments);
                    } else if (typeof fun === "string") {
                        var method = function () {
                            waf.proxyCall(fun, undefined, rid, gid, act, pos);
                        }
                        method.apply(null, arguments);
                    }
                    $("#"+gid).wafGrid("removeSelect",rid);
                }
            }
        }
        $.fmatter = {};
        $.fmatter.util = {
            // Taken from YAHOO utils
            NumberFormat:function (nData, opts) {
                if (!$.type.isNumber(nData)) {
                    nData *= 1;
                }
                if ($.type.isNumber(nData)) {
                    var bNegative = (nData < 0);
                    var sOutput = nData + "";
                    var sDecimalSeparator = (opts.decimalSeparator) ? opts.decimalSeparator : ".";
                    var nDotIndex;
                    if ($.type.isNumber(opts.decimalPlaces)) {
                        // Round to the correct decimal place
                        var nDecimalPlaces = opts.decimalPlaces;
                        var nDecimal = Math.pow(10, nDecimalPlaces);
                        sOutput = Math.round(nData * nDecimal) / nDecimal + "";
                        nDotIndex = sOutput.lastIndexOf(".");
                        if (nDecimalPlaces > 0) {
                            // Add the decimal separator
                            if (nDotIndex < 0) {
                                sOutput += sDecimalSeparator;
                                nDotIndex = sOutput.length - 1;
                            }
                            // Replace the "."
                            else if (sDecimalSeparator !== ".") {
                                sOutput = sOutput.replace(".", sDecimalSeparator);
                            }
                            // Add missing zeros
                            while ((sOutput.length - 1 - nDotIndex) < nDecimalPlaces) {
                                sOutput += "0";
                            }
                        }
                    }
                    if (opts.thousandsSeparator) {
                        var sThousandsSeparator = opts.thousandsSeparator;
                        nDotIndex = sOutput.lastIndexOf(sDecimalSeparator);
                        nDotIndex = (nDotIndex > -1) ? nDotIndex : sOutput.length;
                        var sNewOutput = sOutput.substring(nDotIndex);
                        var nCount = -1;
                        for (var i = nDotIndex; i > 0; i--) {
                            nCount++;
                            if ((nCount % 3 === 0) && (i !== nDotIndex) && (!bNegative || (i > 1))) {
                                sNewOutput = sThousandsSeparator + sNewOutput;
                            }
                            sNewOutput = sOutput.charAt(i - 1) + sNewOutput;
                        }
                        sOutput = sNewOutput;
                    }
                    // Prepend prefix
                    sOutput = (opts.prefix) ? opts.prefix + sOutput : sOutput;
                    // Append suffix
                    sOutput = (opts.suffix) ? sOutput + opts.suffix : sOutput;
                    return sOutput;

                } else {
                    return nData;
                }
            },
            // Tony Tomov
            // PHP implementation. Sorry not all options are supported.
            // Feel free to add them if you want
            DateFormat:function (format, date, newformat, opts) {
                var token = /\\.|[dDjlNSwzWFmMntLoYyaABgGhHisueIOPTZcrU]/g,
                    timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
                    timezoneClip = /[^-+\dA-Z]/g,
                    msDateRegExp = new RegExp("^\/Date\\((([-+])?[0-9]+)(([-+])([0-9]{2})([0-9]{2}))?\\)\/$"),
                    msMatch = ((typeof date === 'string') ? date.match(msDateRegExp) : null),
                    pad = function (value, length) {
                        value = String(value);
                        length = parseInt(length, 10) || 2;
                        while (value.length < length) {
                            value = '0' + value;
                        }
                        return value;
                    },
                    ts = {m:1, d:1, y:1970, h:0, i:0, s:0, u:0},
                    timestamp = 0, dM, k, hl,
                    dateFormat = ["i18n"];
                // Internationalization strings
                dateFormat.i18n = {
                    dayNames:opts.dayNames,
                    monthNames:opts.monthNames
                };
                if (format in opts.masks) {
                    format = opts.masks[format];
                }
                if (!isNaN(date - 0) && String(format).toLowerCase() == "u") {
                    //Unix timestamp
                    timestamp = new Date(parseFloat(date) * 1000);
                } else if (date.constructor === Date) {
                    timestamp = date;
                    // Microsoft date format support
                } else if (msMatch !== null) {
                    timestamp = new Date(parseInt(msMatch[1], 10));
                    if (msMatch[3]) {
                        var offset = Number(msMatch[5]) * 60 + Number(msMatch[6]);
                        offset *= ((msMatch[4] == '-') ? 1 : -1);
                        offset -= timestamp.getTimezoneOffset();
                        timestamp.setTime(Number(Number(timestamp) + (offset * 60 * 1000)));
                    }
                } else {
                    date = String(date).split(/[\\\/:_;.,\t\T\s-]/);
                    format = format.split(/[\\\/:_;.,\t\T\s-]/);
                    // parsing for month names
                    for (k = 0, hl = format.length; k < hl; k++) {
                        if (format[k] == 'M') {
                            dM = $.inArray(date[k], dateFormat.i18n.monthNames);
                            if (dM !== -1 && dM < 12) {
                                date[k] = dM + 1;
                            }
                        }
                        if (format[k] == 'F') {
                            dM = $.inArray(date[k], dateFormat.i18n.monthNames);
                            if (dM !== -1 && dM > 11) {
                                date[k] = dM + 1 - 12;
                            }
                        }
                        if (date[k]) {
                            ts[format[k].toLowerCase()] = parseInt(date[k], 10);
                        }
                    }
                    if (ts.f) {
                        ts.m = ts.f;
                    }
                    if (ts.m === 0 && ts.y === 0 && ts.d === 0) {
                        return "&#160;";
                    }
                    ts.m = parseInt(ts.m, 10) - 1;
                    var ty = ts.y;
                    if (ty >= 70 && ty <= 99) {
                        ts.y = 1900 + ts.y;
                    }
                    else if (ty >= 0 && ty <= 69) {
                        ts.y = 2000 + ts.y;
                    }
                    timestamp = new Date(ts.y, ts.m, ts.d, ts.h, ts.i, ts.s, ts.u);
                }

                if (newformat in opts.masks) {
                    newformat = opts.masks[newformat];
                } else if (!newformat) {
                    newformat = 'Y-m-d';
                }
                var
                    G = timestamp.getHours(),
                    i = timestamp.getMinutes(),
                    j = timestamp.getDate(),
                    n = timestamp.getMonth() + 1,
                    o = timestamp.getTimezoneOffset(),
                    s = timestamp.getSeconds(),
                    u = timestamp.getMilliseconds(),
                    w = timestamp.getDay(),
                    Y = timestamp.getFullYear(),
                    N = (w + 6) % 7 + 1,
                    z = (new Date(Y, n - 1, j) - new Date(Y, 0, 1)) / 86400000,
                    flags = {
                        // Day
                        d:pad(j),
                        D:dateFormat.i18n.dayNames[w],
                        j:j,
                        l:dateFormat.i18n.dayNames[w + 7],
                        N:N,
                        S:opts.S(j),
                        //j < 11 || j > 13 ? ['st', 'nd', 'rd', 'th'][Math.min((j - 1) % 10, 3)] : 'th',
                        w:w,
                        z:z,
                        // Week
                        W:N < 5 ? Math.floor((z + N - 1) / 7) + 1 : Math.floor((z + N - 1) / 7) || ((new Date(Y - 1, 0, 1).getDay() + 6) % 7 < 4 ? 53 : 52),
                        // Month
                        F:dateFormat.i18n.monthNames[n - 1 + 12],
                        m:pad(n),
                        M:dateFormat.i18n.monthNames[n - 1],
                        n:n,
                        t:'?',
                        // Year
                        L:'?',
                        o:'?',
                        Y:Y,
                        y:String(Y).substring(2),
                        // Time
                        a:G < 12 ? opts.AmPm[0] : opts.AmPm[1],
                        A:G < 12 ? opts.AmPm[2] : opts.AmPm[3],
                        B:'?',
                        g:G % 12 || 12,
                        G:G,
                        h:pad(G % 12 || 12),
                        H:pad(G),
                        i:pad(i),
                        s:pad(s),
                        u:u,
                        // Timezone
                        e:'?',
                        I:'?',
                        O:(o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                        P:'?',
                        T:(String(timestamp).match(timezone) || [""]).pop().replace(timezoneClip, ""),
                        Z:'?',
                        // Full Date/Time
                        c:'?',
                        r:'?',
                        U:Math.floor(timestamp / 1000)
                    };
                return newformat.replace(token, function ($0) {
                    return $0 in flags ? flags[$0] : $0.substring(1);
                });
            },
            filterNull:function(value){
//            if(value==null)value=undefined;
                if (value != undefined && (
                    value === "&nbsp;" || value === "&#160;" ||
                        value === "null" || value === "undefined")) {
                    value = undefined;
                }
                return value;
            }
        };



        //
        $.jgrid.extend({
            addFrozenColumn:function (colName) {
                return this.each(function () {
                    if (!this.grid) return;
                    var $t = this;
                    //
                    $($t).jqGrid("destroyFrozenColumns");
                    //
                    var cM = $t.p.colModel;
                    for (var i = 0; i < cM.length; i++) {
                        var coljson = $($t).jqGrid("getColProp", cM[i].name);
                        if (coljson.frozen) {
                            $($t).jqGrid("setColProp", cM[i].name, {frozen:true});
                        }
                    }
                    //
                    $($t).jqGrid("setColProp", colName, {frozen:true});
                    $($t).jqGrid("setFrozenColumns").trigger("reloadGrid", [
                        {current:true}
                    ]);
                });
            },
            removeFrozenColumn:function (colName) {
                return this.each(function () {
                    if (!this.grid) return;
                    var $t = this;
                    //
                    $($t).jqGrid("destroyFrozenColumns");
                    //
                    var cM = $t.p.colModel;
                    for (var i = 0; i < cM.length; i++) {
                        var coljson = $($t).jqGrid("getColProp", cM[i].name);
                        if (coljson.frozen) {
                            if (cM[i].name === colName) {
                                $($t).jqGrid("setColProp", cM[i].name, {frozen:false});
                            } else {
                                $($t).jqGrid("setColProp", cM[i].name, {frozen:true});
                            }
                        }
                    }
                    $($t).jqGrid("setFrozenColumns").trigger("reloadGrid", [
                        {current:true}
                    ]);
                });
            },
            setFrozenColumns : function () {
                return this.each(function() {
                    if ( !this.grid ) {return;}
                    var $t = this, cm = $t.p.colModel,i=0, len = cm.length, maxfrozen = -1, frozen= false;
                    // TODO treeGrid and grouping  Support
                    //celledit
                    if($t.p.subGrid === true || $t.p.treeGrid === true  || $t.p.sortable || $t.p.scroll || $t.p.grouping )
                    {
                        return;
                    }
                    if($t.p.rownumbers) { i++; }
                    if($t.p.multiselect) { i++; }

                    // get the max index of frozen col
                    while(i<len)
                    {
                        // from left, no breaking frozen
                        if(cm[i].frozen === true)
                        {
                            frozen = true;
                            maxfrozen = i;
                        } else {
                            break;
                        }
                        i++;
                    }
                    if( maxfrozen>=0 && frozen) {
                        var top = $t.p.caption ? $($t.grid.cDiv).outerHeight() : 0,
                            hth = $(".ui-jqgrid-htable","#gview_"+$.jgrid.jqID($t.p.id)).height();
                        //headers
                        if($t.p.toppager) {
                            top = top + $($t.grid.topDiv).outerHeight();
                        }
                        if($t.p.toolbar[0] === true) {
                            if($t.p.toolbar[1] != "bottom") {
                                top = top + $($t.grid.uDiv).outerHeight();
                            }
                        }
                        $t.grid.fhDiv = $('<div style="position:absolute;left:0px;top:'+top+'px;height:'+hth+'px;" class="frozen-div ui-state-default ui-jqgrid-hdiv"></div>');
                        $t.grid.fbDiv = $('<div style="position:absolute;left:0px;top:'+(parseInt(top,10)+parseInt(hth,10) + 1)+'px;overflow-y:hidden" class="frozen-bdiv ui-jqgrid-bdiv"></div>');                    $("#gview_"+$.jgrid.jqID($t.p.id)).append($t.grid.fhDiv);
                        var htbl = $(".ui-jqgrid-htable","#gview_"+$.jgrid.jqID($t.p.id)).clone(true);
                        // groupheader support - only if useColSpanstyle is false
                        if($t.p.groupHeader) {
                            $("tr.jqg-first-row-header, tr.jqg-third-row-header", htbl).each(function(){
                                $("th:gt("+maxfrozen+")",this).remove();
                            });
                            var swapfroz = -1, fdel = -1;
                            $("tr.jqg-second-row-header th", htbl).each(function(){
                                var cs= parseInt($(this).attr("colspan"),10);
                                if(cs) {
                                    swapfroz = swapfroz+cs;
                                    fdel++;
                                }
                                if(swapfroz === maxfrozen) {
                                    return false;
                                }
                            });
                            if(swapfroz !== maxfrozen) {
                                fdel = maxfrozen;
                            }
                            $("tr.jqg-second-row-header", htbl).each(function(){
                                $("th:gt("+fdel+")",this).remove();
                            });
                        } else {
                            $("tr",htbl).each(function(){
                                $("th:gt("+maxfrozen+")",this).remove();
                                $("th:eq("+maxfrozen+")",this).addClass("frozelastcell");
                            });
                        }
                        $(htbl).width(1);
                        // resizing stuff
                        $($t.grid.fhDiv).append(htbl)
                            .mousemove(function (e) {
                                if($t.grid.resizing){ $t.grid.dragMove(e);return false; }
                            });
                        $($t).bind('jqGridResizeStop.setFrozenColumns', function (e, w, index) {
                            var rhth = $(".ui-jqgrid-htable",$t.grid.fhDiv);
                            $("th:eq("+index+")",rhth).width( w );
                            var btd = $(".ui-jqgrid-btable",$t.grid.fbDiv);
                            $("tr:first td:eq("+index+")",btd).width( w );
                            //
                            $.jgrid.adjustFrozenColumnHeight($t);
                        });
                        // sorting stuff
                        $($t).bind('jqGridOnSortCol.setFrozenColumns', function (index, idxcol) {

                            var previousSelectedTh = $("tr.ui-jqgrid-labels:last th:eq("+$t.p.lastsort+")",$t.grid.fhDiv), newSelectedTh = $("tr.ui-jqgrid-labels:last th:eq("+idxcol+")",$t.grid.fhDiv);

                            $("span.ui-grid-ico-sort",previousSelectedTh).addClass('ui-state-disabled');
                            $(previousSelectedTh).attr("aria-selected","false");
                            $("span.ui-icon-"+$t.p.sortorder,newSelectedTh).removeClass('ui-state-disabled');
                            $(newSelectedTh).attr("aria-selected","true");
                            if(!$t.p.viewsortcols[0]) {
                                if($t.p.lastsort != idxcol) {
                                    $("span.s-ico",previousSelectedTh).hide();
                                    $("span.s-ico",newSelectedTh).show();
                                }
                            }
                        });

                        // data stuff
                        //TODO support for setRowData
                        $("#gview_"+$.jgrid.jqID($t.p.id)).append($t.grid.fbDiv);
                        jQuery($t.grid.bDiv).scroll(function () {
                            jQuery($t.grid.fbDiv).scrollTop(jQuery(this).scrollTop());
                        });
                        if($t.p.hoverrows === true) {
                            $("#"+$.jgrid.jqID($t.p.id)).unbind('mouseover').unbind('mouseout');
                        }
                        $($t).bind('jqGridAfterGridComplete.setFrozenColumns', function () {
                            $("#"+$.jgrid.jqID($t.p.id)+"_frozen").remove();
                            jQuery($t.grid.fbDiv).height( jQuery($t.grid.bDiv).height()-16);
                            var btbl = $("#"+$.jgrid.jqID($t.p.id)).clone(true);
                            $("tr",btbl).each(function(){
                                $("td:gt("+maxfrozen+")",this).remove();
                                $("td:eq("+maxfrozen+")",this).addClass("frozelastcell");
                            });

                            $(btbl).width(1).attr("id",$t.p.id+"_frozen");
                            $($t.grid.fbDiv).append(btbl);

                            //tr.norecord
                            $("tr.norecord",btbl).find("td").html("");

                            //
                            $.jgrid.adjustFrozenColumnHeight($t);

                            if($t.p.hoverrows === true) {
                                $("tr.jqgrow", btbl).hover(
                                    function(){ $(this).addClass("ui-state-hover"); $("#"+$.jgrid.jqID(this.id), "#"+$.jgrid.jqID($t.p.id)).addClass("ui-state-hover"); },
                                    function(){ $(this).removeClass("ui-state-hover"); $("#"+$.jgrid.jqID(this.id), "#"+$.jgrid.jqID($t.p.id)).removeClass("ui-state-hover"); }
                                );
                                $("tr.jqgrow", "#"+$.jgrid.jqID($t.p.id)).hover(
                                    function(){ $(this).addClass("ui-state-hover"); $("#"+$.jgrid.jqID(this.id), "#"+$.jgrid.jqID($t.p.id)+"_frozen").addClass("ui-state-hover");},
                                    function(){ $(this).removeClass("ui-state-hover"); $("#"+$.jgrid.jqID(this.id), "#"+$.jgrid.jqID($t.p.id)+"_frozen").removeClass("ui-state-hover"); }
                                );
                            }
                            btbl=null;
                        });


                        $t.p.frozenColumns = true;
                    }
                });
            },
            destroyFrozenColumns :  function() {
                return this.each(function() {
                    if ( !this.grid ) {return;}
                    if(this.p.frozenColumns === true) {
                        var $t = this;
                        $($t.grid.fhDiv).remove();
                        $($t.grid.fbDiv).remove();
                        $t.grid.fhDiv = null; $t.grid.fbDiv=null;
                        $(this).unbind('.setFrozenColumns');
                        if($t.p.hoverrows === true) {
                            var ptr;
                            $("#"+$.jgrid.jqID($t.p.id)).bind('mouseover',function(e) {
                                ptr = $(e.target).closest("tr.jqgrow");
                                if($(ptr).attr("class") !== "ui-subgrid") {
                                    $(ptr).addClass("ui-state-hover");
                                }
                            }).bind('mouseout',function(e) {
                                    ptr = $(e.target).closest("tr.jqgrow");
                                    $(ptr).removeClass("ui-state-hover");
                                });
                        }
                        this.p.frozenColumns = false;
                    }
                });
            }
        });
        //
        $.extend($.jgrid,{
            adjustFrozenColumnHeight:function(ts,rowId){
                function innerSetHeight(originTd,frozenTd,frozenTable,body){
                    var browser = $.boxLayoutUtil.userBrowser(),outheight;
                    if("firefox"===browser || "opera"===browser){
                        outheight = originTd.outerHeight();
                    }else{
                        outheight = originTd.height();
                    }
                    $(frozenTd).each(function(){
                        $(this).height(outheight);
                    });
                }
                var gv = $(ts).closest("div.ui-jqgrid");
                if(ts.p.frozenColumns === true) {
                    var i,one=rowId!=undefined;
                    //
                    var frozen = $("#"+ts.p.id+"_frozen",gv);
                    //DIV
                    var frozenDiv = $(frozen).parent("div.frozen-bdiv");
                    //
                    var hth = $(".ui-jqgrid-htable","#gview_"+$.jgrid.jqID(ts.p.id)).height();
                    var hdiv = $("div.ui-jqgrid-hdiv:not(.frozen-div)",gv);
                    if(frozen.length>0){
                        frozen = frozen[0];
                        for(i=0;i<ts.rows.length;i++){
                            if($(ts.rows[i]).hasClass("jqgfirstrow")) continue;
                            if(one){
                                if(ts.rows[i].id===rowId){
                                    innerSetHeight($("td",ts.rows[i]),$("td",frozen.rows[i]),frozen,true);
                                    break;
                                }
                            }else{
                                innerSetHeight($("td",ts.rows[i]),$("td",frozen.rows[i]),frozen,true);
                            }
                        }
                    }

                    if(!one){
                        //
                        var frozenHeader = $("div.frozen-div>table",gv);
                        var tsHeader = $("table",hdiv);
                        if(frozenHeader.length>0 && tsHeader.length>0){
                            frozenHeader = frozenHeader[0];
                            tsHeader = tsHeader[0];
                            for(i=0;i<tsHeader.rows.length;i++){
                                innerSetHeight($("th",tsHeader.rows[i]),$("th",frozenHeader.rows[i]),frozen,false);
                            }
                        }
                    }
                }
            },
            adjustFrozenColumnWidth:function(ts,rowId){
                function innerSetWidth(oriRow,frozenRow,frozenTable,body){
                    var browser = $.boxLayoutUtil.userBrowser(),pos,outwidth;
                    frozenRow = body?$(frozenTable).find("tr.jqgfirstrow"):frozenRow;
                    for(var i=0;i<oriRow.cells.length;i++){
                        pos = $(oriRow.cells[i]).attr("oripos")||i;
                        if($.jgrid.isFrozenColumn(ts,parseInt(pos))){
                            td = $(oriRow).find((body?"td":"th")+":eq("+i+")");
                            if("firefox"===browser || "opera"===browser){
                                outwidth = td.outerWidth();
                            }else{
                                outwidth = td.width();
                            }
                            $(frozenRow).find((body?"td":"th")+":eq("+i+")").each(function(){
                                $(this).width(outwidth);
                            });
                        }
                    }
                }
                var gv = $(ts).closest("div.ui-jqgrid");
                if(ts.p.frozenColumns === true) {
                    var i,one=rowId!=undefined,td;
                    //
                    var frozen = $("#"+ts.p.id+"_frozen",gv);
                    //DIV
                    var frozenDiv = $(frozen).parent("div.frozen-bdiv");
                    //
                    var hth = $(".ui-jqgrid-htable","#gview_"+$.jgrid.jqID(ts.p.id)).height();
                    var hdiv = $("div.ui-jqgrid-hdiv:not(.frozen-div)",gv);
                    if(frozen.length>0){
                        frozen = frozen[0];
                        for(i=0;i<ts.rows.length;i++){
                            if($(ts.rows[i]).hasClass("jqgfirstrow")) continue;
                            if(one){
                                if(ts.rows[i].id===rowId){
                                    innerSetWidth(ts.rows[i],frozen.rows[i],frozen,true);
                                    break;
                                }
                            }else{
                                innerSetWidth(ts.rows[i],frozen.rows[i],frozen,true);
                            }
                        }
                    }

                    if(!one){
                        //
                        var frozenHeader = $("div.frozen-div>table",gv);
                        var tsHeader = $("table",hdiv);
                        if(frozenHeader.length>0 && tsHeader.length>0){
                            frozenHeader = frozenHeader[0];
                            tsHeader = tsHeader[0];
                            for(i=0;i<tsHeader.rows.length;i++){
                                innerSetWidth(tsHeader.rows[i],frozenHeader.rows[i],frozenHeader,false);
                            }
                        }
                    }
                }
            },
            emptyFrozenCell:function(ts,colModel,iRow,iCol){
                if(colModel.frozen){
                    var currentRow = $("#"+$.jgrid.jqID(ts.p.id)+"_frozen")[0].rows[iRow];
                    var frozenCell = $("td:eq(" + iCol + ")", currentRow);
                    frozenCell.empty();
                }
            },
            setFrozenCellValue:function(ts,colModel,iRow,iCol,v,title,cssp,attrp,dirtyCell){
                if(colModel.frozen){
                    var currentRow = $("#"+$.jgrid.jqID(ts.p.id)+"_frozen")[0].rows[iRow];
                    var frozenCell = $("td:eq(" + iCol + ")", currentRow);
                    if(ts.p.treeGrid && $(".tree-wrap",$(frozenCell)).length>0) {
                        $("span",$(frozenCell)).html(v).attr(title);
                    } else {
                        $(frozenCell).html(v).attr(title);
                    }
                    if(typeof cssp === 'string'){
                        $(frozenCell).addClass(cssp);
                    } else if(cssp) {
                        $(frozenCell).css(cssp);
                    }
                    if(typeof attrp === 'object') {$(frozenCell).attr(attrp);}
                    if(dirtyCell){
                        $(frozenCell).addClass("dirty-cell");
                    }
                }
            },
            addFrozenDirtyClass:function(ts,colModel,iRow,iCol){
                if(colModel.frozen){
                    var currentRow = $("#"+$.jgrid.jqID(ts.p.id)+"_frozen")[0].rows[iRow];
                    var frozenCell = $("td:eq(" + iCol + ")", currentRow);
                    $(frozenCell).addClass("dirty-cell");
                }
            },
            isFrozenColumn:function(ts,col){
                if(!ts.p.frozenColumns) return false;
                if(ts.p.subGrid === true || ts.p.treeGrid === true  || ts.p.sortable || ts.p.scroll || ts.p.grouping )
                {
                    return false;
                }
                //col
                if($.isNaN(col)){
                    col = $.jgrid.getIndex(col);
                }
                if(ts.p.colModel[col] && ts.p.colModel[col].frozen){
                    //
                    var i=0,cm=ts.p.colModel,len=cm.length,maxfrozen=-1;
                    if(ts.p.rownumbers) { i++; }
                    if(ts.p.multiselect) { i++; }
                    // get the max index of frozen col
                    while(i<len)
                    {
                        // from left, no breaking frozen
                        if(cm[i].frozen === true)
                        {
                            maxfrozen = i;
                        } else {
                            break;
                        }
                        i++;
                    }
                    if(col<=maxfrozen){
                        return true;
                    }else{
                        return false;
                    }
                }else{
                    return false;
                }
            },
            copyFrozenHeader:function(ts){
                //
                var i=0,cm=ts.p.colModel,len=cm.length,maxfrozen=-1;
                // get the max index of frozen col
                while(i<len)
                {
                    if(cm[i].name !="rn" && cm[i].name !="cb" && cm[i].name !="subgrid"){
                        // from left, no breaking frozen
                        if(cm[i].frozen === true)
                        {
                            maxfrozen = i;
                        } else {
                            break;
                        }
                    }
                    i++;
                }
                var htbl = $(".ui-jqgrid-htable","#gview_"+$.jgrid.jqID(ts.p.id)+" .ui-jqgrid-hbox").clone(true);
                if(ts.p.groupHeader) {
                    $("tr.jqg-first-row-header, tr.jqg-third-row-header", htbl).each(function(){
                        $("th:gt("+maxfrozen+")",this).remove();
                    });
                    var swapfroz = -1, fdel = -1;
                    $("tr.jqg-second-row-header th", htbl).each(function(){
                        var cs= parseInt($(this).attr("colspan"),10);
                        if(cs) {
                            swapfroz = swapfroz+cs;
                            fdel++;
                        }
                        if(swapfroz === maxfrozen) {
                            return false;
                        }
                    });
                    if(swapfroz !== maxfrozen) {
                        fdel = maxfrozen;
                    }
                    $("tr.jqg-second-row-header", htbl).each(function(){
                        $("th:gt("+fdel+")",this).remove();
                    });
                } else {
                    $("tr",htbl).each(function(){
                        $("th:gt("+maxfrozen+")",this).remove();
                        $("th:eq("+maxfrozen+")",this).addClass("frozelastcell");
                    });
                }
                $(htbl).width(1);
                // resizing stuff
                $(ts.grid.fhDiv).empty().append(htbl)
                    .mousemove(function (e) {
                        if(ts.grid.resizing){ ts.grid.dragMove(e);return false; }
                    });
            },
            setFrozenCellStyle:function(ts,rowid,col,style){
                var froz = ts.p.frozenColumns === true ? ts.p.id + "_frozen" : "";
                if(froz){
                    var ft = $("#"+froz);
                    var froind = ft[0].rows.namedItem(rowid);
                    var pos = $.jgrid.getIndex(col, ts);
                    if(pos>=0){
                        $(froind).find("td:eq("+pos+")").attr("style",style);
                    }
                }
            }
        });


        //
        $.extend($.jgrid, {
            //col
            hasRowSpanned:function (col, rnd) {
                return col && rnd && rnd._cellvalues && jlinq.from(rnd._cellvalues).equals("index", col).select().length > 0;
            },
            //index
            getRowSpanIndex:function(col, rnd){
                return rnd._rsc?rnd._rsc[col]:col;
            },
            //values
            getSpannedModel:function(pos, rnd){
                if(rnd && rnd._cellvalues && $.isArray(rnd._cellvalues)){
                    for (var sg, j = 0,clen = rnd._cellvalues.length; j < clen; j++) {
                        sg = rnd._cellvalues[j];
                        if(sg.index == pos){
                            return sg;
                        }
                    }
                }
                return {};
            },
            //
            getParentTd:function(pos,rnd){
                var parentRow = (rnd && rnd._parentSpanedRow && rnd._parentSpanedRow[pos]) || rnd;
                if(parentRow){
                    return parentRow.childNodes[$.jgrid.getRowSpanIndex(pos,parentRow)];
                }
            },
            //
            getParentRow:function(pos,rnd){
                return (rnd && rnd._parentSpanedRow && rnd._parentSpanedRow[pos]) || rnd;
            },
            //
            getChildRows:function(pos,rnd){
                var parentRow = this.getParentRow(pos,rnd);
                return parentRow&&parentRow._rowSpan&&parentRow._rowSpan[pos]?parentRow._rowSpan[pos]:[];
            },
            //
            inRowSpan:function(pos,ts){
                return ts.p && ts.p.colModel && !!ts.p.colModel[pos].rowspan;
            },
            //id
            getParentChildIds:function(pos,rnd){
                var parentRow = this.getParentRow(pos,rnd);
                var ret = [];
                ret.push(parentRow.id);
                ret = ret.concat(this.getChildIds(pos,parentRow));
                return ret;
            },
            //id
            getChildIds:function(pos,rnd){
                var ret = [];

                if(rnd&&rnd._rowSpan&&rnd._rowSpan[pos]){
                    var childRows = rnd._rowSpan[pos];
                    for(var i=0,len=childRows.length;i<len;i++){
                        ret.push(childRows[i].id);
                    }
                }

                return ret;
            },
            setSpannedCellState:function(ts,rnd){
                function handler(ids){
                    var trs = $(ts).wafGrid("getSelectedRows"),td;
                    var find = true;
                    for(var i=0,len1=ids.length;i<len1;i++){
                        if($.inArray(ids[i],trs)==-1){
                            find=false;
                            break;
                        }
                    }
                    td = $.jgrid.getParentTd(col,rnd);
                    if(find){
                        $(td).removeClass("cell-selected").removeClass("cell-spanned");
                    }else{
                        $(td).addClass("cell-selected");
                    }
                }
                //
                var parentRows = rnd&&rnd._parentSpanedRow,ids;
                for(var col in parentRows){
                    ids = $.jgrid.getParentChildIds(col,rnd);
                    if(ids && ids.length>0){
                        handler(ids);
                    }
                }
                //
                if(rnd&&rnd._rowSpan){
                    var ids = [];
                    for(var col in rnd._rowSpan){
                        ids = [rnd.id];
                        var childRows = rnd._rowSpan[col];
                        for(var i=0,len=childRows.length;i<len;i++){
                            ids.push(childRows[i].id);
                        }
                        handler(ids);
                    }
                }
            }
        });
        $.jgrid.extend({
            rowSpanSetup:function () {
                this.each(function () {
                    var ts = this;
                    if (ts.p.colModel && ts.p.colModel.length > 0) {
                        var cm = ts.p.colModel, len = cm.length , rowSpanCols = [], lastKey = null;
                        for (var i = 0; i < len; i++) {
                            if ("rn" == cm[i].name || "subgrid" == cm[i].name) continue;
                            if (!cm[i].editable && !!cm[i].rowspan) {
                                if (!!cm[i].rowSpanKey && (lastKey == null || lastKey != cm[i].name)) {
                                    lastKey = cm[i].name;
                                }
                                rowSpanCols.push({index:i, name:cm[i].name, key:lastKey});
                            }
                        }
                        if (rowSpanCols.length > 0) {
                            //
                            ts.p.rowSpanCols = rowSpanCols;
                        }
                    }
                    //mouseovermouseleaveclick
                    //mouseover
                    $(ts).bind('mouseover',
                        function (e) {
                            //row span
                            if($.jgrid.hasSpan(ts)){
                                var ptd = $(e.target),role;
                                if(ptd.is("input.cbox")){
                                    ptd = ptd.closest("td");
                                }
                                role = ptd.attr("role");
                                if(role&&role=="gridcell"){
                                    var ptr = $(ptd).closest("tr.jqgrow"), rowspan = ptd.attr("rowspan") || 1,i,len;
                                    if (ptd && ptd.length > 0 && ptd[0].tagName == "TD" && ptr.length > 0) {
                                        ptr = ptr[0];
                                        //pos
                                        var currentCellIndex = parseInt($(ptd).attr("oripos")),trs = [ptr.id];
                                        //,childRows.
                                        var childRows = $.jgrid.getChildRows(currentCellIndex,ptr);
                                        for(i=0,len=childRows.length;i<len;i++){
                                            trs.push(childRows[i].id);
                                        }

                                        var ind,td;
                                        for(i=0,len=trs.length;i<len;i++){
                                            ind = ts.rows.namedItem(trs[i]);
                                            if(!$(ind).hasClass("ui-state-hover")){
                                                $(ind).addClass("ui-state-hover");
                                            }
                                            //currentIndexcell-spanned
                                            if(ind&&ind._rowSpan){
                                                for(var id in ind._rowSpan){
                                                    if(parseInt(id)<parseInt(currentCellIndex)){
                                                        td = $.jgrid.getParentTd(id,ind);
                                                        if(td) $(td).addClass("cell-spanned");
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }).bind('mouseout',
                        function (e) {
                            //row span
                            if($.jgrid.hasSpan(ts)){
                                //hovercellSpaned
                                $("tr.jqgrow",ts).removeClass("ui-state-hover");
                                $("td.cell-spanned",ts).removeClass("cell-spanned");
                            }
                        }).bind("click", function (e) {
                            //row span
                            if($.jgrid.hasSpan(ts) && !ts.p.cellEdit){
                                var ptd = $(e.target),role;
                                if(ptd.is("input.cbox")){
                                    ptd = ptd.closest("td");
                                }
                                role = ptd.attr("role");
                                if(role&&role=="gridcell"){
                                    var ptr = $(ptd).closest("tr.jqgrow"),i,len,ind,td;
                                    if (ptd && ptd.length > 0 && ptd[0].tagName == "TD" && ptr.length > 0) {
                                        var cSel = ptr.hasClass("ui-state-highlight");
                                        ptr = ptr[0];
                                        //pos
                                        var currentCellIndex = parseInt($(ptd).attr("oripos")),trs = [ptr.id];
                                        //,childRows.
                                        var childRows = $.jgrid.getChildRows(currentCellIndex,ptr);
                                        for(i=0,len=childRows.length;i<len;i++){
                                            trs.push(childRows[i].id);
                                        }
                                        //
                                        if (cSel === true) {
                                            if(!ts.p.multiselect){
                                                ind= ts.rows.namedItem(ptr[0].id);
                                                $("td[rowspan]:visible",ind).each(function(){
                                                    $(this).addClass("cell-selected");
                                                })
                                            }else{
                                                //
                                                for(i=0;i<trs.length;i++){
                                                    ind = ts.rows.namedItem(trs[i]);
                                                    //setSection
                                                    if (!$(ind).hasClass("ui-state-highlight")) {
                                                        $(ts).jqGrid("setSelection", trs[i], true, e);
                                                    }
                                                    //currentIndexcell-spanned
                                                    if(ind&&ind._rowSpan){
                                                        for(var id in ind._rowSpan){
                                                            if(parseInt(id)<parseInt(currentCellIndex)){
                                                                td = $.jgrid.getParentTd(id,ind);
                                                                if(td) $(td).addClass("cell-selected");
                                                            }
                                                        }
                                                    }
                                                    if(ind!=undefined)$.jgrid.setSpannedCellState(ts,ind);
                                                }
                                            }
                                        }else{
                                            //
                                            if (ts.p.multiselect) {
                                                len = ts.p.colModel.length;
                                                for(i=0;i<trs.length;i++){
                                                    $(ts).jqGrid("removeSelect", trs[i]);
                                                    ind = ts.rows.namedItem(trs[i]);
                                                    $("td.cell-selected",ind).removeClass("cell-selected");
                                                    //currentIndexcell-spanned
                                                    if(ind&&ind._rowSpan){
                                                        for(var id in ind._rowSpan){
                                                            if(parseInt(id)<parseInt(currentCellIndex)){
                                                                td = $.jgrid.getParentTd(id,ind);
                                                                if(td) $(td).removeClass("cell-selected");
                                                            }
                                                        }
                                                    }
                                                    if(ind!=undefined)$.jgrid.setSpannedCellState(ts,ind);
                                                }
                                            }
                                        }

                                    }
                                }
                            }
                        });
                    //end mouseover
                })
            },
            rowSpanPrepare:function (curRow, drows, index, id) {
                this.each(function () {
                    var ts = this;
                    if (ts.p.rowSpanCols && ts.p.rowSpanCols.length > 0) {
                        if (index == 0) return;
                        ts.p.rsCalc = ts.p.rsCalc || new Map();
                        ts.p.rowSpanModel = ts.p.rowSpanModel || [];
                        //
                        var preRow = drows[index - 1],
                            col, curCol, curKey, preCol, preKey, sg, i, len;
                        for (i = 0, len = ts.p.rowSpanCols.length; i < len; i++) {
                            col = ts.p.rowSpanCols[i];
                            curCol = $.wafutil.getAccessor(curRow, col.name);
                            curKey = $.wafutil.getAccessor(curRow, col.key);
                            preCol = $.wafutil.getAccessor(preRow, col.name);
                            preKey = $.wafutil.getAccessor(preRow, col.key);
                            if (curCol == preCol && curKey == preKey) {
                                //ts.p.rsCalc
                                sg = ts.p.rsCalc.get(col.index) || {rowId:"" + $.wafutil.getAccessor(preRow, $.jgrid.getKeyName(ts)), colIndex:col.index, spans:1};
                                sg.spans++;
                                ts.p.rsCalc.put(col.index, sg);
                            } else {
                                //
                                sg = ts.p.rsCalc.get(col.index);
                                if (sg) {
                                    ts.p.rowSpanModel.push(sg);
                                    ts.p.rsCalc.remove(col.index);
                                }
                            }
                        }
                        //rsCalc
                        if (index == (drows.length - 1)) {
                            var tmp;
                            len = ts.p.rsCalc ? ts.p.rsCalc.size() : 0;
                            for (i = 0; i < len; i++) {
                                sg = ts.p.rsCalc.element(i);
                                tmp = sg.value;
                                if (tmp && tmp.spans > 1) {
                                    ts.p.rowSpanModel.push(tmp);
                                }
                            }
                            delete ts.p.rsCalc;
                        }
                    }
                })

            },
            gridRowSpan:function () {
                this.each(function () {
                    var ts = this;
                    if (!!ts.p.autoRowSpan && ts.p.rowSpanModel && ts.p.rowSpanModel.length > 0) {
                        ts.p.rowSpanModel = jlinq.from(ts.p.rowSpanModel).sort("-colIndex").select();
                        //
                        for (var i = 0, len = ts.p.rowSpanModel.length, tmp; i < len; i++) {
                            tmp = ts.p.rowSpanModel[i];
                            if (tmp.spans > 1) {
                                $(ts).wafGrid("setRowSpan", tmp.rowId, tmp.colIndex, tmp.spans);
                            }
                        }
                    }
                    delete ts.p.rowSpanModel;
                })
            },
            restoreRowSpan:function (rowId, col) {
                this.each(function () {
                    var ts = this, rnd = ts.rows.namedItem(rowId), spannedRows, i;
                    //col
                    col = $.jgrid.getIndex(col, ts);
                    if (col == -1) return;
                    var cTd = rnd.childNodes[$.jgrid.getRowSpanIndex(col,rnd)];
                    if ((cTd.rowSpan && cTd.rowSpan != 1) || $.jgrid.hasRowSpanned(col, rnd)) {
                        //parentRow
                        var parentRow = (rnd._parentSpanedRow && rnd._parentSpanedRow[col]) || rnd;
                        if (parentRow && parentRow._rowSpan && parentRow._rowSpan[col]) {
                            spannedRows = parentRow._rowSpan[col];
                            var rlen = spannedRows.length, clen, sg;
                            if (rlen > 0) {
                                parentRow.childNodes[$.jgrid.getRowSpanIndex(col,parentRow)].rowSpan = 1;
                                for (i = 0; i < rlen; i++) {
                                    clen = spannedRows[i]._cellvalues ? spannedRows[i]._cellvalues.length : 0;
                                    for (var j = 0; j < clen; j++) {
                                        sg = spannedRows[i]._cellvalues[j];
                                        if(sg.index == col){
                                            spannedRows[i].insertBefore(sg.td, spannedRows[i]._rsc[sg.index]);
                                            $(ts).wafGrid("refreshRsIndex", spannedRows[i], col, -1);
                                        }
                                    }
                                }
                            }
                        }
                    }
                })
            },
            setRowSpan:function (rowId, col, spanNum) {
                this.each(function () {
                    var ts = this, rnd = ts.rows.namedItem(rowId), spannedRows, i;
                    col = $.jgrid.getIndex(col, ts);
                    if (col == -1) return;
                    //,Excel
                    var cTd = rnd.childNodes[$.jgrid.getRowSpanIndex(col,rnd)];
                    if ((cTd.rowSpan && cTd.rowSpan != 1) || $.jgrid.hasRowSpanned(col, rnd)) {
                        //
                        $(ts).wafGrid("restoreRowSpan",rowId,col);
                    }
                    cTd.rowSpan = spanNum;
                    spannedRows = [];
                    i = 0;
                    for (var tmp = rnd.nextSibling, cellvalues; i < (spanNum - 1); i++) {
                        var cell = tmp.childNodes[$.jgrid.getRowSpanIndex(col,tmp)];
                        //cell,
                        var val = $.unformat.call(ts, cell, {rowId:rowId, colModel:ts.p.colModel[col], gid:ts.p.id}, col);
                        cellvalues = tmp._cellvalues || [];
                        cellvalues.push({val:val, index:col, td:cell});
                        tmp._cellvalues = cellvalues;
                        //index
                        $(ts).wafGrid("refreshRsIndex", tmp, col, 1);
                        cell && cell.parentNode.removeChild(cell);
                        if(tmp!=undefined)spannedRows.push(tmp);
                        tmp._parentSpanedRow = tmp._parentSpanedRow || {};
                        tmp._parentSpanedRow[col] = rnd;
                        tmp = tmp.nextSibling;
                    }
                    rnd._rowSpan = rnd._rowSpan || {};
                    rnd._rowSpan[col] = spannedRows;
                })
            },
            refreshRsIndex:function (row, curIndex, num) {
                if (!row._rsc) {
                    row._rsc = [];
                    for (var a = 0; a < row.childNodes.length; a++)
                        row._rsc[a] = a
                }
                for (a = 0; a < row._rsc.length; a++)
                    a > curIndex && (row._rsc[a] -= num)
            }
        });

        //
        $.jgrid.extend({
            colSpanSetup:function(){},
            //id
            //
            setColSpan:function(rowId,colIndex,numberOfColumns){
                if(numberOfColumns<=1) return;
                this.each(function(){
                    var ts = this;
                    //spannedCellModel
                    if(ts.p.spannedCellModel==undefined){
//                    $.jgrid.initSpannedCellModel(ts);
                    }
                    //
                    var realRowId,realColIndex,colSpanFormatter=ts.p.colModel[colIndex].colSpanFormatter,title,
                        colSpanTemplate=ts.p.colModel[colIndex].colSpanTemplate,spanValue=[],colSpansInfo=[],nm=ts.p.colModel[colIndex].name;
                    //
                    //rowId,colIndexnewRowIdnewCellIndex
                    var target = $.jgrid.getCellModel(rowId,colIndex,ts);
                    if(!target) return;
                    //rowidcellindexrowIdnewRowid
                    realRowId = target.newRowId;
                    realColIndex = target.newCellIndex;
                    //
                    spanValue.push({value:$(ts).wafGrid("getCell",realRowId,realColIndex),rowId:realRowId,colIndex:realColIndex});
                    var i=1,tmp,row = ts.rows.namedItem(realRowId),currentTd=$("td:eq("+realColIndex+")",row);
                    //,
                    while(i<numberOfColumns) {
                        //editabletrue
                        if(ts.p.colModel[realColIndex+i] && ts.p.colModel[realColIndex+i].editable==true){
                            colSpansInfo = [];
                            break;
                        }
                        var td = $("td:eq("+(realColIndex+i)+")",row);
                        if(td.length==0) break; //
                        //tdtdcell
                        tmp = $.jgrid.getCellModel(rowId,(realColIndex+i),ts);
                        if(!tmp) return;
                        //
                        spanValue.push({value:$(ts).wafGrid("getCell",realRowId,(realColIndex+i)),rowId:realRowId,colIndex:(realColIndex+i)});
                        //,targettmptmpnewRowidnewCellIndextarget
                        if(!(tmp.newRowId==target.rowId && tmp.newCellIndex==target.cellIndex)) {
                            //rowSize
                            if(tmp.rowSize==target.rowSize && tmp.rowId == target.rowId){
                                //target,tmp
                                target.colSize = target.colSize + tmp.colSize;
                                //tdcelltmp
                                if(tmp.colSize>1 || tmp.rowSize>1){
                                    //
                                    var children = jlinq.from(ts.p.spannedCellModel)
                                        .equals("newRowId",rowId)
                                        .equals("newCellIndex",(realColIndex+i))
                                        .select();
                                    if(children.length>0){
                                        for(var j=0;j<children.length;j++){
                                            children[j].newRowId=rowId;
                                            children[j].newCellIndex=colIndex;
                                            children[j].isReal=false;
                                            children[j].colSize=1;
                                            children[j].rowSize=1;
                                        }
                                    }
                                }else{
                                    //tmp
                                    tmp.newRowId=rowId;
                                    tmp.newCellIndex=colIndex;
                                    tmp.isReal=false;
                                    tmp.colSize=1;
                                    tmp.rowSize=1;
                                }
                                //td
                                colSpansInfo.push(td);
                            }else{
                                break;
                            }
                            //tmptdtdcellindex
                            var list = jlinq.from(ts.p.spannedCellModel)
                                .equals("rowId",realRowId)
                                .greaterEquals("cellIndex",(realColIndex+numberOfColumns))
                                .select();
                            if(list&&list.length>0){
                                for(var k=0;k<list.length;k++){
                                    //
                                    if(list[k].isReal){
                                        list[k].newCellIndex = list[k].newCellIndex -1;
                                    }
                                }
                            }
                        }
                        i++;
                    }
                    if(colSpansInfo.length>0){
                        //td
                        for(i=0;i<colSpansInfo.length;i++){
                            $(colSpansInfo[i]).remove();
                        }
                        //tdcolspan
                        var spanNum = currentTd.attr("colspan");
                        if($.isNaN(spanNum)) spanNum=1;
                        spanNum=spanNum+colSpansInfo.length;
                        currentTd.attr("colspan",spanNum);
                        //
                        if(colSpanTemplate && !colSpanFormatter){
                            var values = colSpanTemplate;
                            for(var r=0;r<spanValue.length;r++){
                                values = $.wafutil.replaceAll(values,"{"+r+"}",spanValue[r].value);
                            }
                            title = $.jgrid.stripHtml(values);
                            if(ts.p.treeGrid===true && nm == ts.p.ExpandColumn) {
                                $(currentTd).children("span:first").html(values).attr(title);
                            } else {
                                $(currentTd).html(values).attr(title);
                            }
                        }else if(colSpanFormatter && $.isFunction(colSpanFormatter)){
                            var values = colSpanFormatter.call(this,realRowId,realColIndex,spanValue);
                            title = $.jgrid.stripHtml(values);
                            if(ts.p.treeGrid===true && nm == ts.p.ExpandColumn) {
                                $(currentTd).children("span:first").html(values).attr(title);
                            } else {
                                $(currentTd).html(values).attr(title);
                            }
                        }
                        ts.p.colSpanned=true;
                    }
                });
            },
            //.
            gridColSpan:function(){
                this.each(function(){
                    var ts = this,colspans=[],cm=ts.p.colModel,len=cm.length,tmp;
                    for(var i=0;i<len;i++){
                        if(cm[i].colSpan && !$.isNaN(cm[i].colSpan) && (cm[i].editable==undefined || cm[i].editable==false)){
                            colspans.push({cellIndex:i,numberOfColumns:cm[i].colSpan});
                        }
                    }
                    if(colspans.length>0){
                        for(var i=0;i<ts.rows.length;i++){
                            if($(ts.rows[i]).hasClass("jqgfirstrow")) continue;
                            for(var j=0;j<colspans.length;j++){
                                tmp = colspans[j];
                                $(this).wafGrid("setColSpan",ts.rows[i].id,tmp.cellIndex,tmp.numberOfColumns);
                            }
                        }
                    }
                });
            }
        });

        //
        $.extend($.jgrid,{
            template : function(format){ //jqgformat
                var args = $.makeArray(arguments).slice(1), j = 0;
                if(format===undefined) { format = ""; }
                return format.replace(/\{([\w\-]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?\}/g, function(m,i){
                    if(!isNaN(parseInt(i,10))) {
                        j++;
                        return args[parseInt(i,10)];
                    } else {
                        var nmarr = args[ j ],
                            k = nmarr.length;
                        while(k--) {
                            if(i===nmarr[k].nm) {
                                return nmarr[k].v;
                                break;
                            }
                        }
                        j++;
                    }
                });
            }
        });
        $.jgrid.extend({
            groupingSetup : function () {
                return this.each(function (){
                    var $t = this,
                        grp = $t.p.groupingView;
                    if(grp !== null && ( (typeof grp === 'object') || $.isFunction(grp) ) ) {
                        if(!grp.groupField.length) {
                            $t.p.grouping = false;
                        } else {
                            if ( typeof(grp.visibiltyOnNextGrouping) === 'undefined') {
                                grp.visibiltyOnNextGrouping = [];
                            }

                            grp.lastvalues=[];
                            grp.groups =[];
                            grp.counters =[];
                            for(var i=0;i<grp.groupField.length;i++) {
                                if(!grp.groupOrder[i]) {
                                    grp.groupOrder[i] = 'asc';
                                }
                                if(!grp.groupText[i]) {
                                    grp.groupText[i] = '{0} and {test}';
                                }
                                if( typeof(grp.groupColumnShow[i]) !== 'boolean') {
                                    grp.groupColumnShow[i] = true;
                                }
                                if( typeof(grp.groupSummary[i]) !== 'boolean') {
                                    grp.groupSummary[i] = false;
                                }
                                if(grp.groupColumnShow[i] === true) {
                                    grp.visibiltyOnNextGrouping[i] = true;
                                    $($t).jqGrid('showCol',grp.groupField[i]);
                                } else {
                                    grp.visibiltyOnNextGrouping[i] = $("#"+$.jgrid.jqID($t.p.id+"_"+grp.groupField[i])).is(":visible");
                                    $($t).jqGrid('hideCol',grp.groupField[i]);
                                }
                                grp.summary =[];
                                if(grp.groupSummary[i]) {
                                    var cm = $t.p.colModel;
                                    for(var j=0, cml = cm.length; j < cml; j++) {
                                        if(cm[j].summaryType) {
                                            grp.summary.push({nm:cm[j].name,st:cm[j].summaryType, v: '', sr: cm[j].summaryRound, srt: cm[j].summaryRoundType || 'round'});
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        $t.p.grouping = false;
                    }
                });
            },
            groupingPrepare : function (rData, gdata, record, irow) {
                this.each(function(){
                    var grp = this.p.groupingView, $t= this;
                    var grlen = grp.groupField.length,
                        fieldName,
                        v,
                        changed = 0;
                    for(var i=0;i<grlen;i++) {
                        fieldName = grp.groupField[i];
                        v = record[fieldName];
                        if( v ) {
                            if(irow === 0 ) {
                                // First record always starts a new group
                                grp.groups.push({idx:i,dataIndex:fieldName,value:v, startRow: irow, cnt:1, summary : [] } );
                                grp.lastvalues[i] = v;
                                grp.counters[i] = {cnt:1, pos:grp.groups.length-1, summary: $.extend(true,[],grp.summary)};
                                $.each(grp.counters[i].summary,function() {
                                    if ($.isFunction(this.st)) {
                                        this.v = this.st.call($t, this.v, this.nm, record);
                                    } else {
                                        this.v = $($t).jqGrid('groupingCalculations.handler',this.st, this.v, this.nm, this.sr, this.srt, record);
                                    }
                                });
                                grp.groups[grp.counters[i].pos].summary = grp.counters[i].summary;
                            } else {
                                if( (typeof(v) !== "object" && (grp.lastvalues[i] !== v) ) ) {
                                    // This record is not in same group as previous one
                                    grp.groups.push({idx:i,dataIndex:fieldName,value:v, startRow: irow, cnt:1, summary : [] } );
                                    grp.lastvalues[i] = v;
                                    changed = 1;
                                    grp.counters[i] = {cnt:1, pos:grp.groups.length-1, summary: $.extend(true,[],grp.summary)};
                                    $.each(grp.counters[i].summary,function() {
                                        if ($.isFunction(this.st)) {
                                            this.v = this.st.call($t, this.v, this.nm, record);
                                        } else {
                                            this.v = $($t).jqGrid('groupingCalculations.handler',this.st, this.v, this.nm, this.sr, this.srt, record);
                                        }
                                    });
                                    grp.groups[grp.counters[i].pos].summary = grp.counters[i].summary;
                                } else {
                                    if (changed === 1) {
                                        // This group has changed because an earlier group changed.
                                        grp.groups.push({idx:i,dataIndex:fieldName,value:v, startRow: irow, cnt:1, summary : [] } );
                                        grp.lastvalues[i] = v;
                                        grp.counters[i] = {cnt:1, pos:grp.groups.length-1, summary: $.extend(true,[],grp.summary)};
                                        $.each(grp.counters[i].summary,function() {
                                            if ($.isFunction(this.st)) {
                                                this.v = this.st.call($t, this.v, this.nm, record);
                                            } else {
                                                this.v = $($t).jqGrid('groupingCalculations.handler',this.st, this.v, this.nm, this.sr, this.srt, record);
                                            }
                                        });
                                        grp.groups[grp.counters[i].pos].summary = grp.counters[i].summary;
                                    } else {
                                        grp.counters[i].cnt += 1;
                                        grp.groups[grp.counters[i].pos].cnt = grp.counters[i].cnt;
                                        if(grp.groupSummary[i]) {
                                            $.each(grp.counters[i].summary,function() {
                                                if ($.isFunction(this.st)) {
                                                    this.v = this.st.call($t, this.v, this.nm, record);
                                                } else {
                                                    this.v = $($t).jqGrid('groupingCalculations.handler',this.st, this.v, this.nm, this.sr, this.srt, record);
                                                }
                                            });
                                            grp.groups[grp.counters[i].pos].summary = grp.counters[i].summary;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    gdata.push( rData );
                });
                return gdata;
            },
            groupingToggle : function(hid){
                this.each(function(){
                    var $t = this,
                        grp = $t.p.groupingView,
                        strpos = hid.split('_'),
                        //uid = hid.substring(0,strpos+1),
                        num = parseInt(strpos[strpos.length-2], 10);
                    strpos.splice(strpos.length-2,2);
                    var uid = strpos.join("_"),
                        minus = grp.minusicon,
                        plus = grp.plusicon,
                        tar = $("#"+$.jgrid.jqID(hid)),
                        r = tar.length ? tar[0].nextSibling : null,
                        tarspan = $("#"+$.jgrid.jqID(hid)+" span."+"tree-wrap-"+$t.p.direction),
                        collapsed = false;
                    if( tarspan.hasClass(minus) ) {
                        if(grp.showSummaryOnHide && grp.groupSummary[0]) {
                            if(r){
                                while(r) {
                                    if($(r).hasClass('jqfoot') ) { break; }
                                    $(r).hide();
                                    r = r.nextSibling;
                                }
                            }
                        } else  {
                            if(r){
                                while(r) {
                                    if( $(r).hasClass(uid+"_"+String(num) ) || $(r).hasClass(uid+"_"+String(num-1))) { break; }
                                    $(r).hide();
                                    r = r.nextSibling;
                                }
                            }
                        }
                        tarspan.removeClass(minus).addClass(plus);
                        collapsed = true;
                    } else {
                        if(r){
                            while(r) {
                                if($(r).hasClass(uid+"_"+String(num)) || $(r).hasClass(uid+"_"+String(num-1)) ) { break; }
                                $(r).show();
                                r = r.nextSibling;
                            }
                        }
                        tarspan.removeClass(plus).addClass(minus);
                    }
                    $($t).triggerHandler("jqGridGroupingClickGroup", [hid , collapsed]);
                    if( $.isFunction($t.p.onClickGroup)) { $t.p.onClickGroup.call($t, hid , collapsed); }

                });
                return false;
            },
            groupingRender : function (grdata, colspans ) {
                return this.each(function(){
                    var $t = this,
                        grp = $t.p.groupingView,
                        str = "", icon = "", hid, clid, pmrtl = grp.groupCollapse ? grp.plusicon : grp.minusicon, gv, cp=[], ii, len =grp.groupField.length;
                    pmrtl += " tree-wrap-"+$t.p.direction;
                    ii = 0;
                    $.each($t.p.colModel, function (i,n){
                        for(var ii=0;ii<len;ii++) {
                            if(grp.groupField[ii] === n.name ) {
                                cp[ii] = i;
                                break;
                            }
                        }
                    });
                    var toEnd = 0;
                    function findGroupIdx( ind , offset, grp) {
                        if(offset===0) {
                            return grp[ind];
                        } else {
                            var id = grp[ind].idx;
                            if(id===0) { return grp[ind]; }
                            for(var i=ind;i >= 0; i--) {
                                if(grp[i].idx === id-offset) {
                                    return grp[i];
                                }
                            }
                        }
                    }
                    $.each(grp.groups,function(i,n){
                        toEnd++;
                        clid = $t.p.id+"ghead_"+n.idx;
                        hid = clid+"_"+i;
                        icon = "<span style='cursor:pointer;' class='ui-icon "+pmrtl+"' onclick=\"jQuery('#"+$.jgrid.jqID($t.p.id)+"').jqGrid('groupingToggle','"+hid+"');return false;\"></span>";
                        try {
                            gv = $t.formatter(hid, n.value, cp[n.idx], n.value );
                        } catch (egv) {
                            gv = n.value;
                        }
                        str += "<tr id=\""+hid+"\" role=\"row\" class= \"ui-widget-content jqgroup ui-row-"+$t.p.direction+" "+clid+"\"><td style=\"padding-left:"+(n.idx * 12) + "px;"+"\" colspan=\""+colspans+"\">"+icon+$.jgrid.template(grp.groupText[n.idx], gv, n.cnt, n.summary)+"</td></tr>";
                        var leaf = len-1 === n.idx;
                        if( leaf ) {
                            var gg = grp.groups[i+1];
                            var end = gg !== undefined ?  grp.groups[i+1].startRow : grdata.length;
                            for(var kk=n.startRow;kk<end;kk++) {
                                str += grdata[kk].join('');
                            }
                            var jj;
                            if (gg !== undefined) {
                                for (jj = 0; jj < grp.groupField.length; jj++) {
                                    if (gg.dataIndex === grp.groupField[jj]) {
                                        break;
                                    }
                                }
                                toEnd = grp.groupField.length - jj;
                            }
                            for (var ik = 0; ik < toEnd; ik++) {
                                var hhdr = "";
                                if(grp.groupCollapse && !grp.showSummaryOnHide) {
                                    hhdr = " style=\"display:none;\"";
                                }
                                str += "<tr"+hhdr+" role=\"row\" class=\"ui-widget-content jqfoot ui-row-"+$t.p.direction+"\">";
                                var fdata = findGroupIdx(i, ik, grp.groups),
                                    cm = $t.p.colModel,
                                    vv, grlen = fdata.cnt;
                                for(var k=0; k<colspans;k++) {
                                    var tmpdata = "<td "+$t.formatCol(k,1,'')+">&#160;</td>",
                                        tplfld = "{0}";
                                    $.each(fdata.summary,function(){
                                        if(this.nm === cm[k].name) {
                                            if(cm[k].summaryTpl)  {
                                                tplfld = cm[k].summaryTpl;
                                            }
                                            if(this.st.toLowerCase() === 'avg') {
                                                if(this.v && grlen > 0) {
                                                    this.v = (this.v/grlen);
                                                }
                                            }
                                            try {
                                                vv = $t.formatter('', this.v, k, this);
                                            } catch (ef) {
                                                vv = this.v;
                                            }
                                            tmpdata= "<td "+$t.formatCol(k,1,'')+">"+$.jgrid.format(tplfld,vv)+ "</td>";
                                            return false;
                                        }
                                    });
                                    str += tmpdata;
                                }
                                str += "</tr>";
                            }
                            toEnd = jj;
                        }
                    });
                    $("#"+$.jgrid.jqID($t.p.id)+" tbody:first").append(str);
                    // free up memory
                    str = null;
                });
            },
            groupingGroupBy : function (name, options ) {
                return this.each(function(){
                    var $t = this;
                    if(typeof(name) === "string") {
                        name = [name];
                    }
                    var grp = $t.p.groupingView;
                    $t.p.grouping = true;

                    //Set default, in case visibilityOnNextGrouping is undefined
                    if (typeof grp.visibiltyOnNextGrouping === "undefined") {
                        grp.visibiltyOnNextGrouping = [];
                    }
                    var i;
                    // show previous hidden groups if they are hidden and weren't removed yet
                    for(i=0;i<grp.groupField.length;i++) {
                        if(!grp.groupColumnShow[i] && grp.visibiltyOnNextGrouping[i]) {
                            $($t).jqGrid('showCol',grp.groupField[i]);
                        }
                    }
                    // set visibility status of current group columns on next grouping
                    for(i=0;i<name.length;i++) {
                        grp.visibiltyOnNextGrouping[i] = $("#"+$.jgrid.jqID($t.p.id)+"_"+$.jgrid.jqID(name[i])).is(":visible");
                    }
                    $t.p.groupingView = $.extend($t.p.groupingView, options || {});
                    grp.groupField = name;
                    $($t).trigger("reloadGrid");
                });
            },
            groupingRemove : function (current) {
                return this.each(function(){
                    var $t = this;
                    if(typeof(current) === 'undefined') {
                        current = true;
                    }
                    $t.p.grouping = false;
                    if(current===true) {
                        var grp = $t.p.groupingView;
                        // show previous hidden groups if they are hidden and weren't removed yet
                        for(var i=0;i<grp.groupField.length;i++) {
                            if (!grp.groupColumnShow[i] && grp.visibiltyOnNextGrouping[i]) {
                                $($t).jqGrid('showCol', grp.groupField);
                            }
                        }
                        $("tr.jqgroup, tr.jqfoot","#"+$.jgrid.jqID($t.p.id)+" tbody:first").remove();
                        $("tr.jqgrow:hidden","#"+$.jgrid.jqID($t.p.id)+" tbody:first").show();
                    } else {
                        $($t).trigger("reloadGrid");
                    }
                });
            },
            groupingCalculations : {
                handler: function(fn, v, field, round, roundType, rc) {
                    var funcs = {
                        sum: function() {
                            return parseFloat(v||0) + parseFloat((rc[field]||0));
                        },

                        min: function() {
                            if(v==="") {
                                return parseFloat(rc[field]||0);
                            }
                            return Math.min(parseFloat(v),parseFloat(rc[field]||0));
                        },

                        max: function() {
                            if(v==="") {
                                return parseFloat(rc[field]||0);
                            }
                            return Math.max(parseFloat(v),parseFloat(rc[field]||0));
                        },

                        count: function() {
                            if(v==="") {v=0;}
                            if(rc.hasOwnProperty(field)) {
                                return v+1;
                            } else {
                                return 0;
                            }
                        },

                        avg: function() {
                            // the same as sum, but at end we divide it
                            // so use sum instead of duplicating the code (?)
                            return funcs.sum();
                        }
                    }

                    var res = funcs[fn]();
                    if(!res) {
                        //throw ("jqGrid Grouping No such method: " + fn); //comment by jlg.
                    }

                    if (round != null) {
                        if (roundType == 'fixed')
                            res = res.toFixed(round);
                        else {
                            var mul = Math.pow(10, round);

                            res = Math.round(res * mul) / mul;
                        }
                    }

                    return res;
                }
            }
        });

        //
        $.jgrid.extend({
            setTreeNode : function(i, len){
                return this.each(function(){
                    var $t = this;
                    if( !$t.grid || !$t.p.treeGrid ) {return;}
                    var expCol = $t.p.expColInd,
                        expanded = $t.p.treeReader.expanded_field,
                        isLeaf = $t.p.treeReader.leaf_field,
                        level = $t.p.treeReader.level_field,
                        icon = $t.p.treeReader.icon_field,
                        loaded = $t.p.treeReader.loaded,  lft, rgt, curLevel, ident,lftpos, twrap,
                        ldat, lf;
                    while(i<len) {
                        var ind = $t.rows[i].id, dind = $t.p._index[ind], expan;
                        ldat = $t.p.data[dind];
                        //$t.rows[i].level = ldat[level];
                        if($t.p.treeGridModel == 'nested') {
                            if(!ldat[isLeaf]) {
                                lft = parseInt(ldat[$t.p.treeReader.left_field],10);
                                rgt = parseInt(ldat[$t.p.treeReader.right_field],10);
                                // NS Model
                                ldat[isLeaf] = (rgt === lft+1) ? 'true' : 'false';
                                $t.rows[i].cells[$t.p._treeleafpos].innerHTML = ldat[isLeaf];
                            }
                        }
                        //else {
                        //row.parent_id = rd[$t.p.treeReader.parent_id_field];
                        //}
                        curLevel = parseInt(ldat[level],10);
                        if($t.p.tree_root_level === 0) {
                            ident = curLevel+1;
                            lftpos = curLevel;
                        } else {
                            ident = curLevel;
                            lftpos = curLevel -1;
                        }
                        twrap = "<div class='tree-wrap tree-wrap-"+$t.p.direction+"' style='width:"+(ident*18)+"px;'>";
                        twrap += "<div style='"+($t.p.direction=="rtl" ? "right:" : "left:")+(lftpos*18)+"px;' class='ui-icon ";


                        if(ldat[loaded] !== undefined) {
                            if(ldat[loaded]=="true" || ldat[loaded]===true) {
                                ldat[loaded] = true;
                            } else {
                                ldat[loaded] = false;
                            }
                        }
                        if(ldat[isLeaf] == "true" || ldat[isLeaf] === true) {
                            twrap += ((ldat[icon] !== undefined && ldat[icon] !== "") ? ldat[icon] : $t.p.treeIcons.leaf)+" tree-leaf treeclick";
                            ldat[isLeaf] = true;
                            lf="leaf";
                        } else {
                            ldat[isLeaf] = false;
                            lf="";
                        }
                        ldat[expanded] = ((ldat[expanded] == "true" || ldat[expanded] === true) ? true : false) && ldat[loaded];
                        if(ldat[expanded] === false) {
                            twrap += ((ldat[isLeaf] === true) ? "'" : $t.p.treeIcons.plus+" tree-plus treeclick'");
                        } else {
                            twrap += ((ldat[isLeaf] === true) ? "'" : $t.p.treeIcons.minus+" tree-minus treeclick'");
                        }

                        twrap += "></div></div>";
                        $($t.rows[i].cells[expCol]).wrapInner("<span class='cell-wrapper"+lf+"'></span>").prepend(twrap);

                        //
                        if($t.p.rowNum && $t.p.rowNum > -1  && i>1){ //TODO i>1
                            var pnn = $($t).jqGrid('getNodeParent',ldat);
                            var cnn = $($t).jqGrid('getNodeChildren',pnn);

                            //
                            waf.each(cnn, function(idx,item){
                                var itemIndex = $($t).jqGrid("getRowIndex",item.id);
                                $('.expan-more',$t.rows[itemIndex].cells[expCol]).remove();
                            });

                            //
                            $($t.rows[i].cells[expCol]).append($("<span class='expan-more'>[...]</span>"));

                            var nextPage = 2;

                            if(cnn && cnn.length){
                                nextPage = parseInt(cnn.length / $t.p.rowNum) + 1;
                            }


                            var rc = {
                                level:curLevel-1,
                                expandPage:nextPage,
                                rowId: pnn["id"]

                            };

                            $("span.expan-more",$t.rows[i].cells[expCol]).bind('click',function(e){
                                var target = e.target || e.srcElement;
                                var rid = $(target,$t.rows).closest("tr.jqgrow")[0].id;
                                rc['rowIndex'] = $($t).jqGrid("getRowIndex",rid); //TODO 
                                $($t).jqGrid("expandLoadMore",rc);
                            });
                        }

                        if(curLevel !== parseInt($t.p.tree_root_level,10)) {
                            var pn = $($t).jqGrid('getNodeParent',ldat);
                            expan = pn && pn.hasOwnProperty(expanded) ? pn[expanded] : true;
                            if( !expan ){
                                $($t.rows[i]).css("display","none");
                            }
                        }
                        $($t.rows[i].cells[expCol])
                            .find("div.treeclick")
                            .bind("click",function(e){
                                var target = e.target || e.srcElement,
                                    ind2 =$(target,$t.rows).closest("tr.jqgrow")[0].id,
                                    pos = $t.p._index[ind2];
                                if(!$t.p.data[pos][isLeaf]){
                                    if($t.p.data[pos][expanded]){
                                        $($t).jqGrid("collapseRow",$t.p.data[pos]);
                                        $($t).jqGrid("collapseNode",$t.p.data[pos]);
                                    } else {
                                        $($t).jqGrid("expandRow",$t.p.data[pos]);
                                        $($t).jqGrid("expandNode",$t.p.data[pos]);
                                    }
                                }
                                return false;
                            });
                        if($t.p.ExpandColClick === true) {
                            $($t.rows[i].cells[expCol])
                                .find("span.cell-wrapper")
                                .css("cursor","pointer")
                                .bind("click",function(e) {
                                    var target = e.target || e.srcElement,
                                        ind2 =$(target,$t.rows).closest("tr.jqgrow")[0].id,
                                        pos = $t.p._index[ind2];
                                    if(!$t.p.data[pos][isLeaf]){
                                        if($t.p.data[pos][expanded]){
                                            $($t).jqGrid("collapseRow",$t.p.data[pos]);
                                            $($t).jqGrid("collapseNode",$t.p.data[pos]);
                                        } else {
                                            $($t).jqGrid("expandRow",$t.p.data[pos]);
                                            $($t).jqGrid("expandNode",$t.p.data[pos]);
                                        }
                                    }
                                    $($t).jqGrid("setSelection",ind2);
                                    return false;
                                });
                        }
                        i++;
                    }

                });
            },
            setTreeGrid : function() {
                return this.each(function (){
                    var $t = this, i=0, pico, ecol = false, nm, key, dupcols=[];
                    if(!$t.p.treeGrid) {return;}
                    if(!$t.p.treedatatype ) {$.extend($t.p,{treedatatype: $t.p.datatype});}
                    $t.p.subGrid = false;$t.p.altRows =false;
                    $t.p.pgbuttons = false;$t.p.pginput = false;
                    $t.p.gridview =  true;
                    //if($t.p.rowTotal === null ) { $t.p.rowNum = 10000; }
                    $t.p.multiselect = false;$t.p.rowList = [];
                    $t.p.expColInd = 0;
                    pico = 'ui-icon-triangle-1-' + ($t.p.direction=="rtl" ? 'w' : 'e');
                    $t.p.treeIcons = $.extend({plus:pico,minus:'ui-icon-triangle-1-s',leaf:'ui-icon-radio-off'},$t.p.treeIcons || {});
                    if($t.p.treeGridModel == 'nested') {
                        $t.p.treeReader = $.extend({
                            level_field: "level",
                            left_field:"lft",
                            right_field: "rgt",
                            leaf_field: "isLeaf",
                            expanded_field: "expanded",
                            loaded: "loaded",
                            icon_field: "icon"
                        },$t.p.treeReader);
                    } else if($t.p.treeGridModel == 'adjacency') {
                        $t.p.treeReader = $.extend({
                            level_field: "level",
                            parent_id_field: "parent",
                            leaf_field: "isLeaf",
                            expanded_field: "expanded",
                            loaded: "loaded",
                            icon_field: "icon"
                        },$t.p.treeReader );
                    }
                    for ( key in $t.p.colModel){
                        if($t.p.colModel.hasOwnProperty(key)) {
                            nm = $t.p.colModel[key].name;
                            if( nm == $t.p.ExpandColumn && !ecol ) {
                                ecol = true;
                                $t.p.expColInd = i;
                            }
                            i++;
                            //
                            for(var tkey in $t.p.treeReader) {
                                if($t.p.treeReader[tkey] == nm) {
                                    dupcols.push(nm);
                                }
                            }
                        }
                    }
                    $.each($t.p.treeReader,function(j,n){
                        if(n && $.inArray(n, dupcols) === -1){
                            if(j==='leaf_field') { $t.p._treeleafpos= i; }
                            i++;
                            $t.p.colNames.push(n);
                            $t.p.colModel.push({name:n,width:1,hidden:true,sortable:false,resizable:false,hidedlg:true,editable:true,search:false});
                        }
                    });
                });
            },
            expandRow: function (record){
                this.each(function(){
                    var $t = this;
                    if(!$t.grid || !$t.p.treeGrid) {return;}
                    var childern = $($t).jqGrid("getNodeChildren",record),
                        //if ($($t).jqGrid("isVisibleNode",record)) {
                        expanded = $t.p.treeReader.expanded_field,
                        rows = $t.rows;
                    $(childern).each(function(){
                        var id  = $.jgrid.getAccessor(this,$t.p.localReader.id);
                        $(rows.namedItem(id)).css("display","");
                        if(this[expanded]) {
                            $($t).jqGrid("expandRow",this);
                        }
                    });
                    //}
                });
            },
            collapseRow : function (record) {
                this.each(function(){
                    var $t = this;
                    if(!$t.grid || !$t.p.treeGrid) {return;}
                    var childern = $($t).jqGrid("getNodeChildren",record),
                        expanded = $t.p.treeReader.expanded_field,
                        rows = $t.rows;
                    $(childern).each(function(){
                        var id  = $.jgrid.getAccessor(this,$t.p.localReader.id);
                        $(rows.namedItem(id)).css("display","none");
                        if(this[expanded]){
                            $($t).jqGrid("collapseRow",this);
                        }
                    });
                });
            },
            // NS ,adjacency models
            getRootNodes : function() {
                var result = [];
                this.each(function(){
                    var $t = this;
                    if(!$t.grid || !$t.p.treeGrid) {return;}
                    switch ($t.p.treeGridModel) {
                        case 'nested' :
                            var level = $t.p.treeReader.level_field;
                            $($t.p.data).each(function(){
                                if(parseInt(this[level],10) === parseInt($t.p.tree_root_level,10)) {
                                    result.push(this);
                                }
                            });
                            break;
                        case 'adjacency' :
                            var parent_id = $t.p.treeReader.parent_id_field;
                            $($t.p.data).each(function(){
                                if(this[parent_id] === null || String(this[parent_id]).toLowerCase() == "null") {
                                    result.push(this);
                                }
                            });
                            break;
                    }
                });
                return result;
            },
            getNodeDepth : function(rc) {
                var ret = null;
                this.each(function(){
                    if(!this.grid || !this.p.treeGrid) {return;}
                    var $t = this;
                    switch ($t.p.treeGridModel) {
                        case 'nested' :
                            var level = $t.p.treeReader.level_field;
                            ret = parseInt(rc[level],10) - parseInt($t.p.tree_root_level,10);
                            break;
                        case 'adjacency' :
                            ret = $($t).jqGrid("getNodeAncestors",rc).length;
                            break;
                    }
                });
                return ret;
            },
            getNodeParent : function(rc) {
                var result = null;
                this.each(function(){
                    var $t = this;
                    if(!$t.grid || !$t.p.treeGrid) {return;}
                    switch ($t.p.treeGridModel) {
                        case 'nested' :
                            var lftc = $t.p.treeReader.left_field,
                                rgtc = $t.p.treeReader.right_field,
                                levelc = $t.p.treeReader.level_field,
                                lft = parseInt(rc[lftc],10), rgt = parseInt(rc[rgtc],10), level = parseInt(rc[levelc],10);
                            $(this.p.data).each(function(){
                                if(parseInt(this[levelc],10) === level-1 && parseInt(this[lftc],10) < lft && parseInt(this[rgtc],10) > rgt) {
                                    result = this;
                                    return false;
                                }
                            });
                            break;
                        case 'adjacency' :
                            var parent_id = $t.p.treeReader.parent_id_field,
                                dtid = $t.p.localReader.id;
                            $(this.p.data).each(function(){
                                if(this[dtid] == rc[parent_id] ) {
                                    result = this;
                                    return false;
                                }
                            });
                            break;
                    }
                });
                return result;
            },
            getNodeChildren : function(rc) {
                var result = [];
                this.each(function(){
                    var $t = this;
                    if(!$t.grid || !$t.p.treeGrid) {return;}
                    switch ($t.p.treeGridModel) {
                        case 'nested' :
                            var lftc = $t.p.treeReader.left_field,
                                rgtc = $t.p.treeReader.right_field,
                                levelc = $t.p.treeReader.level_field,
                                lft = parseInt(rc[lftc],10), rgt = parseInt(rc[rgtc],10), level = parseInt(rc[levelc],10);
                            $(this.p.data).each(function(){
                                if(parseInt(this[levelc],10) === level+1 && parseInt(this[lftc],10) > lft && parseInt(this[rgtc],10) < rgt) {
                                    result.push(this);
                                }
                            });
                            break;
                        case 'adjacency' :
                            var parent_id = $t.p.treeReader.parent_id_field,
                                dtid = $t.p.localReader.id;
                            $(this.p.data).each(function(){
                                if(this[parent_id] == rc[dtid]) {
                                    result.push(this);
                                }
                            });
                            break;
                    }
                });
                return result;
            },
            getFullTreeNode : function(rc) {
                var result = [];
                this.each(function(){
                    var $t = this, len;
                    if(!$t.grid || !$t.p.treeGrid) {return;}
                    switch ($t.p.treeGridModel) {
                        case 'nested' :
                            var lftc = $t.p.treeReader.left_field,
                                rgtc = $t.p.treeReader.right_field,
                                levelc = $t.p.treeReader.level_field,
                                lft = parseInt(rc[lftc],10), rgt = parseInt(rc[rgtc],10), level = parseInt(rc[levelc],10);
                            $(this.p.data).each(function(){
                                if(parseInt(this[levelc],10) >= level && parseInt(this[lftc],10) >= lft && parseInt(this[lftc],10) <= rgt) {
                                    result.push(this);
                                }
                            });
                            break;
                        case 'adjacency' :
                            if(rc) {
                                result.push(rc);
                                var parent_id = $t.p.treeReader.parent_id_field,
                                    dtid = $t.p.localReader.id;
                                $(this.p.data).each(function(i){
                                    len = result.length;
                                    for (i = 0; i < len; i++) {
                                        if (result[i][dtid] == this[parent_id]) {
                                            result.push(this);
                                            break;
                                        }
                                    }
                                });
                            }
                            break;
                    }
                });
                return result;
            },
            // End NS, adjacency Model
            getNodeAncestors : function(rc) {
                var ancestors = [];
                this.each(function(){
                    if(!this.grid || !this.p.treeGrid) {return;}
                    var parent = $(this).jqGrid("getNodeParent",rc);
                    while (parent) {
                        ancestors.push(parent);
                        parent = $(this).jqGrid("getNodeParent",parent);
                    }
                });
                return ancestors;
            },
            isVisibleNode : function(rc) {
                var result = true;
                this.each(function(){
                    var $t = this;
                    if(!$t.grid || !$t.p.treeGrid) {return;}
                    var ancestors = $($t).jqGrid("getNodeAncestors",rc),
                        expanded = $t.p.treeReader.expanded_field;
                    $(ancestors).each(function(){
                        result = result && this[expanded];
                        if(!result) {return false;}
                    });
                });
                return result;
            },
            isNodeLoaded : function(rc) {
                var result;
                this.each(function(){
                    var $t = this;
                    if(!$t.grid || !$t.p.treeGrid) {return;}
                    var isLeaf = $t.p.treeReader.leaf_field;
                    if(rc !== undefined ) {
                        if(rc.loaded !== undefined) {
                            result = rc.loaded;
                        } else if( rc[isLeaf] || $($t).jqGrid("getNodeChildren",rc).length > 0){
                            result = true;
                        } else {
                            result = false;
                        }
                    } else {
                        result = false;
                    }
                });
                return result;
            },
            expandNode : function(rc) {
                return this.each(function(){
                    if(!this.grid || !this.p.treeGrid) {return;}
                    var expanded = this.p.treeReader.expanded_field,
                        parent = this.p.treeReader.parent_id_field,
                        loaded = this.p.treeReader.loaded,
                        level = this.p.treeReader.level_field,
                        lft = this.p.treeReader.left_field,
                        rgt = this.p.treeReader.right_field;

                    if(!rc[expanded]) {
                        var id = $.jgrid.getAccessor(rc,this.p.localReader.id);
                        var rc1 = $("#"+$.jgrid.jqID(id),this.grid.bDiv)[0];
                        var position = this.p._index[id];
                        if( $(this).jqGrid("isNodeLoaded",this.p.data[position]) ) {
                            rc[expanded] = true;
                            $("div.treeclick",rc1).removeClass(this.p.treeIcons.plus+" tree-plus").addClass(this.p.treeIcons.minus+" tree-minus");
                        } else if (!this.grid.hDiv.loading) {
                            rc[expanded] = true;
                            $("div.treeclick",rc1).removeClass(this.p.treeIcons.plus+" tree-plus").addClass(this.p.treeIcons.minus+" tree-minus");
                            this.p.treeANode = rc1.rowIndex;
                            this.p.datatype = this.p.treedatatype;
                            if(this.p.treeGridModel == 'nested') {
                                $(this).jqGrid("setGridParam",{postData:{nodeid:id,n_left:rc[lft],n_right:rc[rgt],n_level:rc[level]}});
                            } else {
                                $(this).jqGrid("setGridParam",{postData:{nodeid:id,parentid:rc[parent],n_level:rc[level]}} );
                            }
                            $(this).trigger("reloadGrid");
                            rc[loaded] = true;
                            if(this.p.treeGridModel == 'nested') {
                                $(this).jqGrid("setGridParam",{postData:{nodeid:'',n_left:'',n_right:'',n_level:''}});
                            } else {
                                $(this).jqGrid("setGridParam",{postData:{nodeid:'',parentid:'',n_level:''}});
                            }
                        }
                    }
                });
            },
            collapseNode : function(rc) {
                return this.each(function(){
                    if(!this.grid || !this.p.treeGrid) {return;}
                    var expanded = this.p.treeReader.expanded_field;
                    if(rc[expanded]) {
                        rc[expanded] = false;
                        var id = $.jgrid.getAccessor(rc,this.p.localReader.id);
                        var rc1 = $("#"+$.jgrid.jqID(id),this.grid.bDiv)[0];
                        $("div.treeclick",rc1).removeClass(this.p.treeIcons.minus+" tree-minus").addClass(this.p.treeIcons.plus+" tree-plus");
                    }
                });
            },
            SortTree : function( sortname, newDir, st, datefmt) {
                return this.each(function(){
                    if(!this.grid || !this.p.treeGrid) {return;}
                    var i, len,
                        rec, records = [], $t = this, query, roots,
                        rt = $(this).jqGrid("getRootNodes");
                    // Sorting roots
                    query = $.jgrid.from(rt);
                    query.orderBy(sortname,newDir,st, datefmt);
                    roots = query.select();

                    // Sorting children
                    for (i = 0, len = roots.length; i < len; i++) {
                        rec = roots[i];
                        records.push(rec);
                        $(this).jqGrid("collectChildrenSortTree",records, rec, sortname, newDir,st, datefmt);
                    }
                    $.each(records, function(index) {
                        var id  = $.jgrid.getAccessor(this,$t.p.localReader.id);
                        $('#'+$.jgrid.jqID($t.p.id)+ ' tbody tr:eq('+index+')').after($('tr#'+$.jgrid.jqID(id),$t.grid.bDiv));
                    });
                    query = null;roots=null;records=null;
                });
            },
            collectChildrenSortTree : function(records, rec, sortname, newDir,st, datefmt) {
                return this.each(function(){
                    if(!this.grid || !this.p.treeGrid) {return;}
                    var i, len,
                        child, ch, query, children;
                    ch = $(this).jqGrid("getNodeChildren",rec);
                    query = $.jgrid.from(ch);
                    query.orderBy(sortname, newDir, st, datefmt);
                    children = query.select();
                    for (i = 0, len = children.length; i < len; i++) {
                        child = children[i];
                        records.push(child);
                        $(this).jqGrid("collectChildrenSortTree",records, child, sortname, newDir, st, datefmt);
                    }
                });
            },
            // experimental
            setTreeRow : function(rowid, data) {
                var success=false;
                this.each(function(){
                    var t = this;
                    if(!t.grid || !t.p.treeGrid) {return;}
                    success = $(t).jqGrid("setRowData",rowid,data);
                });
                return success;
            },
            delTreeNode : function (rowid) {
                return this.each(function () {
                    var $t = this, rid = $t.p.localReader.id,
                        left = $t.p.treeReader.left_field,
                        right = $t.p.treeReader.right_field, myright, width, res, key;
                    if(!$t.grid || !$t.p.treeGrid) {return;}
                    var rc = $t.p._index[rowid];
                    if (rc !== undefined) {
                        // nested
                        myright = parseInt($t.p.data[rc][right],10);
                        width = myright -  parseInt($t.p.data[rc][left],10) + 1;
                        var dr = $($t).jqGrid("getFullTreeNode",$t.p.data[rc]);
                        if(dr.length>0){
                            for (var i=0;i<dr.length;i++){
                                $($t).jqGrid("delRowData",dr[i][rid]);
                            }
                        }
                        if( $t.p.treeGridModel === "nested") {
                            // ToDo - update grid data
                            res = $.jgrid.from($t.p.data)
                                .greater(left,myright,{stype:'integer'})
                                .select();
                            if(res.length) {
                                for( key in res) {
                                    if(res.hasOwnProperty(key)) {
                                        res[key][left] = parseInt(res[key][left],10) - width ;
                                    }
                                }
                            }
                            res = $.jgrid.from($t.p.data)
                                .greater(right,myright,{stype:'integer'})
                                .select();
                            if(res.length) {
                                for( key in res) {
                                    if(res.hasOwnProperty(key)) {
                                        res[key][right] = parseInt(res[key][right],10) - width ;
                                    }
                                }
                            }
                        }
                    }
                });
            },
            addChildNode : function( nodeid, parentid, data ) {
                //return this.each(function(){
                var $t = this[0];
                if(data) {
                    // we suppose tha the id is autoincremet and
                    var expanded = $t.p.treeReader.expanded_field,
                        isLeaf = $t.p.treeReader.leaf_field,
                        level = $t.p.treeReader.level_field,
                        //icon = $t.p.treeReader.icon_field,
                        parent = $t.p.treeReader.parent_id_field,
                        left = $t.p.treeReader.left_field,
                        right = $t.p.treeReader.right_field,
                        loaded = $t.p.treeReader.loaded,
                        method, parentindex, parentdata, parentlevel, i, len, max=0, rowind = parentid, leaf, maxright;

                    if ( typeof nodeid === 'undefined' || nodeid === null ) {
                        i = $t.p.data.length-1;
                        if(	i>= 0 ) {
                            while(i>=0){max = Math.max(max, parseInt($t.p.data[i][$t.p.localReader.id],10)); i--;}
                        }
                        nodeid = max+1;
                    }
                    var prow = $($t).jqGrid('getInd', parentid);
                    leaf = false;
                    // if not a parent we assume root
                    if ( parentid === undefined  || parentid === null || parentid==="") {
                        parentid = null;
                        rowind = null;
                        method = 'last';
                        parentlevel = $t.p.tree_root_level;
                        i = $t.p.data.length+1;
                    } else {
                        method = 'after';
                        parentindex = $t.p._index[parentid];
                        parentdata = $t.p.data[parentindex];
                        parentid = parentdata[$t.p.localReader.id];
                        parentlevel = parseInt(parentdata[level],10)+1;
                        var childs = $($t).jqGrid('getFullTreeNode', parentdata);
                        // if there are child nodes get the last index of it
                        if(childs.length) {
                            i = childs[childs.length-1][$t.p.localReader.id];
                            rowind = i;
                            i = $($t).jqGrid('getInd',rowind)+1;
                        } else {
                            i = $($t).jqGrid('getInd', parentid)+1;
                        }
                        // if the node is leaf
                        if(parentdata[isLeaf]) {
                            leaf = true;
                            parentdata[expanded] = true;
                            //var prow = $($t).jqGrid('getInd', parentid);
                            $($t.rows[prow])
                                .find("span.cell-wrapperleaf").removeClass("cell-wrapperleaf").addClass("cell-wrapper")
                                .end()
                                .find("div.tree-leaf").removeClass($t.p.treeIcons.leaf+" tree-leaf").addClass($t.p.treeIcons.minus+" tree-minus");
                            $t.p.data[parentindex][isLeaf] = false;
                            parentdata[loaded] = true;
                        }
                    }
                    len = i+1;

                    data[expanded] = false;
                    data[loaded] = true;
                    data[level] = parentlevel;
                    data[isLeaf] = true;
                    if( $t.p.treeGridModel === "adjacency") {
                        data[parent] = parentid;
                    }
                    if( $t.p.treeGridModel === "nested") {
                        // this method requiere more attention
                        var query, res, key;
                        //maxright = parseInt(maxright,10);
                        // ToDo - update grid data
                        if(parentid !== null) {
                            maxright = parseInt(parentdata[right],10);
                            query = $.jgrid.from($t.p.data);
                            query = query.greaterOrEquals(right,maxright,{stype:'integer'});
                            res = query.select();
                            if(res.length) {
                                for( key in res) {
                                    if(res.hasOwnProperty(key)) {
                                        res[key][left] = res[key][left] > maxright ? parseInt(res[key][left],10) +2 : res[key][left];
                                        res[key][right] = res[key][right] >= maxright ? parseInt(res[key][right],10) +2 : res[key][right];
                                    }
                                }
                            }
                            data[left] = maxright;
                            data[right]= maxright+1;
                        } else {
                            maxright = parseInt( $($t).jqGrid('getCol', right, false, 'max'), 10);
                            res = $.jgrid.from($t.p.data)
                                .greater(left,maxright,{stype:'integer'})
                                .select();
                            if(res.length) {
                                for( key in res) {
                                    if(res.hasOwnProperty(key)) {
                                        res[key][left] = parseInt(res[key][left],10) +2 ;
                                    }
                                }
                            }
                            res = $.jgrid.from($t.p.data)
                                .greater(right,maxright,{stype:'integer'})
                                .select();
                            if(res.length) {
                                for( key in res) {
                                    if(res.hasOwnProperty(key)) {
                                        res[key][right] = parseInt(res[key][right],10) +2 ;
                                    }
                                }
                            }
                            data[left] = maxright+1;
                            data[right] = maxright + 2;
                        }
                    }
                    if( parentid === null || $($t).jqGrid("isNodeLoaded",parentdata) || leaf ) {
                        $($t).jqGrid('addRowData', nodeid, data, method, rowind);
                        $($t).jqGrid('setTreeNode', i, len);
                    }
                    if(parentdata && !parentdata[expanded]) {
                        $($t.rows[prow])
                            .find("div.treeclick")
                            .click();
                    }
                }
                //});
            },
            //
            expandLoadMore : function(rc){
                return this.each(function(){
                    //this.p.treeANode = rc.rowIndex;
                    //this.p.treeANode = $(this).jqGrid("getRowIndex",rc['rowId'])+2;
                    //this.p.treeANode = rc['rowIndex'] + (this.p.rowNum*(rc.expandPage-1));

                    this.p.treeANode = rc['rowIndex'];
                    $(this).jqGrid("setGridParam",{postData:{nodeid:rc['rowId'], n_level:rc['level'],expandPage:rc['expandPage'] }} );
                    $(this).trigger("reloadGrid");
                    $(this).jqGrid("setGridParam",{postData:{nodeid:'',parentid:'',n_level:'',expandPage:1}});
                });
            }
        });

        $.extend($.jgrid,{
            filterSpecialChar:function(colModel,v){
                var filterSpecialChar = true;
                if(colModel.filterSpecialChar===undefined){
                    var formatter = colModel.formatter,
                        formatters = ["menuoperations","operations","integer","number","currency","date","checkbox","email","showlink","wafcheckbox","wafenum","f7","wafselect","datepicker","timepicker","numberfield","radioGroup"];
                    if(!$.type.isString(v) || (formatter&&$.inArray(formatter,formatters)>-1)){
                        filterSpecialChar = false;
                    }
                }else{
                    filterSpecialChar = colModel.filterSpecialChar;
                }
                if(filterSpecialChar){
                    if(v && typeof v === "string"
                        && (v.indexOf("l1")==-1&&v.indexOf("l2")==-1&&v.indexOf("l3")==-1)) v = $.jgrid.htmlEncode(v);
                }
                return v;
            },
            initSpannedCellModel:function(ts){
                //SpannedCell{rowId,cellIndex,newRowId,newCellIndex,isReal}
                //rowId:id
                //cellIndex:
                //newRowId:/rowId
                //newCellIndex:/cellIndex
                //isReal:td
                //colSize:
                //rowSize:
                var table = ts,rowId,row;
                var spannedCellModel = [];
                if(table){
                    ts.p.rowSpanned = false;
                    ts.p.colSpanned = false;
                    for(var i=0;i<table.rows.length;i++){
                        row = table.rows[i];
                        if($(row).hasClass("jqgfirstrow")) continue;
                        rowId = row.id;
                        for(var j=0;j<table.rows[i].cells.length;j++){
                            spannedCellModel.push({
                                rowId:rowId,
                                cellIndex:j,
                                newRowId:rowId,
                                newCellIndex:j,
                                isReal:true,
                                colSize:1,
                                rowSize:1,
                                value:$(ts).wafGrid("getCell",rowId,j)
                            });
                        }
                    }
                }
                //
                table.p.spannedCellModel = spannedCellModel;
            },
            getCellModel:function(rowId,cellIndex,ts){
                if(!ts.p.spannedCellModel || !$.isArray(ts.p.spannedCellModel)) return;
                var target = jlinq.from(ts.p.spannedCellModel)
                    .equals("rowId",rowId)
                    .equals("cellIndex",cellIndex)
                    .select();
                if(target && target.length>0) return target[0];
                return undefined;
            },
            getRowCellModel:function(rowId,ts){
                if(!ts.p.spannedCellModel || !$.isArray(ts.p.spannedCellModel)) return;
                if(!ts.p.spannedCellModel || !$.isArray(ts.p.spannedCellModel)) return;
                var target = jlinq.from(ts.p.spannedCellModel)
                    .equals("rowId",rowId)
                    .select();
                if(target && target.length>0) return target;
                return undefined;
            },
            addSpannedCellModel:function(ts,rowId,rowdata){
                if(!ts.p.spannedCellModel || !$.isArray(ts.p.spannedCellModel)) return;
                //spannedCellModel
                var target = jlinq.from(ts.p.spannedCellModel)
                    .equals("rowId",rowId)
                    .select();
                if(target && target.length>0) return;
                var spannedCellModel = ts.p.spannedCellModel || [];
                var rowInd = ts.rows.namedItem(rowId);
                for(var j=0;j<rowInd.cells.length;j++){
                    spannedCellModel.push({
                        rowId:rowId,
                        cellIndex:j,
                        newRowId:rowId,
                        newCellIndex:j,
                        isReal:true,
                        colSize:1,
                        rowSize:1,
                        value:rowdata[ts.p.colModel[j].name]
                    });
                }
                //
                ts.p.spannedCellModel = spannedCellModel;
            },
            removeSpannedCellModel:function(ts,rowId,colIndex){
                if(!ts.p.spannedCellModel || !$.isArray(ts.p.spannedCellModel)) return;
                if(colIndex){
                    //
                }else{
                    //
                    var target = jlinq.from(ts.p.spannedCellModel)
                        .notEquals("rowId",rowId)
                        .select();
                    ts.p.spannedCellModel = target;
                }
            },
            updateColSpanLabel:function(colspans,t){
                if(colspans&&colspans.length>0){
                    var tmp,td,colSpanTemplate,colSpanFormatter,list,spanValue=[],title,values,nm;
                    for(var i=0;i<colspans.length;i++){
                        tmp = colspans[i].cellModel;
                        td = colspans[i].td;
                        nm = t.p.colModel[tmp.newCellIndex].name;
                        if(tmp.colSize>1){
                            colSpanTemplate=t.p.colModel[tmp.newCellIndex].colSpanTemplate;
                            colSpanFormatter=t.p.colModel[tmp.newCellIndex].colSpanFormatter;
                            list = jlinq.from(t.p.spannedCellModel)
                                .equals("rowId",tmp.newRowId)
                                .greaterEquals("cellIndex",tmp.newCellIndex)
                                .lessEquals("cellIndex",(tmp.newCellIndex+tmp.colSize-1))
                                .select();
                            if(list&&list.length>0){
                                for(var s=0;s<list.length;s++){
                                    spanValue.push({value:list[s].value,rowId:list[s].rowId,colIndex:list[s].cellIndex});
                                }
                            }
                            //
                            if(colSpanTemplate && !colSpanFormatter){
                                values = colSpanTemplate;
                                for(var r=0;r<spanValue.length;r++){
                                    values = $.wafutil.replaceAll(values,"{"+r+"}",spanValue[r].value);
                                }
                            }else if(colSpanFormatter && $.isFunction(colSpanFormatter)){
                                values = colSpanFormatter.call(td,tmp.newRowId,tmp.newCellIndex,spanValue);
                            }
                            title = $.jgrid.stripHtml(values);
                            if(t.p.treeGrid===true && nm == t.p.ExpandColumn) {
                                $(td).children("span:first").html(values).attr(title);
                            } else {
                                $(td).html(values).attr(title);
                            }
                        }
                    }
                }
            },
            colInSpan:function(ts,colName){
                var ret = false,len,cm,colspan,colspanIndex=-1;
                if(ts){
                    len = ts.p.colModel.length;
                    for(var i=0;i<len;i++){
                        cm=ts.p.colModel[i];
                        if(cm.colSpan){
                            colspan = cm.colSpan;
                            colspanIndex = i;
                        }
                        if(cm.name == colName){
                            ret = !!cm.colSpan || !!cm.rowspan;
                            //TODO:
                            //
                            if(ret&&colspanIndex>-1){
                                colspan = parseInt(colspan);
                                if(i<(colspanIndex+colspan)){
                                    ret = true;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                }
                return ret;
            },
            hasRowSpan:function(ts){
                return ts.p.rowSpanned == true;
            },
            hasColSpan:function(ts){
                return ts.p.colSpanned == true;
            },
            hasSpan:function(ts){
                return !!ts.p.rowSpanCols;
            },
            getRealColIndex:function(ts,rowId,col){
                //cellIndex
                var tmp = $.jgrid.getCellModel(rowId,col,ts);
                if(tmp){
                    return tmp.newCellIndex;
                }
                return col;
            },
            getNoSpanRealColIndex:function(ts,rowId,col){
                //CellIndex
                var tmp = $.jgrid.getCellModel(rowId,col,ts);
                if(tmp && tmp.isReal && tmp.colSize==1 && tmp.rowSize==1){
                    return tmp.newCellIndex;
                }
                return col;
            },
            getCellValue:function(ts,rowId,pos,mthd){
                //pospos
                var val,td,tmpInd,tmp,nm;
                try {
                    tmpInd = ts.rows.namedItem(rowId);
                    nm = ts.p.colModel[pos].name;
                    if($.jgrid.hasSpan(ts)){
                        var cTd = tmpInd.childNodes[$.jgrid.getRowSpanIndex(pos,tmpInd)];
                        if($.jgrid.inRowSpan(pos,ts)){
                            if($.jgrid.hasRowSpanned(pos, tmpInd)){
                                //
                                val = $.jgrid.getSpannedModel(pos,tmpInd);
                                if(val) val = val.val;
                            }else {
                                //
                                val = $.jgrid.getTdValue(ts,rowId,pos,$(cTd),mthd);
                            }
                        }else{
                            val = $.jgrid.getTdValue(ts,rowId,pos,$(cTd),mthd);
                        }
                    }else{
                        td=$("td:eq("+pos+")", tmpInd);
                        val = $.jgrid.getTdValue(ts,rowId,pos,td,mthd);
                    }
                } catch (e) {
                    val = $.jgrid.htmlDecode(ts.rows.namedItem(rowId).cells[pos].innerHTML);
                }
                return val;
            },
            setCellValue:function(ts,rowid,pos,v,record,cssp,attrp){
                var cm = ts.p.colModel[pos],nm = cm.name,editable=ts.p.cellEdit&&record,realValue = v,dirtyCell=false,
                    ind = ts.rows.namedItem(rowid),
                    title,oldValue,td,realV = v;

                //oldValue,oldValueCelldirty-cell
                if(editable) oldValue = $(ts).jqGrid("getCell",rowid,nm);

                //
                v = $.jgrid.filterSpecialChar(cm,v);
                //
                v = ts.formatter( rowid, v, pos, $.jgrid.getBinderData(ind.rowIndex,ts), 'edit');
                //title
                title = cm.title ? {"title":$.jgrid.stripHtml(v)} : {};
                //
                if($.jgrid.hasSpan(ts)){
                    if($.jgrid.inRowSpan(pos,ts)){
                        //cellcell
                        var cTd = ind.childNodes[$.jgrid.getRowSpanIndex(pos,ind)];
                        if($.jgrid.hasRowSpanned(pos, ind)){
                            //
                            td = $.jgrid.getParentTd(pos,ind);
                            td = td?$(td):undefined;
                            //
                            var val = $.jgrid.getSpannedModel(pos,ind);
                            if(val) val.val = realV;
                        }else{
                            //
                            td=$(cTd);
                        }
                    }else{
                        //td
                        td = $(ind.childNodes[$.jgrid.getRowSpanIndex(pos,ind)]);
                    }
                }else{
                    td = $("td:eq("+pos+")",ind);
                }
                if(td && td.length>0){
                    if(ts.p.treeGrid===true && nm == ts.p.ExpandColumn) {
                        $(td).children("span:first").html(v).attr(title);
                    } else {
                        $(td).html(v).attr(title);
                    }
                    //
                    if(!!editable && !$.type.isEquals(oldValue,realValue)){
                        if(!!editable) $(ind).addClass("edited");
                        $(td).addClass("dirty-cell");
                        dirtyCell=true;
                    }
                    //
                    $.jgrid.setFrozenCellValue(ts,ts.p.colModel[pos],ind.rowIndex,pos,realValue,title,undefined,undefined,dirtyCell);
                    //
                    $.jgrid.updateBinderData(ind.rowIndex,ts,pos,realValue);
                    //cssattr
                    if(typeof cssp === 'string'){
                        $(td).addClass(cssp);
                    } else if(cssp) {
                        $(td).css(cssp);
                    }
                    if(typeof attrp === 'object') {$(td).attr(attrp);}
                }
            }
        });



        //
        $.wafGrid = $.jgrid || {};
        $.extend($.wafGrid,{
            gridTag:"grid",
            editGridTag:"editGrid",
            pagerTag:"pager",
            headGroupTag:"gridHeaderGroup",
            dataGroupTag:"gridDataGroup",
            columnTag:"gridColumn",
            cmpType:"wafGrid",

            //optionID,DOM
            createGridDOM:function(options){
                var obj = options && options.id && $("#"+options.id);
                if(!(obj&&obj.data("domcreated"))){
                    var doms = [];
                    if(options && options.id){
                        var table = $("<table></table>");
                        table.attr("id",options.id);
                        doms.push(table);
                        if(options.pager){
                            var pager = $("<div></div>");
                            pager.attr("id","pager"+options.id);
                            doms.push(pager);
                        }
                    }
                    return doms;
                }else{
                    return obj;
                }

            },
            //
            initGrid:function(options,el){
                el=$.isArray(el)?$(el[0]):$(el);

                if(el && options){
                    var ts = el;
                    if(options.colModel && options.colModel.length>0){
                        var len = options.colModel.length;
                        for(var i=0;i<len;i++){
                            if(!options.colModel[i].width) options.colModel[i].width=80;
                        }
                    }
                    $(ts).wafGrid(options);
                    $(ts).wafGrid("resizeGrid",{base:waf("#"+options.id),offset:0});
                    waf.ieHack.hackResize(function(e){
                        $(ts).wafGrid("resizeGrid",{base:waf("#"+options.id),offset:0});
                    },$(ts));
                }
            },
            //
            deleteGrid:function(options){
                $("#"+options.id).wafGrid("gridDestroy");
            },
            //
            modifyGrid:function(options){
                var ts = $("#"+options.id),refreshGrid=false;
                if(ts.length>0){
                    ts = ts[0];
                    $.each(options, function (key, value) {
                        if("id"!==key){
                            $(ts).wafGrid("option",key,value);
                            //
                            if("sortname"===key || "sortorder"===key || "altclass"===key || "altRows"===key ||
                                "footerrow"===key || "userDataOnFooter"===key || "entrys" ===key){
                                refreshGrid=true;
                            }
                        }
                    });
                    if(refreshGrid) $(ts).wafGrid("reloadGrid");
                }
            },

            //
            createPagerDOM:function(options){
                return "";
            },
            //
            initPager:function(options,el){
                //
                if(options && options["parentId"]){
                    var id = options["parentId"],ts = waf("#"+id)[0];
                    var newOptions = $.extend(true,{},options);
                    delete newOptions.id;
                    delete newOptions.parentId;
                    $(ts).wafGrid("createPager",newOptions);
                    $(ts).wafGrid("reloadGrid");
                }
            },
            //
            deletePager:function(options){
                if(options && options["parentId"]){
                    var id = options["parentId"],ts = waf("#"+id)[0];
                    $(ts).wafGrid("deletePager");
                }
            },
            //
            modifyPager:function(options){
                if(options && options["parentId"]){
                    var id = options["parentId"],ts = waf("#"+id)[0];
                    waf(ts).wafGrid("setPagerProp",options);
                }
            },


            //
            createHeadGroupDOM:function(options){
                return "";
            },
            //
            initHeadGroup:function(options,el){
                if(options && options["parentId"]){
                    if(options["parentId"] && options["useColSpanStyle"] && options["startColumnName"] && options["numberOfColumns"]
                        && options["titleText"]){
                        var ts = waf("#"+options["parentId"]);
                        waf(ts).wafGrid("createHeadGroup",options);
                    }
                }
            },
            //
            deleteHeadGroup:function(options){
                if(options && options["parentId"]){
                    var ts = waf("#"+options["parentId"]);
                    waf(ts).wafGrid("deleteHeadGroup");
                }
            },
            //
            modifyHeadGroup:function(options){
                if(options && options["parentId"]){
                    var ts = waf("#"+options["parentId"]);
                    waf(ts).wafGrid("setHeadGroupProp",options);
                }
            },


            //DOM
            createDataGroupDOM:function(options){
                return "";
            },
            //
            initDataGroup:function(options,el){
                if(options && options["parentId"]){
                    if(options["parentId"]){
                        var id=options["parentId"],ts = waf("#"+id)[0];
                        waf(ts).wafGrid("setDataGroup",options);
                    }
                }
            },
            //
            deleteDataGroup:function(options){
                if(options && options["parentId"]){
                    var ts = waf("#"+options["parentId"]);
                    waf(ts).wafGrid("destoryDataGroup");
                }
            },
            //
            modifyDataGroup:function(options){
                if(options && options["parentId"]){
                    var id=options["parentId"],ts = waf("#"+id)[0];
                    waf(ts).wafGrid("setDataGroupProp",options);
                }
            },


            //
            getDataGroupProps:function(){
                return ["groupField","groupOrder","groupText","groupColumnShow","groupSummary","showSummaryOnHide","groupCollapse","plusicon","minusicon"];
            },
            getHeadGroupProps:function(){
                return ["useColSpanStyle","startColumnName","numberOfColumns","titleText"];
            },
            getPagerProps:function(){
                return ["page","rowNum","rowList"];
            }
        });
        //
        $(function(){
            //
            waf.registerComponent($.wafGrid.gridTag,{
                createDOMFun:$.wafGrid.createGridDOM,
                initFun:$.wafGrid.initGrid,
                deleteFun:$.wafGrid.deleteGrid,
                modifyFun:$.wafGrid.modifyGrid,lazyInit:false
            });
            //pager
            waf.registerComponent($.wafGrid.pagerTag,{
                createDOMFun:$.wafGrid.createPagerDOM,
                initFun:$.wafGrid.initPager,
                deleteFun:$.wafGrid.deletePager,
                modifyFun:$.wafGrid.modifyPager
            });
            //gridHeaderGroup
            waf.registerComponent($.wafGrid.headGroupTag,{
                createDOMFun:$.wafGrid.createHeadGroupDOM,
                initFun:$.wafGrid.initHeadGroup,
                deleteFun:$.wafGrid.deleteHeadGroup,
                modifyFun:$.wafGrid.modifyHeadGroup
            });
            //gridDataGroup
            waf.registerComponent($.wafGrid.dataGroupTag,{
                createDOMFun:$.wafGrid.createDataGroupDOM,
                initFun:$.wafGrid.initDataGroup,
                deleteFun:$.wafGrid.deleteDataGroup,
                modifyFun:$.wafGrid.modifyDataGroup
            });
        });
    })(jQuery);
//});




//mod.defineModule("editgrid", ["base","waf","grid"],function(){
    (function ($) {
        $.jgrid.extend({
            changeCellConfig:function(rowId, colName, config){
                return $(this).jqGrid("changeCellEditor",rowId,colName,config);
            },
            /**deprecated**/
            getCellEditorConfig:function (rowId, colName) {
                return $(this).wafGrid("getCellConfig",colName,rowId);
            },
            getCurrentEditCellXY:function () {
                var ret;
                this.each(function () {
                    var $t = this;
                    ret = {rowIndex:$t.p.iRow, colIndex:$t.p.iCol};
                });
                return ret;
            },

            getChangedCells:function () {
                var changed =  this.jqGrid("getChangedRows","dirty");
                return changed.modifys;
            },
            /**deprecated**/
            setCellEditorConfig:function (colName, propName, value, rowId, isPromptSelf) {
                //
                var tagType="common";
                if(isPromptSelf){
                    tagType="promptBox";
                }
                $(this).jqGrid("setCellEditorAllConfig",colName,propName,value,tagType,rowId);
            },
            setCellEditorAllConfig:function (colName, propName, value, tagType, rowId) {
                //
                var col = (undefined === rowId || null === rowId);
                var colModel = this.wafGrid("getCellConfig", colName,rowId);
                var tmp = $.extend(true, {}, colModel);
                //
                tmp = $.jgrid.setCellEditorAllConfig(tmp, propName, value, tagType);
                //
                $(this).wafGrid("editStop");
                //
                if (col) {
                    this.wafGrid("optionColumn", colName, tmp);
                } else {
                    this.wafGrid("changeCellEditor", rowId, colName, tmp);
                }
            },
            changeCellEditor:function (rowId, colName, config) {
                if(!config || $.isEmptyObject(config) || this.length==0) return;
                var $t = this[0];
                var p = {},len = $.jgrid.getCellConfigItem().length,tmp;
                for(var i=0;i<len;i++){
                    tmp = config[$.jgrid.getCellConfigItem()[i]];
                    if(tmp !== undefined) p[$.jgrid.getCellConfigItem()[i]] = tmp;
                }
                //editor
                if (rowId) {
                    var keyStr = rowId + "-" + colName,
                        cellEditorConfig = this.data("cellEditorConfig") || {};
                    cellEditorConfig[keyStr] = p;
                    this.data("cellEditorConfig", cellEditorConfig);
                }else{
                    this.wafGrid("optionColumn", colName, p);
                }
            },
            setCellConfig:function(colName, propName, value, rowId){
                //
                if($.inArray(propName,$.jgrid.getCellConfigItem()) == -1) return;
                //
                var col = (undefined === rowId || null === rowId);
                var tmp = {};
                //
                tmp[propName] = value;
                //
                $(this).wafGrid("editStop");
                //
                if (col) {
                    this.wafGrid("setColumnProp", colName,propName, value);
                } else {
                    this.wafGrid("changeCellEditor", rowId, colName, tmp);
                }
            },
            getErrorInput:function () {
                var ts = this[0];
                if (ts.p.cellEdit === false) return null;
                var errorInput = this.find("tr.jqgrow td.errorinput");
                if (errorInput && errorInput.length > 0) {
                    return errorInput;
                }
                return null;
            },
            lockCell:function(rowid,colName){
                $(this).wafGrid("setCellConfig",colName,"editable",false,rowid);
            },
            unLockCell:function(rowid,colName){
                $(this).wafGrid("setCellConfig",colName,"editable",true,rowid);
            }
        });


        //**
        $.jgrid.extend({
            //addRow
            addEntryRow:function (p) {
                return $(this).wafGrid("addRow", p);
            },
            //delRow
            delEntryRow:function (rowid, p) {
                return $(this).wafGrid("delRow", rowid, p);
            },
            getChangedRows:function (mthd) {
                //mthd
                var ret = [], del = [];
                if (!mthd) {
                    mthd = 'all'; //modify by jlg.  mthd==all or dirty
                }
                this.each(function () {
                    var $t = this, nm, val;
                    if (!$t.grid || $t.p.cellEdit !== true) {
                        return;
                    }
                    //add by jlg.
                    $(this).jqGrid("editStop");

                    $($t.rows).each(function (j) {
                        var res = {};
                        if ($(this).hasClass("edited")) {
                            //colModel
                            for (var i = 0; i < $t.p.colModel.length; i++) {
                                nm = $t.p.colModel[i].name;
                                if (nm !== 'cb' && nm !== 'subgrid' && nm !== 'rn') {
                                    val = $.jgrid.getCellValue($t, this.id, i, mthd);
                                    if (val) res[nm] = val;
                                }
                            }
                            res.id = this.id;
                            ret.push(res);
                        }
                    });
                    del = $t.p.havedDelRowKey || [];
                });
                var tmp = {};
                tmp["modifys"] = ret;
                tmp["deletes"] = del;
                return tmp;
            },
            lockRow:function (rowid) {
                return $(this).wafGrid("innerLockRow", rowid, false);
            },
            unLockRow:function (rowid) {
                return $(this).wafGrid("innerLockRow", rowid, true);
            },
            innerLockRow:function (rowid, editable) {
                this.each(function () {
                    var $t = this, nm;
                    $(this).wafGrid("editStop");
                    for (var i = 0; i < $t.p.colModel.length; i++) {
                        nm = $t.p.colModel[i].name;
                        if (nm !== 'cb' && nm !== 'subgrid' && nm !== 'rn') {
                            $(this).wafGrid("setCellConfig", $t.p.colModel[i].name, "editable", editable, rowid);
                        }
                    }
                });
            },
            lockColumn:function(colName){
                return $(this).jqGrid("innerLockColumn",colName,false)
            },
            unLockColumn:function(colName){
                return $(this).jqGrid("innerLockColumn",colName,true)
            },
            innerLockColumn:function(colName,editable){
                this.each(function(){
                    var $t = this,nm;
                    $(this).wafGrid("editStop");
                    if (colName === 'cb' || colName ==='subgrid' || nm ==='rn') {
                        return;
                    }
                    //editable
                    $(this).wafGrid("setColumnProp",colName,"editable",editable);
                    //

                    var $t = $(this),key = "editable",value=editable;

                    $(this).jqGrid("innerSetAllCellConfig",$t, colName, key, value);
                });
            },
            innerSetAllCellConfig: function($t, colName,key, value){
                if($t.jqGrid("getDataIDs").length == 0) return;

                var cellEditorConfig = $t.data("cellEditorConfig") || {},keyStr;
                for(keyStr in cellEditorConfig){
                    var arr = keyStr.split("-");
                    if(arr.length === 2 && colName === arr[1]){
                        $t.wafGrid("setCellConfig",colName,key,value,arr[0]);
                    }
                }

            }
        });

        //
        $.jgrid.extend({
            cellEditSetUp:function(){},
            editCell:function (iRow, iCol, ed) {
                return this.each(function () {
                    var $t = this, nm, tmp, cc, cm,rowdata,ia;
                    //cellEdit
                    if (!$t.grid || $t.p.cellEdit !== true) {
                        return;
                    }
                    iCol = parseInt(iCol, 10);
                    if (!$t.p.knv) {
                        $($t).jqGrid("GridNav");
                    }
                    // check to see if we have already edited cell
                    if ($t.p.savedRow.length > 0) {
                        // prevent second click on that field and enable selects
                        if (ed === true) {
                            if (iRow == $t.p.iRow && iCol == $t.p.iCol) {
                                return;
                            }
                        }
                        // save the cell
                        $($t).jqGrid("saveCell", $t.p.savedRow[0].id, $t.p.savedRow[0].ic);
                    } else {
                        window.setTimeout(function () {
//                        $("#" + $.jgrid.jqID($t.p.knv)).attr("tabindex", "-1").focus();
                        }, 0);
                    }
                    cm = $t.p.colModel[iCol];
                    nm = cm.name;
                    if (nm == 'subgrid' || nm == 'cb' || nm == 'rn') {
                        return;
                    }
                    //
                    if ($($t).find("tr.norecord").length > 0) {
                        return;
                    }

                    //rowdatasaveCellsetCellrowdata,setCell
                    rowdata = $.jgrid.getBinderData(iRow,$t);

                    cm = $($t).jqGrid("getCellConfig", cm.name, $t.rows[iRow].id);

                    cc = $("td:eq(" + iCol + ")", $t.rows[iRow]);
                    if (cm.editable === true && ed === true && !cc.hasClass("not-editable-cell")) {

                        //class
                        if (parseInt($t.p.iCol, 10) >= 0 && parseInt($t.p.iRow, 10) >= 0) {
                            $("td:eq(" + $t.p.iCol + ")", $t.rows[$t.p.iRow]).removeClass("edit-cell ui-state-highlight");
                            //
                            $($t).jqGrid("removeSelect",$t.rows[$t.p.iRow].id);
                        }
                        //$.jgrid.removeAllSelect($t);
                        //
                        $($t.rows[iRow]).addClass("edited-row");
                        //setSelectionselarrow
                        ia = $.inArray($t.rows[iRow].id, $t.p.selarrrow);
                        if(ia>-1){$t.p.selarrrow.splice(ia, 1);}
                        $($t).jqGrid("setSelection", $t.rows[iRow].id ,true);

                        //
                        try {
                            tmp = $.unformat.call($t, cc[0], {rowId:$t.rows[iRow].id, colModel:cm, gid:$($t).attr("id")}, iCol);
                        } catch (_) {
                            tmp = ( cm.edittype && cm.edittype == 'textarea' ) ? $(cc).text() : $(cc).html();
                        }
                        if ($t.p.autoencode) {
                            tmp = $.jgrid.htmlDecode(tmp);
                        }
                        if (tmp === undefined || tmp == "&nbsp;" || tmp == "&#160;" || (tmp instanceof Array && tmp.length===0) || (typeof tmp==="string" && tmp.length === 1 && tmp.charCodeAt(0) == 160)) {
                            tmp = '';
                        }
                        //
                        if ($.isFunction($t.p.formatCell)) {
                            var tmp2 = $t.p.formatCell.call($t, $t.rows[iRow].id, nm, tmp, iRow, iCol);
                            if (tmp2 !== undefined) {
                                tmp = tmp2;
                            }
                        }
                        //celleditor
                        if ($.isFunction($t.p.formatCellEditor)) {
                            //
                            $t.p.formatCellEditor.call($t, $t.rows[iRow].id, nm, tmp, iCol, rowdata);
                            cm = $($t).jqGrid("getCellConfig", cm.name, $t.rows[iRow].id);
                        }

                        var editable = cm.editable;
                        if ($.isFunction($t.p.beforeEditCell)) {
                            //
                            var tmp3 = $t.p.beforeEditCell.call($t, $t.rows[iRow].id, nm, tmp, iRow, iCol, rowdata);
                            if (tmp3 != undefined && typeof tmp3 === "boolean") editable = tmp3;
                        }

                        //
                        if (editable === undefined || editable === true) {
                            //CLASS
                            $(cc).addClass("edit-cell ui-state-highlight");
                            //savedRow
                            if (!cm.edittype) {
                                cm.edittype = "defaultEditor";
                            }
                            $t.p.savedRow.push({id:iRow, ic:iCol, name:nm, v:tmp});

                            var opt = $.extend({grid:$t}, cm.editoptions || {cm:cm}, {id:iRow + "_" + $.wafutil.replaceAll(nm,".","-"), name:nm});

                            //
                            var type = eval("celleditor."+cm.edittype);
                            var editor = new type($t,opt,iRow,iCol,cc);
                            editor.edit(tmp);
                            //
                            $.jgrid.adjustFrozenColumnHeight($t,$t.rows[iRow].id);
                            $(cc)[0].editor = editor;
                            //.
                            var cell = cc;
                            if(editor && editor.colModel.frozen && editor.frozenCell){
                                cell = editor.frozenCell;
                            }
                            $("input, select, textarea,div.ui-multiselect,span.ui-radiogroup-span", cell).bind("keydown", function (e) {
                                $.jgrid.editKeyHandler(e,$t,iRow,iCol);
                            });

                            //
                            $($t).triggerHandler("jqGridAfterEditCell", [$t.rows[iRow].id, nm, tmp, iRow, iCol]);
                            if ($.isFunction($t.p.afterEditCell)) {
                                $t.p.afterEditCell.call($t, $t.rows[iRow].id, nm, tmp, iRow, iCol);
                            }
                        }
                    } else {
                        if (parseInt($t.p.iCol, 10) >= 0 && parseInt($t.p.iRow, 10) >= 0) {
                            $("td:eq(" + $t.p.iCol + ")", $t.rows[$t.p.iRow]).removeClass("edit-cell ui-state-highlight");
                            //
                            $($t).jqGrid("removeSelect",$t.rows[$t.p.iRow].id);
                        }
                        //
                        //$.jgrid.removeAllSelect($t);
                        $($t.rows[iRow]).addClass("edited-row");
                        //setSelectionselarrow
                        ia = $.inArray($t.rows[iRow].id, $t.p.selarrrow);
                        if(ia>-1){$t.p.selarrrow.splice(ia, 1);}
                        //
                        $($t).jqGrid("setSelection", $t.rows[iRow].id ,true);
                        cc.addClass("edit-cell ui-state-highlight");

                        tmp = cc.html().replace(/\&#160\;/ig, '');
                        $($t).triggerHandler("jqGridSelectCell", [$t.rows[iRow].id, nm, tmp, iRow, iCol]);
                        if ($.isFunction($t.p.onSelectCell)) {
                            $t.p.onSelectCell.call($t, $t.rows[iRow].id, nm, tmp, iRow, iCol);
                        }
                        //
                        $.jgrid.adjustFrozenColumnHeight($t,$t.rows[iRow].id);
                    }

                    $t.p.iCol = iCol;
                    $t.p.iRow = iRow;
                });
            },
            saveCell:function (iRow, iCol) {
                return this.each(function () {
                    var $t = this, fr;
                    if (!$t.grid || $t.p.cellEdit !== true) {
                        return;
                    }
                    if ($t.p.savedRow.length >= 1) {
                        fr = 0;
                    } else {
                        fr = null;
                    }
                    try {
                        if (fr !== null) {
                            var cc = $("td:eq(" + iCol + ")", $t.rows[iRow]);
                            var editor = cc[0].editor;
                            var values = editor.getValue();
                            $($t).jqGrid("saveInnerCell",values,cc,iRow, iCol);
                        }
                    } catch (e) {}
                    $.jgrid.focusKnv($t);
                });
            },
            saveInnerCell:function(values,cc,iRow, iCol,oldValue){
                return this.each(function () {
                    var $t = this, v,v2,nm;
                    if (!$t.grid || $t.p.cellEdit !== true) {
                        return;
                    }
                    if(!oldValue){
                        if ($t.p.savedRow.length >= 1) {
                            oldValue = $t.p.savedRow[0].v;
                        } else {
                            oldValue = null;
                        }
                    }
                    //cceditor
                    var editor = $(cc)[0].editor;
                    try {
                        if (oldValue !== null) {
                            if(values instanceof Array){
                                v=values[0];
                                v2=values[1];
                            }else{
                                v=values;
                                v2=v;
                            }
                            nm = $t.p.colModel[iCol].name;
                            if (!$.type.isEquals(v2,oldValue)) {
                                var vvv = $($t).triggerHandler("jqGridBeforeSaveCell", [$t.rows[iRow].id, nm, v, iRow, iCol]);
                                if (vvv) {
                                    v = vvv;
                                    v2 = vvv;
                                }
                                if ($.isFunction($t.p.beforeSaveCell)) {
                                    var vv = $t.p.beforeSaveCell.call($t, $t.rows[iRow].id, nm, v, iRow, iCol);
                                    if (vv) {
                                        v = vv;
                                        v2 = vv;
                                    }
                                }
                                v2 = v;//add by jlg.
                                var cv = $.jgrid.checkValues(v, iCol, $t);
                                if (cv[0] === true) {
                                    var addpost = $($t).triggerHandler("jqGridBeforeSubmitCell", [$t.rows[iRow].id, nm, v, iRow, iCol]) || {};
                                    if ($.isFunction($t.p.beforeSubmitCell)) {
                                        addpost = $t.p.beforeSubmitCell.call($t, $t.rows[iRow].id, nm, v, iRow, iCol);
                                        if (!addpost) {
                                            addpost = {};
                                        }
                                    }
                                    if ($t.p.cellsubmit == 'clientArray') {
                                        $(cc).empty();
                                        //
                                        $.jgrid.emptyFrozenCell($t,$t.p.colModel[iCol],iRow,iCol);
                                        $($t).jqGrid("setCell", $t.rows[iRow].id, iCol, v2, false, false, true,false);
                                        $(cc).addClass("dirty-cell");
                                        $($t.rows[iRow]).addClass("edited");
                                        $.jgrid.addFrozenDirtyClass($t,$t.p.colModel[iCol],iRow, iCol);
                                        //modiby by jlg. change its location from last line here.
                                        //savedRowafterSaveRowgetRowRealData.
                                        $t.p.savedRow.splice(0, 1);
                                        $($t).triggerHandler("jqGridAfterSaveCell", [$t.rows[iRow].id, nm, v, iRow, iCol,oldValue]);
                                        if ($.isFunction($t.p.afterSaveCell)) {
                                            $t.p.afterSaveCell.call($t, $t.rows[iRow].id, nm, v, iRow, iCol,oldValue);
                                        }
                                        //add by jlg.
                                        $.jgrid.updateBinderData(iRow,$t,iCol,v2);
                                        //
                                        $.jgrid.adjustFrozenColumnHeight($t,$t.rows[iRow].id);
                                    }
                                } else {
                                    try {
                                        window.setTimeout(function () {
                                            $.jgrid.info_dialog($.jgrid.errors.errcap, v + " " + cv[1], $.jgrid.edit.bClose);
                                        }, 100);
                                        $($t).jqGrid("restoreCell", iRow, iCol);
                                    } catch (e) {
                                    }
                                }
                            } else {
                                $($t).jqGrid("restoreCell", iRow, iCol);
                            }
                        }
                    } catch (e) {alert(e)}
                    $.jgrid.focusKnv($t);
                    if(editor){
                        editor.clear();
                        delete $(cc)[0].editor;
                    }
                });
            },
            restoreCell:function (iRow, iCol) {
                return this.each(function () {
                    var $t = this, fr;
                    if (!$t.grid || $t.p.cellEdit !== true) {
                        return;
                    }
                    if ($t.p.savedRow.length >= 1) {
                        fr = 0;
                    } else {
                        fr = null;
                    }
                    if (fr !== null) {
                        var cc = $("td:eq(" + iCol + ")", $t.rows[iRow]);
                        // datepicker fix
                        if ($.isFunction($.fn.datepicker)) {
                            try {
                                $("input.hasDatepicker", cc).datepicker('hide');
                            } catch (e) {
                            }
                        }
                        $(cc).empty().attr("tabindex", "-1");
                        $($t).jqGrid("setCell", $t.rows[iRow].id, iCol, $t.p.savedRow[fr].v, false, false, true,false);
                        $($t).triggerHandler("jqGridAfterRestoreCell", [$t.rows[iRow].id, $t.p.savedRow[fr].v, iRow, iCol]);
                        if ($.isFunction($t.p.afterRestoreCell)) {
                            $t.p.afterRestoreCell.call($t, $t.rows[iRow].id, $t.p.savedRow[fr].v, iRow, iCol);
                        }
                        $(cc).removeClass("edit-cell ui-state-highlight");
                        var editor = $(cc)[0].editor;//add by jlg.
                        if(editor){
                            editor.clear();
                            delete $(cc)[0].editor;
                        }
                        $t.p.savedRow.splice(0, 1);
                        //add by jlg.
                        //
                        $.jgrid.adjustFrozenColumnHeight($t,$t.rows[iRow].id);
                    }
                    $.jgrid.focusKnv($t);
                });
            },
            nextCell:function (iRow, iCol) {
                return this.each(function () {
                    var $t = this, nCol = false,colModel,nRow=false,keyOptions = $t.p.keyOptions,rowLength=$t.rows.length,colLength=$t.p.colModel.length,lr=false,lc=false;
                    if (!$t.grid || $t.p.cellEdit !== true) {
                        return;
                    }
                    // try to find next editable cell
                    if(keyOptions.horizontal==undefined || keyOptions.horizontal){
                        nCol = $.jgrid.getNextEditableCol($t,iCol,iRow);
                        if(nCol>-1){
                            //
                            nRow = iRow<=0?1:iRow;
                        }else{
                            //
                            nCol = false;
                        }
                        if(!nCol){
                            //,
                            var nextRow = iRow + 1;
                            var row = $t.rows[nextRow];
                            if (row != undefined) {
                                $($t).jqGrid("nextCell", nextRow, 0);
                                if($t.p.editModel=="floatEdit"){
                                    var floatCellEdit = $t.p.editModelOptions && $t.p.editModelOptions.cellEdit;
                                    if(floatCellEdit){
                                        $($t).jqGrid("hideFloatBar");
                                        $($t).jqGrid("showHoverHandle",$(row));
                                    }
                                }
                                return;
                            }
                        }
                    }else{
                        //
                        nRow = iRow+1;
                        lr=(nRow>=rowLength);
                        //
                        nCol = iCol;
                        lc=(nCol>=(colLength-1));
                        //
                        if(lr&&lc){
                            nCol=false;
                            nRow=false;
                        }else{
                            //
                            if(lr&&!lc){
                                nRow=1;
                                nCol++;
                            }
                            //ncol
                            colModel = $(this).jqGrid("getCellConfig",$t.p.colModel[nCol].name,$t.rows[nRow].id);
                            if(colModel.hidden ||!colModel.editable||undefined===colModel.editoptions){
                                nCol = $.jgrid.getNextEditableCol($t,nCol,nRow);
                                if(nCol==-1) nCol = false;
                            }
                        }
                    }

                    if (nCol !== false && nRow!==false) {
                        $($t).jqGrid("editCell", nRow, nCol, true);
                    } else {
                        if ($t.p.savedRow.length > 0) {
                            $($t).jqGrid("saveCell", iRow, iCol);
                        }
                        if(keyOptions){
                            if((!(keyOptions.nextLoop||keyOptions.loop))&&(keyOptions.addNewRowForLastCell == undefined || keyOptions.addNewRowForLastCell)){
                                if(keyOptions["lastCellAction"] && $.isFunction(keyOptions["lastCellAction"])){
                                    keyOptions["lastCellAction"].call(this,$t,iRow,iCol);
                                }else{
                                    var newrow = $($t).jqGrid("addRow");
                                    var rowObject = $($t).jqGrid("getRowObject",newrow);
                                    $($t).jqGrid("hideFloatBar");
                                    $($t).jqGrid("showHoverHandle",$(rowObject));
                                }
                            }else{
                                //,
                                nCol = $.jgrid.getNextEditableCol($t,-1,1);
                                if((keyOptions.nextLoop||keyOptions.loop) && nCol>-1){
                                    $(this).jqGrid("nextCell", 0, 0);
                                }else{
                                    window.setTimeout(function () {
                                        $("#" + $t.p.knv).blur();
                                        $($t).blur();
                                        if (parseInt($t.p.iCol, 10) >= 0 && parseInt($t.p.iRow, 10) >= 0) {
                                            $("td:eq(" + $t.p.iCol + ")", $t.rows[$t.p.iRow]).removeClass("edit-cell ui-state-highlight");
                                            $($t.rows[$t.p.iRow]).removeClass("edited-row");
                                        }
                                        if ($.enter2tab) {
                                            $.enter2tab.enter($t.p.id, false);
                                        }
                                    }, 0);
                                }
                            }
                        }
                    }
                });
            },
            prevCell:function (iRow, iCol) {
                return this.each(function () {
                    var $t = this, nCol = false,nRow=false,firstCol=0,keyOptions = $t.p.keyOptions,rowLength=$t.rows.length,colLength=$t.p.colModel.length,fr=false,fc=false;
                    if (!$t.grid || $t.p.cellEdit !== true) {
                        return;
                    }
                    // try to find next editable cell
                    var colModel;
                    if(keyOptions.horizontal==undefined || keyOptions.horizontal){
                        if(rowLength===iRow) iRow = rowLength-1;
                        nCol = $.jgrid.getPrevEditableCol($t,iCol,iRow);
                        if(nCol>-1){
                            nRow = iRow;
                        }else{
                            nCol = false;
                        }
                        if(!nCol){
                            //
                            var previousRow = iRow - 1;
                            if (previousRow > 0) {
                                $($t).jqGrid("prevCell", previousRow, (colLength));
                                return;
                            }
                        }
                    }else{
                        //
                        nRow = iRow-1;
                        fr=(nRow<=0);
                        //
                        if(colLength===iCol) iCol = colLength -1;
                        nCol = iCol;
                        $t.p.rownumbers?firstCol++:firstCol;
                        $t.p.multiselect?firstCol++:firstCol;
                        fc=(nCol<=firstCol);
                        //
                        if(fr&&fc){
                            nCol=false;
                            nRow=false;
                        }else{
                            //
                            if(fr&&!fc){
                                nRow=(rowLength-1);
                                nCol--;
                            }
                            //col
                            colModel = $(this).jqGrid("getCellConfig",$t.p.colModel[nCol].name,$t.rows[nRow].id);
                            if(colModel.hidden ||!colModel.editable||undefined===colModel.editoptions){
                                nCol = $.jgrid.getPrevEditableCol($t,nCol,nRow);
                                if(nCol==-1) nCol = false;
                            }
                        }
                    }


                    if (nCol !== false && nRow !== false) {
                        $($t).jqGrid("editCell", nRow, nCol, true);
                    } else {
                        if ($t.p.savedRow.length > 0) {
                            $($t).jqGrid("saveCell", iRow, iCol);
                        }
                        //,
                        nCol = $.jgrid.getPrevEditableCol($t,colLength,1);
                        if(keyOptions.prevLoop && nCol>-1){
                            $($t).jqGrid("prevCell", (rowLength), (colLength));
                        }else{
                            window.setTimeout(function () {
                                $("#" + $t.p.knv).blur();
                                $($t).blur();
                                if (parseInt($t.p.iCol, 10) >= 0 && parseInt($t.p.iRow, 10) >= 0) {
                                    $("td:eq(" + $t.p.iCol + ")", $t.rows[$t.p.iRow]).removeClass("edit-cell ui-state-highlight");
                                    $($t.rows[$t.p.iRow]).removeClass("edited-row");
                                }
                                if ($.enter2tab) {
                                    $.enter2tab.enter($t.p.id, true);
                                }
                            }, 0);
                        }
                    }
                });
            },
            GridNav:function () {
                return this.each(function () {
                    var $t = this;
                    if (!$t.grid || $t.p.cellEdit !== true) {
                        return;
                    }
                    // trick to process keydown on non input elements
                    $t.p.knv = $t.p.id + "_kn";
                    var selection = $("<div style='width:0px;height:0px;background-color:black;dispaly:block' tabindex='0'><div tabindex='-1' style='width:0px;height:0px;background-color:grey' id='" + $t.p.knv + "'></div></div>"),
                        i, kdir;
                    function scrollGrid(iR, iC, tp) {
                        if (tp.substr(0, 1) == 'v') {
                            var ch = $($t.grid.bDiv)[0].clientHeight,
                                st = $($t.grid.bDiv)[0].scrollTop,
                                nROT = $t.rows[iR].offsetTop + $t.rows[iR].clientHeight,
                                pROT = $t.rows[iR].offsetTop;
                            if (tp == 'vd') {
                                if (nROT >= ch) {
                                    $($t.grid.bDiv)[0].scrollTop = $($t.grid.bDiv)[0].scrollTop + $t.rows[iR].clientHeight;
                                }
                            }
                            if (tp == 'vu') {
                                if (pROT < st) {
                                    $($t.grid.bDiv)[0].scrollTop = $($t.grid.bDiv)[0].scrollTop - $t.rows[iR].clientHeight;
                                }
                            }
                        }
                        if (tp == 'h') {
                            var cw = $($t.grid.bDiv)[0].clientWidth,
                                sl = $($t.grid.bDiv)[0].scrollLeft,
                                nCOL = $t.rows[iR].cells[iC].offsetLeft + $t.rows[iR].cells[iC].clientWidth,
                                pCOL = $t.rows[iR].cells[iC].offsetLeft;
                            if (nCOL >= cw + parseInt(sl, 10)) {
                                $($t.grid.bDiv)[0].scrollLeft = $($t.grid.bDiv)[0].scrollLeft + $t.rows[iR].cells[iC].clientWidth;
                            } else if (pCOL < sl) {
                                $($t.grid.bDiv)[0].scrollLeft = $($t.grid.bDiv)[0].scrollLeft - $t.rows[iR].cells[iC].clientWidth;
                            }
                        }
                    }

                    function findNextVisible(iC, act) {
                        var ind, i;
                        if (act == 'lft') {
                            ind = iC + 1;
                            for (i = iC; i >= 0; i--) {
                                if ($t.p.colModel[i].hidden !== true) {
                                    ind = i;
                                    break;
                                }
                            }
                        }
                        if (act == 'rgt') {
                            ind = iC - 1;
                            for (i = iC; i < $t.p.colModel.length; i++) {
                                if ($t.p.colModel[i].hidden !== true) {
                                    ind = i;
                                    break;
                                }
                            }
                        }
                        return ind;
                    }

                    $(selection).insertBefore($t.grid.cDiv);
                    $("#" + $t.p.knv)
                        .keydown(function (e) {
                            kdir = e.keyCode;
                            if ($t.p.direction == "rtl") {
                                if (kdir === 37) {
                                    kdir = 39;
                                }
                                else if (kdir === 39) {
                                    kdir = 37;
                                }
                            }
                            switch (kdir) {
                                case 38:
                                    if ($t.p.iRow - 1 > 0) {
                                        scrollGrid($t.p.iRow - 1, $t.p.iCol, 'vu');
                                        $($t).jqGrid("editCell", $t.p.iRow - 1, $t.p.iCol, false);
                                    }
                                    break;
                                case 40 :
                                    if ($t.p.iRow + 1 <= $t.rows.length - 1) {
                                        scrollGrid($t.p.iRow + 1, $t.p.iCol, 'vd');
                                        $($t).jqGrid("editCell", $t.p.iRow + 1, $t.p.iCol, false);
                                    }
                                    break;
                                case 37 :
                                    if ($t.p.iCol - 1 >= 0) {
                                        i = findNextVisible($t.p.iCol - 1, 'lft');
                                        scrollGrid($t.p.iRow, i, 'h');
                                        $($t).jqGrid("editCell", $t.p.iRow, i, false);
                                    }
                                    break;
                                case 39 :
                                    if ($t.p.iCol + 1 <= $t.p.colModel.length - 1) {
                                        i = findNextVisible($t.p.iCol + 1, 'rgt');
                                        scrollGrid($t.p.iRow, i, 'h');
                                        $($t).jqGrid("editCell", $t.p.iRow, i, false);
                                    }
                                    break;
                                case 13:
                                    if (parseInt($t.p.iCol, 10) >= 0 && parseInt($t.p.iRow, 10) >= 0) {
                                        $($t).jqGrid("editCell", $t.p.iRow, $t.p.iCol, true);
                                    }
                                    break;
                                default :
                                    return true;
                            }
                            return false;
                        });


                });
            },
            editStop:function (model) {
                if(this.length<=0) return;
                var $t = this[0];
                if (!$t.grid || $t.p.cellEdit !== true) {
                    return;
                }
                model = model || true;
                //add by jlg.
                //add by jlg.
                if ($t.p.savedRow.length > 0) {
                    // save the cell
                    if($t.p.savedRow[0].saving === undefined){
                        $t.p.savedRow[0].saving = true;
                        if(model){
                            $($t).jqGrid("saveCell", $t.p.savedRow[0].id, $t.p.savedRow[0].ic);
                        }else{
                            $($t).jqGrid("restoreCell", $t.p.savedRow[0].id, $t.p.savedRow[0].ic);
                        }
                        if($t.p.savedRow[0]){
                            delete $t.p.savedRow[0].saving;
                        }
                    }else{
                        $.jgrid.focusKnv($t);
                    }
                }
            }
        });



        //
        waf.defineCustomeClass("celleditor.defaultEditor",null,{
            table:null,
            opts:{},
            iRow:0,
            iCol:0,
            colModel:{},
            nmjq:"",
            elem:null,
            cell:null,
            canValidate:false,
            constructor:function(table,opts,iRow,iCol,cell){
                if(table){
                    this.table = table;
                    this.opts = opts;
                    this.iRow = iRow;
                    this.iCol = iCol;
                    this.colModel = table.p.colModel[iCol];
                    this.nmjq = this.colModel.name;
                    this.cell = cell;
                }
            },
            init:function(){
                var $t = this.table;
                if(!this.cell){
                    this.cell =  $("td:eq(" + this.iCol + ")", $t.rows[this.iRow]);
                }
                if(!$t.closestForm){
                    $t.closestForm = $($t).jqGrid("findParentForm");
                }
                this.form = $t.closestForm;
                if(this.form){
                    this.validator = $.data(this.form[0], "validator");
                }
                if(this.colModel.frozen){
                    this.currentRow = $("#"+$.jgrid.jqID(this.table.p.id)+"_frozen")[0].rows[this.iRow];
                    this.frozenCell = $("td:eq(" + this.iCol + ")", this.currentRow);
                }else{
                    this.currentRow = $t.rows[this.iRow];
                }
            },
            edit:function(value){
                this.init();
                this.createEditor(value);
                this.show();
            },
            createEditor:function(value){
                var self = this;
                var elem = _waf2_createInput_("text", this.opts, value);
                $(elem).attr("ctrlrole", "text").attr("grid", this.opts.grid.id + "$" + this.opts.id);
                var inputJson = this.opts.inputJson;
                var op = _waf2_filterOptions_(this.opts);
                op.value = value;
                if (inputJson) {
                    inputJson = $.extend(inputJson, op);
                    inputJson.operateState = "EDIT";
                    $(elem).wafText(inputJson);
                    if (this.opts.validateJson) {
                        this.opts.validateJson.errorShowMode = "float";
                        this.opts.validateJson.validateOnSumbit = false;
                        if(!this.opts.validateJson.validatetrigger) this.opts.validateJson.validatetrigger =  "focus datachange";
                        $(elem).wafValidator("loadElemValidator", this.opts.validateJson);
                    }
                }
                this.elem = elem;
            },
            validate:function(){
                if(this.canValidate){
                    this.validator.initElement($("#" + this.opts.id,$(this.table)),false);
                }
            },
            getValue:function(){
                var $t = this.table;
                //
                var v = $("#" + this.getId(), this.currentRow).val();
                return [v,v];
            },
            show:function(){
                var self = this,cell=(this.frozenCell)?this.frozenCell:this.cell;
                $(cell).html("").append(this.elem).attr("tabindex", "0");
                if (this.form && this.validator && this.validator != null && this.opts.validateJson) {
                    this.canValidate = true;
                    this.validate();
                    var trigggerEvent = "";
                    if(this.opts.validateJson.validatetrigger){
                        if(this.opts.validateJson.validatetrigger.indexOf("focus")>-1){
                            trigggerEvent += "focus ";
                        }
                        if(this.opts.validateJson.validatetrigger.indexOf("click")>-1){
                            trigggerEvent += "click ";
                        }
                        if(this.opts.validateJson.validatetrigger.indexOf("keyup")>-1){
                            trigggerEvent += "keyup ";
                        }
                        if(this.opts.validateJson.validatetrigger.indexOf("datachange")>-1){
                            trigggerEvent += "change ";
                        }
                        if(this.opts.validateJson.validatetrigger.indexOf("blur")>-1){
                            trigggerEvent += "blur ";
                        }
                    }
                    $(this.form).validateDelegate($("#" + this.opts.id,$(this.table)), trigggerEvent, _waf2_delegate_);
                }
                window.setTimeout(function () {
                    $("div.ui-validate-div").remove();
                    $("#" + self.opts.id,this.currentRow).focus().select();
                }, 0);
            },
            clear:function(){
                $(this.elem).remove();
                $.powerFloat&&$.powerFloat.hide();
            },
            getId:function(){
                return this.opts.id;
            }
        });

        /**wafText**/
        waf.defineCustomeClass("celleditor.waftext",celleditor.defaultEditor,{});

        /**wafcheckbox**/
        waf.defineCustomeClass("celleditor.wafcheckbox",celleditor.defaultEditor,{
            createEditor:function(value){
                var self = this;
                var elem = _waf2_createInput_("checkbox", this.opts, value);
                $(elem).attr("ctrlrole", "checkbox").attr("grid", this.opts.grid.id + "$" + this.opts.id);
                var inputJson = this.opts.inputJson;
                var op=_waf2_filterOptions_(this.opts);
                op.checked = value;
                if (inputJson) {
                    inputJson = $.extend(inputJson, op);
                    inputJson.operateState = "EDIT";
                    $(elem).wafCheckbox(inputJson);
                    if (this.opts.validateJson) {
                        this.opts.validateJson.errorShowMode = "float";
                        this.opts.validateJson.validateOnSumbit = false;
                        if(!this.opts.validateJson.validatetrigger) this.opts.validateJson.validatetrigger =  "click";
                        $(elem).wafValidator("loadElemValidator", this.opts.validateJson);
                    }
                }
                this.elem = elem;
            },
            getValue:function(){
                var $t = this.table,oBoolean = {"1":$.jgrid.booleanCaption.yes, "0":$.jgrid.booleanCaption.no},v;
                if (!$.type.isUndefined(this.colModel.formatoptions) && !$.type.isUndefined(this.colModel.formatoptions.value)) {
                    oBoolean = this.colModel.formatoptions.value;
                } else if (!$.type.isUndefined(this.colModel.editoptions) && !$.type.isUndefined(this.colModel.editoptions.value)) {
                    oBoolean = this.colModel.editoptions.value;
                }
//            var checked = $("#" + this.iRow + "_" + this.nmjq, $t.rows[this.iRow]).attr("checked") === "checked";
                var checked = $(this.elem, $t.rows[this.iRow]).attr("checked") === "checked";
                if(checked){
                    v = $(this.elem, $t.rows[this.iRow]).attr("value");
                }else{
                    var real = $(this.elem, $t.rows[this.iRow]).attr("value");
                    for(var p in oBoolean){
                        if(p!=real){
                            v = p;
                            break;
                        }
                    }
                }
                return [v,v];
            }
        });

        /**wafMultiLangBox**/
        waf.defineCustomeClass("celleditor.wafMultiLangBox",celleditor.defaultEditor,{
            createEditor:function(value){
                //cellvall1,l2,l3
                if(value && typeof value ==="string" && value.indexOf("{")>-1){
                    value = waf.toJSONObject(value);
                }
                var self = this;
                var elem = _waf2_createInput_("text", this.opts, value);
                $(elem).attr("ctrlrole", "multiLangBox").attr("grid", this.opts.grid.id + "$" + this.opts.id);
                //WAF.
                var inputJson = this.opts.inputJson;
                var op = _waf2_filterOptions_(this.opts);
                var lang = inputJson.defaultLang || waf.getContext().locale || "l2";
                var tmp = {l1: null, l2: null,l3: null};
                if($.type.isObject(value)){
                    tmp = $.extend(tmp,value);
                }else{
                    tmp[lang] = value;
                }
                op.value = tmp;
                if (inputJson) {
                    inputJson = $.extend(inputJson, op);
                    inputJson.operateState = "EDIT";
                    $(elem).wafMultiLangBox(inputJson);
                    if (this.opts.validateJson) {
                        this.opts.validateJson.errorShowMode = "float";
                        this.opts.validateJson.validateOnSumbit = false;
                        if(!this.opts.validateJson.validatetrigger) this.opts.validateJson.validatetrigger =  "focus datachange";
                        $(elem).wafValidator("loadElemValidator", this.opts.validateJson);
                    }
                }
                elem = $(elem).closest("div.ui-multiLangBox");
//            $(elem).css({"width":"100%"});
                this.elem = elem;
            },
            getValue:function(){
                var $t = this.table;
//            var v = $("#" + this.iRow + "_" + this.nmjq, $t.rows[this.iRow]).wafMultiLangBox("option","value");
                var v = $(this.elem).find("input.ui-multiLangBox-input").wafMultiLangBox("option","value");
                v = waf.toJSONString(v);
                return [v,v];
            },
            clear:function(){
                $(this.elem).find("input").remove();
                $(this.elem).remove();
                $.powerFloat&&$.powerFloat.hide();
            }
        });

        /**autoComplete**/
        waf.defineCustomeClass("celleditor.autoComplete",celleditor.defaultEditor,{
            createEditor:function(value){
                var self = this;
                var elem = _waf2_createInput_("text", this.opts, value);
                $(elem).attr("ctrlrole", "autoComplete").attr("grid", this.opts.grid.id + "$" + this.opts.id);
                var inputJson = this.opts.inputJson;
                var autoCompleteJson = this.opts.autoCompleteJson;
                var op=_waf2_filterOptions_(this.opts);
                op.value = value;
                if (inputJson) {
                    inputJson = $.extend(inputJson, op);
                    inputJson.operateState = "EDIT";
                    $(elem).wafText(inputJson);
                    if (this.opts.validateJson) {
                        this.opts.validateJson.errorShowMode = "float";
                        this.opts.validateJson.validateOnSumbit = false;
                        if(!this.opts.validateJson.validatetrigger) this.opts.validateJson.validatetrigger =  "focus datachange";
                        $(elem).wafValidator("loadElemValidator", this.opts.validateJson);
                    }
                }
                if (autoCompleteJson) {
                    $(elem).autocomplete(autoCompleteJson);
                }
                this.elem = elem;
            }
        });

        /**f7**/
        waf.defineCustomeClass("celleditor.f7",celleditor.defaultEditor,{
            createEditor:function(value){
                var self = this;
                var elem,input = _waf2_createInput_("text", this.opts, value);
                $(input).attr("ctrlrole", "promptBox").attr("grid", this.opts.grid.id + "$" + this.opts.id);
                if (this.opts) {
                    var f7Json = this.opts.f7Json, subWidgetName = this.opts.subWidgetName, subTagJson = this.opts.subTagJson;
                    var op = _waf2_filterOptions_(this.opts);
                    var f7_json = f7Json || {};
                    f7_json = $.extend(f7_json, op);
                    f7_json.subWidgetName = subWidgetName;
                    f7_json.subWidgetOptions = subTagJson;
                    f7_json.value = value;
                    f7_json.operateState = "EDIT";
                    $(input).wafPromptBox(f7_json);
                    if (this.opts.validateJson) {
                        this.opts.validateJson.errorShowMode = "float";
                        this.opts.validateJson.validateOnSumbit = false;
                        if(!this.opts.validateJson.validatetrigger) this.opts.validateJson.validatetrigger =  "focus datachange";
                        $(input).wafValidator("loadElemValidator", this.opts.validateJson);
                    }

                    //hidden
                    var hidden = document.createElement("input");
                    hidden.type = "hidden";
                    hidden.value = value;
                    hidden.name = "hidd_name_" + this.opts.id;
                    hidden.id = this.opts.id + "_el";

//                $(input).css("width", "100%");
                    elem = $(input).closest(".ui-f7-frame").eq(0);
                    $(hidden).appendTo($(elem));
//                $(elem).css("width", "100%");
                }
                this.elem = elem;
            },
            getValue:function(){
                var $t = this.table;
//            var v = $("#" + this.iRow + "_" + this.nmjq, $t.rows[this.iRow]).wafPromptBox("getValue");
                var v = $(this.elem).find("input.ui-f7").wafPromptBox("getValue");
                var v2 = v;
                if(v2==null){v2=undefined;}
                if (v2 === undefined || v2 == "&nbsp;" || v2 == "&#160;" || (v2 instanceof Array && v2.length===0) || (typeof v2==="string" && v2.length === 1 && v2.charCodeAt(0) == 160)) {
                    v2 = '';
                }
                return [v,v2];
            },
            clear:function(){
                $(this.elem).find("input").remove();
                $(this.elem).remove();
                $("#f7-panel-" + this.opts.id).remove();
            }
        });

        /**datepicker**/
        waf.defineCustomeClass("celleditor.datepicker",celleditor.defaultEditor,{
            createEditor:function(value){
                var self = this,parent,elem,date,
                    datepickerjson = this.opts.datepickerjson,
                    type = datepickerjson.type;
                elem = _waf2_createInput_("text", this.opts, value);
                $(elem).attr("ctrlrole", "datePicker").attr("grid", this.opts.grid.id + "$" + this.opts.id).css("width", "100%");
                //WAF.
                var op = _waf2_filterOptions_(this.opts);
                if (datepickerjson) {
                    datepickerjson = $.extend(datepickerjson, op);
                    datepickerjson.altField = "#" + this.opts.id + "_el";
                    datepickerjson.altFormat = "yy-mm-dd";
                    datepickerjson.value=value;
                    datepickerjson.operateState = "EDIT";
                    $(elem).wafDatePicker(datepickerjson);
                    if (this.opts.validateJson) {
                        this.opts.validateJson.errorShowMode = "float";
                        this.opts.validateJson.validateOnSumbit = false;
                        if(!this.opts.validateJson.validatetrigger) this.opts.validateJson.validatetrigger =  "focus datachange";
                        $(elem).wafValidator("loadElemValidator", this.opts.validateJson);
                    }
                }

                //hidden
                var hidden = document.createElement("input");
                hidden.type = "hidden";
                hidden.name = "hidd_name_" + this.opts.id;
                hidden.id = this.opts.id + "_el";
                hidden.value = value;

                parent = $(elem).closest(".ui-datepicker-frame").eq(0);
//            $(parent).append($(hidden)).css("width", "100%").css("height","100%");
                $(parent).append($(hidden));
                this.elem = parent;
//            this.tmp = value;
            },
            getValue:function(){
                var $t = this.table,datepickerjson = this.opts.datepickerjson,v="",
//                date = $("#" + this.iRow + "_" + this.nmjq, $t.rows[this.iRow]).wafDatePicker("getValue");
                    date = $(this.elem).find("input.hasDatepicker").wafDatePicker("getValue");
                if(date && date!=null){
                    v =waf.wafDatePicker.formatDateTime("yy-mm-dd", "hh:mm:ss", date);
                }
                return [v,v];
            }
        });

        /**timepicker**/
        waf.defineCustomeClass("celleditor.timepicker",celleditor.defaultEditor,{
            createEditor:function(value){
                var self = this,parent,elem,timepickerjson = this.opts.inputJson;
                elem = _waf2_createInput_("text", this.opts, value);
                $(elem).attr("ctrlrole", "timePicker").attr("grid", this.opts.grid.id + "$" + this.opts.id).css("width", "100%");
                //WAF.
                var op = _waf2_filterOptions_(this.opts);
                if (timepickerjson) {
                    timepickerjson = $.extend(timepickerjson, op);
                    timepickerjson.submitField = "#" + this.opts.id + "_el";
                    if(value) timepickerjson.value = value;
                    timepickerjson.operateState = "EDIT";
                    $(elem).wafTimePicker(timepickerjson);
                    if (this.opts.validateJson) {
                        this.opts.validateJson.errorShowMode = "float";
                        this.opts.validateJson.validateOnSumbit = false;
                        if(!this.opts.validateJson.validatetrigger) this.opts.validateJson.validatetrigger =  "focus datachange";
                        $(elem).wafValidator("loadElemValidator", this.opts.validateJson);
                    }
                }

                //hidden
                var hidden = document.createElement("input");
                hidden.type = "hidden";
                hidden.name = "hidd_name_" + this.opts.id;
                hidden.id = this.opts.id + "_el";

                parent = $(elem).closest(".ui-timepicker-frame").eq(0);
                $(parent).find(".ui-timepicker-layout").append($(hidden));
//            $(parent).css("width", "100%").css("height","100%");
                this.elem = parent;
            },
            getValue:function(){
                var $t = this.table,ret="";
//            var v = $("#" + this.iRow + "_" + this.nmjq, $t.rows[this.iRow]).wafTimePicker("getValue");
                var v = $(this.elem).find("input.ui-timepicker").wafTimePicker("getValue");
                if(v){
                    ret = v.hour+":"+v.minute+":"+v.second;
                }
                return [ret,ret];
            },
            clear:function(){
                $(this.elem).find("input").remove();
                $(this.elem).remove();
            }
        });

        /**wafselect**/
        waf.defineCustomeClass("celleditor.wafselect",celleditor.defaultEditor,{
            createEditor:function(value){
                var self =this;
                var elem = document.createElement("select");
                $(elem).attr("ctrlrole", "select").attr("grid", this.opts.grid.id + "$" + this.opts.id);
                elem.id = this.opts.id;
                var selectJson = this.opts.selectJson;
                if (this.opts.filterJson) {
                    selectJson.filterJson = this.opts.filterJson;
                }
                var op = _waf2_filterOptions_(this.opts);
                selectJson = $.extend(selectJson, op);
                selectJson.value = value;
                selectJson.operateState = "EDIT";
                $(elem).wafSelect(selectJson);
                if (this.opts.validateJson) {
                    this.opts.validateJson.errorShowMode = "float";
                    this.opts.validateJson.validateOnSumbit = false;
                    if(!this.opts.validateJson.validatetrigger) this.opts.validateJson.validatetrigger =  "focus datachange";
                    $(elem).wafValidator("loadElemValidator", this.opts.validateJson);
                }
                $(elem).wrap("<div  class='selectEditor'></div>");
                $(elem).parent().css("width", "100%").css("height","100%");
                var tmp = $(elem).data("multiselect");
                $(tmp.button).appendTo($(elem).parent());

                //hidden
                var hidden = document.createElement("input");
                hidden.type = "hidden";
                hidden.value = value;
                hidden.name = "hidd_name_" + this.opts.id;
                hidden.id = this.opts.id + "_hidden";
                $(hidden).appendTo($(elem).parent());

//            $(tmp.button).css("width", "100%");
                elem = $(elem).parent();
                this.elem = elem;
            },
            getValue:function(){
                var $t = this.table;
//            var v = $("#" + this.iRow + "_" + this.nmjq, $t.rows[this.iRow]).wafSelect("getValue");
                var v = $(this.elem).find("select").wafSelect("getValue");
                return [v,v];
            },
            clear:function(){
                $(this.elem).find("select").remove();
                $(this.elem).remove();
                $("#ui-multiselect-menu-" + this.opts.id).remove();
            },
            show:function(){
                celleditor.defaultEditor.prototype.show.call(this);
                //
                var self = this;
                window.setTimeout(function () {
                    $(self.elem,$(self.table)).children("div").focus();
                }, 0);
            }
        })

        /**numberfield**/
        waf.defineCustomeClass("celleditor.numberfield",celleditor.defaultEditor,{
            createEditor:function(value){
                var self =this;
                var elem = _waf2_createInput_("text", this.opts, value);
                $(elem).attr("ctrlrole", "numberField").attr("grid", this.opts.grid.id + "$" + this.opts.id);
                //WAF.
                var inputJson = this.opts.inputJson;
                var op = _waf2_filterOptions_(this.opts);
                op.value = value;
                if (inputJson) {
                    inputJson = $.extend(inputJson, op);
                    inputJson.operateState = "EDIT";
                    $(elem).wafNumberField(inputJson);
                    $(elem).css("width", "100%");
                    if (this.opts.validateJson) {
                        this.opts.validateJson.errorShowMode = "float";
                        this.opts.validateJson.validateOnSumbit = false;
                        if(!this.opts.validateJson.validatetrigger) this.opts.validateJson.validatetrigger =  "focus datachange";
                        $(elem).wafValidator("loadElemValidator", this.opts.validateJson);
                    }
                    //hidden
                    var hidden = document.createElement("input");
                    hidden.type = "hidden";
                    hidden.value = value;
                    hidden.name = "hidd_name_" + this.opts.id;
                    hidden.id = this.opts.id + "_el";

                    $(elem).wrap("<div class='numberfieldEditor'></div>");
                    elem = $(elem).parent();
//                $(elem).css("width", "100%");
                    $(hidden).appendTo($(elem));
                }
                this.elem = elem;
            },
            getValue:function(){
                var $t = this.table;
//            var v = $("#" + this.iRow + "_" + this.nmjq, $t.rows[this.iRow]).wafNumberField("getValue");
                var v = this.elem.find("input.ui-numberfield").wafNumberField("getValue");
                var v2 = v;
                if(v2==null){v2=undefined;}
                if (v2 === undefined || v2 == "&nbsp;" || v2 == "&#160;" || (v2 instanceof Array && v2.length===0) || (typeof v2==="string" && v2.length === 1 && v2.charCodeAt(0) == 160)) {
                    v2 = '';
                }
                return [v,v2];
            }
        });

        /**wafTextArea**/
        waf.defineCustomeClass("celleditor.wafTextArea",celleditor.defaultEditor,{
            createEditor:function(value){
                var self = this,elem = document.createElement("textarea"),cell;
                elem.id = this.opts.id;
                elem.value = value;
                $(elem).attr("ctrlrole", "textarea").attr("grid", this.opts.grid.id + "$" + this.opts.id);
                var inputJson = this.opts.inputJson;
                var op = _waf2_filterOptions_(this.opts);
                op.value = value;
                if (inputJson) {
                    inputJson = $.extend(inputJson, op);
                    inputJson.operateState = "EDIT";
                    $(elem).wafTextarea(inputJson);
                    if (this.opts.validateJson) {
                        this.opts.validateJson.errorShowMode = "float";
                        this.opts.validateJson.validateOnSumbit = false;
                        if(!this.opts.validateJson.validatetrigger) this.opts.validateJson.validatetrigger =  "focus datachange";
                        $(elem).wafValidator("loadElemValidator", this.opts.validateJson);
                    }
                }
                $(elem).css({"overflow-y":"auto"});
                this.elem = elem;
                cell=(this.frozenCell)?this.frozenCell:this.cell;
                if(cell){
                    $(this.elem).height($(cell).height());
                }
            }
        });

        /**wafMultiLangArea**/
        waf.defineCustomeClass("celleditor.wafMultiLangArea",celleditor.defaultEditor,{
            createEditor:function(value){
                //cellvall1,l2,l3
                if(value && typeof value ==="string" && value.indexOf("{")>-1){
                    value = waf.toJSONObject(value);
                }
                var self =this;
                var elem = document.createElement("textarea");
                elem.id = this.opts.id;
                $(elem).attr("ctrlrole", "multiLangArea").attr("grid", this.opts.grid.id + "$" + this.opts.id);
                var inputJson = this.opts.inputJson;
                var op =_waf2_filterOptions_(this.opts);
                var lang = inputJson.defaultLang || waf.getContext().locale || "l2";
                var tmp = {l1: null, l2: null,l3: null};
                if($.type.isObject(value)){
                    tmp = $.extend(tmp,value);
                }else{
                    tmp[lang] = value;
                }
                op.value = tmp;
                if (inputJson) {
                    inputJson = $.extend(inputJson, op);
                    inputJson.operateState = "EDIT";
                    $(elem).wafMultiLangArea(inputJson);
                    if (this.opts.validateJson) {
                        this.opts.validateJson.errorShowMode = "float";
                        this.opts.validateJson.validateOnSumbit = false;
                        if(!this.opts.validateJson.validatetrigger) this.opts.validateJson.validatetrigger =  "focus datachange";
                        $(elem).wafValidator("loadElemValidator", this.opts.validateJson);
                    }
                }
//            $(elem).css("height","100%");
                elem =$(elem).closest("div.ui-multiLangArea");
//            $(elem).css({"width":"100%"});
                this.elem = elem;
            },
            getValue:function(){
                var $t = this.table;
//            var v = $("#" + this.iRow + "_" + this.nmjq, $t.rows[this.iRow]).wafMultiLangArea("option","value");
                var v = $(this.elem).find("textarea.ui-multiLangArea-input").wafMultiLangArea("option","value");
                v = waf.toJSONString(v);
                return [v,v];
            },
            clear:function(){
                $(this.elem).find("textarea").remove();
                $(this.elem).remove();
                $.powerFloat&&$.powerFloat.hide();
            }
        });

        /**wafradio**/
        waf.defineCustomeClass("celleditor.wafradio",celleditor.defaultEditor,{
            createEditor:function(value){
                var self = this;
                var elem = _waf2_createInput_("radio", this.opts, value);
                var inputJson = this.opts.inputJson;
                var op = _waf2_filterOptions_(this.opts);
                op.value = value;
                if (inputJson) {
                    inputJson = $.extend(inputJson, op);
                    inputJson.operateState = "EDIT";
                    $(elem).wafRadio(inputJson);
                    if (this.opts.validateJson) {
                        this.opts.validateJson.errorShowMode = "float";
                        this.opts.validateJson.validateOnSumbit = false;
                        if(!this.opts.validateJson.validatetrigger) this.opts.validateJson.validatetrigger =  "click";
                        $(elem).wafValidator("loadElemValidator", this.opts.validateJson);
                    }
                }
                this.elem = elem;
            },
            getValue:function(){
                var $t = this.table;
                var v = $(this.elem).wafRadio("isChecked");
                return [v,v];
            }
        });

        /**checkbox**/
        waf.defineCustomeClass("celleditor.checkbox",celleditor.defaultEditor,{
            createEditor:function(value){
                var self = this;
                var elem = $("input[type=checkbox]",this.cell);
                this.elem = elem;
                //focus
                window.setTimeout(function () {
                    $(elem,$(self.table)).focus().select();
                }, 0);
            },
            getValue:function(){
                var newValue;
                var elem = $("input[type=checkbox]",this.cell);
                var checked = $(elem).is(":checked");
                var values = (this.colModel.formatoptions && this.colModel.formatoptions.value) ? this.colModel.formatoptions.value : "1:0";
                if(values){
                    values = values.split(":");
                }else{
                    values = ["1","0"];
                }
                if(checked){
                    newValue = values[0];
                }else{
                    newValue = values[1];
                }
                return [newValue,newValue];
            },
            show:function(){
            }
        });
        /**radioGroup**/
        waf.defineCustomeClass("celleditor.radioGroup",celleditor.defaultEditor,{
            createEditor:function(value){
                var self = this;
                var elem = $("span>input:radio:checked",this.cell);
                if(elem.length<=0){
                    elem = $("span>input:radio",this.cell);
                }
                this.elem = elem;
                //focus
                window.setTimeout(function () {
                    $(elem,$(self.table)).focus().select();
                }, 0);
            },
            getValue:function(){
                var value = $('span>input:radio:checked',this.cell).val();
                if (value === undefined || value == "&nbsp;" || value == "&#160;") {
                    value = '';
                }
                return [value,value];
            },
            show:function(){
            }
        });



        //
        waf.defineCustomeClass("cellformatter.f7", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                if ($.type.isUndefined(cellval) || cellval === null) return "";
                if (typeof cellval === "string") {
                    try {
                        cellval = $.parseJSON(cellval);
                    } catch (e) {
                        return cellval === "" ? cellformatter.defaultFormatter.prototype.format.call(this, cellval, rwd) : ret;
                    }
                }
                var displayFormat, ret = cellval;
                if (!$.type.isUndefined(this.opts.colModel.formatoptions) && this.opts.colModel.formatoptions!=null) {
                    displayFormat = this.opts.colModel.formatoptions.displayFormat;
                } else if (!$.type.isUndefined(this.opts.colModel.editoptions) && this.opts.colModel.editoptions!=null) {
                    displayFormat = this.opts.colModel.editoptions.f7Json.displayFormat;
                }
                if (displayFormat == null) displayFormat = "{name}";
                if (displayFormat) {
                    //
                    var storeValue = $(this.table).data("storeValue") || {};
                    storeValue[this.opts.colModel.name + "-" + this.opts.rowId] = cellval;
                    $(this.table).data("storeValue", storeValue);
                    return $.wafPromptBox.format(cellval, displayFormat);
                }
                return  cellval === "" ? cellformatter.defaultFormatter.prototype.format.call(this, cellval, rwd) : ret;
            },
            unformat:function (cell, rowId) {
                var ret, val = $(cell).text();    //
                if (val && val.length > 0) {
                    var storeValue = $(this.table).data("storeValue");
                    if (storeValue) {
                        ret = storeValue[this.opts.colModel.name + "-" + this.opts.rowId];
                    }
                }else{
                    ret = "";
                }
                return $.fmatter.util.filterNull(ret);
            }
        });
        //datepicker
        waf.defineCustomeClass("cellformatter.datepicker", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                var dateFormat;
                if (!$.type.isUndefined(this.opts.colModel.editoptions) && this.opts.colModel.editoptions!=null) {
                    dateFormat = this.opts.colModel.editoptions.datepickerjson.dateFormat || waf.wafDatePicker._defaults.dateFormat;
                }
                if (cellval) {
                    if (cellval && cellval.indexOf("-") > -1) {
                        try {
                            //yyyy-mm-dd hh:mm:ss
                            var date = waf.datepicker.parseDateTime("yy-mm-dd","hh:mm:ss", cellval);
                            if (dateFormat) {
                                if("datetime" === this.opts.colModel.editoptions.datepickerjson.type){
                                    return waf.datepicker.formatDateTime(dateFormat,"hh:mm:ss",date);
                                }else{
                                    return waf.datepicker.formatDate(dateFormat,date);
                                }
                            }
                        } catch (e) {
                        }
                    }
                }
                return  cellformatter.defaultFormatter.prototype.format.call(this, cellval, rwd);
            },
            unformat:function (cell, rowId) {
                var cellval = $(cell).text(),ret;
                if (!$.type.isUndefined(this.opts.colModel.editoptions) && this.opts.colModel.editoptions!=null) {
                    var dateFormat = this.opts.colModel.editoptions.datepickerjson.dateFormat|| waf.wafDatePicker._defaults.dateFormat;
                    var type = this.opts.colModel.editoptions.datepickerjson.type;
                    try {
                        var date;
                        if("datetime" === type){
                            date = waf.datepicker.parseDateTime(dateFormat,"hh:mm:ss", cellval);
                        }else{
                            date = waf.datepicker.parseDate(dateFormat, cellval);
                        }
                        ret = waf.datepicker.formatDateTime("yy-mm-dd","hh:mm:ss", date);
                    } catch (e1) {
                    }
                }
                if(!ret) ret = "";
                return $.fmatter.util.filterNull(ret);
            }
        });
        //timepicker
        waf.defineCustomeClass("cellformatter.timepicker", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                var inputJson = {};
                if (!$.type.isUndefined(this.opts.colModel.editoptions) && this.opts.colModel.editoptions!=null) {
                    inputJson = this.opts.colModel.editoptions.inputJson;
                }
                if (cellval) {
                    return "<span value='" + cellval + "'>" + $.wafTimePicker.format(cellval,inputJson) + "</span>";
                }
                return  "<span></span>";
            },
            unformat:function (cell, rowId) {
                var cellval = $(cell).html();
                var ret = $(cellval).attr("value");
                if(!ret){
                    ret = "";
                }
                return $.fmatter.util.filterNull(ret);
            }
        });
        //numberfield
        waf.defineCustomeClass("cellformatter.numberfield", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                var formatJson;
                if (!$.type.isUndefined(this.opts.colModel.editoptions)) {
                    formatJson = this.opts.colModel.editoptions;
                }
                if (formatJson && formatJson.inputJson) {
                    if (cellval && typeof cellval == "string") {
                        try {
                            cellval = parseFloat(cellval);
                        } catch (e) {
                        }
                    }
                    if(cellval===undefined || cellval===""){
                        cellval = formatJson.inputJson.value?parseFloat(formatJson.inputJson.value):"";
                    }
                    if (!$.isNaN(cellval)) {
                        return "<span value='" + cellval + "'>" + $.wafNumberField.format(cellval, formatJson.inputJson) + "</span>";
                    }
                }
                return  "<span></span>";
            },
            unformat:function (cellval, rowId) {
                var cell = $(cellval).html();
                var ret = $(cell).attr("value");
                if(!ret){
                    ret = "";
                }
                ret =  $.fmatter.util.filterNull(ret);
                if(ret && !$.isNaN(ret)){
                    ret = parseFloat(ret);
                }
                return ret;
            }
        });
        //wafTextArea
        waf.defineCustomeClass("cellformatter.wafTextArea", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                if ($.type.isUndefined(cellval) || cellval === null) return "";
                return $.wafutil.getMultiValue(cellval);
            },
            unformat:function (cell, rowId) {
                var cellval = $(cell).text();
                return $.fmatter.util.filterNull(cellval);
            }
        });
        //waftext
        waf.defineCustomeClass("cellformatter.waftext", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                if ($.type.isUndefined(cellval) || cellval === null) return "";
                return $.wafutil.getMultiValue(cellval);
            },
            unformat:function (cell, rowId) {
                var cellval = $(cell).text();
                return $.fmatter.util.filterNull(cellval);
            }
        });
        //wafradioGroup
        waf.defineCustomeClass("cellformatter.radioGroup", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                var op,checked,ds="";
                if(this.opts.colModel.formatoptions){
                    op = $.extend({}, this.opts.colModel.formatoptions);
                }else if(this.opts.colModel.editoptions && this.opts.colModel.editoptions.items){
                    op = $.extend({items:this.opts.colModel.editoptions.items}, this.opts.colModel.editoptions.inputJson);
                }
                //
                if(typeof cellval === "object"){
                    op.value = cellval.value+"";
                }else{
                    op.value = cellval+"";
                }
                var id = "rgb_"+this.gid + "_" + $.wafutil.replaceAll(this.opts.colModel.name,".","-") + "_"+ $.wafutil.replaceSpecialChar(this.opts.rowId,"");
                var elem = document.createElement("span");
                elem.id = id;
                //
                if(waf.getUrlParams){
                    if($.wafutil.isViewOperateState()){
                        op.disabled = true;
                    }
                }
                op.id=id;
                op.name=id;
                $(elem).wafRadioGroup(op);
                $(elem).attr("oldValue",op.value);

                var self = this.table;
                $(self).undelegate("#"+id,"click");
                $(self).delegate("#"+id,"click",function(e){
                    var input = this;
                    var newValue,oldValue;
                    var td = $(event.target).closest("td",self);
                    var parent = td.parent("tr",self);
                    if(td.length>0 && parent.length>0){
                        var iCol = td[0].cellIndex;
                        var iRow = parent[0].rowIndex;
                        var canEdit = true,old;
                        if (self.p.savedRow.length > 0) {
                            old = self.p.savedRow[0];
                            if(old && iRow == old.id && iCol == old.ic){
                                canEdit = false;
                            }
                        }
                        if(canEdit){
                            oldValue = $("span",td).attr("oldValue");
                            $(self).jqGrid("editCell",iRow,iCol,true);
                            //
                            //check
                            if (self.p.savedRow.length > 0) {
                                old = self.p.savedRow[0];
                                if(old && iRow == old.id && iCol == old.ic){
                                    //
                                    self.p.savedRow[0].v = oldValue;
                                }
                            }
                            newValue = $('span>input:radio:checked',td).val();
                            $("span",td).attr("oldValue",newValue);
                        }
                    }
                });

                $(self).undelegate("#"+id,"keydown");
                $(self).delegate("#"+id,"keydown",function(e){
                    if(e.keyCode == 37 || e.keyCode == 39 ){
                        e.stopPropagation();
                    }
                });
                return $(elem).outerHTML();
            },
            unformat:function(cell,rowId){
                var value = $('span>input:radio:checked',cell).val();
                return $.fmatter.util.filterNull(value);
            }
        });
        //wafMultiLangArea
        waf.defineCustomeClass("cellformatter.wafMultiLangArea", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                if ($.type.isUndefined(cellval) || cellval === null) return "";
                //cellvall1,l2,l3
                if(cellval && $.type.isString(cellval)){
                    if(cellval.indexOf("{")>-1){
                        cellval = waf.toJSONObject(cellval);
                    }else if($.type.isObject(rwd[this.opts.colModel.name])){
                        cellval = rwd[this.opts.colModel.name];
                    }
                }
                var ret = cellval;
                if (typeof cellval === "object") {
                    var defaultlang = "l2";
                    if (!$.type.isUndefined(this.opts.colModel.formatoptions) && !$.type.isUndefined(this.opts.colModel.formatoptions.defaultLang)) {
                        defaultlang = this.opts.colModel.formatoptions.defaultLang;
                    } else if (!$.type.isUndefined(this.opts.colModel.editoptions) && !$.type.isUndefined(this.opts.colModel.editoptions.inputJson.defaultLang)) {
                        defaultlang = this.opts.colModel.editoptions.inputJson.defaultLang;
                    }
                    //
                    var storeValue = $(this.table).data("storeValue") || {};
                    storeValue[this.opts.colModel.name + "-" + this.opts.rowId] = cellval;
                    $(this.table).data("storeValue", storeValue);
                    ret = cellval[defaultlang];
                }
                //cellval.
                return  cellval === "" ? cellformatter.defaultFormatter.prototype.format.call(this, cellval, rwd) : ret;
            },
            unformat:function (cell, rowId) {
                var ret;
                var storeValue = $(this.table).data("storeValue");
                if (storeValue) {
                    ret = storeValue[this.opts.colModel.name + "-" + this.opts.rowId];
                }
                if (undefined === ret) {
                    ret = $(cell).text();
                    ret = $.fmatter.util.filterNull(ret);
                    if(ret){
                        var defaultlang = "l2";
                        if (!$.type.isUndefined(this.opts.colModel.formatoptions) && !$.type.isUndefined(this.opts.colModel.formatoptions.defaultLang)) {
                            defaultlang = this.opts.colModel.formatoptions.defaultLang;
                        } else if (!$.type.isUndefined(this.opts.colModel.editoptions) && !$.type.isUndefined(this.opts.colModel.editoptions.inputJson.defaultLang)) {
                            defaultlang = this.opts.colModel.editoptions.inputJson.defaultLang;
                        }
                        var tmp = {"l1":"", "l2":"", "l3":""};
                        tmp[defaultlang] = ret;
                        ret = tmp;
                    }else{
                        ret = undefined;
                    }
                }
                if(ret==null) return undefined;
                if(!$.type.isObject(ret)){
                    ret = undefined;
                }
                return waf.toJSONString(ret);
            }
        });
        //wafMultiLangBox
        waf.defineCustomeClass("cellformatter.wafMultiLangBox", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                if ($.type.isUndefined(cellval) || cellval === null) return "";
                //cellvall1,l2,l3
                if(cellval && $.type.isString(cellval)){
                    if(cellval.indexOf("{")>-1){
                        //unformat
                        cellval = waf.toJSONObject(cellval);
                    }else if($.type.isObject(rwd[this.opts.colModel.name])){
                        //
                        cellval = rwd[this.opts.colModel.name];
                    }
                }
                var ret = cellval;
                if (typeof cellval === "object") {
                    var defaultlang = "l2";
                    if (!$.type.isUndefined(this.opts.colModel.formatoptions) && !$.type.isUndefined(this.opts.colModel.formatoptions.defaultLang)) {
                        defaultlang = this.opts.colModel.formatoptions.defaultLang;
                    } else if (!$.type.isUndefined(this.opts.colModel.editoptions) && !$.type.isUndefined(this.opts.colModel.editoptions.inputJson.defaultLang)) {
                        defaultlang = this.opts.colModel.editoptions.inputJson.defaultLang;
                    }
                    //
                    var storeValue = $(this.table).data("storeValue") || {};
                    storeValue[this.opts.colModel.name + "-" + this.opts.rowId] = cellval;
                    $(this.table).data("storeValue", storeValue);
                    ret = cellval[defaultlang];
                }
                //cellval.
                return  cellval === "" ? cellformatter.defaultFormatter.prototype.format.call(this, cellval, rwd) : ret;
            },
            unformat:function (cell, rowId) {
                var ret;
                var storeValue = $(this.table).data("storeValue");
                if (storeValue) {
                    ret = storeValue[this.opts.colModel.name + "-" + this.opts.rowId];
                }
                if (undefined === ret) {
                    ret = $(cell).text();
                    ret = $.fmatter.util.filterNull(ret);
                    if(ret){
                        var defaultlang = "l2";
                        if (!$.type.isUndefined(this.opts.colModel.formatoptions) && !$.type.isUndefined(this.opts.colModel.formatoptions.defaultLang)) {
                            defaultlang = this.opts.colModel.formatoptions.defaultLang;
                        } else if (!$.type.isUndefined(this.opts.colModel.editoptions) && !$.type.isUndefined(this.opts.colModel.editoptions.inputJson.defaultLang)) {
                            defaultlang = this.opts.colModel.editoptions.inputJson.defaultLang;
                        }
                        var tmp = {"l1":"", "l2":"", "l3":""};
                        tmp[defaultlang] = ret;
                        ret = tmp;
                    }else{
                        ret = undefined;
                    }
                }
                if(ret==null) return undefined;
                if(!$.type.isObject(ret)){
                    ret = undefined;
                }
                return waf.toJSONString(ret);
            }
        });
        //autoComplete
        waf.defineCustomeClass("cellformatter.autoComplete", cellformatter.defaultFormatter, {
            format:function (cellval, rwd) {
                if ($.type.isUndefined(cellval) || cellval === null) return "";
                return cellval;
            },
            unformat:function (cell, rowId) {
                var cellval = $(cell).text();
                return $.fmatter.util.filterNull(cellval);
            }
        });
        //selectf7
        waf.defineCustomeClass("cellformatter.databaseToSelect", cellformatter.defaultFormatter, {
            format:function (cellvalue, rwd) {
                var cellConfig = $(this.table).wafGrid("getCellConfig", this.opts.colModel.name, this.opts.rowId);
                var oSelect = cellConfig.editoptions.enumSource;
                var self = this;
                if (undefined == oSelect || oSelect === null) {
                    if (cellConfig.editoptions.urlSource != null) {
                        $.ajax({
                            type:"get",
                            url:cellConfig.editoptions.urlSource,
                            async:false,
                            success:function (data) {
                                cellConfig.editoptions.enumSource = data;
                                $(self.table).wafGrid("changeCellEditor", self.opts.rowId, cellConfig.name, cellConfig);
                                $(self.table).wafGrid("setCellEditorAllConfig", cellConfig.name, "enumSource",data,"select");
                                oSelect = data;
                            },
                            dataType:"json"
                        });
                    }
                }
                if (oSelect && oSelect.length > 0 && cellvalue) {
                    if ($.type.isObject(cellvalue)) cellvalue = cellvalue.id;
                    for (var i = 0; i < oSelect.length; i++) {
                        if (oSelect[i].value === cellvalue) {
                            return oSelect[i].alias;
                        }
                    }
                }
                return "";
            },
            unformat:function (cell, rowId) {
                //unformat
                var cellConfig = $(this.table).wafGrid("getCellConfig", this.opts.colModel.name, this.opts.rowId);
                var self = this, cellvalue = $(cell).text();
                var oSelect = cellConfig.editoptions.enumSource;
                if (undefined == oSelect || oSelect === null) {
                    if (cellConfig.editoptions.urlSource != null) {
                        $.ajax({
                            type:"get",
                            url:cellConfig.editoptions.urlSource,
                            async:false,
                            success:function (data) {
                                cellConfig.editoptions.enumSource = data;
                                $(self.table).wafGrid("changeCellEditor", self.opts.rowId, cellConfig.name, cellConfig);
                                $(self.table).wafGrid("setCellEditorAllConfig", cellConfig.name, "enumSource",data,"select");
                                oSelect = data;
                            },
                            dataType:"json"
                        });
                    }
                }
                if (oSelect && oSelect.length > 0 && cellvalue && cellvalue.length > 0) {
                    for (var i = 0; i < oSelect.length; i++) {
                        if (oSelect[i].alias === cellvalue) {
                            return {"id":oSelect[i].value};
                        }
                    }
                }
            }
        });
        //selectf7
        waf.defineCustomeClass("celleditor.databaseToSelect", celleditor.wafselect, {
            edit:function (value) {
                if ($.type.isObject(value)) {
                    value = value.id;
                }
                celleditor.wafselect.prototype.edit.call(this, value);
            }
        });

        //
        $.jgrid = $.jgrid || {};
        $.extend($.jgrid,{
            getCellConfigItem:function(){
                return ['editable', 'editoptions', 'edittype', 'formatter','formatoptions'];
            },
            setCellEditorAllConfig:function (colModel, propName, value, tagType) {
                var eltypearr = ["wafpassword","wafcheckbox","wafradio","numberfield","wafMultiLangArea","wafMultiLangBox","wafTextArea","waftext"];
                var tagtypearr = ["password","checkbox","radio","numberField","multiLangArea","multiLangBox","textarea","text"];
                var eltype = colModel.edittype;
                //validator
                if("validator" === tagType){
                    colModel.editoptions.validateJson[propName] = value;
                    return colModel;
                }else if((eltype && $.inArray(eltype,eltypearr)>-1) || (tagType && $.inArray(tagType,tagtypearr)>-1)){
                    if (colModel.editoptions && colModel.editoptions.inputJson) {
                        colModel.editoptions.inputJson[propName] = value;
                    }
                    return colModel;
                }else if("autoComplete" === eltype || "autoComplete" === tagType){
                    if (tagType==="autoComplete" &&  colModel.editoptions && colModel.editoptions.autoCompleteJson) {
                        colModel.editoptions.autoCompleteJson[propName] = value;
                    }else{
                        colModel.editoptions.inputJson[propName] = value;
                    }
                    return colModel;
                }else if("f7" === eltype || "promptBox"===tagType || tagType.indexOf("prompt")>-1){
                    if (tagType==="promptBox") {
                        if (colModel.editoptions && colModel.editoptions.f7Json) {
                            colModel.editoptions.f7Json[propName] = value;
                        }
                    } else {
                        if (colModel.editoptions && colModel.editoptions.subTagJson) {
                            colModel.editoptions.subTagJson[propName] = value;
                        }
                    }
                    return colModel;
                }else if("datepicker"===eltype || "datePicker"==tagType){
                    if (colModel.editoptions && colModel.editoptions.datepickerjson) {
                        colModel.editoptions.datepickerjson[propName] = value;
                    }
                    if (propName === "dateFormat") colModel.editoptions.dateFormat = value;
                    return colModel;
                }else if("wafselect"===eltype || "select"===tagType){
                    if("enumSource"===propName || "urlSource"===propName ||"filterJson"===propName ||"multiple"===propName){
                        if (colModel.editoptions) {
                            colModel.editoptions[propName] = value;
                        }
                        if("urlSource"===propName) colModel.editoptions["enumSource"] = undefined;
                    }else{
                        if (colModel.editoptions && colModel.editoptions.selectJson) {
                            colModel.editoptions.selectJson[propName] = value;
                        }
                    }
                    return colModel;
                }else{
                    colModel.editoptions[propName] = value;
                }
                return colModel;
            },
            checkDate:function (format, date) {
                var daysInFebruary = function (year) {
                    // February has 29 days in any year evenly divisible by four,
                    // EXCEPT for centurial years which are not also divisible by 400.
                    return (((year % 4 === 0) && ( year % 100 !== 0 || (year % 400 === 0))) ? 29 : 28 );
                },
                    DaysArray = function (n) {
                        for (var i = 1; i <= n; i++) {
                            this[i] = 31;
                            if (i == 4 || i == 6 || i == 9 || i == 11) {
                                this[i] = 30;
                            }
                            if (i == 2) {
                                this[i] = 29;
                            }
                        }
                        return this;
                    };

                var tsp = {}, sep;
                format = format.toLowerCase();
                //we search for /,-,. for the date separator
                if (format.indexOf("/") != -1) {
                    sep = "/";
                } else if (format.indexOf("-") != -1) {
                    sep = "-";
                } else if (format.indexOf(".") != -1) {
                    sep = ".";
                } else {
                    sep = "/";
                }
                format = format.split(sep);
                date = date.split(sep);
                if (date.length != 3) {
                    return false;
                }
                var j = -1, yln, dln = -1, mln = -1;
                for (var i = 0; i < format.length; i++) {
                    var dv = isNaN(date[i]) ? 0 : parseInt(date[i], 10);
                    tsp[format[i]] = dv;
                    yln = format[i];
                    if (yln.indexOf("y") != -1) {
                        j = i;
                    }
                    if (yln.indexOf("m") != -1) {
                        mln = i;
                    }
                    if (yln.indexOf("d") != -1) {
                        dln = i;
                    }
                }
                if (format[j] == "y" || format[j] == "yyyy") {
                    yln = 4;
                } else if (format[j] == "yy") {
                    yln = 2;
                } else {
                    yln = -1;
                }
                var daysInMonth = DaysArray(12),
                    strDate;
                if (j === -1) {
                    return false;
                } else {
                    strDate = tsp[format[j]].toString();
                    if (yln == 2 && strDate.length == 1) {
                        yln = 1;
                    }
                    if (strDate.length != yln || (tsp[format[j]] === 0 && date[j] != "00")) {
                        return false;
                    }
                }
                if (mln === -1) {
                    return false;
                } else {
                    strDate = tsp[format[mln]].toString();
                    if (strDate.length < 1 || tsp[format[mln]] < 1 || tsp[format[mln]] > 12) {
                        return false;
                    }
                }
                if (dln === -1) {
                    return false;
                } else {
                    strDate = tsp[format[dln]].toString();
                    if (strDate.length < 1 || tsp[format[dln]] < 1 || tsp[format[dln]] > 31 || (tsp[format[mln]] == 2 && tsp[format[dln]] > daysInFebruary(tsp[format[j]])) || tsp[format[dln]] > daysInMonth[tsp[format[mln]]]) {
                        return false;
                    }
                }
                return true;
            },
            isEmpty:function (val) {
                if (val.match(/^\s+$/) || val === "") {
                    return true;
                } else {
                    return false;
                }
            },
            checkTime:function (time) {
                // checks only hh:ss (and optional am/pm)
                var re = /^(\d{1,2}):(\d{2})([ap]m)?$/, regs;
                if (!this.isEmpty(time)) {
                    regs = time.match(re);
                    if (regs) {
                        if (regs[3]) {
                            if (regs[1] < 1 || regs[1] > 12) {
                                return false;
                            }
                        } else {
                            if (regs[1] > 23) {
                                return false;
                            }
                        }
                        if (regs[2] > 59) {
                            return false;
                        }
                    } else {
                        return false;
                    }
                }
                return true;
            },
            checkValues:function (val, valref, g, customobject, nam) {
                var edtrul, i, nm, dft, len;
                if (typeof(customobject) === "undefined") {
                    if (typeof(valref) == 'string') {
                        for (i = 0, len = g.p.colModel.length; i < len; i++) {
                            if (g.p.colModel[i].name == valref) {
                                edtrul = g.p.colModel[i].editrules;
                                valref = i;
                                try {
                                    nm = g.p.colModel[i].formoptions.label;
                                } catch (e) {
                                }
                                break;
                            }
                        }
                    } else if (valref >= 0) {
                        edtrul = g.p.colModel[valref].editrules;
                    }
                } else {
                    edtrul = customobject;
                    nm = nam === undefined ? "_" : nam;
                }
                if (edtrul) {
                    if (!nm) {
                        nm = g.p.colNames[valref];
                    }
                    if (edtrul.required === true) {
                        if (this.isEmpty(val)) {
                            return [false, nm + ": " + $.jgrid.edit.msg.required, ""];
                        }
                    }
                    // force required
                    var rqfield = edtrul.required === false ? false : true;
                    if (edtrul.number === true) {
                        if (!(rqfield === false && this.isEmpty(val))) {
                            if (isNaN(val)) {
                                return [false, nm + ": " + $.jgrid.edit.msg.number, ""];
                            }
                        }
                    }
                    if (typeof edtrul.minValue != 'undefined' && !isNaN(edtrul.minValue)) {
                        if (parseFloat(val) < parseFloat(edtrul.minValue)) {
                            return [false, nm + ": " + $.jgrid.edit.msg.minValue + " " + edtrul.minValue, ""];
                        }
                    }
                    if (typeof edtrul.maxValue != 'undefined' && !isNaN(edtrul.maxValue)) {
                        if (parseFloat(val) > parseFloat(edtrul.maxValue)) {
                            return [false, nm + ": " + $.jgrid.edit.msg.maxValue + " " + edtrul.maxValue, ""];
                        }
                    }
                    var filter;
                    if (edtrul.email === true) {
                        if (!(rqfield === false && this.isEmpty(val))) {
                            // taken from $ Validate plugin
                            filter = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i;
                            if (!filter.test(val)) {
                                return [false, nm + ": " + $.jgrid.edit.msg.email, ""];
                            }
                        }
                    }
                    if (edtrul.integer === true) {
                        if (!(rqfield === false && this.isEmpty(val))) {
                            if (isNaN(val)) {
                                return [false, nm + ": " + $.jgrid.edit.msg.integer, ""];
                            }
                            if ((val % 1 !== 0) || (val.indexOf('.') != -1)) {
                                return [false, nm + ": " + $.jgrid.edit.msg.integer, ""];
                            }
                        }
                    }
                    if (edtrul.date === true) {
                        if (!(rqfield === false && this.isEmpty(val))) {
                            if (g.p.colModel[valref].formatoptions && g.p.colModel[valref].formatoptions.newformat) {
                                dft = g.p.colModel[valref].formatoptions.newformat;
                            } else {
                                dft = g.p.colModel[valref].datefmt || "Y-m-d";
                            }
                            if (!this.checkDate(dft, val)) {
                                return [false, nm + ": " + $.jgrid.edit.msg.date + " - " + dft, ""];
                            }
                        }
                    }
                    if (edtrul.time === true) {
                        if (!(rqfield === false && this.isEmpty(val))) {
                            if (!this.checkTime(val)) {
                                return [false, nm + ": " + $.jgrid.edit.msg.date + " - hh:mm (am/pm)", ""];
                            }
                        }
                    }
                    if (edtrul.url === true) {
                        if (!(rqfield === false && this.isEmpty(val))) {
                            filter = /^(((https?)|(ftp)):\/\/([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*\/?)/i;
                            if (!filter.test(val)) {
                                return [false, nm + ": " + $.jgrid.edit.msg.url, ""];
                            }
                        }
                    }
                    if (edtrul.custom === true) {
                        if (!(rqfield === false && this.isEmpty(val))) {
                            if ($.isFunction(edtrul.custom_func)) {
                                var ret = edtrul.custom_func.call(g, val, nm);
                                if ($.isArray(ret)) {
                                    return ret;
                                } else {
                                    return [false, $.jgrid.edit.msg.customarray, ""];
                                }
                            } else {
                                return [false, $.jgrid.edit.msg.customfcheck, ""];
                            }
                        }
                    }
                }
                return [true, "", ""];
            },
            getBinderData:function(iRow,$t){
                //rowdatasaveCellsetCellrowdata,setCell
                var rowdata = $($t.rows[iRow]).data("currentData");
                if(undefined ==rowdata) {
                    rowdata = $("#" + $t.p.id).jqGrid("getRowData", $t.rows[iRow].id);
                    $($t.rows[iRow]).data("currentData",rowdata);
                }
                return rowdata;
            },
            updateBinderData:function(iRow,$t,iCol,v2){
                var rowdata = $.jgrid.getBinderData(iRow,$t);
                if(rowdata){
                    var nm = $t.p.colModel[iCol].name;
                    rowdata[nm] = v2;
                }
                $($t.rows[iRow]).data("currentData",rowdata);
            },
            editKeyHandler:function(e,$t,iRow,iCol){
                if (e.keyCode === 27) {
                    $($t).jqGrid("restoreCell", iRow, iCol);
                    e.stopPropagation();
                } //ESC
                //add by jlg.
                if (e.keyCode === 13 || e.keyCode == 9) {
                    function goCell(){
                        $($t).jqGrid("saveCell", iRow, iCol);
                        //add by jlg.
                        if (!$t.grid.hDiv.loading) {
                            if (e.shiftKey) {
                                $($t).jqGrid("prevCell", iRow, iCol);
                            } //Shift Enter
                            else {
                                $($t).jqGrid("nextCell", iRow, iCol);
                            } //Enter
                        } else {
                            return false;
                        }
                    }
                    function exittable(){
                        $($t).jqGrid("saveCell", iRow, iCol);
                        window.setTimeout(function () {
                            $("#" + $t.p.knv).blur();
                            $($t).focus();
                            if (parseInt($t.p.iCol, 10) >= 0 && parseInt($t.p.iRow, 10) >= 0) {
                                $("td:eq(" + $t.p.iCol + ")", $t.rows[$t.p.iRow]).removeClass("edit-cell ui-state-highlight");
                                $($t.rows[$t.p.iRow]).removeClass("edited-row");
                            }
                            if ($.enter2tab) {
                                $.enter2tab.enter($t.p.id);
                            }
                        }, 0);
                    }
                    var textarea = (e.target.tagName==="TEXTAREA");
                    if (e.ctrlKey) {
                        if(textarea){
                            goCell();
                        }else{
                            exittable();
                        }
                    } else {
                        //TextareaCTRL+ENTER
                        if(textarea&&e.keyCode === 13&&!e.shiftKey) return;
                        goCell();
                    }
                    e.stopPropagation();
                }//Enter
            },
            focusKnv:function($t){
                //
                if((undefined===$t.p.focusInGrid)||($t.p.focusInGrid===true)){
                    if ($.browser.opera) {
//                        $("#" + $t.p.knv).attr("tabindex", "-1").focus();
                    } else {
//                    window.setTimeout(function () {
//                        $("#" + $t.p.knv).attr("tabindex", "-1").focus();
//                    }, 0);
                    }
                }
            },
            removeAllSelect:function($t){
                var rowids = $($t).jqGrid("getSelectedRows"),currentRow;
                for(var k=0;k<rowids.length;k++){
                    currentRow = $t.rows.namedItem(rowids[k]);
                    $(currentRow).removeClass("edited-row");
                }
                $($t).jqGrid("removeSelect");
            },
            getNextEditableCol:function($t,iCol,iRow){
                var colLength=$t.p.colModel.length,colModel;
                for (var i = iCol + 1; i < colLength; i++) {
                    colModel = $($t).jqGrid("getCellConfig",$t.p.colModel[i].name,$t.rows[iRow].id);
                    if (colModel.editable === true && colModel.editoptions && !colModel.hidden) {
                        return i;
                    }
                }
                return -1;
            },
            getPrevEditableCol:function($t,iCol,iRow){
                var colModel;
                for (var i = iCol - 1; i >= 0; i--) {
                    colModel = $($t).jqGrid("getCellConfig",$t.p.colModel[i].name,$t.rows[iRow].id);
                    if (colModel.editable === true && colModel.editoptions  && !colModel.hidden) {
                        return i;
                    }
                }
                return -1;
            }
        });


        //
        var rowOverLayer =
            "<div id='rowOverLayer_{{id}}' class='rowoverlay'>" +
                "    <div class='overlay'></div>" +
                "    <div class='actions'>" +
                "        <span class='action edit f-icon-edit'></span>" +
                "        <span class='action add f-icon-plus'></span>" +
                "        <span class='action remove f-icon-minus'></span>" +
                "        <span class='line'></span>" +
                "    </div>" +
                "</div>";
        //
        $.jgrid.extend({
            //float
            floatEditSetUp:function(){
                //cellEdit
                this.each(function(){
                    var ts = this,
                        te = $.wafutil.getTemplateEngine(),
                        ops = ts.p.editModelOptions,
                        cellEdit = ops.cellEdit;
                    //rowLayout
                    var fun = te.compile(rowOverLayer);
                    var template = te.render(fun,{id:ts.p.id});
                    ($("div.page_margins")||$("body")).append(template);
                    var overlay=$("#rowOverLayer_"+ts.p.id);
                    //ie8line8hack
                    if($.browser.msie&&($.browser.version == "8.0"||$.browser.version == "9.0")){
                        overlay.find(".actions .line").addClass("ie8linehack");
                    }
                    $(ts).wafGrid("setFloatActions",ops.actions||[{"add":true},{"edit":true},{"remove":true}]);
                    //cellEditfalse
                    ts.p.floatCellEdit=cellEdit||false;
                    //hover
                    $(ts).mouseover(function(e){
                        var ptd = $(e.target);
                        if(ptd.is("input.cbox")){
                            ptd = ptd.closest("td");
                        }
                        var ptr = $(ptd).closest("tr.jqgrow,tr.norecord");
                        $(ts).wafGrid("showHoverHandle",ptr);
                    });
                    //documentclick
                    $(document).bind("click.editGrid", function(event) {
                        var $target = $(event.target);
                        //frameinputpanel
                        if(!($target.closest(".ui-jqgrid-btable").length ||
                            $target.hasClass("ui-jqgrid-btable") ||
                            $target.closest(".editPanel").length ||
                            $target.closest(".rowoverlay").length)) {
                            overlay.hide();
                            $(ts).wafGrid("cancelEdit");
                            if(ops && ops.afterClickOuterGrid &&
                                $.isFunction(ops.afterClickOuterGrid)){
                                ops.afterClickOuterGrid.call(ts,overlay);
                            }
                        }
                    });
                })
            },
            showHoverHandle:function(ptr){
                this.each(function(){
                    var ts = this,
                        ops = ts.p.editModelOptions,
                        overlay=$("#rowOverLayer_"+ts.p.id),
                        cellEdit = ops.cellEdit;
                    if(ptr.length>0){
                        var target = ptr.closest(".ui-jqgrid");
                        var ptrWid = target.width();
                        if(cellEdit==true){
                            //targettarget
                            overlay.css({width:ptrWid}).show().position($.extend({of: target}, {
                                my : "left top",
                                at : "left bottom",
                                offset:"0 0"
                            })).attr("rowid",ptr[0].id).addClass("floatCellEdit");
                            overlay.css("top",ptr.offset().top+ptr.outerHeight(true));
                        }else{
                            overlay.css({height:ptr.outerHeight(),width:ptrWid}).show().position($.extend({of: target}, {
                                my : "center center",
                                at : "center center",
                                offset:"0 0"
                            })).attr("rowid",ptr[0].id);
                            overlay.css("top",ptr.offset().top);
                        }
                        overlay.find(".actions .edit,.actions .remove")[ptr.hasClass("norecord")?"hide":"show"]();
                        if(ops && ops.afterHover &&
                            $.isFunction(ops.afterHover)){
                            ops.afterHover.call(ts,overlay,ptr);
                        }
                        $(ts).wafGrid("cancelEdit");
                    }
                })
            },
            removeAllFloatActions:function(){
                this.each(function(){
                    if(this.p.editModel!="floatEdit") return;
                    var ts = this,
                        overlay=$("#rowOverLayer_"+ts.p.id);
                    overlay.find(".action").unbind("click.editGrid").remove();
                    overlay.find(".actions").hide();
                })
            },
            setFloatActions:function(actions){


                this.each(function(){
                    if(this.p.editModel!="floatEdit") return;
                    var ts = this,elem,
                        overlay=$("#rowOverLayer_"+ts.p.id),
                        len,action,tmp;

                    function findIndex(actionName){
                        var len = ts.p.editModelOptions&&ts.p.editModelOptions.actions?ts.p.editModelOptions.actions.length:0,action;
                        if(len>0){
                            for(var i=0;i<ts.p.editModelOptions.actions.length;i++){
                                action = ts.p.editModelOptions.actions[i];
                                if(action[actionName]!=undefined){return i}
                            }
                        }
                        return -1;
                    }
                    function contactArray(){
                        if(actions&&actions.length>0){
                            var len = actions.length,actionName;
                            ts.p.editModelOptions.actions = ts.p.editModelOptions.actions || [];
                            for(var i=0;i<len;i++){
                                for(var prop in actions[i]){
                                    actionName = actions[i][prop];
                                    var index = findIndex(prop);
                                    if(index>-1){
                                        var tmp = $.extend({},ts.p.editModelOptions.actions[index],actions[i]);
                                        ts.p.editModelOptions.actions.splice(index,1,tmp);
                                    }else{
                                        ts.p.editModelOptions.actions.push(actions[i]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    function defaultAdd(e){
                        var rowid = $(e.target).closest(".rowoverlay").attr("rowid");
                        var width = $(overlay).width();
                        var actionsWid = overlay.find(".actions").width();
                        var tmp = findIndex("add");
                        tmp=tmp>-1?ts.p.editModelOptions.actions[tmp]:undefined;
                        if(tmp&&tmp.onAdd&&$.isFunction(tmp.onAdd)){
                            tmp.onAdd.call(ts,rowid,tmp.defaultValue||{},width-actionsWid);
                        }else if(ops.target){
                            var entry = $(ops.target);
                            entry.addClass("editPanel");
                            if(entry.attr("ctrlrole")&&entry.attr("ctrlrole")=="infoBlock"){
                                entry.wafInfoBlock("clearData");
                                var defaultValue = tmp.defaultValue||{};
                                if(tmp.beforeAdd&&$.isFunction(tmp.beforeAdd)){
                                    var ret = tmp.beforeAdd.call(ts,defaultValue,rowid,entry);
                                    if(ret==false) return;
                                    if(ret&&$.type.isObject(ret)) defaultValue = ret;
                                }
                                entry.wafInfoBlock("addRow",defaultValue);
                                $(entry).css({"width":width-actionsWid,"position":"absolute"}).addClass("editPanel");
                                $(entry).show().position($.extend({of: overlay}, {
                                    my : "left top",
                                    at : "left bottom"
                                })).attr("action","add").attr("rowid",rowid);
                                if(tmp.afterAdd&&$.isFunction(tmp.afterAdd)){
                                    tmp.afterAdd.call(ts,defaultValue,rowid,entry);
                                }
                            }
                        }
                    }
                    function defaultEdit(e){
                        var rowid = $(e.target).closest(".rowoverlay").attr("rowid");
                        if($.type.isEmpty(rowid)){return;}
                        var rowData = $(ts).wafGrid("getRowRealData",rowid);
                        var width = $(overlay).width();
                        var actionsWid = overlay.find(".actions").width();
                        var tmp = findIndex("edit");
                        tmp=tmp>-1?ts.p.editModelOptions.actions[tmp]:undefined;
                        if(tmp&&tmp.onEdit&&$.isFunction(tmp.onEdit)){
                            tmp.onEdit.call(ts,rowid,rowData,width-actionsWid);
                        }else if(ops.target){
                            var entry = $(ops.target);
                            entry.addClass("editPanel");
                            if(entry.attr("ctrlrole")&&entry.attr("ctrlrole")=="infoBlock"){
                                entry.wafInfoBlock("clearData");
                                if(tmp.beforeEdit&&$.isFunction(tmp.beforeEdit,entry)){
                                    var ret = tmp.beforeEdit.call(ts,rowData,rowid);
                                    if(ret==false) return;
                                    if(ret&&$.type.isObject(ret)) rowData = ret;
                                }
                                entry.wafInfoBlock("addRow",rowData);
                                $(entry).css({"width":width-actionsWid,"position":"absolute"}).addClass("editPanel");
                                $(entry).show().position($.extend({of: overlay}, {
                                    my : "left top",
                                    at : "left bottom"
                                })).attr("action","edit").attr("rowid",rowid);
                                if(tmp.afterEdit&&$.isFunction(tmp.afterEdit)){
                                    tmp.afterEdit.call(ts,rowData,rowid,entry);
                                }
                            }
                        }
                    }
                    function defaultRemove(e){
                        var rowid = $(e.target).closest(".rowoverlay").attr("rowid");
                        if($.type.isEmpty(rowid)){return;}
                        overlay.hide();
                        var tmp = findIndex("remove");
                        tmp=tmp>-1?ts.p.editModelOptions.actions[tmp]:undefined;
                        if(tmp&&tmp.onRemove&&$.isFunction(tmp.onRemove)){
                            tmp.onRemove.call(ts,rowid);
                        }else if(ops.target){
                            if(tmp.beforeRemove&&$.isFunction(tmp.beforeRemove)){
                                var ret = tmp.beforeRemove.call(ts,rowid);
                                if(ret==false) return;
                            }
                            $(ts).wafGrid("delRow",rowid);
                            $(ts).wafGrid("cancelEdit");
                            if(tmp.afterRemove&&$.isFunction(tmp.afterRemove)){
                                tmp.afterRemove.call(ts);
                            }
                        }
                    }

                    contactArray();
                    var ops = ts.p.editModelOptions;
                    if(actions && $.isArray(actions)){
                        len = actions.length;
                        for(var i=0;i<len;i++){
                            action = actions[i];
                            for(var prop in action){
                                if(prop=="add"){
                                    if(action.add==undefined||action.add){
                                        elem = overlay.find(".actions .add");
                                        if(action.elem){
                                            //elem
                                            tmp = $(action.elem);
                                            if(!tmp.hasClass("add")) tmp.addClass("add");
                                            elem.replaceWith(tmp);
                                            elem = tmp;
                                        }else{
                                            if(!elem.length){
                                                elem = $("<span class='action add f-icon-plus'></span>");
                                                overlay.find(".actions").append(elem);
                                            }
                                        }
                                        elem.show();
                                        if(!elem.hasClass("action")) elem.addClass("action");
                                        elem.handleFunction("click.editGrid",action.onclick?action.onclick:defaultAdd);
                                    }else{
                                        overlay.find(".actions .add").unbind("click.editGrid").remove();
                                    }
                                    break;
                                }else if(prop=="edit"){
                                    if(action.edit==undefined||action.edit){
                                        elem = overlay.find(".actions .edit");
                                        if(action.elem){
                                            //elem
                                            tmp = $(action.elem);
                                            if(!tmp.hasClass("edit")) tmp.addClass("edit");
                                            elem.replaceWith(tmp);
                                            elem = tmp;
                                        }else{
                                            if(!elem.length){
                                                elem = $("<span class='action edit f-icon-edit'></span>");
                                                overlay.find(".actions").append(elem);
                                            }
                                        }
                                        elem.show();
                                        if(!elem.hasClass("action")) elem.addClass("action");
                                        elem.handleFunction("click.editGrid",action.onclick?action.onclick:defaultEdit);
                                    }else{
                                        overlay.find(".actions .edit").unbind("click.editGrid").remove();
                                    }
                                    break;
                                }else if(prop=="remove"){
                                    if(action.remove==undefined||action.remove){
                                        elem = overlay.find(".actions .remove");
                                        if(action.elem){
                                            tmp = $(action.elem);
                                            if(!tmp.hasClass("remove")) tmp.addClass("remove");
                                            elem.replaceWith(tmp);
                                            elem = tmp;
                                        }else{
                                            if(!elem.length){
                                                elem = $("<span class='action remove f-icon-minus'></span>");
                                                overlay.find(".actions").append(elem);
                                            }
                                        }
                                        elem.show();
                                        if(!elem.hasClass("action")) elem.addClass("action");
                                        elem.handleFunction("click.editGrid",action.onclick?action.onclick:defaultRemove);
                                    }else{
                                        overlay.find(".actions .remove").unbind("click.editGrid").remove();
                                    }
                                    break;
                                }else{
                                    if(action[prop]){
                                        elem = overlay.find(".actions ."+prop);
                                        if(action.elem){
                                            elem.remove();
                                            elem = $(action.elem);
                                            if(!elem.hasClass(prop)) elem.addClass(prop);
                                            overlay.find(".actions").append(elem);
                                            if(!elem.hasClass("action")) elem.addClass("action");
                                        }
                                        if(elem.length && action.onclick){
                                            elem.handleFunction("click.editGrid",action.onclick);
                                        }
                                    }else{
                                        overlay.find(".actions ."+prop).unbind("click.editGrid").remove();
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if(!overlay.find(".action").length){
                        overlay.find(".actions").hide();
                    }else{
                        overlay.find(".actions").show();
                    }
                })
            },
            cancelEdit:function(){
                this.each(function(){
                    if(this.p.editModel!="floatEdit") return;
                    var ts = this,
                        ops = ts.p.editModelOptions;
                    if(ops.target){
                        var entry = $(ops.target);
                        if(entry.attr("ctrlrole")&&entry.attr("ctrlrole")=="infoBlock"){
                            $(entry).wafInfoBlock("clearData");
                            $(entry).hide();
                        }
                    }
                })
            },
            addActionToFloatActionBar:function(content){
                this.each(function(){
                    if(this.p.editModel!="floatEdit") return;
                    var ts = this,
                        overlay=$("#rowOverLayer_"+ts.p.id);
                    overlay.find(".actions").append(content);
                })
            },
            hideFloatBar:function(){
                this.each(function(){
                    if(this.p.editModel!="floatEdit") return;
                    $("#rowOverLayer_"+this.p.id).hide();
                })
            }
        });

    })(jQuery);
//
    function _waf2_createInput_(eltype, options, vl){
        var elem;
        elem = document.createElement("input");
        elem.id = options.id;
        elem.type = eltype;
        elem.value = vl;
        return elem;
    }
    function _waf2_filterOptions_(options){
        var exclude = ['dataInit', 'dataEvents', 'dataUrl', 'buildSelect', 'sopt', 'searchhidden',
            'defaultValue', 'attr', 'textJson', 'autoCompleteJson',
            'datepickerjson', 'selectJson', 'enumJson', 'inputJson', 'filterJson',
            'f7Json', 'displayFormat', 'editFormat', 'subWidgetName', 'subTagJson' , 'grid'
        ];
        var op = $.extend({},options,true);
        for (var item in op) {
            if ($.inArray(item, exclude) === -1) {
            } else {
                op[item] = undefined;
                delete op[item];
            }
        }
        return op;
    }

    function _waf2_delegate_(event) {
        if (this[0].form) {
            var validator = $.data(this[0].form, "validator"),
                eventType = "on" + event.type.replace(/^validate/, "");
            validator.settings[eventType] && $.isFunction(validator.settings[eventType]) && validator.settings[eventType].call(validator, this[0], event);
        }
    }

//});




//mod.defineModule("section",["base","waf"],function(){
    (function ($, undefined) {
        $.wafSection = $.wafSection||{};
        $.widget("ui.wafSection", {
            options:{
                tagClass:'',
                style:'',
                title:'',
                openIconCls:'ui-section-minus',
                closeIconCls:'ui-section-plus',
                autoOpen:true,
                hidden:false
            },
            _create:function () {
                var section = this.element,
                    o = this.options,
                    self = this;

                this.title =  section.children("div.sheader").children("span.title");
                this.content = section.children("div.content");
                self._toggle(this.options.autoOpen);
                this.element.attr('data-domcreated', "true");

                $.each(this.options, function (key, value) {
                    self._setOption(key, value);
                });

                this.title.bind("click",function(event){
                    if(!self.title.hasClass(o.openIconCls)){
                        self._toggle(true);
                    }else{
                        self._toggle(false);
                    }
                });

            } ,
            open:function(){
                if(!this.title.hasClass(this.options.openIconCls)){
                    this._toggle(true);
                }
            },
            close:function(){
                if(!this.title.hasClass(this.options.closeIconCls)){
                    this._toggle(false);
                }
            },
            _toggle:function(show){
                var o = this.options;
                if(show){
                    $(this.title).removeClass(o.closeIconCls).addClass(o.openIconCls);
                    $(this.title).closest(".sheader").removeClass("headClose");
                    this.content.show();
                    this._trigger("onopen");
                }else{
                    $(this.title).removeClass(o.openIconCls).addClass(o.closeIconCls);
                    $(this.title).closest(".sheader").addClass("headClose");
                    this.content.hide();
                    this._trigger("onclose");
                }
            },
            _setOption:function(key,value){
                var section = this.element,o=this.options;
                switch(key){
                    case "tagClass":
                        section.removeClass(o.tagClass).addClass(value);
                        break;
                    case "style":
                        section.attr("style",value);
                        break;
                    case "title":
                        this.title.html(value);
                        break;
                    case "hidden":
                        section.toggle(!value);
                        break;
                    case "openIconCls":
                        if(!this.content.is(":hidden")){
                            this.title.removeClass(o.openIconCls).addClass(value);
                        }
                        this.options.openIconCls=value;
                        break;
                    case "closeIconCls":
                        if(this.content.is(":hidden")){
                            this.title.removeClass(o.closeIconCls).addClass(value);
                        }
                        this.options.closeIconCls=value;
                        break;
                }
                $.Widget.prototype._setOption.apply( this, arguments );
            },
            destroy:function(){
                this.title = null;
                this.content = null;
                this.element.removeClass("ui-section").removeAttr("ctrlrole");
                $.Widget.prototype.destroy.call( this );
            },
            appendChildren:function(source,pos){
                //pos
                var content = $(this.element).children("div.content");
                $.dynamicutil.appendChildren(content,source,pos);
            },
            removeChildren:function(source){
                //idsourcejquery
                if(typeof source == "string"){
                    if(source.substr(0,1) !="#") {
                        source = "#"+source;
                    }
                    source = $(source);
                }
                var content = $(this.element).children("div.content");
                $.dynamicutil.removeChildren(content,source);
            },
            addHeaderItem:function(source){
                var header = $(this.element).children("div.sheader");
                header.append(source);
            },
            removeHeaderItem:function(){
                var header = $(this.element).children("div.sheader");
                return header.children("*").not("span.title").remove();
            },
            getHeaderItem:function(){
                var header = $(this.element).children("div.sheader");
                return header.children("*").not("span.title");
            }
        });

        /*
         * Section
         * author:Zhang yanfang
         * 2012-11-13
         */
        $.extend($.wafSection, {
            createSectionDOM:function (opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    var elem = $("<div></div>");
                    elem.addClass("ui-section");
                    elem.attr("id", opts.id);
                    elem.attr("ctrlrole", "section");

                    var head = $("<div></div>");
                    head.addClass("sheader");
                    head.append("<span class='title'></span>");
                    elem.append(head);

                    var content = $("<div></div>");
                    content.addClass("content");
                    content.attr("id", opts.id + "_content");
                    elem.append(content);
                    return elem;
                } else {
                    return obj;
                }
            },
            initSection:function (opts, el) {
                if(el && $(el).hasClass("ui-section")){
                    $(el).wafSection(opts);
                }
            },
            removeSection:function (opts) {
                $("#"+opts.id).remove();
            },
            modifySection:function (opts) {
                $("#"+opts.id).wafSection("option",opts);
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("section", {createDOMFun:$.wafSection.createSectionDOM, initFun:$.wafSection.initSection,
                    deleteFun:$.wafSection.removeSection, modifyFun:$.wafSection.modifySection,lazyInit:true});
        });
    }((jQuery)));
//});
//mod.defineModule("column",["base","waf","boxUtil"],function(){
    /*
     * Column
     */
    (function ($, undefined) {

        var defaultClass = {
            defaultColumnClass:"ui-column",
            defaultColumnLayoutClass:"ui-columnLayout",
            splitPanelClass:"col-splitPanel",
            splitLetterSpacing:"-0.5em",
            completeEvent:"columnLayout.completeCreate",
            dataFlg:"column.data"
        };

        $.wafColumn = $.wafColumn||{};

        $.widget("ui.wafColumn", {
            options:{
                id:null,
                tagClass:"span12",
                style:null,
                colWidth:null, //
                equalize:false, //
                autoMax:false, //=
                split:false, //
                splitClass:"splitPanelClass", //class
                splitWidth:"5px", //
                shrink:false, //
                draggable:false, //
                afterDragStop:null, //,
                afterShrink:null, //
                afterInsertSplit:null //
            },
            _create:function () {
                $.extend(this.options, defaultClass);
                var self = this, o = this.options;
                if(!this.element.data("domcreated")){
                    $(this.element).attr("ctrlrole","column").attr("data-domcreated","true");
                    //class
                    if (!self.element.hasClass(o.defaultColumnClass)) {
                        self.element.addClass(o.defaultColumnClass);
                    }
                }
                //Option
                this.options.create = true;
                $.each(this.options, function (key, value) {
                    self._setOption(key, value);
                });
                this.options.create = false;
                //
                if (this.options.afterDragStop && this.options.afterDragStop != null) {
                    self.element.bind("column.afterDragStop", this.options.afterDragStop);
                }
                if (this.options.afterShrink && this.options.afterShrink != null) {
                    self.element.bind("column.afterShrink", this.options.afterDragStop);
                }
                if (this.options.afterInsertSplit && this.options.afterInsertSplit != null) {
                    self.element.bind("column.afterInsertSplit", this.options.afterInsertSplit);
                }
            },
            _setOption:function (key, value) {
                if (key === "tagClass" && value && value != null) {
                    if(!this.element.hasClass(value)){
                        this.element.removeClass(this.options.tagClass).addClass(value);
                    }
                    this.options.tagClass = value;
                }
                if (key === "style" && value && value != null) {
                    this.element.attr("style", value);
                }
                if (key === "colWidth" && value && value != null) {
                    var colWidth = value;
                    if (!$.isNaN(colWidth)) {
                        colWidth = $.trim(colWidth) + "%";
                    }
                    this.element.css("width", colWidth);
                    //
                    this.options.oriWPercentage = colWidth;
                }
                if(key === "afterDragStop" && value && value!=null && $.isFunction(value)){
                    this.element.bind("column.afterDragStop", value);
                }
                if(key === "afterShrink" && value && value!=null && $.isFunction(value)){
                    this.element.bind("column.afterShrink", value);
                }
                if(key === "afterInsertSplit" && value && value!=null && $.isFunction(value)){
                    this.element.bind("column.afterInsertSplit", value);
                }

                if (key === "autoMax" && value && value != null) {
                    this.options.autoMax = value;
                    this.element.attr("autoMax",value);
                }

                if (key === "split" && value && value != null) {
                    this.options.split = value;
                    this.element.attr("split",value);
                }

                if (key === "equalize" && value && value != null) {
                    this.options.equalize = value;
                    this.element.attr("equalize",value);
                }

                if (key === "draggable" && value && value != null) {
                    this.options.draggable = value;
                    if(value!=undefined && !this.options.create){
                        var splitElem = this.element.prev("." + defaultClass.splitPanelClass);
                        if(splitElem.length>0){
                            waf(this.getParent()).wafColumnLayout("buildDraggable",splitElem,this.element);
                        }
                    }
                }

                if (key === "shrink" && value && value != null) {
                    this.options.shrink = value;
                    if(value!=undefined && !this.options.create){
                        var splitElem = this.element.prev("." + defaultClass.splitPanelClass);
                        if(splitElem.length>0){
                            waf(this.getParent()).wafColumnLayout("buildShrink",splitElem,this.element);
                        }
                    }
                }

                if (key === "splitClass" && value && value != null) {
                    this.options.splitClass = value;
                }

            },
            _setOptions:function(options){
                var self = this;
                $.each( options, function( key, value ) {
                    self._setOption( key, value );
                });
                //
                if(options.split!=undefined && !this.options.create){
                    waf(this.getParent()).wafColumnLayout("createAllSplit");
                }

                return this;
            },
            getParent:function () {
                var parent = this.element.parent();
                if (parent.hasClass(this.options.defaultColumnLayoutClass)) {
                    return parent;
                }
                return null;
            },
            destroy:function(){
                var oldWidth = $.columnLayoutUtil.getElementWidth(this.element);
                var parent = this.getParent();
                $.Widget.prototype.destroy.call( this );
                $.columnLayoutUtil.avgWidToNoSplitColumn(oldWidth,parent);
            },
            appendChildren:function(source,pos){
                $.dynamicutil.appendChildren(this.element,source,pos);
            },
            removeChildren:function(source){
                //idsourcejquery
                if(typeof source == "string"){
                    if(source.substr(0,1) !="#") {
                        source = "#"+source;
                    }
                    source = $(source);
                }
                $.dynamicutil.removeChildren(this.element,source);
            }
        });

        $.widget("ui.wafColumnLayout", {
            options:{
                afterAdjustLayout:null
            },
            _create:function () {
                var self = this;
                if(!this.element.data("domcreated")){
                    $(this.element).attr("ctrlrole","columnLayout").attr("data-domcreated","true");
                    //class
                    if (!self.element.hasClass(defaultClass.defaultColumnLayoutClass)) {
                        self.element.addClass(defaultClass.defaultColumnLayoutClass);
                    }
                }
                this._setOptions(this.options);
                //Split
                this.createAllSplit();
                //,equalizemax.
                this.adjustLayout();
                //safari hack
                var browser = $.browser;
                var safari = (browser && browser.safari && $.boxLayoutUtil.userBrowser()==="webkit");
                if (safari) {
                    this.element.addClass("safarihack");
                }else{
                    this.element.removeClass("safarihack");
                }
            },
            _setOption:function(key,value){
                switch(key){
                    case "afterAdjustLayout":
                        this.options.afterAdjustLayout = value;
                        break;
                }
                $.Widget.prototype._setOption.apply( this, arguments );
            },
            getChildren:function () {
                //
                var self = this;
                return self.element.children("." + defaultClass.defaultColumnClass);
            },
            canAdjustLayout:function(){
                var childrens = $(this.element).children("." + defaultClass.defaultColumnClass);
                return this.hasChildrenInit() && (childrens.attr("equalize")||childrens.attr("autoMax")||childrens.attr("split"));
            },
            hasChildrenInit:function(){
                var childrens = $(this.element).children("." + defaultClass.defaultColumnClass);
                //
                return !(!childrens.data("wafColumn") && !childrens.data("_OPTIONS_"));
            },
            createAllSplit:function () {
                //split,shrink
                var layout = this;
                if(!this.hasChildrenInit()) return;
                $.each($(this.element).children("." + defaultClass.defaultColumnClass), function () {
                    //
                    var col = $(this), split = $(this).wafColumn("option","split"), op = $(this).data("wafColumn").options;
                    if (split) {
                        //ui-column,
                        var tmp = col.prev("." + defaultClass.defaultColumnClass);
                        if (tmp && tmp.length > 0 && !tmp.hasClass(defaultClass.splitPanelClass)) {
                            //SPLIT DIV,
    //                        var totalWidth = $(layout.element).width();
                            var elem = layout.buildSplit({colWidth:op.splitWidth, tagClass:(op.splitPanelClass + " " + op.splitClass)},col);
                            if (op.shrink) {
                                layout.buildShrink(elem,col);
                            }
                            if (op.draggable) {
                                layout.buildDraggable(elem,col);
                            }
                            //afterInsertSplit
                            if (elem) {
                                $(elem).next().triggerHandler("column.afterInsertSplit");
                            }
                        }
                    }
                });
            },
            //elem,target
            buildShrink:function(elem,target){
                if(target){
                    var shrink = $(target).wafColumn("option","shrink"),shrinkDiv=$(elem).children(".shrink"),totalWidth=this.element.width();
                    if(shrink){
                        if(shrinkDiv.length<=0){
                            //shrink
                            var div = document.createElement("div");
                            $(div).addClass("shrink").addClass("shrink-left");
                            $(elem).append($(div));
                            $(div).click(function () {
                                var nextElem =$(elem).next(),prevElem=$(elem).prev(),prewid,nextWid,status = prevElem.css("display");
                                prevElem.toggle();
                                if (status != "none") {
                                    $(div).removeClass("shrink-right").removeClass("shrink-left").addClass("shrink-right");
                                    //
                                    prewid = $.columnLayoutUtil.getElementWidth(prevElem);
                                    //
                                    prevElem.attr("originalWid",prewid);
                                    //=+
                                    nextWid = $.columnLayoutUtil.getElementWidth(nextElem) ;
                                    //
                                    nextElem.attr("originalWid",nextWid);
                                    nextElem.width(nextWid + prewid);
                                } else {
                                    $(div).removeClass("shrink-right").removeClass("shrink-left").addClass("shrink-left");
                                    //
                                    prewid = prevElem.attr("originalWid");
                                    prevElem.width(prewid);
                                    //
                                    nextWid = nextElem.attr("originalWid");
                                    nextElem.width(nextWid);
                                }
                                //
                                $(elem).next().triggerHandler("column.afterShrink");
                            });
                        }
                    }else{
                        //shrink
                        shrinkDiv.unbind("click");
                        shrinkDiv.remove();
                    }
                }
            },
            buildDraggable:function(elem,target){
                var layout = this;
                if(target){
                    var draggable = $(target).wafColumn("option","draggable"),shrinkDiv=$(elem).children(".shrink"),totalWidth=this.element.width();
                    if(draggable){
                        var containment = $.columnLayoutUtil.getContainment(elem);
                        //
                        $(elem).css("cursor", "col-resize");
                        //
                        $(elem).draggable({
                            "axis":"x",
                            helper:"clone",
                            containment:containment,
                            start:function(event, ui){
                                var nextElem = $(elem).next(),prevElem = $(elem).prev();
                                //elemcolumn
                                nextElem.width($.columnLayoutUtil.getElementWidth(nextElem)-$.wafutil.getVerticalScrollBarWidth());
                                //
                                nextElem.triggerHandler("column.beforeStartDrag");
                                //iframeiframeDIV.
                                nextElem.children("iframe").each(function(){
                                    $('<div class="ui-layout-mask"/>')
                                        .css({
                                            background:	"fff"
                                            ,	opacity:	"0.009"
                                            ,	zIndex:		9
                                            ,	position:	"absolute"
                                            ,	width:		nextElem[0].offsetWidth+"px"
                                            ,	height:		nextElem[0].offsetHeight+"px"
                                        })
                                        .css($(nextElem).position())
                                        .appendTo(this.parentNode)
                                    ;
                                });
                                //iframeiframeDIV.
                                prevElem.children("iframe").each(function(){
                                    $('<div class="ui-layout-mask"/>')
                                        .css({
                                            background:	"fff"
                                            ,	opacity:	"0.009"
                                            ,	zIndex:		9
                                            ,	position:	"absolute"
                                            ,	width:		prevElem[0].offsetWidth+"px"
                                            ,	height:		prevElem[0].offsetHeight+"px"
                                        })
                                        .css($(prevElem).position())
                                        .appendTo(this.parentNode)
                                    ;
                                });
                            },
                            stop:function (event, ui) {
                                var prevWid = 0, nextWid = 0, rangeWid = 0, nextElem =$(elem).next(),prevElem=$(elem).prev(),status = prevElem.css("display");
                                //shrink,
                                var hidden = (status === "none");
                                if (hidden) {
                                    //0
                                    prevWid = 0;
                                    nextWid = prevElem.attr("originalWid")+nextElem.attr("originalWid");
                                    //
                                    $(shrinkDiv).removeClass("shrink-right").removeClass("shrink-left").addClass("shrink-left");
                                    prevElem.css("display", $(elem).css("display"));
                                } else {
                                    prevWid = $.columnLayoutUtil.getElementWidth(prevElem);
                                    nextWid = $.columnLayoutUtil.getElementWidth(nextElem);
                                }
                                //
                                var offset = ui.position.left - ui.originalPosition.left;
                                prevWid = offset + prevWid;
                                nextWid = nextWid - offset;
                                prevElem.width(prevWid).attr("originalWid", prevWid);
                                nextElem.width(nextWid).attr("originalWid", nextWid);
                                //clonesplitpanel
                                var splitpanels = $(elem).parent().children("." + defaultClass.defaultColumnClass + "." + defaultClass.splitPanelClass);
                                if (splitpanels && splitpanels.length > 0) {
                                    splitpanels.each(function () {
                                        var id = $(this).attr("id");
                                        if (id === undefined || id === "") {
                                            $(this).remove();
                                        }
                                    });
                                }
                                layout.adjustLayout();
                                //
                                $(elem).next().triggerHandler("column.afterDragStop");
                                //iframeoverlay
                                $("div.ui-layout-mask",layout.element).remove();
                            }
                        });
                    }else{
                        $(elem).draggable("destory");
                    }
                }
            },
            buildSplit:function (op, target) {
                if(target){
                    var split = $(target).wafColumn("option","split"),tmp = target.prev("." + defaultClass.splitPanelClass);
                    if(split){
                        if(tmp && tmp.length<=0){
                            var o = {
                                id:null,
                                tagClass:defaultClass.splitPanelClass,
                                style:"position:relative;top:0",
                                colWidth:"5px",
                                equalize:true
                            },elem;
                            //targetsplit
                            o = $.extend(o, op);
                            //ID
                            if (o.id || o.id === null) {
                                o.id = "splitpanel_" + target.attr("id");
                            }
                            elem = document.createElement("div");
                            elem.id = o.id;
                            $(elem).wafColumn(o);
                            //targetsplit,adjustlayout
                            var targetWid = $.columnLayoutUtil.getElementWidth($(target));
                            $(target).width(targetWid-$.columnLayoutUtil.getElementWidth($(elem)));
                            //target
                            $(elem).insertBefore($(target)).height(1);
                            //
                            this.adjustLayout();
                            return elem;
                        }
                    }else{
                        //split
                        $(tmp).wafColumn("destory");
                        $(tmp).remove();
                        //
                        this.adjustLayout();
                    }
                }
            },
            adjustColumnWidth:function(){
                //1. split.
                //2. resize
                if(this.element.is(":hidden")) return;
                //splitpanel0split
                var tpanelWid = 0;
                $.each(this.element.children("." + defaultClass.defaultColumnClass + "." + defaultClass.splitPanelClass), function () {
                    tpanelWid += $.columnLayoutUtil.getElementWidth(this);
                });
                //split,
                if(tpanelWid==0)return;
                //
                var hasAllocateWid = 0, wid, percentage, id, kid,
                    totalWidth=this.element.width(),
                    oldWidth = parseInt(this.element.attr("totalwidth"));
                //,totalWidth
                var yscroll=this.element[0].scrollHeight>this.element[0].offsetHeight;
                if(yscroll) {
                    totalWidth = totalWidth-$.wafutil.getVerticalScrollBarWidth();
                }
                if($.isNaN(oldWidth)) oldWidth = totalWidth;

                $.each($(this.element).children("." + defaultClass.defaultColumnClass).not("." + defaultClass.splitPanelClass), function () {
                    kid = this;
                    //
                    wid = $.columnLayoutUtil.getElementWidth($(kid));
                    //=*/
                    wid = $.columnLayoutUtil.round(totalWidth * wid/oldWidth);
                    $(kid).width(wid).attr("originalWid",wid);
                    hasAllocateWid += wid;
                });

                //target,
                var span = totalWidth - hasAllocateWid - tpanelWid;
                if(!$.isNaN(span)&&span!=0){
                    wid = wid +span;
                    $(kid).width(wid).attr("originalWid",wid);
                }
                $(this.element).attr("totalWidth",totalWidth);
            },
            adjustColumnHeight:function(){
                //1. 2.
                //autoMaxtrueequalizetrue
                //autoMaxtrue
                //equalizetrue
                //splitsplit
                //autoMaxtruetrueequalize
                if(!this.hasChildrenInit()) return;
                //autoMaxequalize,allMaxnoEqualizeequalize=true
                var self = this,allMax = true,avaliableHeight,noEqualize=true;
                //maxHeight                           getMarginHeight
                var maxHeight = self._getMaxHeightByColumn();
                //splitsplit
                $.each($(this.element).children("." + defaultClass.defaultColumnClass).not("." + defaultClass.splitPanelClass), function () {
                    var col = $(this),
                        autoMax=$(col).wafColumn("option","autoMax"),
                        equalize = $(col).wafColumn("option","equalize");

                    if (autoMax) {
                        //,.
                        if(avaliableHeight===undefined) {
                            avaliableHeight = self._getAvaliableHeightByParent();
                            //columnbox-sizing,
                            avaliableHeight = avaliableHeight - $.boxLayoutUtil.getMarginHeight(self.element);
                        }
                        //
                        col.height(avaliableHeight);
                        //maxHeightavaliableHeight
                        if(maxHeight<avaliableHeight){
                            maxHeight = avaliableHeight;
                        }
                    }else{
                        allMax = false;
                    }

                    if (equalize) {
                        noEqualize = false;
                        col.height(maxHeight);
                    }
                });

                //
                if(allMax && noEqualize) {
                    this.element.height(avaliableHeight);
                }else{
                    //this.element.css("height","auto");
                }

                //split
                $.each(this.element.children("." + defaultClass.defaultColumnClass + "." + defaultClass.splitPanelClass), function () {
                    //
                    $(this).height(self.element[0].scrollHeight);
                });
            },
            adjustLayout:function (adjustHei,adjustWid) {
                if(!this.canAdjustLayout()) return;
                //
                if(adjustWid===undefined || adjustWid){
                    this.adjustColumnWidth();
                    //
                    var splitpanels = this.element.children("." + defaultClass.defaultColumnClass + "." + defaultClass.splitPanelClass);
                    if (splitpanels && splitpanels.length > 0) {
                        splitpanels.each(function () {
                            if ($(this).attr("id") != null && $(this).attr("id") != "" && $(this).next() != null) {
                                $(this).draggable("option", "containment", $.columnLayoutUtil.getContainment($(this)));
                            }
                        });
                    }
                }
                //,margindoBody
                if(adjustHei==undefined || adjustHei){
                    this.adjustColumnHeight();
                }

                if(this.options.afterAdjustLayout && $.isFunction(this.options.afterAdjustLayout)){
                    this.options.afterAdjustLayout.call(this);
                }
            },
            _getMaxHeightByColumn:function () {
                var kids = this.getChildren();
                //equalize,auto
                kids.each(function(){
                    var col = $(this), equalize = $(col).wafColumn("option","equalize");
                    if(equalize){
                        col.css("height", "auto");
                    }
                });
                var maxHeight = 0;
                kids.each(function () {
                    var tmp = $.columnLayoutUtil.getElementHeight(this);
                    if (tmp > maxHeight) {
                        maxHeight = tmp;
                    }
                });
                return maxHeight;
            },
            _getAvaliableHeightByParent:function () {
                var elem = this.element, container = this.element.parent(), totalHeight = container.height(), avaliableHeight = totalHeight;
                $.each(container.children(), function () {
                    if (this.tagName !== "SCRIPT" &&
                        this.tagName !== "LINK" && "none"!=$(this).css("display")) {
                        avaliableHeight -= $.columnLayoutUtil.getElementHeight(this);
                    }
                });
                return avaliableHeight + $.columnLayoutUtil.getElementHeight(this.element);
            },
            destroy:function () {
                this.element.removeClass(defaultClass.defaultColumnLayoutClass).removeAttr("ctrlrole");
                $.Widget.prototype.destroy.call( this );
            },
            appendChildren:function(source,pos){
                $.dynamicutil.appendChildren(this.element,source,pos);
            },
            removeChildren:function(source){
                //idsourcejquery
                if(typeof source == "string"){
                    if(source.substr(0,1) !="#") {
                        source = "#"+source;
                    }
                    source = $(source);
                }
                //
                if($(source).is("div") && $(source).hasClass("ui-column") && $(source).hasClass("border-sizing")) {
                    //
                    var oldWidth = $.columnLayoutUtil.getElementWidth($(source));
                    $.dynamicutil.removeChildren(this.element,source);
                    $.columnLayoutUtil.avgWidToNoSplitColumn(oldWidth,this.element);
                }

            }
        });


        $.columnLayoutUtil = $.columnLayoutUtil || {};
        $.extend($.columnLayoutUtil, {
            getContainment:function (elem) {
                var prev = $(elem).prev();
                var next = $(elem).next();
                return [prev.offset().left, prev.offset().top,
                    $.boxLayoutUtil.getElementWidth(next) + next.offset().left - parseInt($(elem).width(), 10)
                    , next.offset().top
                ];
            },
            getElementWidth:function (elem) {
                return $(elem).outerWidth(true);
            },
            getElementHeight:function (elem) {
                return $(elem).outerHeight(true);
            },
            avgWidToNoSplitColumn:function(allWidth,columnLayout){
                if($(columnLayout).is(":hidden")) return;
                //splitpanel0split
                var tpanelWid = 0;
                $.each($(columnLayout).children("." + defaultClass.defaultColumnClass + "." + defaultClass.splitPanelClass), function () {
                    tpanelWid += $.columnLayoutUtil.getElementWidth(this);
                });
                //split,
                if(tpanelWid==0)return;

                //
                var allNoSplitColumn = $(columnLayout).children("." + defaultClass.defaultColumnClass).not("." + defaultClass.splitPanelClass);
                var averageWid = allWidth/allNoSplitColumn.length;
                $.each(allNoSplitColumn,function(){
                    var col = $(this);
                    var newWid = $.columnLayoutUtil.getElementWidth(col) + averageWid;
                    $(col).width(newWid).attr("originalWid",newWid);
                })
                waf(columnLayout).wafColumnLayout("adjustLayout");
            },
            round:function(num, dec){
                var sNum = num + '';
                var idx = sNum.indexOf(".");
                if (idx < 0)
                    return num;
                var n = sNum.length - idx - 1;
                if (dec < n) {
                    var e = Math.pow(10, dec);
                    return Math.round(num * e) / e;
                } else {
                    return num;
                }
            }
        });


        waf.ieHack.hackResize(function(e){
            var columnLayouts = $("." + defaultClass.defaultColumnLayoutClass),data;
            for(var i=0;i<columnLayouts.length;i++){
                if(!$(columnLayouts[i]).is(":hidden")){
                    data = $(columnLayouts[i]).data();
                    if(data.wafColumnLayout){
                        $(columnLayouts[i]).wafColumnLayout("adjustLayout");
                    }
                }
            }
            //
            var totalWidth = $("." + defaultClass.defaultColumnLayoutClass).attr("totalWidth");
            var nowWidth = $("." + defaultClass.defaultColumnLayoutClass).width();
            if(totalWidth<nowWidth){
                var layout = $("." + defaultClass.defaultColumnLayoutClass);
                data = layout.data();
                if(data.wafColumnLayout){
                    layout.wafColumnLayout("adjustLayout");
                }

            }
        });

        window.onload = function () {
            var columnLayouts = $("." + defaultClass.defaultColumnLayoutClass);
            for(var i=0;i<columnLayouts.length;i++){
                if(!$(columnLayouts[i]).is(":hidden")){
                    var data = $(columnLayouts[i]).data();
                    if(data.wafColumnLayout){
                        $(columnLayouts[i]).wafColumnLayout("adjustLayout");
                    }
                }
            }
        }

        /*
         * wafColumn
         * 2013-01-05
         */
        $.extend($.wafColumn, {
            createColumnDOM:function (opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    var elem = $("<div id='"+opts.id+"' ctrlrole='column' class='ui-column border-sizing'></div>");
                    if(opts.colWidth){
                        var wid = opts.colWidth;
                        try{
                            wid = parseFloat(wid) + "%";
                            elem.css("width",wid);
                        }catch(e){}
                    }
                    return elem;
                }else{
                    return obj;
                }

            },
            initColumn:function (opts, el) {
                if(el && el instanceof jQuery){
                    $(el).wafColumn(opts);
                }
            },
            removeColumn:function (opts) {
                $("#"+opts.id).remove();
            },
            modifyColumn:function (opts) {
                $("#"+opts.id).wafColumn("option",opts);
            }
        });

        $(function () {
            if ($.registerComponent)
                $.registerComponent("column", {createDOMFun:$.wafColumn.createColumnDOM, initFun:$.wafColumn.initColumn,
                    deleteFun:$.wafColumn.removeColumn, modifyFun:$.wafColumn.modifyColumn,lazyInit:true});
        });

    }(jQuery));
//});
//mod.defineModule("checkbox", ["base","waf"], function() {

    /*
     * author: Zhang Yanfang
     * date: 2012-2-3
     * ----------------------------------------------------------------------------------
     * updateLog:
     * 12012-11-21
     * 
     * idnameoption
     */

    (function ($, undefined) {
        $.wafCheckbox = $.wafCheckbox || {};
        $.widget("ui.wafCheckbox", $.ui.wafctrl, {
            options:{
                label:'',
                value:1,
                checked:false,
                disabled:false,
                tabindex:0,
                style:null,
                tagClass:null,
                onclick:null,
                hidden:false,
                onchange:null
            },
            _create:function () {
                var checkbox = this.element,
                        o = this.options,
                        id = checkbox[0].id,
                        hidden = $("#" + id + "_el");
                //label init move to checkbox.tag 
                //label = $("<label for='" + id + "'>" + o.label + "</label>"),
                //checkbox.after(label);
                var self = this;
                checkbox.attr("value", o.value).attr("ctrlrole", "checkbox").addClass("ui-wafcheckbox");
                this.checkedType = o.checkedType;
                this.initFlag = true;

                if (!checkbox.data("domcreated")) {
                     checkbox.attr('data-domcreated', "true");
                }
                $.each(o, function (key, value) {
                    if (key != "id" && key != "name") {
                        self._setOption(key, value);
                    }
                });
                this._enter2tab();

                checkbox.bind("click",
                        function (e) {
                            var checked = checkbox[0].checked;
                            self.options["checked"] = checked;
                            self._trigger("onclick", e, { value:o.value, label:o.label, checked:checked });
                            self._handleHidden(checked);
                        }).bind("change", function (e) {
                    var checked = checkbox[0].checked;
                    self.options["checked"] = checked;
                    self._handleHidden(checked);
                    if (self._trigger("onchange", e, { value:o.value, label:o.label, checked:checked }) === false) {
                        self.options["checked"] = !checked;
                        checkbox[0].checked = !checked;
                        self._handleHidden(!checked);
                    }
                    ;
                });

                // formreset, .
                checkbox.closest("form").bind('reset.wafCheckbox', function () {
                    setTimeout($.proxy(self._reset, self), 10);
                });
                //view
                this._operateState();
            },
            _reset:function () {
                this.element[0].checked = this.defaultChecked;
                this._handleHidden(this.defaultChecked);
            },
            _handleHidden:function (checked) {
                var el = this.element, hidden = $("#" + el[0].id + "_el");
                if (this.checkedType == "boolean") {
                    hidden.val(checked);
                } else if (checked == true) {
                    hidden.val(this.options["value"]);
                } else {
                    hidden.val("");
                }
            },
            _setOption:function (key, value) {
                if (value === undefined) {
                    return;
                }
                var originalChecked = this.options["checked"], //applychecked
                        checkedResult = false;
                var checkbox = this.element;

                switch (key) {
                    case "checked":
                        var v = this.options.value, //
                                result = false;
                        if ($.type.isNumber(value) && v == value) {
                            result = true;
                        } else if ($.type.isString(value) && value.length > 0 && (value == "true" || v == value)) {
                            result = true;
                        } else if ($.type.isBoolean(value) && value == true) {
                            result = true;
                        } else if ($.type.isString(value) && value.indexOf(",") != -1) {
                            var array = value.split(",");
                            if ($.inArray(v, array) != -1) {
                                result = true;
                            }
                        }
                        checkbox[0].checked = result;
                        checkedResult = result;
                        if (!this.initFlag) {
                            if (result != originalChecked
                                    && this._trigger("onchange", "onchange",
                            { value:v, label:this.options.label, checked:result }) === false) {
                                checkbox[0].checked = !result;
                                checkedResult = !result;
                            }
                        } else {
                            this.defaultChecked = checkedResult;
                            this.initFlag = false;
                        }
                        this._handleHidden(checkedResult);
                        break;
                    case "disabled":
                        checkbox[0].disabled = value;
                        break;
                    case "tabindex":
                        checkbox.attr("tabindex", value);
                        break;
                    case "style":
                        if (value != null)checkbox.attr("style", value);
                        break;
                    case "tagClass":
                        if (value != null)checkbox.removeClass(this.options.tagClass).addClass(value);
                        break;
                    case "hidden":
                        checkbox[value ? "hide" : "show"]();
                        checkbox.next("label")[value ? "hide" : "show"]();
                        break;
                }
                $.Widget.prototype._setOption.apply(this, arguments);
                if (key == "checked") {
                    this.options[key] = checkedResult;
                }
                //view
                this._operateState();
            },
            _operateState: function() {
                var isView = $.wafutil.isViewOperateState(this.options);
                this.element[0].disabled = this.options.disabled || isView;
            },
            isChecked:function () {
                return this.element[0].checked;
            },
            setChecked:function (value) {
                if (value == null)
                    value = false;
                this._setOption("checked", value);
            },
            getChecked:function () {
                var name = this.element.attr("name");
                return $("[name='" + name + "']").filter(":checked");
            },
            getCheckedValue:function () {
                var checked = this.getChecked();
                var optionValue = checked.map(
                        function () {
                            return this.value;
                        }).get().join(", ");
                return optionValue;
            },
            getValue:function() {
                return this.getCheckedValue();
            },
            setValue:function(value) {
                this.setChecked(value);
            },
            _enter2tab:function () {
                if ($.fn.enter2tab) {
                    this.element.enter2tab();
                }
            }
        });
        /*
         * checkbox
         * author:Zhang yanfang
         * 2012-11-19
         */
        $.extend($.wafCheckbox, {
            createCheckboxDOM:function (opts) {
                if (opts) {
                    var obj = opts && opts.id && $("#" + opts.id);
                    if (!(obj && obj.data("domcreated"))) {
                        //checkbox
                        var checkbox = $("<input type='checkbox' name='" + opts.name + "_el' id='" + opts.id + "' >"),
                             label =  $("<label for='" +  opts.id + "'>" + opts.label + "</label>"),
                                doms = [];
                        if ($.wafutil.isViewOperateState(opts)) {
                            doms.push(checkbox,label);
                            return doms;
                        } else {
                            var hidden = $("<input type='hidden' name='" + opts.name + "' id='" + opts.id + "_el' >");
                            doms.push(hidden, checkbox,label);
                            return doms;
                        }
                    } else {
                        return obj;
                    }
                }
            },
            initCheckbox:function (opts, el) {
                //checkedType
                if ($.wafutil.isViewOperateState(opts)) {
                    if (el && opts) {
                        el=$.isArray(el)?el[el.length-2]:el;
                        el.attr("id", opts.id);
                        opts.disabled = true;
                        el.wafCheckbox(opts);
                        return el;
                    }
                } else {
                    el=$.isArray(el)?el[el.length-2]:el;
                    el.wafCheckbox(opts);
                    return el;
//                    if (el && opts && $.isArray(el)) {
//                        if (opts.id) {
//                            el[0].attr("id", opts.id + "_el");
//                            el[1].attr("id", opts.id);
//                        }
//                        if (opts.name) {
//                            el[0].attr("name", opts.name);
//                            el[1].attr("name", opts.name + "_el");
//                        }
//                        var temp = {
//                            id:opts.id,
//                            name:opts.name
//                        };
//                        delete opts.id;
//                        delete opts.name;
//                        el[1].wafCheckbox(opts);
//                        $.extend(opts, temp);
//                        return el[1];
//                    }
                }
            },
            removeCheckbox:function (opts) {
                var checkbox = $("#" + opts.id),
                        hidden = $("#" + opts.id + "_el"),
                        label = $("label[for='" + opts.id + "']");
                if (hidden.length > 0) {
                    hidden.remove();
                }
                label.remove();
                checkbox.remove();
            },
            modifyCheckbox:function (opts) {
                var checkbox = $("#" + opts.id),
                        temp = {
                            id:opts.id,
                            name:opts.name,
                            checked:opts.checked
                        };

                delete opts.id;
                delete opts.name;
                delete opts.checked
                checkbox.wafCheckbox("option", opts);
                checkbox.wafCheckbox("setChecked", temp.checked);
                $.extend(opts, temp);
                return checkbox;
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("checkbox", {createDOMFun:$.wafCheckbox.createCheckboxDOM, initFun:$.wafCheckbox.initCheckbox,
                    deleteFun:$.wafCheckbox.removeCheckbox, modifyFun:$.wafCheckbox.modifyCheckbox,lazyInit:true});
        });
    }(jQuery));
//});
//mod.defineModule("radio", ["base","waf"], function() {
    /*
     * author: Zhang Yanfang
     * date: 2012-2-3
     */

    (function ($, undefined) {
        $.wafRadio = $.wafRadio || {};
        $.widget("ui.wafRadio", $.ui.wafctrl, {
            options:{
                label:'',
                value:null,
                checked:false,
                disabled:false,
                tabindex:0,
                style:null,
                tagClass:null,
                onclick:null,
                hidden:false
            },
            _create:function () {
                var radio = this.element,
                        o = this.options;
                radio.attr("value", o.value).attr("ctrlrole", "radio").addClass("ui-radio");
                var self = this;

                radio.attr('data-domcreated', "true");
                $.each(this.options, function (key, value) {
                    self._setOption(key, value);
                });
                this._enter2tab();

                radio.bind("click", function (e) {
                    self.options["checked"] = true;
                    var id = this.id, name = this.name;
                    $(":radio").filter(
                            function () {
                                return (this.id != id) && (this.name == name);
                            }).each(function () {
                        $(this).wafRadio("option", "checked", false);
                    });
                    self._trigger("onclick", e, { value:o.value, label:o.label});
                });
                //view
                this._operateState();
            },
            _setOption:function (key, value) {
                if (value === undefined) {
                    return;
                }
                var radio = this.element,
                        checkedResult = false;
                switch (key) {
                    case "checked":
                        var v = this.options.value; //
                        if ($.type.isNumber(value) && v == value) {
                            checkedResult = true;
                        } else if ($.type.isBoolean(value) && value == true) {
                            checkedResult = true;
                        } else if ($.type.isString(value) && (value == v || value == "true")) {
                            checkedResult = true;
                        }
                        radio[0].checked = checkedResult;
                        break;
                    case "disabled":
                        radio[0].disabled = value;
                        break;
                    case "tabindex":
                        radio.attr("tabindex", value);
                        break;
                    case "style":
                        radio.attr("style", value);
                        break;
                    case "tagClass":
                        radio.removeClass(this.options.tagClass).addClass(value);
                        break;
                    case "hidden":
                        radio.toggle(!value);
                        radio.next("label").toggle(!value);
                        break;
                }
                $.Widget.prototype._setOption.apply(this, arguments);
                if (key == "checked") {
                    this.options[key] = checkedResult;
                }
            },
            _operateState: function() {
                var isView = $.wafutil.isViewOperateState(this.options);
                this.element[0].disabled = this.options.disabled || isView;
            },
            isChecked:function () {
                return this.element[0].checked;
            },
            getChecked:function () {
                var name = this.element.attr("name");
                return $("[name='" + name + "']").filter(":checked");
            },
            getCheckedValue:function () {
                var checked = this.getChecked();
                var optionValue = checked.map(
                        function () {
                            return this.value;
                        }).get().join(", ");
                return optionValue;
            },
            _enter2tab:function () {
                if ($.fn.enter2tab) {
                    this.element.enter2tab();
                }
            }
        });
        /*
         radio
         authorZhang Yanfang
         date2012-11-26
         */

        $.extend($.wafRadio, {
            createRadioDom:function (opts) {
                var result = false;
                    if (opts) {
                        if (opts.checked == "true") {
                            result = true;
                        } else if (opts.checked != null && opts.value != null) {
                            if (opts.checked == opts.value) {
                                result = true;
                            }
                        }
                    }

                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    var el = $("<input type='radio' " + (result ? "checked='true'" : "") + " name='" + opts.name + "' id='" + opts.id + "'>"),
                            label = $("<label for='" + opts.id + "'>" + opts.label + "</label>"),
                            dom = [];
                    dom.push(el, label);
                    return dom;
                } else {
                    obj.checked = result;
                    return obj;
                }
            },
            initRadio:function (opts, el) {
                el=$.isArray(el)?el[0]:el;
                if (el && opts) {
                    if ($.wafutil.isViewOperateState(opts)) {
                        opts.disabled = true;
                    }
//                    if (opts.id) {
//                        el.attr("id", opts.id);
//                    }
//                    if (opts.name) {
//                        el.attr("name", opts.name);
//                    }
//                    var temp = {
//                        id:opts.id,
//                        name:opts.name
//                    };
//                    delete opts.id;
//                    delete opts.name;
//                    $.extend(opts, temp);
                    el.wafRadio(opts);
                    return el;
                }
            },
            modifyRadio:function (opts) {
                if (opts && opts.id) {
                    var el = $("#" + opts.id);
                    var temp = {
                        id:opts.id,
                        name:opts.name
                    };
                    delete opts.id;
                    delete opts.name;
                    el.wafRadio("option", opts);
                    $.extend(opts, temp);
                    return el;
                }
            },
            removeRadio:function (opts) {
                if (opts && opts.id) {
                    var el = $("#" + opts.id),
                            label = $("label[for='" + opts.id + "']");
                    label.remove();
                    el.remove();
                }
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("radio", {createDOMFun:$.wafRadio.createRadioDom, initFun:$.wafRadio.initRadio,
                    deleteFun:$.wafRadio.removeRadio, modifyFun:$.wafRadio.modifyRadio,lazyInit:true});
        });
    }(jQuery));
//});
//mod.defineModule("menu", ["base","waf","position"], function() {
    /*!
     * jQuery UI Menu 1.9.0m8
     *
     * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
     * Dual licensed under the MIT or GPL Version 2 licenses.
     * http://jquery.org/license
     *
     * http://docs.jquery.com/UI/Menu
     *
     * Depends:
     *  jquery.ui.core.js
     *  jquery.ui.widget.js
     */
//menuID
//blurdelayif
// 2012-5-24
//click 2012-5-30
// 2012-7-10
    (function($) {

        var idIncrement = 0,
            currentEventTarget = null;

        $.widget( "ui.menu", {
            version: "1.9.0m8",
            defaultElement: "<ul>",
            delay: 300,
            options: {
                menus: "ul",
                position: {
                    my: "left top",
                    at: "right top"
                },
                role: "menu",

                // callbacks
                blur: null,
                focus: null,
                select: null
            },
            _create: function() {
                this.activeMenu = this.element;
//            this.menuId = this.element.attr( "id" ) || "ui-menu-" + idIncrement++;
                if ( this.element.find( ".ui-icon" ).length ) {
                    this.element.addClass( "ui-menu-icons" );
                }
                this.element
                    .addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
                    .attr({
//                    id: this.menuId,
                        role: this.options.role,
                        tabIndex: 0
                    })
                    // need to catch all clicks on disabled menu
                    // not possible through _bind
                    .bind( "click.menu", $.proxy(function( event ) {
                    if ( this.options.disabled ) {
                        event.preventDefault();
                    }
                }, this ));

                if ( this.options.disabled ) {
                    this.element
                        .addClass( "ui-state-disabled" )
                        .attr( "aria-disabled", "true" );
                }

                this._bind({
                    // Prevent focus from sticking to links inside menu after clicking
                    // them (focus should always stay on UL during navigation).
                    "mousedown .ui-menu-item > a": function( event ) {
                        event.preventDefault();
                    },
                    "click .ui-state-disabled > a": function( event ) {
                        event.preventDefault();
                    },
                    "click .ui-menu-item:has(a):not(:has(ul))": function( event ) {
                        //:not(:has(ul))liclick
                        var target = $( event.target );
                        if ( target[0] !== currentEventTarget ) {
                            currentEventTarget = target[0];
                            target.one( "click.menu", function( event ) {
                                currentEventTarget = null;
                            });
                            // Don't select disabled menu items
                            if ( !target.closest( ".ui-menu-item" ).is( ".ui-state-disabled" ) ) {
                                this.select( event );
                                // Redirect focus to the menu with a delay for firefox
                                this._delay(function() {
                                    if ( !this.element.is(":focus") ) {
                                        this.element.focus();
                                    }
                                }, 20 );
                            }
                        }
                    },
                    "mouseenter .ui-menu-item": function( event ) {
                        var target = $( event.currentTarget );
                        // Remove ui-state-active class from siblings of the newly focused menu item
                        // to avoid a jump caused by adjacent elements both having a class with a border
                        target.siblings().children( ".ui-state-active" ).removeClass( "ui-state-active" );
                        this.focus( event, target );
                    },
                    "mouseleave": "collapseAll",
                    "mouseleave .ui-menu": "collapseAll",
                    "focus": function( event ) {
                        var menu = this.element,
                            firstItem = menu.children( ".ui-menu-item" ).eq( 0 );
                        if ( this._hasScroll() && !this.active ) {
                            menu.children().each(function() {
                                var currentItem = $( this );
                                if ( currentItem.offset().top - menu.offset().top >= 0 ) {
                                    firstItem = currentItem;
                                    return false;
                                }
                            });
                        } else if ( this.active ) {
                            firstItem = this.active;
                        }
                        this.focus( event, firstItem );
                    },
                    blur: function( event ) {
                        this._delay(function() {
//                        if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
                            this.collapseAll( event );
//                        }
                        });
                    },
                    "keydown": "_keydown"
                });

                this.refresh();

                this._bind( this.document, {
                    click: function( event ) {
                        if ( !$( event.target ).closest( ".ui-menu" ).length ) {
                            this.collapseAll( event );
                        }
                    }
                });
            },

            destroy: function() {
                $.Widget.prototype.destroy.call( this );

                // destroy (sub)menus
                this.element
                    .removeAttr( "aria-activedescendant" )
                    .find( ".ui-menu" ).andSelf()
                    .removeClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
                    .removeAttr( "role" )
                    .removeAttr( "tabIndex" )
                    .removeAttr( "aria-labelledby" )
                    .removeAttr( "aria-expanded" )
                    .removeAttr( "aria-hidden" )
                    .show();

                // destroy menu items
                this.element.find( ".ui-menu-item" )
                    .unbind( ".menu" )
                    .removeClass( "ui-menu-item" )
                    .removeAttr( "role" )
                    .children( "a" )
                    .removeClass( "ui-corner-all ui-state-hover" )
                    .removeAttr( "tabIndex" )
                    .removeAttr( "role" )
                    .removeAttr( "aria-haspopup" )
                    .children( ".ui-icon" )
                    .remove();

                // unbind currentEventTarget click event handler
                $( currentEventTarget ).unbind( "click.menu" );
            },

            _keydown: function( event ) {
                switch ( event.keyCode ) {
                    case $.ui.keyCode.PAGE_UP:
                        this.previousPage( event );
                        event.preventDefault();
                        break;
                    case $.ui.keyCode.PAGE_DOWN:
                        this.nextPage( event );
                        event.preventDefault();
                        break;
                    case $.ui.keyCode.HOME:
                        this._move( "first", "first", event );
                        event.preventDefault();
                        break;
                    case $.ui.keyCode.END:
                        this._move( "last", "last", event );
                        event.preventDefault();
                        break;
                    case $.ui.keyCode.UP:
                        this.previous( event );
                        event.preventDefault();
                        break;
                    case $.ui.keyCode.DOWN:
                        this.next( event );
                        event.preventDefault();
                        break;
                    case $.ui.keyCode.LEFT:
                        this.collapse( event );
                        event.preventDefault();
                        break;
                    case $.ui.keyCode.RIGHT:
                        if ( !this.active.is( ".ui-state-disabled" ) ) {
                            this.expand( event );
                        }
                        event.preventDefault();
                        break;
                    case $.ui.keyCode.ENTER:
                        if ( !this.active.is( ".ui-state-disabled" ) ) {
                            if ( this.active.children( "a[aria-haspopup='true']" ).length ) {
                                this.expand( event );
                            } else {
                                //click
                                this.active.children("a").trigger("click");
                                this.select( event );
                            }
                        }
                        event.preventDefault();
                        break;
                    case $.ui.keyCode.ESCAPE:
                        this.collapse( event );
                        event.preventDefault();
                        break;
                    case $.ui.keyCode.TAB:
                        event.preventDefault();
                        break;
                    default:
                        clearTimeout( this.filterTimer );
                        var match,
                            prev = this.previousFilter || "",
                            character = String.fromCharCode( event.keyCode ),
                            skip = false;

                        if ( character === prev ) {
                            skip = true;
                        } else {
                            character = prev + character;
                        }
                    function escape( value ) {
                        return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
                    }
                        match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
                            return new RegExp( "^" + escape( character ), "i" )
                                .test( $( this ).children( "a" ).text() );
                        });
                        match = skip && match.index(this.active.next()) !== -1 ?
                            this.active.nextAll(".ui-menu-item") :
                            match;
                        if ( !match.length ) {
                            character = String.fromCharCode(event.keyCode);
                            match = this.activeMenu.children(".ui-menu-item").filter(function() {
                                return new RegExp( "^" + escape(character), "i" )
                                    .test( $( this ).children( "a" ).text() );
                            });
                        }
                        if ( match.length ) {
                            this.focus( event, match );
                            if ( match.length > 1 ) {
                                this.previousFilter = character;
                                this.filterTimer = this._delay(function() {
                                    delete this.previousFilter;
                                }, 1000 );
                            } else {
                                delete this.previousFilter;
                            }
                        } else {
                            delete this.previousFilter;
                        }
                }
            },

            refresh: function() {
                // initialize nested menus
                var menus,
                    submenus = this.element.find( this.options.menus)
                        .addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
                        .hide()
                        .attr({
                            role: this.options.role,
                            "aria-hidden": "true",
                            "aria-expanded": "false"
                        });

                // don't refresh list items that are already adapted
                menus = submenus.add( this.element );

                menus.children( ":not( .ui-menu-item ):has( a )" )
                    .addClass( "ui-menu-item" )
                    .attr( "role", "presentation" )
                    .children( "a" )
                    .addClass( "" )
                    .attr( "tabIndex", -1 )
                    .attr( "role", this._itemRole() );

                // initialize unlinked menu-items as dividers
                menus.children( ":not(.ui-menu-item)" ).addClass( "ui-widget-content ui-menu-divider" );

                // add aria-disabled attribute to any disabled menu item
                menus.children( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

                submenus.each(function() {
                    var menu = $( this ),
                        item = menu.prev( "a" );

                    item.attr( "aria-haspopup", "true" )
                        .prepend( '<span class="ui-menu-icon ui-icon ui-icon-carat-1-e"></span>' );
                    menu.attr( "aria-labelledby", item.attr( "id" ) );
                });
            },

            _itemRole: function() {
                return {
                    menu: "menuitem",
                    listbox: "option"
                }[ this.options.role ];
            },

            focus: function( event, item ) {
                var nested, borderTop, paddingTop, offset, scroll, elementHeight, itemHeight, focused;
                this.blur( event, event && event.type === "focus" );

                if ( this._hasScroll() ) {
                    borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
                    paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
                    offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
                    scroll = this.activeMenu.scrollTop();
                    elementHeight = this.activeMenu.height();
                    itemHeight = item.height();

                    if ( offset < 0 ) {
                        this.activeMenu.scrollTop( scroll + offset );
                    } else if ( offset + itemHeight > elementHeight ) {
                        this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
                    }
                }

                this.active = item.first();
                focused = this.active.children( "a" ).addClass( "ui-state-focus" );
                // only update aria-activedescendant if there's a role
                // otherwise we assume focus is managed elsewhere
                if ( this.options.role ) {
                    this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
                }

                // highlight active parent menu item, if any
                this.active.parent().closest( ".ui-menu-item" ).children( "a:first" ).addClass( "ui-state-active" );

                if ( event.type === "keydown" ) {
                    this._close();
                } else {
                    this.timer = this._delay(function() {
                        this._close();
                    }, this.delay );
                }

                nested = $( "> .ui-menu", item );
                if ( nested.length && ( /^mouse/.test( event.type ) ) ) {
                    this._startOpening(nested);
                }
                this.activeMenu = item.parent();

                this._trigger( "focus", event, { item: item } );
            },

            blur: function( event, fromFocus ) {
                if ( !fromFocus ) {
                    clearTimeout( this.timer );
                }

                if ( !this.active ) {
                    return;
                }

                this.active.children( "a" ).removeClass( "ui-state-focus" );
                this.active = null;

                this._trigger( "blur", event, { item: this.active } );
            },

            _startOpening: function( submenu ) {
                clearTimeout( this.timer );

                // Don't open if already open fixes a Firefox bug that caused a .5 pixel
                // shift in the submenu position when mousing over the carat icon
                if ( submenu.attr( "aria-hidden" ) !== "true" ) {
                    return;
                }

                this.timer = this._delay(function() {
                    this._close();
                    this._open( submenu );
                }, this.delay );
            },

            _open: function( submenu ) {
                //
                if(this.active.children("a:first").hasClass("ui-lb-disabled")){
                    return;
                }
                clearTimeout( this.timer );
                this.element.find( ".ui-menu" ).not( submenu.parents() )
                    .hide()
                    .attr( "aria-hidden", "true" );

                var position = $.extend( {}, {
                        of: this.active
                    }, $.type(this.options.position) === "function" ?
                    this.options.position(this.active) :
                    this.options.position
                );

                submenu
                    .show()
                    .removeAttr( "aria-hidden" )
                    .attr( "aria-expanded", "true" )
                    .position( position );
            },

            collapseAll: function( event, all ) {
                clearTimeout( this.timer );
                this.timer = this._delay(function() {
                    // if we were passed an event, look for the submenu that contains the event
                    var currentMenu = all ? this.element :
                        $( event && event.target ).closest( this.element.find( ".ui-menu" ) );

                    // if we found no valid submenu ancestor, use the main menu to close all sub menus anyway
                    if ( !currentMenu.length ) {
                        currentMenu = this.element;
                    }

                    this._close( currentMenu );

                    this.blur( event );
                    this.activeMenu = currentMenu;
                }, this.delay );
            },

            // With no arguments, closes the currently active menu - if nothing is active
            // it closes all menus.  If passed an argument, it will search for menus BELOW
            _close: function( startMenu ) {
                if ( !startMenu ) {
                    startMenu = this.active ? this.active.parent() : this.element;
                }

                startMenu
                    .find( ".ui-menu" )
                    .hide()
                    .attr( "aria-hidden", "true" )
                    .attr( "aria-expanded", "false" )
                    .end()
                    .find( "a.ui-state-active" )
                    .removeClass( "ui-state-active" );
            },

            collapse: function( event ) {
                var newItem = this.active &&
                    this.active.parent().closest( ".ui-menu-item", this.element );
                if ( newItem && newItem.length ) {
                    this._close();
                    this.focus( event, newItem );
                    return true;
                }
            },

            expand: function( event ) {
                var newItem = this.active &&
                    this.active
                        .children( ".ui-menu " )
                        .children( ".ui-menu-item" )
                        .first();

                if ( newItem && newItem.length ) {
                    this._open( newItem.parent() );

                    //timeout so Firefox will not hide activedescendant change in expanding submenu from AT
                    this._delay(function() {
                        this.focus( event, newItem );
                    }, 20 );
                    return true;
                }
            },

            next: function( event ) {
                this._move( "next", "first", event );
            },

            previous: function( event ) {
                this._move( "prev", "last", event );
            },

            isFirstItem: function() {
                return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
            },

            isLastItem: function() {
                return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
            },

            _move: function( direction, filter, event ) {
                var next;
                if ( this.active ) {
                    if ( direction === "first" || direction === "last" ) {
                        next = this.active
                            [ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
                            .eq( -1 );
                    } else {
                        next = this.active
                            [ direction + "All" ]( ".ui-menu-item" )
                            .eq( 0 );
                    }
                }
                if ( !next || !next.length || !this.active ) {
                    next = this.activeMenu.children( ".ui-menu-item" )[ filter ]();
                }

                this.focus( event, next );
            },

            nextPage: function( event ) {
                if ( !this.active ) {
                    this._move( "next", "first", event );
                    return;
                }
                if ( this.isLastItem() ) {
                    return;
                }
                if ( this._hasScroll() ) {
                    var base = this.active.offset().top,
                        height = this.element.height(),
                        result;
                    this.active.nextAll( ".ui-menu-item" ).each(function() {
                        result = $( this );
                        return $( this ).offset().top - base - height < 0;
                    });

                    this.focus( event, result );
                } else {
                    this.focus( event, this.activeMenu.children( ".ui-menu-item" )
                        [ !this.active ? "first" : "last" ]() );
                }
            },

            previousPage: function( event ) {
                if ( !this.active ) {
                    this._move( "next", "first", event );
                    return;
                }
                if ( this.isFirstItem() ) {
                    return;
                }
                if ( this._hasScroll() ) {
                    var base = this.active.offset().top,
                        height = this.element.height(),
                        result;
                    this.active.prevAll( ".ui-menu-item" ).each(function() {
                        result = $( this );
                        return $(this).offset().top - base + height > 0;
                    });

                    this.focus( event, result );
                } else {
                    this.focus( event, this.activeMenu.children( ".ui-menu-item" ).first() );
                }
            },

            _hasScroll: function() {
                return this.element.outerHeight() < this.element.prop( "scrollHeight" );
            },

            select: function( event ) {
                // save active reference before collapseAll triggers blur
                var ui = {
                    item: this.active
                };
                this.collapseAll( event, true );
                this._trigger( "select", event, ui );
            }
        });

    }( jQuery ));
//});

//mod.defineModule("popup", ["base","waf","menu","position"], function() {
    /*
     * jQuery UI Popup 1.9m6
     *
     * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
     * Dual licensed under the MIT or GPL Version 2 licenses.
     * http://jquery.org/license
     *
     * http://docs.jquery.com/UI/Popup
     *
     * Depends:
     *  jquery.ui.core.js
     *  jquery.ui.widget.js
     *  jquery.ui.position.js
     */
    (function($) {

        var idIncrement = 0;

        $.widget( "ui.popup", {
            version: "1.9m6",
            options: {
                position: {
                    my: "left top",
                    at: "left bottom"
                }
            },
            _create: function() {
                var self = this;
                if ( !this.options.trigger ) {
                    this.options.trigger = this.element.prev();
                }

                if ( !this.element.attr( "id" ) ) {
                    this.element.attr( "id", "ui-popup-" + idIncrement++ );
                    this.generatedId = true;
                }

                if ( !this.element.attr( "role" ) ) {
                    // TODO alternatives to tooltip are dialog and menu, all three aren't generic popups
                    this.element.attr( "role", "dialog" );
                    this.generatedRole = true;
                }

                this.options.trigger
                    .attr( "aria-haspopup", "true" )
                    .attr( "aria-owns", this.element.attr( "id" ) );

                this.element
                    .addClass( "ui-popup" );
                this.close();

                this._bind(this.options.trigger, {
                    keydown: function( event ) {
                        // prevent space-to-open to scroll the page, only happens for anchor ui.button
                        if ( $.ui.button && this.options.trigger.is( "a:ui-button" ) && event.keyCode == $.ui.keyCode.SPACE ) {
                            event.preventDefault();
                        }
                        // TODO handle SPACE to open popup? only when not handled by ui.button
                        if ( event.keyCode == $.ui.keyCode.SPACE && this.options.trigger.is( "a:not(:ui-button)" ) ) {
                            this.options.trigger.trigger( "click", event );
                        }
                        // translate keydown to click
                        // opens popup and let's tooltip hide itself
                        if ( event.keyCode == $.ui.keyCode.DOWN ) {
                            // prevent scrolling
                            event.preventDefault();
                            self.options.trigger.trigger( "click", event );
                        }
                    },
                    click: function( event ) {
                        event.preventDefault();
                        if (this.isOpen) {
                            // let it propagate to close
                            return;
                        }
                        clearTimeout( this.closeTimer );
                        this._delay(function() {
                            this.open( event );
                        }, 1);
                    },
                    //add by jlg. cannot use click event,for table
                    clickopen:function(event){
                        event.preventDefault();
                        if (this.isOpen) {
                            // let it propagate to close
                            return;
                        }
                        clearTimeout( this.closeTimer );
                        this._delay(function() {
                            this.open( event );
                        }, 1);
                    }
                });

                if ( !this.element.is( ":ui-menu" ) ) {
                    //default use case, wrap tab order in popup
                    this._bind({ keydown : function( event ) {
                        if ( event.keyCode !== $.ui.keyCode.TAB ) {
                            return;
                        }
                        var tabbables = $( ":tabbable", this.element ),
                            first = tabbables.first(),
                            last  = tabbables.last();
                        if ( event.target === last[ 0 ] && !event.shiftKey ) {
                            first.focus( 1 );
                            event.preventDefault();
                        } else if ( event.target === first[ 0 ] && event.shiftKey ) {
                            last.focus( 1 );
                            event.preventDefault();
                        }
                    }
                    });
                }

                this._bind({
                    focusout: function( event ) {
                        // use a timer to allow click to clear it and letting that
                        // handle the closing instead of opening again
                        this.closeTimer = this._delay( function() {
                            this.close( event );
                        }, 100);
                    },
                    focusin: function( event ) {
                        clearTimeout( this.closeTimer );
                    }
                });

                this._bind({
                    // TODO only triggered on element if it can receive focus
                    // bind to document instead?
                    // either element itself or a child should be focusable
                    keyup: function( event ) {
                        if ( event.keyCode == $.ui.keyCode.ESCAPE && this.element.is( ":visible" ) ) {
                            this.close( event );
                            // TODO move this to close()? would allow menu.select to call popup.close, and get focus back to trigger
                            this.options.trigger.focus();
                        }
                    }
                });

                this._bind(document, {
                    click: function( event ) {
                        if ( this.isOpen && !$(event.target).closest(".ui-popup").length
                            ) {
                            this.close( event );
                        }
                    }
                })
            },

            destroy: function() {
                $.Widget.prototype.destroy.call( this );

                this.element
                    .show()
                    .removeClass( "ui-popup" )
                    .removeAttr( "aria-hidden" )
                    .removeAttr( "aria-expanded" )
                    .unbind( "keypress.ui-popup");

                this.options.trigger
                    .removeAttr( "aria-haspopup" )
                    .removeAttr( "aria-owns" );

                if ( this.generatedId ) {
                    this.element.removeAttr( "id" );
                }
                if ( this.generatedRole ) {
                    this.element.removeAttr( "role" );
                }
            },

            open: function( event ) {
                if(this.options.trigger.hasClass("ui-popup-disabled")){
                    return;
                }
                var belongId = this.element.attr("belong"),
                    ofElement = $("#"+belongId);
                if(ofElement.length == 0){
                    ofElement =  this.options.trigger;
                }
                var position = $.extend( {}, {
                    //menubuttontrigger
                    of: ofElement
                }, this.options.position );

                this.element
                    .show()
                    .attr( "aria-hidden", "false" )
                    .attr( "aria-expanded", "true" )
                    .position( position );

                if (this.element.is( ":ui-menu" )) { //popup is a menu
                    this.element.menu( "focus", event, this.element.children( "li" ).first() );
                    this.element.focus();
                } else {
                    // set focus to the first tabbable element in the popup container
                    // if there are no tabbable elements, set focus on the popup itself
                    var tabbables = this.element.find( ":tabbable" );
                    this.removeTabIndex = false;
                    if ( !tabbables.length ) {
                        if ( !this.element.is(":tabbable") ) {
                            //
//----------------------------------------------------------------------------------------
//                  this.element.attr("tabindex", "0");
//----------------------------------------------------------------------------------------
                            this.removeTabIndex = true;
                        }
                        tabbables = tabbables.add( this.element[ 0 ] );
                    }
                    tabbables.first().focus( 1 );
                }

                // take trigger out of tab order to allow shift-tab to skip trigger
                //
//----------------------------------------------------------------------------------------
//      this.options.trigger.attr( "tabindex", -1 );
//----------------------------------------------------------------------------------------
                this.isOpen = true;
                this._trigger( "open", event );
            },

            close: function( event ) {
                this.element
                    .hide()
                    .attr( "aria-hidden", "true" )
                    .attr( "aria-expanded", "false" );
                //
                //----------------------------------------------------------------------------------------
//      this.options.trigger.attr( "tabindex" , 0 );
//      if ( this.removeTabIndex ) {
//          this.element.removeAttr( "tabindex" );
//      }
//----------------------------------------------------------------------------------------
                this.isOpen = false;
                this._trigger( "close", event );
            }
        });

    }(jQuery));

//});

//mod.defineModule("menuButton", ["base","waf","menu","popup"], function() {
    /*
     * author: Zhang Yanfang
     * date: 2012-2-3
     * log
     * -----------------------------------------------------2012-12-19------------------------------------------------------
     * 1js
     * 2menubelongid"btnId_ul"
     */

    (function ($, undefined) {
        $.wafMenuButton = $.wafMenuButton || {};
        $.widget("ui.wafMenuButton", {
            options: {
                caption: null,
                iconCls: null,
                style: null,
                tagClass: null,
                disabled: false,
                tabindex: 0,
                onclick: null,
                menuWidth: 100,
                hidden: false,
                position:null
            },

            _create: function() {
                var o = this.options,
                        id = this.element[0].id,
                        self = this;
                if (!this.element.data('domcreated')) {
                    //
                    this.element.addClass("ui-menubutton ui-linkbutton")
                            .attr("ctrlrole", "menuButton")
                            .attr("data-domcreated", "true")
                            .append("<span class='ui-lb-text'></span><span class='ui-menubtn-right icondefault ui-icon-triangle-1-s'></span>");
                    this.domcreated = false;
                }else{
                    this.domcreated = true;
                }
                this.arrow = this.element.find(".ui-menubtn-right");


                if (!this._isOne() && !this.domcreated) {
                    this.arrow = $("<div class='separateArrow'></div>").append(this.arrow).appendTo(this.element);
                }
                this.arrow.bind("click", function(e) {
                    if (o["onclick"] || o["actionBinding"]) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });

//                $("#" + id + "_ul").remove();
                this.menu = $("#" + id + "_ul")
                        .attr("belong", id)
                        .css("display", "none")
                        .addClass("ui-menu-ul-root ui-menu-ul")
                        .appendTo($(".page_margins .page")[0] || "body")
                        .css({
                    "position": "absolute",
                    "z-index": 999,
                    "top": 0,
                    "left": 0
                });


                this._initMenu();

                this._setOptions(o);

                //onclickactionBinding
                this.element.bind("click.wafMenuButton", function(e) {
                    if (!o.disabled) {
                        if (o["actionBinding"]) {
                            //actionBinding
                            setTimeout(function() {
                                waf.proxyCall.call(this, o["actionBinding"], undefined, e);
                            }, 100);
                        } else if (o["onclick"]) {
                            //onclick
                            var temp = o["onclick"];
                            setTimeout(function() {
                                if ($.isFunction(temp)) {
                                    self._trigger("onclick", e);
                                } else if ($.type.isString(temp)) {
                                    if (temp.indexOf("(") > -1) {
                                        eval(o["onclick"]);
                                    } else {
                                        var fun = eval(temp);
                                        if ($.isFunction(fun)) {
                                            o["onclick"] = fun;
                                            self._trigger("onclick", e);
                                        }
                                    }
                                }
                            }, 100);
                        }
                    }
                });

                this._enter2tab();
                if (!$.browser.msie) {
                    this.element.attr("href", "javascript:void(null)");
                }
            },

            _setOptions: function(options) {
                var self = this;
                $.each(options, function(key, value) {
                    self._setOption(key, value);
                });

                this._popupMenu();
            },

            _initMenu: function(menu) {
                this.menu.menu("destroy").menu({
                    select: function(e, ui) {
                        if (ui.item) {
                            var link = ui.item.find("a:first");
                            if (!link.find("span.ui-icon").length && !link.hasClass("ui-lb-disabled")) {
                                link.parents("ul.ui-menu-ul").hide();
                            }
                        }
                    }
                });
            },

            _popupMenu: function() {
                this.popupMenu(!!this.menu.children("li:not(.ui-item-invisible)").length);
            },

            _isOne:function() {
                var opts = this.options;
                return (!opts["onclick"] && !opts["actionBinding"]);
            },

            popupMenu: function(isShow) {
                var opts = this.options,
                        triggerElement = this._isOne() ? this.element : this.arrow;

                this.menu.popup("destroy");
                if (isShow) {
                    this.menu.popup({
                        trigger: triggerElement
                    });
                }
                this.arrow[isShow ? "show" : "hide"]();
            },

            _setOption: function(key, value) {
                if (value === undefined) {
                    return;
                }
                var el = this.element,
                        o = this.options;

                switch (key) {
                    case "iconCls":
                        var iconSpan = el.find("span.ui-lb-icon");
                        if (value == null || value.length == 0) {
                            if (iconSpan.length > 0) {
                                iconSpan.remove();
                            }
                        } else {
                            if (iconSpan.length == 0) {
                                iconSpan = $("<span class='ui-lb-icon'></span>");
                                el.prepend(iconSpan);
                            }
                            iconSpan.removeClass(o.iconCls).addClass(value);
                        }
                        break;
                    case "caption":
                        el.find("span.ui-lb-text").text(value);
                        break;
                    case "menuWidth":
                        this.menu.width(value);
                        break;
                    case "style":
                        el.attr(key, value);
                        break;
                    case "tagClass":
                        el.removeClass(o.tagClass).addClass(value);
                        break;
                    case "disabled":
                        //ui-popup-disabled triggerpopupopen
                        el[value ? "addClass" : "removeClass"]("ui-lb-disabled ui-state-disabled ui-popup-disabled");
                        this.arrow[value ? "addClass" : "removeClass"]("ui-popup-disabled");
                        break;
                    case "hidden":
                        el[value ? "hide" : "show"]();
                        break;
                    case "tabindex":
                        el.attr(key, value);
                        break;
                    case "position":
                        if (value) {
                            var li = this.element.parent("li");
                            if (value == "right") {
                                value = "pull-right";
                            } else if (value == "left") {
                                value = "pull-left";
                            } else {
                                value = null;
                            }
                            if (li.length > 0 && value != null && !li.hasClass(value)) {
                                li.addClass(value);
                            }
                        }
                        break;
                }
                this.options[key] = value;
            },

            _enter2tab: function() {
                if ($.fn.enter2tab) {
                    this.element.enter2tab();
                }
            },

            addMenuItem: function(itemOpts, pos) {
                if (itemOpts && $.type.isObject(itemOpts)) {
                    var itemId = itemOpts.id,
                            itemDom = $("<li id='" + itemId + "_li' class='ui-li-menuitem'><a id='" + itemId + "'></a></li>");

                    if (pos == undefined) {
                        this.menu.append(itemDom);
                    } else if ($.type.isNumber(pos)) {
                        if (pos == 0) {
                            this.menu.prepend(itemDom);
                        } else {
                            this.menu.children("li:eq(" + (index - 1) + ")").after(itemDom);
                        }
                    }
                    itemDom.find("#" + itemId).wafMenuItem(itemOpts);

                    this._initMenu();
                    this._popupMenu();
                }
            },

            removeMenuItem: function(itemId) {
                if (itemId != null) {
                    this.menu.menu("destroy");
                    waf.removeComponent("menuItem", {
                        id: itemId
                    });
                    if (this.menu.children("li.ui-li-menuitem").length) {
                        this._initMenu();
                        this._popupMenu();
                    } else {
                        this.menu.empty();
                        this.arrow.hide();
                    }
                }
            },

            appendChildren: function(source, pos) {
                source = $(source);
                var itemOpts = source.data('wafMenuItemOptions');

                if (pos == undefined) {
                    this.menu.append(source);
                } else if ($.type.isNumber(pos)) {
                    if (pos == 0) {
                        this.menu.prepend(source);
                    } else {
                        var temp = this.menu.children("li:eq(" + (index - 1) + ")");
                        temp.after(source);
                    }
                }
                this._initMenu();
                if (source && itemOpts) {
                    source.find("#" + itemOpts.id).wafMenuItem(itemOpts);
                }
                this._popupMenu();
            },

            removeChildren: function(source) {
                this.removeMenuItem($(source).attr('id'));
            }
        });
        /*
         menubutton
         authorZhang Yanfang
         date2012-11-28
         */
        $.extend($.wafMenuButton, {
            createMenuBtnDOM: function(opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    var menuBtn = $("<a id='" + opts.id + "'></a>"),
                        ul = $("<ul id='" + opts.id + "_ul'></ul>"),
                        doms = [];
                    doms.push(menuBtn, ul);
                    return doms;
                }else{
                    return obj;
                }

            },
            initMenuBtn: function(opts, el) {
                el=$.isArray(el)?el[0]:el;
                el.wafMenuButton(opts);
            },
            modifyMenuBtn: function(opts) {
                var menuBtn = $("#" + opts.id);
                menuBtn.wafMenuButton("option", opts);
            },
            removeMenuBtn: function(opts) {
                var menuBtn = $("#" + opts.id),
                        ul = $("ul[belong='" + opts.id + "']");
                menuBtn.remove();
                ul.remove();
            }
        });
        $(function() {
            if (waf.registerComponent)
                waf.registerComponent("menuButton", {
                    createDOMFun: $.wafMenuButton.createMenuBtnDOM,
                    initFun: $.wafMenuButton.initMenuBtn,
                    deleteFun: $.wafMenuButton.removeMenuBtn,
                    modifyFun: $.wafMenuButton.modifyMenuBtn,lazyInit:true
                });
        });
    }(jQuery));
//});
//mod.defineModule("menuItem", ["base","waf","popup","menu"], function() {
    /*
     * author: Zhang Yanfang
     * date: 2012-3-16
     */

    (function ($, undefined) {
        $.wafMenuItem = $.wafMenuItem || {};
        $.widget("ui.wafMenuItem", {
            options: {
                caption: '',
                disabled: false,
                style: null,
                tagClass: '',
                iconCls: null,
                onclick: null,
                hidden: false
            },
            submenu: null,
            menuitem: null,
            _create: function() {
                var o = this.options,
                        el = this.element,
                        id = el[0].id,
                        self = this;

                //
                el.attr("ctrlrole", "menuItem")
                        .addClass("ui-a-menuitem ui-linkbutton")
                        .append("<span class='ui-lb-icon'></span><span class='ui-lb-text'></span>");

                this.menuitem = el.parent("#" + id + "_li");

                //
                this.submenu = $("#" + id + "_ul");
                if (this.submenu.length) {
                    this.submenu.css("width", "100%").addClass("ui-menu-ul");
                }

                //
                this._setOptions(o);

                //
                el.bind("click.wafMenuItem", function(e) {
                    if (!o.disabled) {
                        if (o["actionBinding"]) {
                            waf.proxyCall.call(this, o["actionBinding"], undefined, e);
                        } else if (o["onclick"]) {
                            var temp = o["onclick"];
                            if ($.isFunction(temp)) {
                                self._trigger("onclick", e);
                            } else if ($.type.isString(temp)) {
                                if (temp.indexOf("(") > -1) {
                                    eval(o["onclick"]);
                                } else {
                                    var fun = eval(temp);
                                    if ($.isFunction(fun)) {
                                        o["onclick"] = fun;
                                        self._trigger("onclick", e);
                                    }
                                }
                            }
                        }
                    }
                });

                //IEhrefnull
                if (!$.browser.msie) {
                    el.attr("href", "javascript:void(null)");
                }
            },

            _setOptions: function(options) {
                var self = this;
                $.each(options, function(key, value) {
                    self._setOption(key, value);
                });

                var ul = this.element.closest("ul.ui-menu-ul");

                if (ul.length) {
                    var visibleItems = ul.children("li:not(.ui-item-invisible)");

                    if (visibleItems.length) {
                        var iconSpans = visibleItems.children("a").find("span.ui-lb-icon");

                        if (iconSpans.filter("[hasIcon=true]").length) {
                            iconSpans.css("display", "inline-block");
                        } else {
                            iconSpans.css("display", "inline");
                        }
                    }
                }
            },

            _setOption: function(key, value) {
                if (value === undefined) {
                    return;
                }
                var el = this.element,
                        o = this.options;
                switch (key) {
                    case "iconCls":
                        var iconSpan = el.find("span.ui-lb-icon");
                        iconSpan.removeClass(o.iconCls).addClass(value);
                        if (value && value.length) {
                            iconSpan.attr("hasIcon", true);
                        } else {
                            iconSpan.attr("hasIcon", false);
                        }
                        break;
                    case "caption":
                        el.find("span.ui-lb-text").text(value);
                        break;
                    case "style":
                        el.attr(key, value);
                        break;
                    case "tagClass":
                        el.removeClass(o.tagClass).addClass(value);
                        break;
                    case "disabled":
                        el[value ? "addClass" : "removeClass"]("ui-lb-disabled ui-state-disabled");
                        this.menuitem[value ? "addClass" : "removeClass"]("ui-state-disabled");
                        break;
                    case "hidden":
                        this.menuitem[value ? "addClass" : "removeClass"]("ui-item-invisible");
                        this.menuitem[value ? "hide" : "show"]();
                        break;
                }
                this.options[key] = value;
            },

            addMenuItem: function(itemOpts, pos) {
                if (itemOpts && $.type.isObject(itemOpts)) {
                    var itemId = itemOpts.id,
                            itemDom = $("<li id='" + itemId + "_li' class='ui-li-menuitem'><a id='" + itemId + "'></a></li>"),
                            el = this.element;

                    if (!this.submenu || !this.submenu.length) {
                        this.submenu = $("<ul id='" + el[0].id + "_ul' style='width:100%' class='ui-menu-ul'></ul>");
                        el.after(this.submenu);
                    }

                    if (pos == undefined) {
                        this.submenu.append(itemDom);
                    } else if ($.type.isNumber(pos)) {
                        if (pos == 0) {
                            this.submenu.prepend(itemDom);
                        } else {
                            this.submenu.children("li:eq(" + (index - 1) + ")").after(itemDom);
                        }
                    }
                    itemDom.find("#" + itemId).wafMenuItem(itemOpts);

                    this._refreshMenu();
                }
            },

            removeMenuItem: function(itemId) {
                if (this.submenu && this.submenu.length) {
                    this.submenu.find("#" + itemId + "_li").remove();

                    var visibleItems = this.submenu.children("li:not(.ui-item-invisible)");
                    if (visibleItems.length) {
                        var iconSpans = visibleItems.find("a span.ui-lb-icon");
                        if (iconSpans.filter("[hasIcon=true]").length) {
                            iconSpans.css("display", "inline-block");
                        } else {
                            iconSpans.css("display", "inline");
                        }
                    }

                    if (!this.submenu.children("li.ui-li-menuitem").length) {
                        this.submenu.remove();
                        this.submenu = null;
                    }

                    this._refreshMenu();
                }
            },

            _refreshMenu: function() {
                var menu = this.element.closest(".ui-menu-ul-root");
                menu.menu('destroy').menu({
                    select: function(e, ui) {
                        if (ui.item) {
                            var link = ui.item.find("a:first");
                            if (!link.find("span.ui-icon").length && !link.hasClass("ui-lb-disabled")) {
                                link.parents("ul.ui-menu-ul").hide();
                            }
                        }
                    }
                }).hide();
            },

            appendChildren: function(source, pos) {
                source = $(source);
                var itemOpts = source.data('wafMenuItemOptions'),
                        itemId = itemOpts.id,
                        el = this.element;

                if (!this.submenu || !this.submenu.length) {
                    this.submenu = $("<ul id='" + el[0].id + "_ul' style='width:100%' class='ui-menu-ul'></ul>");
                    el.after(this.submenu);
                }

                if (pos == undefined) {
                    this.submenu.append(source);
                } else if ($.type.isNumber(pos)) {
                    if (pos == 0) {
                        this.submenu.prepend(source);
                    } else {
                        this.submenu.children("li:eq(" + (index - 1) + ")").after(source);
                    }
                }
                source.find("#" + itemId).wafMenuItem(itemOpts);

                this._refreshMenu();
            },

            removeChildren: function(source) {
                this.removeMenuItem($(source).attr('id'));
            }
        });

        /*
         menuitem
         authorZhang Yanfang
         date2012-11-28
         */
        $.extend($.wafMenuItem, {
            createMenuItemDOM: function(opts) {
                var menuItem = $("<li id='" + opts.id + "_li' class='ui-li-menuitem'><a id='" + opts.id + "'></a></li>");
                menuItem.data('wafMenuItemOptions', opts);
                return menuItem;
            },
            initMenuItem: function(opts, el) {
            },
            modifyMenuItem: function(opts) {
                $("#" + opts.id).wafMenuItem("option", opts);
            },
            removeMenuItem: function(opts) {
                var menuItem = $("#" + opts.id),
                        li = menuItem.parent("li"),
                        ul = li.parent(".ui-menu-ul");
                li.remove();

                var visibleItems = ul.children("li:not(.ui-item-invisible)");
                if (visibleItems.length) {
                    var iconSpans = visibleItems.children("a").find("span.ui-lb-icon");
                    if (iconSpans.filter("[hasIcon=true]").length) {
                        iconSpans.css("display", "inline-block");
                    } else {
                        iconSpans.css("display", "inline");
                    }
                }
            }
        });
        $(function() {
            if ($.registerComponent)
                $.registerComponent("menuItem", {
                    createDOMFun: $.wafMenuItem.createMenuItemDOM,
                    initFun: $.wafMenuItem.initMenuItem,
                    deleteFun: $.wafMenuItem.removeMenuItem,
                    modifyFun: $.wafMenuItem.modifyMenuItem,lazyInit:true
                });
        });
    }(jQuery));
//});
//mod.defineModule("toolBar",["base","waf","boxUtil","position","menuButton","popup"],function(){
    /*
     * author: Zhang Yanfang
     * date: 2012-4-9
     */
    (function($, undefined) {

        $.fn.showMore = function(options) {
            options = $.extend({
                menuClass: "",
                btnMore: "down"
            }, options || {});

            var toolbar = $(this).children("div.ui-toolbar-main"),
                toolbarId = $(this).attr("id"),
                ul = toolbar.children("ul:first"),
                toolbarMore = $(this).children("div.ui-toolbar-more"),
                ulMore = $("ul.ui-toolbar-more-ul[belong='" + toolbarId + "']"),
                moreLi = ulMore.children("li");

            moreLi.each(function(idx, el) {
                el = $(el);
                if(el.is(".ui-hsplitbtn-li")) {
                    el.remove();
                    var vsplit = $("<li class='ui-vsplitbtn-li'><span></span></li>");
                    ul.append(vsplit);
                } else {
                    var innerElement = el.children("a:first"),
                        tempClass = innerElement.data("tempclass");
                    innerElement.addClass(tempClass).removeClass("ui-corner-all ui-toolbar-more-textindent ui-state-active ui-state-focus");
                    innerElement.next("ul.ui-menu-ul").find("a").removeClass("ui-state-active  ui-state-focus");
                    el.removeAttr("role").removeClass("ui-menu-item");

                    if(innerElement.attr("ctrlrole") == "menuButton") {
                        $("ul[belong='" + innerElement.attr("id") + "']")
                            .appendTo("body")
                            .css({"top": 0, "left": 0});
                        innerElement.wafMenuButton('popupMenu', true);
                        innerElement.children('.ui-menu-icon.ui-icon.ui-icon-carat-1-e').remove();
                    }

                    el.find("ul").removeClass(options.menuClass);
                    ul.append(el);
                }
            });
            ulMore.remove();
            toolbarMore.remove();

            var allLi = ul.children("li"),
                ulWidth = ul.width(),
                temp = 0,
                turnpoint = null;

            allLi.each(function(idx, el) {
                el = $(el);
                if(el.hasClass("ui-vsplitbtn-li")) {
                    var nextSplit = el.next("li.ui-vsplitbtn-li");
                    if(nextSplit.length > 0) {
                        el.remove();
                        return;
                    }
                }
                var liWidth = $.boxLayoutUtil.getElementWidth(el);
                if(temp + liWidth > ulWidth) {
                    turnpoint = el;
                    moreLi = turnpoint.prev().nextAll("li");
                    return false;
                } else {
                    temp += liWidth;
                }
            });

            if(turnpoint) {
                var div = $(this).children("div.ui-toolbar-more");
                if(!div.length) {
                    div = $("<div class='ui-toolbar-more'></div>").appendTo(this);
                    var spanMore = $("<span></span>").addClass(options.btnMore).appendTo(div),
                        ulMore = $("ul.ui-toolbar-more-ul[belong='" + toolbarId + "']");

                    if(!ulMore.length) {
                        ulMore = $("<ul class='ui-toolbar-more-ul ui-menu-ul' belong='" + toolbarId + "'></ul>")
                                    .css({"top": 0, "left": 0})
                                    .appendTo("body");
                    }
                }

                var btn = div.children("span:first"),
                    menu = ulMore,
                    maxLength = 0;

                moreLi.each(function(idx, el) {
                    el = $(el);
                    if(el.is(".ui-vsplitbtn-li")) {
                        el.remove();
                        menu.append("<li class='ui-hsplitbtn-li ui-menu-item'><span></span></li>");
                    } else {
                        var innerElement = el.children("a:first");
                        if(innerElement.attr("ctrlrole") == "menuButton") {
                            //,,wafMenuButton
                            $("ul[belong='" + innerElement.attr("id") + "']")
                                .insertAfter(innerElement);
                            innerElement.wafMenuButton('popupMenu', false);
                        }
                        if(innerElement.length) {
                            //classli
                            var tagClass = innerElement.attr("class");
                            innerElement.data("tempclass", tagClass);
                            innerElement.removeClass(tagClass).addClass("ui-linkbutton");
                            if(tagClass && tagClass.indexOf("ui-lb-disabled") != -1) {
                                innerElement.addClass("ui-lb-disabled");
                            }
                            menu.append(el);
                        }
                    }
                });


                menu.css({
                    "position": "absolute"
                }).menu("destroy").menu({
                    select: function(e, ui) {
                        if(ui.item) {
                            var link = ui.item.children("a:first");
                            if(!link.children("span.ui-menubtn-right").length) {
                                link.parents("ul.ui-menu-ul").hide();
                            }
                        }
                    },
                    position: {
                        my: "right top",
                        at: "left top"
                    }
                }).popup("destroy").popup({
                    trigger: btn,
                    position: {
                        my: "right top",
                        at: "right bottom"
                    }
                });
                if(options.menuClass) {
                    menu.addClass(options.menuClass);
                    menu.find("ul").addClass(options.menuClass);
                }
                if(menu.children("li").children("a").children("span.ui-lb-icon").length) {
                    menu.children("li").children("a:not(:has(span.ui-lb-icon))")
                        .addClass("ui-toolbar-more-textindent");
                }
                div.css("top", (toolbar.height() - div.height()) / 2);
            }
        }

        $.wafToolBar = $.wafToolBar || {};
        $.widget("ui.wafToolBar", {
            options: {
                btnMore: "down",
                hidden: false,
                isShowMore: false,
                menuClass: null,
                style: null,
                tagClass: null
            },
            _create: function() {
                var outDiv = this.element,
                    toolbar = outDiv.children("div.ui-toolbar-main"),
                    o = this.options;

                this._initByOptions("style", "tagClass", "hidden");
                this.element.attr('data-domcreated', "true");

                if(!o.isShowMore) {
                    toolbar.addClass("ui-div-showmenu");
                    toolbar.children("ul").addClass("ui-ul-showmenu");
                    outDiv.showMore(o);
                }
                $.ieHack.hackResize(function(e) {
                    if(!o.isShowMore) {
                        outDiv.showMore(o);
                    }
                }, outDiv);

            },

            _setOption: function(key, value) {
                var outDiv = this.element;
                if(key == "style") {
                    outDiv.attr(key, value);
                } else if(key == "tagClass") {
                    outDiv.removeClass(this.options.tagClass).addClass(value);
                } else if(key === "hidden") {
                    outDiv[value ? "hide" : "show"]();
                }
                this.options[key] = value;
                return this;
            },

            addElement: function(obj, index) {
                if($.type.isObject(obj)) {
                    if(obj[0].tagName == "A") {
                        obj.addClass("ui-linkbutton");
                    }
                    var ul = this.element.children("div.ui-toolbar-main").children("ul:first"),
                        added = $("<li></li>").append(obj);

                    if($.type.isNumber(index)){
                        added.insertBefore(ul.children("li:eq(" + index + ")"));
                    }else{
                        ul.append(added);
                    }

                    this.showMore(this.options);
                }
            },

            removeElement: function(index) {
                if($.type.isNumber(index)) {
                    var toolbar = this.element.children("div.ui-toolbar-main"),
                        obj = toolbar.find("ul:first li:eq(" + index + ")");
                    obj.remove();
                    this.showMore(this.options);
                }
            },

            getElement: function(index) {
                var toolbar = this.element.children("div.ui-toolbar-main"),
                    obj = toolbar.find("ul:first li:eq(" + index + ")").children();
                return obj;
            },

            addVSplitbutton: function(index) {
                var ul = this.element.children("div.ui-toolbar-main").children("ul:first"),
                    added = $("<li class='ui-vsplitbtn-li'><span></span></li>");

                if($.type.isNumber(index)){
                    added.insertBefore(ul.children("li:eq(" + index + ")"));
                }else{
                    ul.append(added);
                }

                this.showMore(this.options);
            },

            appendChildren: function(source, pos) {
                source = $.map(source, function(val, i){
                    if(i){
                        return val;
                    }
                    return $("<li></li>").append(val);
                });
                var ul = this.element.children("div.ui-toolbar-main").children("ul:first");
                $.dynamicutil.appendChildren(ul, source, pos);
            },

            removeChildren: function(source) {
                $.dynamicutil.removeChildren(this.element, source.parent("li"));
            },

            showMore: function(opts) {
                this.element.showMore(opts);
            }
        });
        /*
         * toolbar
         * author:Zhang yanfang
         * 2012-11-27
         */
        $.extend($.wafToolBar, {
            createToolbarDOM: function(opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    return $("<div class='ui-toolbar cf' ctrlrole='toolBar'><div class='ui-toolbar-main'><ul class='ui-toolbar-ul'></ul></div></div>");
                } else {
                    return obj;
                }
            },
            initToolbar: function(opts, el) {
                if(el && opts) {
                    if(opts.id) {
                        el.attr("id", opts.id);
                    }
                    var temp = {
                        id: opts.id
                    };
                    delete opts.id;
                    el.wafToolBar(opts);
                    $.extend(opts, temp);
                }
            },
            removeToolbar: function(opts) {
                var toolbar = $("#" + opts.id);
                toolbar.remove();
            },
            modifyToolbar: function(opts) {
                var toolbar = $("#" + opts.id),
                    temp = {
                        id: opts.id
                    };

                delete opts.id;
                toolbar.wafToolBar("option", opts);
                $.extend(opts, temp);
            }
        });
        $(function() {
            if($.registerComponent)
                $.registerComponent("toolBar", {
                    createDOMFun: $.wafToolBar.createToolbarDOM,
                    initFun: $.wafToolBar.initToolbar,
                    deleteFun: $.wafToolBar.removeToolbar,
                    modifyFun: $.wafToolBar.modifyToolbar,
                    lazyInit:true
                });
        });
    }(jQuery));
//});
//mod.defineModule("tab",["base","waf"],function(){
    (function($, undefined) {
        $.widget("ui.wafTab", {
            options : {
                id : null,
                title : null,
                url : null,
                iconClass : null,
                closable : false,
                tagClass : null,
                style : null,
                hidden : false
            },
            _create:function(){
                var opts = this.options,
                    id = opts.id;

                this.liPanel = $("#" + opts.tabPanelID);
                this.ul = this.liPanel.children("ul");
                this.li = this.ul.children("li#li_" + id);
                this.a = this.li.find('a:eq(0)');

                if (!$("#"+id).data("domcreated")) {
                    if (!this.li.length) {
                        this.li = $("<li id='li_" + id + "' customerid='" + id + "'></li>").appendTo(this.ul);
                    }
                    this.a = this.li.find('a:eq(0)');
                    if (!this.a.length) {
                        this.a = $("<a href='" + (opts.url || ("#" + id)) + "'><span class='tabs-title'>" + (opts.title || "&nbsp") + "</span></a>")
                                .appendTo(this.li);
                    }
                    $("#"+id).attr('data-domcreated', "true");
                }
                this._setOption("iconClass", opts.iconClass);
                this._setOption("closable", opts.closable);
                this._setOption("tagClass", opts.tagClass);
                this._setOption("style", opts.style);
                this._setOption("hidden", opts.hidden);
            },

            destory:function(){
                $.Widget.prototype.destroy.call( this );
            },
            widget:function(){
                return this.element;
            },
            url: function(url){
                var tabIndex = this.index();
                if(tabIndex>=0){
                    this.liPanel.wafTabs("url", tabIndex, url);
                }
            },
            load: function(url){
                var tabIndex = this.index();
                if(tabIndex>=0){
                    this.liPanel.wafTabs("load" , tabIndex, url);
                }
            },
            remove: function(){
                var tabIndex = this.index();
                if(tabIndex>=0){
                    this.liPanel.wafTabs("remove", tabIndex);
                }
            },
            select: function(){
                var tabIndex = this.index();
                if(tabIndex>=0){
                    this.liPanel.wafTabs('select', tabIndex);
                }
            },
            enable: function(){
                var tabIndex = this.index();
                if(tabIndex>=0){
                    this.liPanel.wafTabs('enable', tabIndex);
                }
            },
            disable: function(){
                var tabIndex = this.index();
                if(tabIndex>=0){
                    this.liPanel.wafTabs('disable', tabIndex);
                }
            },
            index: function(){
                return this.li.index();
            },
            _setOption: function( key, value ) {
                if ( key == "title" ) {
                    this.a.children('.tabs-title').html(value);
                }else if(key == "url"){
                    this.url(value);
                }else if(key == "disabled"){
                    value ? this.disable() : this.enable();
                }else if(key == "closable"){
                    var closeSpan = this.a.next(".ui-icon.ui-icon-close");
                    if(value){
                        if(!closeSpan.length){
                            this.a.after("<span class='ui-icon ui-icon-close'>Remove Tab</span>");
                        }
                    }else{
                        if(closeSpan.length){
                            closeSpan.remove();
                        }
                    }
                }else if(key == "tagClass"){
                    this.li.removeClass(this.options.tagClass).addClass(value);
                }else if(key == "style"){
                    this.li.attr(key, value);
                }else if(key == "hidden"){
                    this.li[value ? "hide" : "show"]();
                }else if(key == "iconClass"){
                    if(value){
                        this.a.prepend("<span class='tabs-icon " + value + "'></span>");
                        this.a.children(".tabs-title").addClass("tab-hasIcon");
                    }else{
                        this.a.children(".tabs-icon").remove();
                        this.a.children(".tabs-title").removeClass("tab-hasIcon");
                    }
                }
                this.options[ key ] = value;
            },

            appendChildren: function(source, pos){
                $.dynamicutil.appendChildren(this.element, source, pos);
            },

            removeChildren: function(source){
                $.dynamicutil.removeChildren(this.element, source);
            }
        });

        $.wafTab = $.wafTab || {};
        $.extend($.wafTab, {
            createTabDOM: function(opts){
                var obj = opts && opts.id && $("#" + opts.id);
                $.dynamicutil.addContextPath(opts, "url");
                if (!(obj && obj.data("domcreated"))) {
                    var dom = $('<div id="' + opts.id + '" ctrlrole="tab"></div>');
                    dom.data('wafTabOptions', opts);
                    return dom;
                } else {
                    obj.data('wafTabOptions', opts);
                    return obj;
                }
            },
            initTab: function(opts, el){
            },
            removeTab: function(opts){
                var tab = $("#" + opts.id),
                    tabPanel = $("#" + opts.parentId);

                if(tab.length && tabPanel.length){
                    tabPanel.wafTabs('remove', tab.wafTab('index'));
                }
            },
            modifyTab: function(opts){
                $.dynamicutil.addContextPath(opts, "url");
                $("#" + opts.id).wafTab('option', opts);
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("tab",{createDOMFun: $.wafTab.createTabDOM,
                                                   initFun: $.wafTab.initTab,
                                                   deleteFun: $.wafTab.removeTab,
                                                   modifyFun: $.wafTab.modifyTab,
                                                                   lazyInit:true});
        });
    }(jQuery));
//});
//mod.defineModule("tabPanel",["base","waf"],function(){
    (function( $, undefined ) {

        var tabId = 0,
            listId = 0;

        function getNextTabId() {
            return ++tabId;
        }

        function getNextListId() {
            return ++listId;
        }

        $.widget( "ui.wafTabs", {
            options: {
                ajaxOptions: null,
                cache: false,
                cookie: null, // e.g. { expires: 7, path: '/', domain: 'jquery.com', secure: true }
                collapsible: false,
                disabled: [],
                event: "click",
                fx: null, // e.g. { height: 'toggle', opacity: 'toggle', duration: 200 }
                idPrefix: "ui-waftabs-",
                panelTemplate: "<div></div>",
                spinner: null,//"<em>Loading&#8230;</em>",
                tabTemplate: "<li><a href='#{href}'><span class='tabs-title'>#{label}</span></a></li>",
                style: null,
                tagClass: null,
                onAdd: null,
                onLoad: null,
                onDisable: null,
                onEnable: null,
                onRemove: null,
                onSelect: null,
                onShow: null,
                beforeOnLoad: null,
                hidden: false
            },

            _create: function() {
                var self = this,
                    id = this.element[0].id;
                this._tabify( true );

                //ZP:scrollable
                /*
                if(this.options.scrollable)
                    this.element.scrollabletab();
                */

                //ZP:scrollable
                $("#" + id + " span.ui-icon-close" ).live("click.wafTabs", function() {
                    var index = $("li", self.element).index($(this).parent()),
                        disabled = $(self.panels[index]).wafTab('option', 'disabled');

                    if(!disabled){
                        self.remove(index);
                    }
                });

                this._setOption("tagClass", this.options.tagClass);
                this._setOption("style", this.options.style);
                this._setOption("hidden", this.options.hidden);
                this.element.attr("data-domcreated","true");
            },
            _setOption: function( key, value ) {
                if ( key == "selected" ) {
                    if (this.options.collapsible && value == this.options.selected ) {
                        return;
                    }
                    this.select( value );
                } else if (key === "tagClass") {
                    this.element.removeClass(this.options.tagClass).addClass(value);
                    this.options[ key ] = value;
                } else if (key === "style"){
                    this.element.attr(key, value);
                    this.options[ key ] = value;
                } else if (key === "hidden"){
                    this.element[value ? "hide" : "show"]();
                    this.options[ key ] = value;
                }else {
                    this.options[ key ] = value;
                    this._tabify();
                }
            },

            _tabId: function( a ) {
                return a.title && a.title.replace( /\s/g, "_" ).replace( /[^\w\u00c0-\uFFFF-]/g, "" ) ||
                    this.options.idPrefix + getNextTabId();
            },

            _sanitizeSelector: function( hash ) {
                // we need this because an id may contain a ":"
                return hash.replace( /:/g, "\\:" );
            },

            _cookie: function() {
                var cookie = this.cookie ||
                    ( this.cookie = this.options.cookie.name || "ui-waftabs-" + getNextListId() );
                return $.cookie.apply( null, [ cookie ].concat( $.makeArray( arguments ) ) );
            },

            _ui: function( tab, panel ) {
                return {
                    tab: tab,
                    panel: panel,
                    index: this.anchors.index( tab )
                };
            },

            _cleanup: function() {
                // restore all former loading tabs labels
                this.lis.filter( ".ui-state-processing" )
                    .removeClass( "ui-state-processing" )
                    .find( "span:data(label.wafTabs)" )
                        .each(function() {
                            var el = $( this );
                            el.html( el.data( "label.wafTabs" ) ).removeData( "label.wafTabs" );
                        });
            },

            _tabify: function( init ) {
                var self = this,
                    o = this.options,
                    fragmentId = /^#.+/; // Safari 2 reports '#' for an empty hash

                this.list = this.element.find( "ol,ul" ).eq( 0 );
                this.lis = $( " > li:has(a[href])", this.list );
                this.anchors = this.lis.map(function() {
                    return $( "a", this )[ 0 ];
                });
                this.panels = $( [] );

                this.anchors.each(function( i, a ) {
                    var href = $( a ).attr( "href" );
                    // For dynamically created HTML that contains a hash as href IE < 8 expands
                    // such href to the full page url with hash and then misinterprets tab as ajax.
                    // Same consideration applies for an added tab with a fragment identifier
                    // since a[href=#fragment-identifier] does unexpectedly not match.
                    // Thus normalize href attribute...
                    var hrefBase = href.split( "#" )[ 0 ],
                        baseEl;
                    if ( hrefBase && ( hrefBase === location.toString().split( "#" )[ 0 ] ||
                            ( baseEl = $( "base" )[ 0 ]) && hrefBase === baseEl.href ) ) {
                        href = a.hash;
                        a.href = href;
                    }

                    // inline tab
                    if ( fragmentId.test( href ) ) {
                        var $panel = self.element.find(self._sanitizeSelector(href));
                        if ($panel.length && $panel.data("wafTab") &&  ($panel.wafTab("option", "disabled") === true)) {
                            o.disabled.push(i);
                        }
                        self.panels = self.panels.add($panel);

                    // remote tab
                    // prevent loading the page itself if href is just "#"
                    } else if ( href && href !== "#" ) {
                        // required for restore on destroy
                        $.data( a, "href.wafTabs", href );

                        // TODO until #3808 is fixed strip fragment identifier from url
                        // (IE fails to load from such url)
                        $.data( a, "load.wafTabs", href.replace( /#.*$/, "" ) );

                        var customer = $(a).parent().attr('customerid'),
                            id = customer || self._tabId( a );
                        a.href = "#" + id;
                        var $panel = self.element.find( "#" + id );
                        if ( !$panel.length ) {
                            $panel = $( o.panelTemplate )
                                .attr( "id", id )
                                .addClass( "ui-waftabs-panel ui-widget-content ui-corner-bottom" )
                                .insertAfter( self.panels[ i - 1 ] || self.list );
                            $panel.data( "destroy.wafTabs", true );
                        }else{
                            if($panel.wafTab("option", "disabled") === true){
                                o.disabled.push(i);
                            }
                        }
                        self.panels = self.panels.add( $panel );
                    // invalid tab href
                    } else {
                        o.disabled.push( i );
                    }
                });

                // initialization from scratch
                if ( init ) {
                    // attach necessary classes for styling
                    this.element.addClass( "ui-waftabs ui-widget ui-widget-content ui-corner-all" );
                    this.list.addClass( "ui-waftabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" );
                    this.lis.addClass( "ui-state-default ui-corner-top" );
                    this.panels.addClass( "ui-waftabs-panel ui-widget-content ui-corner-bottom" );

                    // Selected tab
                    // use "selected" option or try to retrieve:
                    // 1. from fragment identifier in url
                    // 2. from cookie
                    // 3. from selected class attribute on <li>
                    if ( o.selected === undefined ) {
                        if ( location.hash ) {
                            this.anchors.each(function( i, a ) {
                                if ( a.hash == location.hash ) {
                                    o.selected = i;
                                    return false;
                                }
                            });
                        }
                        if ( typeof o.selected !== "number" && o.cookie ) {
                            o.selected = parseInt( self._cookie(), 10 );
                        }
                        if ( typeof o.selected !== "number" && this.lis.filter( ".ui-waftabs-selected" ).length ) {
                            o.selected = this.lis.index( this.lis.filter( ".ui-waftabs-selected" ) );
                        }
                        o.selected = o.selected || ( this.lis.length ? 0 : -1 );
                    } else if ( o.selected === null ) { // usage of null is deprecated, TODO remove in next release
                        o.selected = -1;
                    }

                    // sanity check - default to first tab...
                    o.selected = ( ( o.selected >= 0 && this.anchors[ o.selected ] ) || o.selected < 0 )
                        ? o.selected
                        : 0;

                    // Take disabling tabs via class attribute from HTML
                    // into account and update option properly.
                    // A selected tab cannot become disabled.
                    o.disabled = $.unique( o.disabled.concat(
                        $.map( this.lis.filter( ".ui-state-disabled" ), function( n, i ) {
                            return self.lis.index( n );
                        })
                    ) ).sort();

                    if ( $.inArray( o.selected, o.disabled ) != -1 ) {
                        o.disabled.splice( $.inArray( o.selected, o.disabled ), 1 );
                    }

                    // highlight selected tab
                    this.panels.addClass( "ui-waftabs-hide" );
                    this.lis.removeClass( "ui-waftabs-selected ui-state-active" );
                    // check for length avoids error when initializing empty list
                    if ( o.selected >= 0 && this.anchors.length ) {
                        self.element.find( self._sanitizeSelector( self.anchors[ o.selected ].hash ) ).removeClass( "ui-waftabs-hide" );
                        this.lis.eq( o.selected ).addClass( "ui-waftabs-selected ui-state-active" );

                        // seems to be expected behavior that the show callback is fired
                        self.element.queue( "wafTabs", function() {
                            var panel = self.element.find( self._sanitizeSelector( self.anchors[ o.selected ].hash ) )[ 0 ];
                            self._adjustJQGrid(panel);
                            self._trigger( "onShow", null, self._ui( self.anchors[ o.selected ], panel));
                        });

                        this.load( o.selected );
                    }

                    // clean up to avoid memory leaks in certain versions of IE 6
                    // TODO: namespace this event
                    $( window ).bind( "unload", function() {
                        self.lis.add( self.anchors ).unbind( ".wafTabs" );
                        self.lis = self.anchors = self.panels = null;
                    });
                // update selected after add/remove
                } else {
                    o.selected = this.lis.index( this.lis.filter( ".ui-waftabs-selected" ) );
                }

                // update collapsible
                // TODO: use .toggleClass()
                this.element[ o.collapsible ? "addClass" : "removeClass" ]( "ui-waftabs-collapsible" );

                // set or update cookie after init and add/remove respectively
                if ( o.cookie ) {
                    this._cookie( o.selected, o.cookie );
                }

                // disable tabs
                for ( var i = 0, li; ( li = this.lis[ i ] ); i++ ) {
                    $( li )[ $.inArray( i, o.disabled ) != -1 &&
                        // TODO: use .toggleClass()
                        !$( li ).hasClass( "ui-waftabs-selected" ) ? "addClass" : "removeClass" ]( "ui-state-disabled" );
                }

                // reset cache if switching from cached to not cached
                if ( o.cache === false ) {
                    this.anchors.removeData( "cache.wafTabs" );
                }

                // remove all handlers before, tabify may run on existing tabs after add or option change
                this.lis.add( this.anchors ).unbind( ".wafTabs" );

                if ( o.event !== "mouseover" ) {
                    var addState = function( state, el ) {
                        if ( el.is( ":not(.ui-state-disabled)" ) ) {
                            el.addClass( "ui-state-" + state );
                        }
                    };
                    var removeState = function( state, el ) {
                        el.removeClass( "ui-state-" + state );
                    };
                    this.lis.bind( "mouseover.wafTabs" , function() {
                        addState( "hover", $( this ) );
                    });
                    this.lis.bind( "mouseout.wafTabs", function() {
                        removeState( "hover", $( this ) );
                    });
                    this.anchors.bind( "focus.wafTabs", function() {
                        addState( "focus", $( this ).closest( "li" ) );
                    });
                    this.anchors.bind( "blur.wafTabs", function() {
                        removeState( "focus", $( this ).closest( "li" ) );
                    });
                }

                // set up animations
                var hideFx, showFx;
                if ( o.fx ) {
                    if ( $.isArray( o.fx ) ) {
                        hideFx = o.fx[ 0 ];
                        showFx = o.fx[ 1 ];
                    } else {
                        hideFx = showFx = o.fx;
                    }
                }

                // Reset certain styles left over from animation
                // and prevent IE's ClearType bug...
                function resetStyle( $el, fx ) {
                    $el.css( "display", "" );
                    if ( !$.support.opacity && fx.opacity ) {
                        $el[ 0 ].style.removeAttribute( "filter" );
                    }
                }

                // Show a tab...
                var showTab = showFx
                    ? function( clicked, $show ) {
                        $( clicked ).closest( "li" ).addClass( "ui-waftabs-selected ui-state-active" );
                        $show.hide().removeClass( "ui-waftabs-hide" ) // avoid flicker that way
                            .animate( showFx, showFx.duration || "normal", function() {
                                resetStyle( $show, showFx );
                                self._adjustJQGrid($show[ 0 ]);
                                self._trigger( "onShow", null, self._ui( clicked,  $show[ 0 ]) );
                            });
                    }
                    : function( clicked, $show ) {
                        $( clicked ).closest( "li" ).addClass( "ui-waftabs-selected ui-state-active" );
                        $show.removeClass( "ui-waftabs-hide" );
                        self._adjustJQGrid($show[ 0 ]);
                        self._trigger( "onShow", null, self._ui( clicked, $show[ 0 ] ) );
                    };

                // Hide a tab, $show is optional...
                var hideTab = hideFx
                    ? function( clicked, $hide ) {
                        $hide.animate( hideFx, hideFx.duration || "normal", function() {
                            self.lis.removeClass( "ui-waftabs-selected ui-state-active" );
                            $hide.addClass( "ui-waftabs-hide" );
                            resetStyle( $hide, hideFx );
                            self.element.dequeue( "wafTabs" );
                        });
                    }
                    : function( clicked, $hide, $show ) {
                        self.lis.removeClass( "ui-waftabs-selected ui-state-active" );
                        $hide.addClass( "ui-waftabs-hide" );
                        self.element.dequeue( "wafTabs" );
                    };

                // attach tab event handler, unbind to avoid duplicates from former tabifying...
                this.anchors.bind( o.event + ".wafTabs", function() {
                    var el = this,
                        $li = $(el).closest( "li" ),
                        $hide = self.panels.filter( ":not(.ui-waftabs-hide)" ),
                        $show = self.element.find( self._sanitizeSelector( el.hash ) );

                    // If tab is already selected and not collapsible or tab disabled or
                    // or is already loading or click callback returns false stop here.
                    // Check if click handler returns false last so that it is not executed
                    // for a disabled or loading tab!
                    if ( ( $li.hasClass( "ui-waftabs-selected" ) && !o.collapsible) ||
                        $li.hasClass( "ui-state-disabled" ) ||
                        $li.hasClass( "ui-state-processing" ) ||
                        self.panels.filter( ":animated" ).length ||
                        self._trigger( "onSelect", null, self._ui( this, $show[ 0 ] ) ) === false ) {
                        this.blur();
                        return false;
                    }

                    o.selected = self.anchors.index( this );

                    self.abort();

                    // if tab may be closed
                    if ( o.collapsible ) {
                        if ( $li.hasClass( "ui-waftabs-selected" ) ) {
                            o.selected = -1;

                            if ( o.cookie ) {
                                self._cookie( o.selected, o.cookie );
                            }

                            self.element.queue( "wafTabs", function() {
                                hideTab( el, $hide );
                            }).dequeue( "wafTabs" );

                            this.blur();
                            return false;
                        } else if ( !$hide.length ) {
                            if ( o.cookie ) {
                                self._cookie( o.selected, o.cookie );
                            }

                            self.element.queue( "wafTabs", function() {
                                showTab( el, $show );
                            });

                            // TODO make passing in node possible, see also http://dev.jqueryui.com/ticket/3171
                            self.load( self.anchors.index( this ) );

                            this.blur();
                            return false;
                        }
                    }

                    if ( o.cookie ) {
                        self._cookie( o.selected, o.cookie );
                    }

                    // show new tab
                    if ( $show.length ) {
                        if ( $hide.length ) {
                            self.element.queue( "wafTabs", function() {
                                hideTab( el, $hide );
                            });
                        }
                        self.element.queue( "wafTabs", function() {
                            showTab( el, $show );
                        });

                        self.load( self.anchors.index( this ) );
                    } else {
                        throw "jQuery UI Tabs: Mismatching fragment identifier.";
                    }

                    // Prevent IE from keeping other link focussed when using the back button
                    // and remove dotted border from clicked link. This is controlled via CSS
                    // in modern browsers; blur() removes focus from address bar in Firefox
                    // which can become a usability and annoying problem with tabs('rotate').
                    if ( $.browser.msie ) {
                        this.blur();
                    }
                });

                // disable click in any case
                this.anchors.bind( "click.wafTabs", function(){
                    return false;
                });
            },

            _getIndex: function( index ) {
                // meta-function to give users option to provide a href string instead of a numerical index.
                // also sanitizes numerical indexes to valid values.
                if ( typeof index == "string" ) {
                    index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
                }

                return index;
            },

            destroy: function() {
                var o = this.options;

                this.abort();

                this.element
                    .unbind( ".wafTabs" )
                    .removeClass( "ui-waftabs ui-widget ui-widget-content ui-corner-all ui-waftabs-collapsible" )
                    .removeData( "wafTabs" );

                this.list.removeClass( "ui-waftabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" );

                this.anchors.each(function() {
                    var href = $.data( this, "href.wafTabs" );
                    if ( href ) {
                        this.href = href;
                    }
                    var $this = $( this ).unbind( ".wafTabs" );
                    $.each( [ "href", "load", "cache" ], function( i, prefix ) {
                        $this.removeData( prefix + ".wafTabs" );
                    });
                });

                this.lis.unbind( ".wafTabs" ).add( this.panels ).each(function() {
                    if ( $.data( this, "destroy.wafTabs" ) ) {
                        $( this ).remove();
                    } else {
                        $( this ).removeClass([
                            "ui-state-default",
                            "ui-corner-top",
                            "ui-waftabs-selected",
                            "ui-state-active",
                            "ui-state-hover",
                            "ui-state-focus",
                            "ui-state-disabled",
                            "ui-waftabs-panel",
                            "ui-widget-content",
                            "ui-corner-bottom",
                            "ui-waftabs-hide"
                        ].join( " " ) );
                    }
                });

                this.element.die("click.wafTabs");

                if ( o.cookie ) {
                    this._cookie( null, o.cookie );
                }

                return this;
            },

            add: function( option, label, index ) {
                if($.isPlainObject(option)){
                    index = label;
                    label = option.title;
                }
                if ( index === undefined ) {
                    index = this.anchors.length;
                }

                var self = this,
                    o = this.options,
                    url = $.isPlainObject(option) ? (option.url || ("#"+option.id)): option,
                    $li = $( o.tabTemplate.replace( /#\{href\}/g, url ).replace( /#\{label\}/g, label ) ),
                    id = $.isPlainObject(option) ? (option.id || this._tabId( $( "a", $li )[ 0 ] )) : !url.indexOf( "#" ) ? url.replace( "#", "" ) : this._tabId( $( "a", $li )[ 0 ] );

                $li.attr("id", "li_" + id).attr("customerid", id).addClass( "ui-state-default ui-corner-top" ).data( "destroy.wafTabs", true );

                // try to find an existing element before creating a new one
                var $panel = self.element.find( "#" + id );
                if ( !$panel.length ) {
                    $panel = $( o.panelTemplate )
                        .attr( "id", id )
                        .data( "destroy.wafTabs", true );
                }
                $panel.addClass( "ui-waftabs-panel ui-widget-content ui-corner-bottom ui-waftabs-hide" );

                var obj = option && option.id && $("#" + option.id);
                if (!(obj && obj.data("domcreated"))) {
                    if (index >= this.lis.length) {
                        $li.appendTo(this.list);
                        $panel.appendTo(this.list[ 0 ].parentNode);
                    } else {
                        $li.insertBefore(this.lis[ index ]);
                        $panel.insertBefore(this.panels[ index ]);
                    }
                }

                $panel.wafTab($.isPlainObject(option) ? $.extend(option, {'id':id, 'tabPanelID':o.id}) : {'id':id, 'url':url, 'title': label, 'tabPanelID':o.id});

                o.disabled = $.map( o.disabled, function( n, i ) {
                    return n >= index ? ++n : n;
                });

                this._tabify();

                if ( this.anchors.length == 1 ) {
                    o.selected = 0;
                    $li.addClass( "ui-waftabs-selected ui-state-active" );
                    $panel.removeClass( "ui-waftabs-hide" );
                    this.element.queue( "wafTabs", function() {
                        self._adjustJQGrid(self.panels[ 0 ]);
                        self._trigger( "onShow", null, self._ui( self.anchors[ 0 ], self.panels[ 0 ] ) );
                    });

                    this.load( 0 );
                }

                this._trigger( "onAdd", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
                return this;
            },

            remove: function( index ) {
                index = this._getIndex( index );
                var o = this.options,
                    $li = this.lis.eq( index ),
                    $panel = this.panels.eq( index ),
                    reselect = $li.hasClass( "ui-waftabs-selected" ) && this.anchors.length > 1,
                    nextSelectTab = reselect ? this._getNextSelectTab($li) : null;

                $li.remove();
                $panel.remove();
                // If selected tab was removed focus tab to the right or
                // in case the last tab was removed the tab to the left.
                if (reselect && nextSelectTab != null) {
                    this.select( nextSelectTab );
                }

                o.disabled = $.map(
                    $.grep( o.disabled, function(n, i) {
                        return n != index;
                    }),
                    function( n, i ) {
                        return n >= index ? --n : n;
                    });

                this._tabify();

                this._trigger( "onRemove", null, this._ui( $li.find( "a" )[ 0 ], $panel[ 0 ] ) );
                return this;
            },

            _getNextSelectTab: function(li){
                var tab = li.nextAll(":not(.ui-state-disabled):visible");
                if(!tab.length){
                    tab = li.prevAll(":not(.ui-state-disabled):visible");
                }
                if(tab.length){
                    return this.lis.index(tab.eq(0));
                }
                return null;
            },

            enable: function( index ) {
                index = this._getIndex( index );
                var o = this.options;
                if ( $.inArray( index, o.disabled ) == -1 ) {
                    return;
                }

                this.lis.eq( index ).removeClass( "ui-state-disabled" );
                this.panels.eq(index).data('wafTab').options.disabled = false;

                o.disabled = $.grep( o.disabled, function( n, i ) {
                    return n != index;
                });

                this._trigger( "onEnable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
                return this;
            },

            disable: function( index ) {
                index = this._getIndex( index );
                var self = this, o = this.options;
                // cannot disable already selected tab
                if ( index != o.selected ) {
                    this.lis.eq( index ).addClass( "ui-state-disabled" );
                    this.panels.eq(index).data('wafTab').options.disabled = true;

                    o.disabled.push( index );
                    o.disabled.sort();

                    this._trigger( "onDisable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
                }

                return this;
            },

            select: function( index ) {
                index = this._getIndex( index );
                if ( index == -1 ) {
                    if ( this.options.collapsible && this.options.selected != -1 ) {
                        index = this.options.selected;
                    } else {
                        return this;
                    }
                }
                this.anchors.eq( index ).trigger( this.options.event + ".wafTabs" );
                return this;
            },

            load: function( index , url ) {
                this._trigger("beforeOnLoad", null, this._ui(this.anchors[ index ], this.panels[ index ]));

                index = this._getIndex( index );
                var self = this,
                    o = this.options,
                    a = this.anchors.eq( index )[ 0 ];

                url = url || $.data( a, "load.wafTabs" );

                this.abort();

                // not remote or from cache
                if ( !url || this.element.queue( "wafTabs" ).length !== 0 && $.data( a, "cache.wafTabs" ) ) {
                    this.element.dequeue( "wafTabs" );
                    return;
                }

                // load remote from here on
                this.lis.eq( index ).addClass( "ui-state-processing" );

                if ( o.spinner ) {
                    var span = $( "span", a );
                    span.data( "label.wafTabs", span.html() ).html( o.spinner );
                }

                this.xhr = $.ajax( $.extend( {}, o.ajaxOptions, {
                    url: url,
                    success: function( r, s ) {
                        self.element.find( self._sanitizeSelector( a.hash ) ).html( r );

                        // take care of tab labels
                        self._cleanup();

                        if ( o.cache ) {
                            $.data( a, "cache.wafTabs", true );
                        }

                        self._trigger( "onLoad", null, self._ui( self.anchors[ index ], self.panels[ index ] ) );
                        try {
                            o.ajaxOptions.success( r, s );
                        }
                        catch ( e ) {}
                    },
                    error: function( xhr, s, e ) {
                        // take care of tab labels
                        self._cleanup();

                        self._trigger( "onLoad", null, self._ui( self.anchors[ index ], self.panels[ index ] ) );
                        try {
                            // Passing index avoid a race condition when this method is
                            // called after the user has selected another tab.
                            // Pass the anchor that initiated this request allows
                            // loadError to manipulate the tab content panel via $(a.hash)
                            o.ajaxOptions.error( xhr, s, index, a );
                        }
                        catch ( e ) {}
                    }
                } ) );

                // last, so that load event is fired before show...
                self.element.dequeue( "wafTabs" );

                return this;
            },

            abort: function() {
                // stop possibly running animations
                this.element.queue( [] );
                this.panels.stop( false, true );

                // "wafTabs" queue must not contain more than two elements,
                // which are the callbacks for the latest clicked tab...
                this.element.queue( "wafTabs", this.element.queue( "wafTabs" ).splice( -2, 2 ) );

                // terminate pending requests from other tabs
                if ( this.xhr ) {
                    this.xhr.abort();
                    delete this.xhr;
                }

                // take care of tab labels
                this._cleanup();
                return this;
            },

            url: function( index, url ) {
                this.anchors.eq( index ).removeData( "cache.wafTabs" ).data( "load.wafTabs", url );
                return this;
            },

            length: function() {
                return this.anchors.length;
            },

            changeTitle: function(index, title){
                var self = this,
                    a = this.anchors.eq( index )[ 0 ];

                if(a && title){
                    if($(title).length>0){
                        $(a).html(title);
                    }else{
                        $(a).find("span:first-child").text(title);
                    }
                }
            },

            _adjustJQGrid: function(panel){
                if(panel){
                    var tables = $(panel).find(".ui-jqgrid .ui-jqgrid-btable");
                    if(tables && tables.length > 0){
                        tables.wafGrid("adjustWidthInTab");
                    }
                }
            },

            appendChildren: function(source, pos){
                source = $(source);
                if (!source.data("domcreated")) {
                    this.element.append(source);
                }
                this.add(source.data('wafTabOptions'), pos);
            },

            removeChildren: function(source){
                source = $(source, this.element);

                var panelIdx = $.inArray(source, this.panels),
                    liIdx = $.inArray(source, this.lis),
                    index = panelIdx >= 0 ? panelIdx : liIdx >= 0 ? llIdx : -1;

                if(index >= 0){
                    this.remove(index);
                }else{
                    $.dynamicutil.removeChildren(this.element, source);
                }
            }
        });

        /*
         * Rotate
         */
        $.extend( $.ui.wafTabs.prototype, {
            rotation: null,
            rotate: function( ms, continuing ) {
                var self = this,
                    o = this.options;

                var rotate = self._rotate || ( self._rotate = function( e ) {
                    clearTimeout( self.rotation );
                    self.rotation = setTimeout(function() {
                        var t = o.selected;
                        self.select( ++t < self.anchors.length ? t : 0 );
                    }, ms );

                    if ( e ) {
                        e.stopPropagation();
                    }
                });

                var stop = self._unrotate || ( self._unrotate = !continuing
                    ? function(e) {
                        if (e.clientX) { // in case of a true click
                            self.rotate(null);
                        }
                    }
                    : function( e ) {
                        rotate();
                    });

                // start rotation
                if ( ms ) {
                    this.element.bind( "wafTabsshow", rotate );
                    this.anchors.bind( o.event + ".wafTabs", stop );
                    rotate();
                // stop rotation
                } else {
                    clearTimeout( self.rotation );
                    this.element.unbind( "wafTabsshow", rotate );
                    this.anchors.unbind( o.event + ".wafTabs", stop );
                    delete this._rotate;
                    delete this._unrotate;
                }

                return this;
            }
        });
        $.wafTabs = $.wafTabs || {};
        $.extend($.wafTabs, {
            createTabPanelDOM: function(opts){
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                   return $('<div id="' + opts.id + '" ctrlrole="tabPanel"><ul id="' + opts.id + '_ul"></ul></div>');
                } else {
                   return obj;
                }
            },
            initTabPanel: function(opts, el){
                el.wafTabs(opts);
            },
            removeTabPanel: function(opts){
                var el = $("#" + opts.id);
                if(el.length){
                    el.wafTabs('destroy');
                    el.remove();
                }
            },
            modifyTabPanel: function(opts){
                $("#" + opts.id).wafTabs('option', opts);
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("tabPanel",{createDOMFun: $.wafTabs.createTabPanelDOM,
                                                   initFun: $.wafTabs.initTabPanel,
                                                   deleteFun: $.wafTabs.removeTabPanel,
                                                   modifyFun: $.wafTabs.modifyTabPanel,
                                                                   lazyInit:true});
        });
    })( jQuery );
//});
//mod.defineModule("floatbar",["base","waf","position"],function(){
    /*******************************************************************************
     * waf2 float bar
     *
     * @version 1.0
     * @author peng_zhou1
     * @Depends:
     * 		jquery.ui.core.js
     * 		jquery.ui.widget.js
     * 		jquery.ui.position.js
     ******************************************************************************/
    (function($) {
        var widgetClass = "ui-wafwidget",
            rnumpx = /^-?\d+(?:px)?$/i;


        $.widget("ui.wafFloatBar", {

            options : {
                side : "outer", // outer inner
                position : "right", // left right
                margin : null,
                zindex : null,
                targetSelector : "div.page_margins",
                speed : 350,
                fixed : true,

                buttonClass : null,
                buttonStyle : null,
                buttonHeight : null,
                buttonWidth : null,

                widgetBarClass : null,
                widgetBarStyle : null,
                widgetBarHeight : null,
                widgetBarWidth : null,

                buttonOverflow : false,
                widgetBarOverflow : true,

                beforeOpen : null,
                beforeClose : null,
                onOpen : null,
                onClose : null,

                hidden : false
            },
            elementVisible: false,
            buttonVisible: true,
            usingButtonIcon : null,
            target : null,
            buttonShow : true,
            widgetbarShow : false,
            _create : function() {
                var self = this,
                    doc = this.element[0].ownerDocument,
                    listHeight = 0;

                this.target = $(this.options.targetSelector);

                this.toolbar = $(".ui-floatbar-toolbar", this.element).eq(0);
                $('<a href="#" class="ui-floatbar-closeBtn" onclick="return false;"><span class="ui-icon ui-icon-circle-close"></span></a>')
                    .bind("click.wafFloatBar", function() {
                        self.close();
                    })
                    .appendTo(this.toolbar);

                this.list = $(".ui-floatbar-list", this.element).eq(0);
                this.list.children("." + widgetClass).wrap('<li style="padding-right: 16px;"></li>');

                this.element
                    .addClass(this.options.widgetBarClass)
                    .attr("style", this.options.widgetBarStyle)
                    .height(this.options.widgetBarHeight)
                    .width(this.options.widgetBarWidth)
                    .zIndex(this.options.zindex ? this.options.zindex : (this.target.zIndex() + 1))
                    .appendTo(this.target);

                this._setListHeight(true);

                this.element.hide();

                this.button = $('<div class="ui-floatbar-button ui-widget ui-state-default"></div>')
                    .addClass(this.options.buttonClass)
                    .attr("style", this.options.buttonStyle)
                    .height(this.options.buttonHeight)
                    .width(this.options.buttonWidth)
                    .zIndex(this.options.zindex ? this.options.zindex : (this.target.zIndex() + 1))
                    .hover(function(){$(this).addClass('ui-state-hover');}, function(){$(this).removeClass('ui-state-hover');})
                    .appendTo(this.target)
                    .bind("click.wafFloatBar", function(e){
                        self.open();
                    });

                this.buttonIcon = $('<span class="ui-icon"></span>')
                    .appendTo(this.button);
                this._positionButtonIcon();

                this._setOption("fixed", this.options.fixed);
                this._setOption("hidden", this.options.hidden);
            },

            open : function() {
                if(!this.widgetbarShow && this._trigger("beforeOpen")){
                    if(this.buttonDisappear) {
                        this.button.fadeOut();
                        this.buttonShow = false;
                    }
                    this.element.trigger("open");
                    this._showWidgetBar();
                    this.widgetbarShow = true;

                    this._trigger("onOpen");
                }
            },

            close : function() {
                if(this.widgetbarShow && this._trigger("beforeClose")){
                    if(this.buttonDisappear) {
                        this.button.fadeIn();
                        this.buttonShow = true;
                    }
                    this.element.trigger("close");
                    this._hideWidgetBar();
                    this.widgetbarShow = false;

                    this._trigger("onClose");
                }
            },

            _showWidgetBar : function(){
                if ($.effects && $.effects["slide"]){
                    this.element.show("slide", {direction : this.direction});
                }else{
                    this.element.fadeIn();
                }
            },

            _hideWidgetBar : function(){
                if ($.effects && $.effects["slide"]){
                    this.element.hide("slide", {direction : this.direction});
                }else{
                    this.element.fadeOut();
                }
            },

            _setOption : function(key, value) {
                var self = this;
                if (key === "widgetBarClass") {
                    this.element.removeClass(this.options.widgetBarClass).addClass(value);
                } else if(key === "widgetBarStyle" ) {
                    this.element.attr("style", value);
                    this.widgetbarShow ? this.element.show() : this.element.hide();
                } else if(key === "buttonClass") {
                    this.button.removeClass(this.options.buttonClass).addClass(value);
                } else if(key === "buttonStyle") {
                    this.button.attr("style", value);
                    this.buttonShow ? this.button.show() : this.button.hide();
                } else if(key === "zindex") {
                    value = value ? value : (this.target.zIndex() + 1);
                    this.element.zIndex(value);
                    this.button.zIndex(value);
                } else if(key === "buttonHeight") {
                    this.button.css("height", value ? value : '');
                } else if(key === "buttonWidth") {
                    this.button.css("width", value ? value : '');
                } else if(key === "widgetBarHeight") {
                    this.element.css("height", value ? value : '');
                } else if(key === "widgetBarWidth") {
                    this.element.css("width", value ? value : '');
                } else if(key == "fixed") {
                    if(value){
                        this.element.removeClass("ui-floatbar-absolute");
                        this.button.removeClass("ui-floatbar-absolute");
                        this.element.addClass("ui-floatbar-fixed");
                        this.button.addClass("ui-floatbar-fixed");

                        $(window).unbind("scroll.wafFloatBar");
                    } else {
                        this.element.removeClass("ui-floatbar-fixed");
                        this.button.removeClass("ui-floatbar-fixed");
                        this.element.addClass("ui-floatbar-absolute");
                        this.button.addClass("ui-floatbar-absolute");

                        $(window).bind("scroll.wafFloatBar", function(e){
                            self._setY(true);
                        });
                    }
                } else if(key == "hidden") {
                    if(value){
                        this.elementVisible = this.element.is(":visible");
                        this.buttonVisible = this.button.is(":visible");
                        this.element.hide();
                        this.button.hide();
                    }else{
                        if(this.elementVisible)this.element.show();
                        if(this.buttonVisible)this.button.show();
                    }
                }

                $.Widget.prototype._setOption.apply( this, arguments );

                if(key === "widgetBarHeight" || key === "widgetBarClass" || key === "widgetBarStyle") {
                    this._setListHeight(value == null);
                }
                if(key === "side" || key === "position" || key === "widgetBarStyle" || key === "buttonStyle" || key === "fixed") {
                    this._setX();
                }
                if(key === "margin" || key === "widgetBarStyle" || key === "buttonStyle" || key === "buttonOverflow" || key === "widgetBarOverflow" || key === "fixed") {
                    this._setY();
                }
                if(key === "buttonClass" || key === "buttonStyle" || key === "buttonHeight" || key === "buttonWidth") {
                    this._positionButtonIcon();
                }
                if(key === "targetSelector"){
                    this.refresh();
                }

            },

            widget : function(){
                return this.element;
            },

            destroy : function(){
                $.Widget.prototype.destroy.call( this );
            },
            //
            _setX : function(){
                var buttonCss = {},
                    elementCss = {},
                    buttonIcon = null,
                    clearCss = {right:"", left:""};

                this.button.css(clearCss);
                this.element.css(clearCss);

                if(this.options.position === "left") {
                    if(this.options.side === "outer" && !this.options.fixed){
                        buttonCss.left = 0 - this.button.outerWidth(true);
                    }else{
                        buttonCss.left = 0;
                    }
                    elementCss.left = 0;
                    buttonIcon = "ui-icon-carat-1-e";
                    this.direction = "left";
                }else if(this.options.position === "right") {
                    if(this.options.side === "outer" && !this.options.fixed){
                        buttonCss.right = 0  - this.button.outerWidth(true);
                    }else{
                        buttonCss.right = 0;
                    }

                    elementCss.right = 0;
                    buttonIcon = "ui-icon-carat-1-w";
                    this.direction = "right";
                }

                this.button.css(buttonCss);
                this.element.css(elementCss);


                if(this.options.side === "outer" && !this.options.fixed){
                    this.buttonDisappear = false;
                }else{
                    this.buttonDisappear = true;
                }

                this.buttonIcon.removeClass(this.usingButtonIcon);
                this.buttonIcon.addClass(buttonIcon);
                this.usingButtonIcon = buttonIcon;
            },

            _setY : function(animate){
                if(this.options.fixed){
                    this.button.css("top", this._getMargin());
                    this.element.css("top", this._getMargin());
                }else{
                    var targetTop = this.target.offset().top,
                        targetHeight = this.target.outerHeight() - this.element.outerHeight(true),
                        topOffest = $(window).scrollTop() - targetTop,
                        scrollHeight = (topOffest > 0 ? topOffest : 0) + this._getMargin(),
                        buttonHeight = this.target.outerHeight() - this.button.outerHeight(true),
                        widgetbarHeight = this.target.outerHeight() - this.element.outerHeight(true),
                        buttonTop = this.options.buttonOverflow ? scrollHeight : Math.min(scrollHeight, buttonHeight),
                        widgetbarTop = this.options.widgetBarOverflow ? scrollHeight : Math.min(scrollHeight, widgetbarHeight);;

                    if(animate){
                        this.button
                          .stop()
                          .animate(
                              {top: buttonTop}, this.options.speed, "linear"
                            );

                        this.element
                          .stop()
                          .animate(
                              {top: widgetbarTop}, this.options.speed, "linear"
                            );
                    }else{
                        this.button.css("top", buttonTop);
                        this.element.css("top", widgetbarTop);
                    }
                }
            },

            _getMargin : function(){
                var margin = this.options.margin;
                if(margin){
                    if(typeof margin === "string" && rnumpx.test(margin)){
                        margin = parseFloat( margin );
                        if ( margin >= 0 ) {
                            return margin + "px";
                        }
                    }
                    return margin;
                }
                return "0px";
            },

            refresh : function(){
                this.target = $(this.options.targetSelector);
                this.button.appendTo(this.target);
                this.element.appendTo(this.target);
                this._setY();
            },

            _positionButtonIcon : function(){
                this.buttonIcon.position({
                        of : this.button,
                        my : "center center",
                        at : "center center"
                    });
            },

            _setListHeight : function(init){
                if(init){
                    this.list.css("height", "");
                }
                this.list.height(this.element.height() - this.toolbar.outerHeight(true));
            }
        });
    })(jQuery);
//});
/*******************************************************************************
 * waf2 outline
 * 
 * @version 1.0
 * @author peng_zhou1
 * @Depends: 
 * 		jquery.ui.core.js 
 * 		jquery.ui.widget.js 
 ******************************************************************************/
(function($) {
		
	$.widget("ui.wafOutline", {
			
		options : {
			selector : "form",
			sectionSelector : ".ui-section",
			titleSelector :  ".sheader > .title",
			highlightClass : "ui-outline-highlight",
			title : "",
			titleIconClass : null,
            hidden : false
		},
		
		_create : function() {
			var self = this,
				doc = this.element[ 0 ].ownerDocument,
				ul = $('<ul class="ui-outline-sectionlist"></ul>').appendTo(this.element),
				contentLi = $('<li></li>').appendTo(ul);
				
			this.contentUl = $('<ul></ul>').appendTo(contentLi);
			
			this.titleLi = $('<li class="ui-outline-top"><span class="ui-outline-title">' + this.options.title + '</span></li>').prependTo(ul);
			this.titleIcon = $('<span class="ui-outline-titleicon"></span>').prependTo(this.titleLi);
			if(this.options.titleIconClass){
				this.titleIcon.addClass(this.options.titleIconClass);
				this.titleIcon.prependTo(this.titleLi);
			}
			
			this._setSection();
		},
		
		clearHighlight : function(){
			var self = this;
			this.sections.each(function(idx, ele) {
				$(ele).removeClass(self.options.highlightClass);
			});
		},
		
		_setOption : function(key, value) {
			if(key === "titleIconClass"){
				this.titleIcon.removeClass(this.options.titleIconClass).addClass(value);
				if(value){
					this.titleIcon.prependTo(this.titleLi);		
				}else{
					this.titleIcon.detach();		
				}
			}
            if(key === "hidden"){
            	this.element[value ? "hide" : "show"]();
            }
			$.Widget.prototype._setOption.apply( this, arguments );
			
			if(key === "selector" || key === "sectionSelector" || key === "titleSelector"){
				this._setSection();
			}
			if(key === "title"){
				this._refreshTitle();
			}
		},
		
		widget : function(){
			return this.element;
		},
		
		destroy : function(){
			$.Widget.prototype.destroy.call( this );
		},
		
		_setSection : function(){
			var self = this;
			this.sections = this._getSection();
			this.contentUl.empty();
			$.each(this.sections, function(idx, value){
				var	element = $(value),
				 	title =	self._getTitle(element), 
					id = element.attr("id")
				
				$('<li class="ui-outline-item"><a href="#' + id + '" class="ui-corner-all ui-outline-button"><span>' + title + '</span></a></li>')
					.bind("click.outline", {"ele" : element}, function(e){
						self.clearHighlight();
						e.data.ele.addClass(self.options.highlightClass);
					}).appendTo(self.contentUl);
			});
		},
		
		_getSection : function(){
			if(this.options.sectionSelector && $.isFunction(this.options.sectionSelector)){
				return this.options.sectionSelector.apply(this, $(this.options.selector));
			}
			return $(this.options.selector).children(this.options.sectionSelector);
		},
		
		_getTitle : function(section){
			if(this.options.titleSelector && $.isFunction(this.options.titleSelector)){
				return this.options.titleSelector.apply(this, $(section));
			}
			return $(this.options.titleSelector, section).text();
		},
		
		_refreshTitle : function(){
			$(".ui-outline-title", this.titleLi).text(this.options.title);
		},
		
		_refreshTitleIcon : function(){
			if(this.options.titleIconClass){
				this.titleIcon.addClass(this.options.titleIconClass);
			}else{
				this.titleIcon.detach();
			}
			$(".ui-outline-title", this.titleLi).text(this.options.title);
		}
	});
})(jQuery);
//mod.defineModule("multiLangBox",["base","waf","position"],function(){
    /*******************************************************************************
     * 
     *
     * @version 1.0
     * @author peng_zhou1
     * @Depends:
     *         jquery.ui.core.js
     *         jquery.ui.widget.js
     *         jquery.ui.position.js
     *         jquery.json.js
     ******************************************************************************/
    (function($) {

        var defaultClass = "ui-multiLangBox",
            layoutClass = "ui-multiLangBox-layout",
            inputClass = "ui-multiLangBox-input",
            triggerClass = "ui-multiLangBox-trigger",
            selectClass = "ui-multiLangBox-langSelect",
            itemClass = "ui-multiLangBox-langItem",
            supportClass = "supportMultiLang",
            notSupportClass = "notSupportMultiLang",
            rnumpx = /^-?\d+(?:px)?$/i,
            textEvents = ["onclick", "onblur", "ondblclick", "onfocus", "onselect", "onkeyup", "onkeypress",
                 "onkeydown", "onmouseover", "onmouseup", "onmouseout", "onmousemove", "onmousedown"],
            defaultOption = {
                id : null,
                name : null,
                langs : [
                    {lang: "l1", alias: "EN", text: "English"},
                    {lang: "l2", alias: "CN", text: ""},
                    {lang: "l3", alias: "TW", text: ""}
                ],
                defaultLang : "l2",
                position : {
                    my : "left top",
                    at : "left bottom"
                },
                disabled : false,
                readonly : false,
                style : null,
                tagClass : null,
                tabindex : 0,
                width : null,
                height : null,
                maxlength : null,
                value : null,
                hidden : false,

                onlangchange : null,
                onchange : null,
                onclick : null,
                onblur : null,
                ondblclick : null,
                onfocus : null,
                onselect : null,
                onkeyup : null,
                onkeypress : null,
                onkeydown : null,
                onmouseover : null,
                onmouseup : null,
                onmouseout : null,
                onmousemove : null,
                onmousedown : null,

                supportMultiLang : true
            };

        $.widget("ui.wafMultiLangBox", $.ui.wafctrl, {
            options : defaultOption,
            defaultValue : null,
            button : null,
            _create : function() {
                $.ui.wafctrl.prototype._create.apply(this, arguments);
                var self = this,
                    suppressKeyPress,
                    defaultLang = this._getDefaultLang(),
                    domcreated = this.element.data('domcreated');

                this.options.value = this._getDefaultValue();
                this.defaultValue = $.extend(true, {}, this.options.value);
                if(!domcreated){
                    this.element.addClass(inputClass)
                        .attr("ctrlrole", "multiLangBox")
                        .wrap('<div class="' + defaultClass + '"></div>')
                        .wrap('<div class="' + layoutClass + '"></div>');
                }

                this.element.attr('data-domcreated', "true");

                this._bindTextEvent();
                this.frame = this.element.closest("." + defaultClass).eq(0).addClass(this.options.supportMultiLang ? supportClass : notSupportClass);
                this.currentLang = defaultLang.lang;
                if(this.options.supportMultiLang) {
                    this.button = domcreated ? this.frame.find("." + triggerClass).text(defaultLang.alias) : $("<em class='" + triggerClass + "'>" + defaultLang.alias + "</em>").appendTo(this.frame);
                    this.button.bind("click.wafMultiLangBox", function(e) {
                        if(!self.options.disabled && !self.options.readonly) {
                            self.element.focus();
                            if(self.langSelect) {
                                self._close();
                            } else {
                                self._open();
                            }
                        }
                    });
                }
                this._createLangHidden(domcreated);
                this._enter2tab();

                this.element.bind("blur.wafMultiLangBox", function(){
                    self.setValue(self.element.val() || null);
                }).bind( "keydown.wafMultiLangBox", function( e ) {
                    var keyCode = $.ui.keyCode,
                        disabled = self.options.disabled,
                        readonly = self.options.readonly,
                        supportMultiLang = self.options.supportMultiLang,
                        eventKeyCode = e.keyCode;

                    if (disabled || readonly) {
                        return;
                    }
                    if(eventKeyCode === keyCode.ENTER || eventKeyCode === keyCode.NUMPAD_ENTER || eventKeyCode === keyCode.TAB){
                        self.setValue(self.element.val() || null);
                    }
                    if(supportMultiLang){
                        suppressKeyPress = false;
                        //input
                        switch( eventKeyCode ) {
                            case keyCode.UP:
                                if(self.langSelect){
                                    self._previous(e);
                                    e.preventDefault();
                                }
                                break;
                            case keyCode.DOWN:
                                if(self.langSelect){
                                    self._next(e);
                                }else{
                                    self._open();
                                }
                                e.preventDefault();
                                break;
                            case keyCode.ENTER:
                            case keyCode.NUMPAD_ENTER:
                                if(self.langSelect){
                                    // when langSelect is open and has focus
                                    if ( self.active ) {
                                        // #6055 - Opera still allows the keypress to occur
                                        // which causes forms to submit
                                        suppressKeyPress = true;
                                        self._select( e );
                                    }
                                    e.preventDefault();
                                    e.stopPropagation();
                                    e.stopImmediatePropagation();
                                }
                            case keyCode.ESCAPE:
                            case keyCode.TAB:
                                if(self.langSelect){
                                    self._close();
                                }
                                break;
                            default:
                                break;
                        }
                    }
                }).bind( "keypress.wafMultiLangBox", function( e ) {
                    if ( suppressKeyPress ) {
                        suppressKeyPress = false;
                        e.preventDefault();
                    }
                }).bind("focus.wafMultiLangBox",function(e){
                    $(self.button).addClass("triggerFocus");
                }).bind("blur.wafMultiLangBox",function(e){
                    $(self.button).removeClass("triggerFocus");
                });

                // formreset, .
                $(this.element[0].form).bind('reset.wafMultiLangBox', function(){
                    setTimeout($.proxy(self._reset, self), 10);
                });

                this._initByOptions("disabled", "readonly", "style", "tagClass", "tabindex", "width", "height", "maxlength", "hidden");
                this._flush();
                this._operateState();
            },

            _flush: function(){
                this._validText();
                this._loadText();
                this._flushToHidden();
            },

            destroy: function(){
                this.element.removeClass(defaultClass)
                    .unwrap()
                    .removeAttr("ctrlrole");
                if(this.button){
                    this.button.remove();
                }
                if(this.hidden){
                    this.hidden.remove();
                }
                $.Widget.prototype.destroy.call(this);
            },

            widget: function(){
                return this.frame;
            },

             _next: function(e) {
                this._move("next", ":first", e);
            },

            _previous: function(e) {
                this._move("prev", ":last", e);
            },

            _move: function(direction, edge, e) {
                if (!this.active) {
                    this._activate(e, $(".ui-multiLangBox-langItem"+edge, this.langSelect));
                    return;
                }
                var next = this.active[direction + "All"](".ui-multiLangBox-langItem").eq(0);
                if (next.length) {
                    this._activate(e, next);
                } else {
                    this._activate(e, $(".ui-multiLangBox-langItem"+edge, this.langSelect));
                }
            },

            _reset:function(){
                this.options.value = $.extend(true, {}, this.defaultValue);
                this._flush();
            },

            _getDefaultValue: function(){
                var value = this.options.value,
                    langs = this.options.langs,
                    length = langs.length,
                    defaultValue = {};

                for(var i = 0; i < length; i++){
                    var lang = langs[i].lang;
                    if(value){
                        defaultValue[lang] = value[lang];
                    }else{
                        defaultValue[lang] = null;
                    }
                }
                return defaultValue;
            },

            _changeValue: function(newValue, lang){
                var langObj = this._getValidLangObj(lang || this.currentLang),
                    oldValue = $.extend({}, this.options.value);
                if(langObj){
                    lang = langObj.lang;
                    if(!$.type.isEquals(oldValue, newValue)){
                        var self = this,
                            isCurrentLang = lang === this.currentLang,
                            setValue = function(val) {
                                self.options.value = val;
                                self._flushToHidden();
                                if(isCurrentLang) {
                                    self._loadText();
                                }
                            };

                        setValue(newValue);
                        if(!this._trigger("onchange", "onchange", {
                            "previous": oldValue,
                            "current": newValue,
                            "lang": lang
                        })) {
                            setValue(oldValue);
                        }
                    }
                }
            },

            _bindTextEvent: function(){
                var self = this;
                $.each(textEvents, function(idx, value){
                     var name = value.substr(2) + ".wafMultiLangBoxInner";
                     self.element.handleFunction(value.substr(2), self.options[value]);
                });
            },

            _getDefaultLang: function(){
                var langs = this.options.langs,
                    defaultLang = this.options.defaultLang;

                return this._getValidLangObj(defaultLang) || langs[0];
            },

            _getValidLangObj: function(lang){
                var langs = this.options.langs;

                for(var i = 0, length = langs.length; i < length; i++){
                    if(equalsIgnoreCase(lang, langs[i].lang)){
                        return langs[i];
                    }
                }
                return null;
            },

            _createLangSelect : function(){
                var $select = $("<div class='" + selectClass + " ui-widget ui-widget-content ui-corner-all'></div>"),
                    $ul = $("<ul></ul>").appendTo($select),
                    langs = this.options.langs;

                for(var i = 0, length = langs.length; i < length; i++){
                    $('<li lang="' + langs[i].lang + '" class="' + itemClass + ' ui-corner-all"><a><em>'+langs[i].alias+'</em><span>'+langs[i].text+'</span></a></li>').appendTo($ul);
                }

                return $select;
            },

            _enter2tab : function(){
                if($.fn.enter2tab){
                    this.element.enter2tab();
                }
            },

            _select: function( e ) {
                var lang = this.active.attr("lang");
                this.lang(lang);
                this._close();
            },

            _activate: function(e, activeItem){
                this._deactivate();
                this.active = activeItem.eq(0)
                        .children("a")
                        .addClass("ui-state-hover")
                        .end();
            },

            _deactivate: function(){
                if (!this.active) { return; }
                this.active.children("a").removeClass("ui-state-hover");
                this.active = null;
            },

            _open: function(){
                var self = this,
                    doc = this.element[0].ownerDocument;

                this.langSelect = this._createLangSelect().appendTo($(".page_margins .page")[0] || "body")
                    .css('top', 0)
                    .css('left', 0)
                    .width(this.frame.width())
                    .zIndex(self.element.zIndex() + 100)
                    .bind("click.wafMultiLangBox", function( e ) {
                        if ( !$( e.target ).closest( "." + itemClass + " a" ).length ) {
                            return;
                        }
                        e.stopPropagation();
                        e.preventDefault();
                        self._select( e );
                    })
                    .hide();

                this.langSelect.find("a").hover(function(e){
                        self._activate( e, $(this).parent() );
                    }, function(e){
                        self._deactivate();
                    });

                this.langSelect.show().position($.extend({of: this.frame}, this.options.position));

                $(doc).bind("mousedown.wafMultiLangBox", function(e){
                    var $target = $(e.target);
                    if($target.closest(self.langSelect).length == 0 && $target.closest(self.frame).length == 0){
                        self._close();
                    }
                });
            },

            _close: function(){
                var doc = this.element[0].ownerDocument;
                $(doc).unbind("mousedown.wafMultiLangBox");
                this.langSelect.remove();
                this.langSelect = null;
                this.active = null;
                this.element.focus();
            },

            _loadText: function(lang){
                var langObj = this._getValidLangObj(lang || this.currentLang);
                if(langObj){
                    lang = langObj.lang;
                    this.currentLang = lang;
                    var text = this._getText(lang);
                    this.element.val(text);
                    this._setDisplayValue(text);
                }
            },

            _flushToHidden: function(){
                this.hidden.val($.toJSON(this.options.value));
            },

            _getText: function(lang){
                return this.options.value[lang || this.currentLang];
            },

            setValue: function(text, lang){
                if(!$.isPlainObject(text)){
                    var lang = lang || this.currentLang,
                        value = $.extend({}, this.options.value);

                    value[lang] = this._getValidText(text);
                    text = value;
                }
                this._changeValue(this._getValidText(text), lang);
            },

            getValue: function(lang){
                var langObj = this._getValidLangObj(lang || this.currentLang);
                if(langObj){
                    return this._getText(langObj.lang);
                }
                return null;
            },

            lang: function(lang){
                if(lang){
                    var langObj = this._getValidLangObj(lang);
                    if(langObj){
                        if(langObj.lang !== this.currentLang && this._trigger("onlangchange", "onlangchange", {"previous" : this.currentLang, "current" : langObj.lang})){
                            if(this.button) this.button.text(langObj.alias);
                            this._loadText(langObj.lang);
                        }
                    }
                }else{
                    return this.currentLang;
                }
            },

            _createLangHidden: function(domcreated){
                var opts = this.options,
                    id = opts.id || "",
                    name = opts.name || "";
                if (domcreated) {
                    this.hidden = $("#"+id+"_el");
                } else {
                    this.hidden = $('<input type="hidden" id="' + id + '_el" name="' + name + '">');
                    this.frame.append(this.hidden);
                }
            },
            _setOption : function(key, value) {
                var oldTagClass = this.options.tagClass,
                    index;
                $.Widget.prototype._setOption.apply( this, arguments );
                if (key === "disabled" || key === "readonly" || key === "tabindex" || key === "maxlength") {
                    this.element.attr(key, value);
                    if(key === "disabled"){
                        if(this.button)this.button[ value ? "addClass" : "removeClass"]("ui-state-disabled").attr( "aria-disabled", value );
                    }
                    if(key === "maxlength"){
                        this._flush();
                    }
                } else if (key === "width" || key === "height"){
                    this.frame.css(key, value ? value : '');
                } else if (key === "tagClass") {
                    this.frame.removeClass(oldTagClass).addClass(value);
                } else if (key === "style"){
                    this.frame.attr(key, value);
                } else if ((index = $.inArray(key, textEvents)) >= 0){
                    this.element.handleFunction(textEvents[index].substr(2) + ".wafMultiLangBoxInner", value);
                } else if (key === "hidden"){
                    this.frame[value ? "hide" : "show"]();
                } else if (key === "defaultLang"){
                    this.lang(value);
                } else if (key === "value"){
                    this.setValue(value);
                }

                if(key === "height"){
                    this._setLineHeight();
                }
            },

            _setLineHeight: function(height){
                if(this.button){
                    var lineHeight = height || this.element.height();
                    this.button.css("line-height", lineHeight ? lineHeight + "px" : '');
                }
            },

            _getValidText: function(text){
                var max = this.options.maxlength;
                if(max && text){
                    if($.isPlainObject(text)){
                        var langs = this.options.langs,
                            length = langs.length;

                        for(var i = 0; i < length; i++){
                            var lang = langs[i].lang;
                            if(text){
                                text[lang] = this._getValidText(text[lang]);
                            }
                        }
                    }else{
                        text = text.substr(0, max);
                    }
                }
                return text;
            },

            _validText: function(){
                this.options.value = this._getValidText(this.options.value);
            },

            _viewDisable: function(isDisable) {
                $.ui.wafctrl.prototype._viewDisable.apply( this, arguments );
                this.element.attr('disabled', isDisable);
            }
        });

        function equalsIgnoreCase(str1, str2){
            if(str1 == null && str2 == null){
                return true;
            }
            if(str1 == null || str2 == null){
                return false;
            }
            return str1.toUpperCase() === str2.toUpperCase();
        }

        $.wafMultiLangBox = $.wafMultiLangBox || {};
        $.extend($.wafMultiLangBox, {
            format: function(value, lang){
                lang = lang || defaultOption.defaultLang;
                if(value){
                    for(var key in value){
                        if(equalsIgnoreCase(key, lang)){
                            return value[key];
                        }
                    }
                }
                return null;
            },
            createMultiLangBoxDOM: function(opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    return [$('<input id="' + opts.id + '" name="' + opts.name + '_el" type="text">'),
                        $('<label class="viewStatus" id="' + opts.id + '_view"></label>')];
                } else {
                    return obj;
                }
            },
            initMultiLangBox: function(opts, el) {
                el=$.isArray(el)?el[0]:el;
                el.wafMultiLangBox(opts);
            },
            removeMultiLangBox: function(opts) {
                var el = $("#" + opts.id),
                    view = $("#" + opts.id + "_view");

                if(el.length) {
                    el.wafMultiLangBox("destroy");
                    el.remove();
                }
                if(view.length) {
                    view.remove();
                }
            },
            modifyMultiLangBox: function(opts) {
                var option = $.extend(true, {}, opts),
                _value = option.value, el = $("#" + option.id);
                delete option.value;
                el.wafMultiLangBox("option", option);
                if(_value != null) {
                    el.wafMultiLangBox("setValue", _value);
                }
            }
        });

        $(function () {
            if ($.registerComponent)
                $.registerComponent("multiLangBox", {createDOMFun:$.wafMultiLangBox.createMultiLangBoxDOM,
                                                       initFun:$.wafMultiLangBox.initMultiLangBox,
                                                       deleteFun:$.wafMultiLangBox.removeMultiLangBox,
                                                       modifyFun:$.wafMultiLangBox.modifyMultiLangBox,
                                                       lazyInit:true});
        });
    })(jQuery);
//});
//mod.defineModule("multiLangArea",["base","waf","position"],function(){
    /*******************************************************************************
     * 
     *
     * @version 1.0
     * @author peng_zhou1
     * @Depends:
     *         jquery.ui.core.js
     *         jquery.ui.widget.js
     *         jquery.ui.position.js
     *         jquery.json.js
     ******************************************************************************/
    (function($) {

        var defaultClass = "ui-multiLangArea",
            layoutClass = "ui-multiLangArea-layout",
            inputClass = "ui-multiLangArea-input",
            triggerClass = "ui-multiLangArea-trigger",
            selectClass = "ui-multiLangArea-langSelect",
            itemClass = "ui-multiLangArea-langItem",
            supportClass = "supportMultiLang",
            notSupportClass = "notSupportMultiLang",
            rnumpx = /^-?\d+(?:px)?$/i,
            textEvents = ["onclick", "onblur", "ondblclick", "onfocus", "onselect", "onkeyup", "onkeypress",
                 "onkeydown", "onmouseover", "onmouseup", "onmouseout", "onmousemove", "onmousedown"],
            defaultOption = {
                id : null,
                name : null,
                langs : [
                    {lang: "l1", alias: "EN", text: "English"},
                    {lang: "l2", alias: "CN", text: ""},
                    {lang: "l3", alias: "TW", text: ""}
                ],
                defaultLang : "l2",
                position : {
                    my : "left top",
                    at : "left bottom"
                },
                disabled : false,
                readonly : false,
                style : null,
                tagClass : null,
                tabindex : 0,
                width : null,
                height : null,
                maxlength : null,
                value : null,
                hidden : false,

                onlangchange : null,
                onchange : null,
                onclick : null,
                onblur : null,
                ondblclick : null,
                onfocus : null,
                onselect : null,
                onkeyup : null,
                onkeypress : null,
                onkeydown : null,
                onmouseover : null,
                onmouseup : null,
                onmouseout : null,
                onmousemove : null,
                onmousedown : null,

                supportMultiLang : true
            };

        $.widget("ui.wafMultiLangArea", $.ui.wafctrl, {
            options : defaultOption,
            defaultValue : null,
            button : null,
            _create : function() {
                $.ui.wafctrl.prototype._create.apply(this, arguments);
                var self = this,
                    defaultLang = this._getDefaultLang(),
                    domcreated = this.element.data('domcreated');

                this.options.value = this._getDefaultValue();
                this.defaultValue = $.extend(true, {}, this.options.value);

                if(!domcreated){
                    this.element.addClass(inputClass)
                        .attr("ctrlrole", "multiLangArea")
                        .wrap('<div class="' + defaultClass + '"></div>')
                        .wrap('<div class="' + layoutClass + '"></div>');
                }

                this._bindTextEvent();

                this.frame = this.element.closest("." + defaultClass).eq(0).addClass(this.options.supportMultiLang ? supportClass : notSupportClass);

                this.currentLang = defaultLang.lang;

                if(this.options.supportMultiLang){
                    this.button = domcreated ? this.frame.find("." + triggerClass).text(defaultLang.alias) : $("<em class='" + triggerClass + "'>" + defaultLang.alias + "</em>").appendTo(this.frame);
                    this.button.bind("click.wafMultiLangArea", function(e){
                            if(!self.options.disabled && !self.options.readonly){
                                if(self.langSelect){
                                    self._close();
                                }else{
                                    self._open();
                                }
                            }
                        });
                }

                this._createLangHidden(domcreated);
                this._enter2tab();
                
                this.element.bind("blur.wafMultiLangArea", function(){
                    self.setValue(self.element.val() || null);
                }).bind( "keydown.wafMultiLangArea", function( e ) {
                    var keyCode = $.ui.keyCode,
                        disabled = self.options.disabled,
                        readonly = self.options.readonly,
                        eventKeyCode = e.keyCode;

                    if (disabled || readonly) {
                        return;
                    }
                    if(eventKeyCode === keyCode.TAB || ((eventKeyCode === keyCode.ENTER || eventKeyCode === keyCode.NUMPAD_ENTER) && e.ctrlKey)) {
                        self.setValue(self.element.val() || null);
                    }
                }).bind("focus.wafMultiLangArea",function(e){
                    $(self.button).addClass("triggerFocus");
                }).bind("blur.wafMultiLangArea",function(e){
                    $(self.button).removeClass("triggerFocus");
                });

                // formreset, .
                $(this.element[0].form).bind('reset.wafMultiLangArea', function(){
                    setTimeout($.proxy(self._reset, self), 10);
                });

                this._initByOptions("disabled", "readonly", "style", "tagClass", "tabindex", "width", "height", "maxlength", "hidden");
                this._flush();
                this._operateState();
            },

            _flush: function(){
                this._validText();
                this._loadText();
                this._flushToHidden();
            },

            destroy: function(){
                this.element.removeClass(defaultClass)
                    .unwrap()
                    .removeAttr("ctrlrole");
                if(this.button){
                    this.button.remove();
                }
                if(this.hidden){
                    this.hidden.remove();
                }
                $.Widget.prototype.destroy.call(this);
            },

            widget: function(){
                return this.frame;
            },

            _reset:function(){
                this.options.value = $.extend(true, {}, this.defaultValue);
                this._flush();
            },

            _getDefaultValue: function(){
                var value = this.options.value,
                    langs = this.options.langs,
                    length = langs.length,
                    defaultValue = {};

                for(var i = 0; i < length; i++){
                    var lang = langs[i].lang;
                    if(value){
                        defaultValue[lang] = value[lang];
                    }else{
                        defaultValue[lang] = null;
                    }
                }
                return defaultValue;
            },

            _changeValue: function(newValue, lang){
                var langObj = this._getValidLangObj(lang || this.currentLang),
                    oldValue = $.extend({}, this.options.value);
                if(langObj){
                    lang = langObj.lang;
                    if(!$.type.isEquals(oldValue, newValue)) {
                        var self = this,
                            isCurrentLang = lang === this.currentLang,
                            setValue = function(val) {
                                self.options.value = val;
                                self._flushToHidden();
                                if(isCurrentLang) {
                                    self._loadText();
                                }
                            };

                        setValue(newValue);
                        if(!this._trigger("onchange", "onchange", {
                            "previous": oldValue,
                            "current": newValue,
                            "lang": lang
                        })) {
                            setValue(oldValue);
                        }
                    }
                }
            },

            _bindTextEvent: function(){
                var self = this;
                $.each(textEvents, function(idx, value){
                     self.element.handleFunction(value.substr(2) + ".wafMultiLangAreaInner", self.options[value]);
                });
            },

            _getDefaultLang: function(){
                var langs = this.options.langs,
                    defaultLang = this.options.defaultLang;

                return this._getValidLangObj(defaultLang) || langs[0];
            },

            _getValidLangObj: function(lang){
                var langs = this.options.langs;

                for(var i = 0, length = langs.length; i < length; i++){
                    if(equalsIgnoreCase(lang, langs[i].lang)){
                        return langs[i];
                    }
                }
                return null;
            },

            _createLangSelect : function(){
                var $select = $("<div class='" + selectClass + " ui-widget ui-widget-content ui-corner-all'></div>"),
                    $ul = $("<ul></ul>").appendTo($select),
                    langs = this.options.langs;

                for(var i = 0, length = langs.length; i < length; i++){
                    $('<li lang="' + langs[i].lang + '" class="' + itemClass + ' ui-corner-all"><a><em>'+langs[i].alias+'</em><span>'+langs[i].text+'</span></a></li>').appendTo($ul);
                }

                return $select;
            },

            _enter2tab : function(){
                if($.fn.enter2tab){
                    this.element.enter2tab();
                }
            },

            _select: function( e ) {
                var lang = this.active.attr("lang");
                this.lang(lang);
                this._close();
            },

            _activate: function(e, activeItem){
                this._deactivate();
                this.active = activeItem.eq(0)
                        .children("a")
                        .addClass("ui-state-hover")
                        .end();
            },

            _deactivate: function(){
                if (!this.active) { return; }
                this.active.children("a").removeClass("ui-state-hover");
                this.active = null;
            },

            _open: function(){
                var self = this,
                    doc = this.element[0].ownerDocument;

                this.langSelect = this._createLangSelect().appendTo($(".page_margins .page")[0] || "body")
                    .css('top', 0)
                    .css('left', 0)
                    .width(this.frame.width())
                    .zIndex(self.element.zIndex() + 100)
                    .bind("click.wafMultiLangArea", function( e ) {
                        if ( !$( e.target ).closest( "." + itemClass + " a" ).length ) {
                            return;
                        }
                        e.preventDefault();
                        e.stopPropagation();
                        self._select( e );
                    })
                    .hide();

                this.langSelect.find("a").hover(function(e){
                        self._activate( e, $(this).parent() );
                    }, function(e){
                        self._deactivate();
                    });

                this.langSelect.show().position($.extend({of: this.frame}, this.options.position));

                $(doc).bind("mousedown.wafMultiLangArea", function(e){
                    var $target = $(e.target);
                    if($target.closest(self.langSelect).length == 0 && $target.closest(self.frame).length == 0){
                        self._close();
                    }
                });
            },

            _close: function(){
                var doc = this.element[0].ownerDocument;
                $(doc).unbind("mousedown.wafMultiLangArea");
                this.langSelect.remove();
                this.langSelect = null;
                this.element.focus();
            },

            _loadText: function(lang){
                var langObj = this._getValidLangObj(lang || this.currentLang);
                if(langObj){
                    lang = langObj.lang;
                    this.currentLang = lang;
                    var text = this._getText(lang);
                    this.element.val(text);
                    //TODO:encode
                    this._setDisplayValue(text ? $.wafutil.htmlEncode(text).replace(/\n/g, '<br>').replace(/[ ]/g, '&nbsp;') : '', true);
                }
            },

            _flushToHidden: function(){
                this.hidden.val($.toJSON(this.options.value));
            },

            _getText: function(lang){
                return this.options.value[lang || this.currentLang];
            },

            setValue: function(text, lang){
                 if(!$.isPlainObject(text)){
                    var lang = lang || this.currentLang,
                        value = $.extend({}, this.options.value);

                    value[lang] = this._getValidText(text);
                    text = value;
                }
                this._changeValue(this._getValidText(text), lang);
            },

            getValue: function(lang){
                var langObj = this._getValidLangObj(lang || this.currentLang);
                if(langObj){
                    return this._getText(langObj.lang);
                }
                return null;
            },

            lang: function(lang){
                if(lang){
                    var langObj = this._getValidLangObj(lang);
                    if(langObj){
                        if(langObj.lang !== this.currentLang && this._trigger("onlangchange", "onlangchange", {"previous" : this.currentLang, "current" : langObj.lang})){
                            if(this.button) this.button.text(langObj.alias);
                            this._loadText(langObj.lang);
                        }
                    }
                }else{
                    return this.currentLang;
                }
            },

            _createLangHidden: function(domcreated){
                var opts = this.options,
                    id = opts.id || "",
                    name = opts.name || "";
                if (domcreated) {
                    this.hidden = $("#" + id + "_el");
                } else {
                    this.hidden = $('<input type="hidden" id="' + id + '_el" name="' + name + '">');
                    this.frame.append(this.hidden);
                }
            },
            _setOption : function(key, value) {
                var oldTagClass = this.options.tagClass,
                    index;
                $.Widget.prototype._setOption.apply( this, arguments );
                if (key === "disabled" || key === "readonly" || key === "tabindex" || key === "maxlength") {
                    this.element.attr(key, value);
                    if(key === "disabled"){
                        if(this.button)this.button[ value ? "addClass" : "removeClass"]("ui-state-disabled").attr( "aria-disabled", value );
                    }
                    if(key === "maxlength"){
                        this._flush();
                    }
                } else if (key === "width" || key === "height"){
                    this.frame.css(key, value ? value : '');
                } else if (key === "tagClass") {
                    this.frame.removeClass(oldTagClass).addClass(value);
                } else if (key === "style"){
                    this.frame.attr(key, value);
                } else if ((index = $.inArray(key, textEvents)) >= 0){
                    this.element.handleFunction(textEvents[index].substr(2) + ".wafMultiLangAreaInner", value);
                } else if (key === "hidden"){
                    this.frame[value ? "hide" : "show"]();
                } else if (key === "defaultLang"){
                    this.lang(value);
                } else if (key === "value"){
                    this.setValue(value);
                }

                if(key === "height"){
                    this._setLineHeight();
                }
            },

            _setLineHeight: function(height){
                if(this.button){
                    var lineHeight = height || this.element.height();
                    this.button.css("line-height", lineHeight ? lineHeight + "px" : '');
                }
            },

            _getValidText: function(text){
                var max = this.options.maxlength;
                if(max && text){
                    if($.isPlainObject(text)){
                        var langs = this.options.langs,
                            length = langs.length;

                        for(var i = 0; i < length; i++){
                            var lang = langs[i].lang;
                            if(text){
                                text[lang] = this._getValidText(text[lang]);
                            }
                        }
                    }else{
                        text = text.substr(0, max);
                    }
                }
                return text;
            },

            _validText: function(){
                this.options.value = this._getValidText(this.options.value);
            },

            _viewDisable: function(isDisable) {
                $.ui.wafctrl.prototype._viewDisable.apply( this, arguments );
                this.element.attr('disabled', isDisable);
            }
        });

        function equalsIgnoreCase(str1, str2){
            if(str1 == null && str2 == null){
                return true;
            }
            if(str1 == null || str2 == null){
                return false;
            }
            return str1.toUpperCase() === str2.toUpperCase();
        }

        $.wafMultiLangArea = $.wafMultiLangArea || {};
        $.extend($.wafMultiLangArea, {
            format: function(value, lang){
                lang = lang || defaultOption.defaultLang;
                if(value){
                    for(var key in value){
                        if(equalsIgnoreCase(key, lang)){
                            return value[key];
                        }
                    }
                }
                return null;
            },
            createMultiLangAreaDOM: function(opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    return [$('<textarea id="' + opts.id + '" name="' + opts.name + '_el" type="text">'),
                        $('<label class="viewStatus" id="' + opts.id + '_view"></label>')];
                } else {
                    return obj;
                }
            },
            initMultiLangArea: function(opts, el) {
                el=$.isArray(el)?el[0]:el;
                el.wafMultiLangArea(opts);
            },
            removeMultiLangArea: function(opts) {
                var el = $("#" + opts.id),
                    view = $("#" + opts.id + "_view");

                if(el.length) {
                    el.wafMultiLangArea("destroy");
                    el.remove();
                }
                if(view.length) {
                    view.remove();
                }
            },
            modifyMultiLangArea: function(opts) {
                var option = $.extend(true, {}, opts);
                _value = option.value, el = $("#" + option.id);
                delete option.value;
                el.wafMultiLangArea("option", option);
                if(_value != null) {
                    el.wafMultiLangArea("setValue", _value);
                }
            }
        });

        $(function(){
            if (waf.registerComponent)
                waf.registerComponent("multiLangArea", {createDOMFun: $.wafMultiLangArea.createMultiLangAreaDOM,
                                                       initFun: $.wafMultiLangArea.initMultiLangArea,
                                                       deleteFun: $.wafMultiLangArea.removeMultiLangArea,
                                                       modifyFun: $.wafMultiLangArea.modifyMultiLangArea,
                                                       lazyInit:true});
        });
    })(jQuery);
//});
(function ($) {
    $.dynamicutil = $.dynamicutil || {};
    $.extend($.dynamicutil, {
        getMethod:function (obj, methodName, cmpType) {
            if (typeof obj == "string") {
                if (obj.substr(0, 1) != "#") {
                    obj = "#" + obj;
                }
                obj = $(obj);
            }
            if (!cmpType) {
                var ctrlrole = obj.attr("ctrlrole");
                cmpType = $.dynamicutil.getJSInvokeTypeByCtrlRole(ctrlrole);
            }
            cmpType = cmpType || "";
            if ("wafGrid" === cmpType) {
                return $.jgrid.getAccessor($.fn.jqGrid, methodName);
            } else if ("datepicker" === cmpType) {
                return $.datepicker['_' + methodName + 'Datepicker'];
            } else {
                return $.data(obj[0], cmpType)[methodName];
            }
        },
        getElementByName:function (name) {
            var elements = document.getElementsByName(name);
            if (elements && elements.length > 0) {
                var ret = new Array(), tagName, ctrlrole, id, parent;
                for (var i = 0; i < elements.length; i++) {
                    //input,textarea,select
                    tagName = elements[i].tagName.toUpperCase();
                    if (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") {
                        //ctrlrole,ctrlrole
                        ctrlrole = $(elements[i]).attr("ctrlrole");
						parent = $(elements[i]).parent();
						if(parent && parent.length>0 && parent[0].tagName==="SPAN" && "radioGroup"===parent.attr("ctrlrole")){
						    ret.push(parent[0]);
							break;
						}else if ("textarea" === ctrlrole || "radio" === ctrlrole) {
                            ret.push(elements[i]);
                        } else{
                            //
                            id = $(elements[i]).attr("id");
                            ret.push($("#" + id.substring(0, (id.length - 3)))[0]);
						}
                    }
                }
                return ret;
            }
        },
        getGridByPropName:function(name){
            var ret = $("table.ui-jqgrid-btable[entryProp='"+name+"']");
            if(ret.length>0){
                return $.makeArray(ret);
            }
        },
        getJSInvokeTypeByCtrlRole:function (ctrlrole) {
            return waf.getCmpTypeByTag(ctrlrole);
//            if ("linkButton" === ctrlrole) {
//                return "wafLinkButton";
//            } else if ("autoComplete" === ctrlrole) {
//                return "autocomplete";
//            } else if ("checkbox" === ctrlrole) {
//                return "wafCheckbox";
//            } else if ("datePicker" === ctrlrole) {
//                return "datepicker";
//            } else if ("promptBox" === ctrlrole) {
//                return "wafPromptBox";
//            } else if ("form" === ctrlrole) {
//                return "wafForm";
//            } else if ("grid" === ctrlrole) {
//                return "wafGrid";
//            } else if ("labelContainer" === ctrlrole) {
//                return "labelContainer";
//            } else if ("menuButton" === ctrlrole) {
//                return "wafMenuButton";
//            } else if ("menuItem" === ctrlrole) {
//                return "wafMenuItem";
//            } else if ("msgArea" === ctrlrole) {
//                return "wafMsgArea";
//            } else if ("multiLangArea" === ctrlrole) {
//                return "wafMultiLangArea";
//            } else if ("multiLangBox" === ctrlrole) {
//                return "wafMultiLangBox";
//            } else if ("numberField" === ctrlrole) {
//                return "wafNumberField";
//            } else if ("password" === ctrlrole) {
//                return "wafPassword";
//            } else if ("progressBar" === ctrlrole) {
//                return "wafProgressBar";
//            } else if ("radio" === ctrlrole) {
//                return "wafRadio";
//            } else if ("section" === ctrlrole) {
//                return "wafSection";
//            } else if ("select" === ctrlrole) {
//                return "wafSelect";
//            } else if ("text" === ctrlrole) {
//                return "wafText";
//            } else if ("textarea" === ctrlrole) {
//                return "wafTextarea";
//            } else if ("toolBar" === ctrlrole) {
//                return "wafToolBar";
//            } else if ("tree" === ctrlrole) {
//                return "wafTree";
//            } else if ("columnLayout" === ctrlrole) {
//                return "wafColumnLayout";
//            } else if ("column" === ctrlrole) {
//                return "wafColumn";
//            } else if ("radioGroup" === ctrlrole){
//                return "wafRadioGroup";
//            }
        },
        getAllCtrlRole:function(){

        },
        removeChildren:function(container, source){
            source = $(source);
            
            var ctrlrole = source.attr("ctrlrole");
            if(ctrlrole){
                var id=source.attr("id");
                waf.removeComponent(ctrlrole,{id:id})
            }else{
                $(source,container).remove();
            }            
        },
        appendChildren:function(container, source, pos){
            if($.type.isString(source)){
                //  
                source = $("<label>"+source+"</label>");
            }else{
                source = $(source);
            }
            

            //pos
            if(!$.isNaN(pos)){
                var target = container.children("*").not("script").eq(pos);
                if(target&&target.length>0){
                    $.each(source,function(i,v){
                        $(v).insertBefore(target);
                    });
                    return;
                }
            }
            $.each(source,function(i,v){
                container.append(v);
            });
        },
        addContextPath: function(opts, key, defaultUrl){
            var url = $.trim(opts[key]),
                contextPath = waf.getContextPath();

            if(url){
                if((url.charAt(0) != "?") && (url.indexOf(contextPath) != 0)){
                    opts[key] = contextPath + url;
                }
            }else if(defaultUrl){
                opts[key] = contextPath + defaultUrl;
            }
        }
    });




})(jQuery);
//mod.defineModule("transport", ["base"], function() {
    (function ($) {
        // Helper variable to create unique names for the transport iframes:
        var counter = 0;

        // The iframe transport accepts three additional options:
        // options.fileInput: a jQuery collection of file input fields
        // options.paramName: the parameter name for the file form data,
        //  overrides the name property of the file input field(s),
        //  can be a string or an array of strings.
        // options.formData: an array of objects with name and value properties,
        //  equivalent to the return data of .serializeArray(), e.g.:
        //  [{name: 'a', value: 1}, {name: 'b', value: 2}]
        $.ajaxTransport('iframe', function (options) {
            if (options.async && (options.type === 'POST' || options.type === 'GET')) {
                var form,
                    iframe;
                return {
                    send: function (_, completeCallback) {
                        form = $('<form style="display:none;"></form>');
                        // javascript:false as initial iframe src
                        // prevents warning popups on HTTPS in IE6.
                        // IE versions below IE8 cannot set the name property of
                        // elements that have already been added to the DOM,
                        // so we set the name along with the iframe HTML markup:
                        iframe = $(
                            '<iframe src="javascript:false;" name="iframe-transport-' +
                                (counter += 1) + '"></iframe>'
                        ).bind('load', function () {
                                var fileInputClones,
                                    paramNames = $.isArray(options.paramName) ?
                                        options.paramName : [options.paramName];
                                iframe
                                    .unbind('load')
                                    .bind('load', function () {
                                        var response;
                                        // Wrap in a try/catch block to catch exceptions thrown
                                        // when trying to access cross-domain iframe contents:
                                        try {
                                            response = iframe.contents();
                                            // Google Chrome and Firefox do not throw an
                                            // exception when calling iframe.contents() on
                                            // cross-domain requests, so we unify the response:
                                            if (!response.length || !response[0].firstChild) {
                                                throw new Error();
                                            }
                                        } catch (e) {
                                            response = undefined;
                                        }
                                        // The complete callback returns the
                                        // iframe content document as response object:
                                        completeCallback(
                                            200,
                                            'success',
                                            {'iframe': response}
                                        );
                                        // Fix for IE endless progress bar activity bug
                                        // (happens on form submits to iframe targets):
                                        $('<iframe src="javascript:false;"></iframe>')
                                            .appendTo(form);
                                        form.remove();
                                    });
                                form
                                    .prop('target', iframe.prop('name'))
                                    .prop('action', options.url)
                                    .prop('method', options.type);
                                if (options.formData) {
                                    $.each(options.formData, function (index, field) {
                                        $('<input type="hidden"/>')
                                            .prop('name', field.name)
                                            .val(field.value)
                                            .appendTo(form);
                                    });
                                }
                                if (options.fileInput && options.fileInput.length &&
                                    options.type === 'POST') {
                                    fileInputClones = options.fileInput.clone();
                                    // Insert a clone for each file input field:
                                    options.fileInput.after(function (index) {
                                        return fileInputClones[index];
                                    });
                                    if (options.paramName) {
                                        options.fileInput.each(function (index) {
                                            $(this).prop(
                                                'name',
                                                paramNames[index] || options.paramName
                                            );
                                        });
                                    }
                                    // Appending the file input fields to the hidden form
                                    // removes them from their original location:
                                    form
                                        .append(options.fileInput)
                                        .prop('enctype', 'multipart/form-data')
                                        // enctype must be set as encoding for IE:
                                        .prop('encoding', 'multipart/form-data');
                                }
                                form.submit();
                                // Insert the file input fields at their original location
                                // by replacing the clones with the originals:
                                if (fileInputClones && fileInputClones.length) {
                                    options.fileInput.each(function (index, input) {
                                        var clone = $(fileInputClones[index]);
                                        $(input).prop('name', clone.prop('name'));
                                        clone.replaceWith(input);
                                    });
                                }
                            });
                        form.append(iframe).appendTo(document.body);
                    },
                    abort: function () {
                        if (iframe) {
                            // javascript:false as iframe src aborts the request
                            // and prevents warning popups on HTTPS in IE6.
                            // concat is used to avoid the "Script URL" JSLint error:
                            iframe
                                .unbind('load')
                                .prop('src', 'javascript'.concat(':false;'));
                        }
                        if (form) {
                            form.remove();
                        }
                    }
                };
            }
        });

        // The iframe transport returns the iframe content document as response.
        // The following adds converters from iframe to text, json, html, and script:
        $.ajaxSetup({
            converters: {
                'iframe text': function (iframe) {
                    return $(iframe[0].body).text();
                },
                'iframe json': function (iframe) {
                    return $.parseJSON($(iframe[0].body).text());
                },
                'iframe html': function (iframe) {
                    return $(iframe[0].body).html();
                },
                'iframe script': function (iframe) {
                    return $.globalEval($(iframe[0].body).text());
                }
            }
        });

    })(jQuery);

//});

//mod.defineModule("fileUploadBase", ["base","transport"], function() {

/*******************************************************************************
     * jQuery FileUpload
     *
     * @version 1.0
     * @author peng_zhou1
     * @Depends:
     *         jquery.ui.core.js
     *         jquery.ui.widget.js
     ******************************************************************************/
    (function ($) {
        // The FileReader API is not actually used, but works as feature detection,
        // as e.g. Safari supports XHR file uploads via the FormData API,
        // but not non-multipart XHR file uploads:
        $.support.xhrFileUpload = !!(window.XMLHttpRequestUpload && window.FileReader);
        $.support.xhrFormDataFileUpload = !!window.FormData;

        // The fileupload widget listens for change events on file input fields defined
        // via fileInput setting and paste or drop events of the given dropZone.
        // In addition to the default jQuery Widget methods, the fileupload widget
        // exposes the "add" and "send" methods, to add or directly send files using
        // the fileupload API.
        // By default, files added via file input selection, paste, drag & drop or
        // "add" method are uploaded immediately, but it is possible to override
        // the "add" callback option to queue file uploads.
        $.widget('ui.wafFileUpload', {

            options: {
                // The namespace used for event handler binding on the dropZone and
                // fileInput collections.
                // If not set, the name of the widget ("fileupload") is used.
                namespace: undefined,
                // The drop target collection, by the default the complete document.
                // Set to null or an empty collection to disable drag & drop support:
                dropZone: $(document),
                // The file input field collection, that is listened for change events.
                // If undefined, it is set to the file input fields inside
                // of the widget element on plugin initialization.
                // Set to null or an empty collection to disable the change listener.
                fileInput: undefined,
                // By default, the file input field is replaced with a clone after
                // each input field change event. This is required for iframe transport
                // queues and allows change events to be fired for the same file
                // selection, but can be disabled by setting the following option to false:
                // input
                replaceFileInput: true,
                // The parameter name for the file form data (the request argument name).
                // If undefined or empty, the name property of the file input field is
                // used, or "files[]" if the file input name property is also empty,
                // can be a string or an array of strings:
                paramName: undefined,
                // By default, each file of a selection is uploaded using an individual
                // request for XHR type uploads. Set to false to upload file
                // selections in one request each:
                singleFileUploads: true,
                // To limit the number of files uploaded with one XHR request,
                // set the following option to an integer greater than 0:
                limitMultiFileUploads: undefined,
                // Set the following option to true to issue all file upload requests
                // in a sequential order:
                // 
                sequentialUploads: false,
                // To limit the number of concurrent uploads,
                // set the following option to an integer greater than 0:
                limitConcurrentUploads: undefined,
                // Set the following option to true to force iframe transport uploads:
                forceIframeTransport: false,
                // Set the following option to the location of a redirect url on the
                // origin server, for cross-domain iframe transport uploads:
                redirect: undefined,
                // The parameter name for the redirect url, sent as part of the form
                // data and set to 'redirect' if this option is empty:
                redirectParamName: undefined,
                // Set the following option to the location of a postMessage window,
                // to enable postMessage transport uploads:
                postMessage: undefined,
                // By default, XHR file uploads are sent as multipart/form-data.
                // The iframe transport is always using multipart/form-data.
                // Set to false to enable non-multipart XHR uploads:
                multipart: true,
                // To upload large files in smaller chunks, set the following option
                // to a preferred maximum chunk size. If set to 0, null or undefined,
                // or the browser does not support the required Blob API, files will
                // be uploaded as a whole.
                maxChunkSize: undefined,
                // When a non-multipart upload or a chunked multipart upload has been
                // aborted, this option can be used to resume the upload by setting
                // it to the size of the already uploaded bytes. This option is most
                // useful when modifying the options object inside of the "add" or
                // "send" callbacks, as the options are cloned for each file upload.
                uploadedBytes: undefined,
                // By default, failed (abort or error) file uploads are removed from the
                // global progress calculation. Set the following option to false to
                // prevent recalculating the global progress data:
                recalculateProgress: true,
                // Interval in milliseconds to calculate and trigger progress events:
                progressUrl: null,
                // Interval in milliseconds to calculate and trigger progress events:
                progressInterval: 1000,
                // Interval in milliseconds to calculate progress bitrate:
                bitrateInterval: 500,

                // Additional form data to be sent along with the file uploads can be set
                // using this option, which accepts an array of objects with name and
                // value properties, a function returning such an array, a FormData
                // object (for XHR file uploads), or a simple object.
                // The form of the first fileInput is given as parameter to the function:
                formData: function (form) {
                    return form.serializeArray();
                },

                // The add callback is invoked as soon as files are added to the fileupload
                // widget (via file input selection, drag & drop, paste or add API call).
                // If the singleFileUploads option is enabled, this callback will be
                // called once for each file in the selection for XHR file uplaods, else
                // once for each file selection.
                // The upload starts when the submit method is invoked on the data parameter.
                // The data object contains a files property holding the added files
                // and allows to override plugin options as well as define ajax settings.
                // Listeners for this callback can also be bound the following way:
                // .bind('fileuploadadd', func);
                // data.submit() returns a Promise object and allows to attach additional
                // handlers using jQuery's Deferred callbacks:
                // data.submit().done(func).fail(func).always(func);
                add: function (e, data) {
                    data.submit();
                },

                // Other callbacks:
                // Callback for the submit event of each file upload:
                // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);
                // Callback for the start of each file upload request:
                // send: function (e, data) {}, // .bind('fileuploadsend', func);
                // Callback for successful uploads:
                // done: function (e, data) {}, // .bind('fileuploaddone', func);
                // Callback for failed (abort or error) uploads:
                // fail: function (e, data) {}, // .bind('fileuploadfail', func);
                // Callback for completed (success, abort or error) requests:
                // always: function (e, data) {}, // .bind('fileuploadalways', func);
                // Callback for upload progress events:
                // progress: function (e, data) {}, // .bind('fileuploadprogress', func);
                // Callback for global upload progress events:
                // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);
                // Callback for uploads start, equivalent to the global ajaxStart event:
                // start: function (e) {}, // .bind('fileuploadstart', func);
                // Callback for uploads stop, equivalent to the global ajaxStop event:
                // stop: function (e) {}, // .bind('fileuploadstop', func);
                // Callback for change events of the fileInput collection:
                // change: function (e, data) {}, // .bind('fileuploadchange', func);
                // Callback for paste events to the dropZone collection:
                // paste: function (e, data) {}, // .bind('fileuploadpaste', func);
                // Callback for drop events of the dropZone collection:
                // drop: function (e, data) {}, // .bind('fileuploaddrop', func);
                // Callback for dragover events of the dropZone collection:
                // dragover: function (e) {}, // .bind('fileuploaddragover', func);

                // The plugin options are used as settings object for the ajax calls.
                // The following are jQuery ajax settings required for the file uploads:
                processData: false,
                contentType: false,
                cache: false
            },

            // A list of options that require a refresh after assigning a new value:
            _refreshOptionsList: [
                'namespace',
                'dropZone',
                'fileInput',
                'multipart',
                'forceIframeTransport'
            ],

            _BitrateTimer: function () {
                this.timestamp = +(new Date());
                this.loaded = 0;
                this.bitrate = 0;
                this.getBitrate = function (now, loaded, interval) {
                    var timeDiff = now - this.timestamp;
                    if (!this.bitrate || !interval || timeDiff > interval) {
                        this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;
                        this.loaded = loaded;
                        this.timestamp = now;
                    }
                    return this.bitrate;
                };
            },

            _isXHRUpload: function (options) {
                return !options.forceIframeTransport &&
                    ((!options.multipart && $.support.xhrFileUpload) ||
                    $.support.xhrFormDataFileUpload);
            },

            _getFormData: function (options) {
                var formData;
                if (typeof options.formData === 'function') {
                    return options.formData(options.form);
                }
                if ($.isArray(options.formData)) {
                    return options.formData;
                }
                if (options.formData) {
                    formData = [];
                    $.each(options.formData, function (name, value) {
                        formData.push({name: name, value: value});
                    });
                    return formData;
                }
                return [];
            },

            _getTotal: function (files) {
                var total = 0;
                $.each(files, function (index, file) {
                    total += file.size || 1;
                });
                return total;
            },

            _onProgress: function (e, data) {
                if (e.lengthComputable) {
                    var now = +(new Date()),
                        total,
                        loaded;
                    if (data._time && data.progressInterval &&
                            (now - data._time < data.progressInterval) &&
                            e.loaded !== e.total) {
                        return;
                    }
                    data._time = now;
                    total = data.total || this._getTotal(data.files);
                    loaded = parseInt(
                        e.loaded / e.total * (data.chunkSize || total),
                        10
                    ) + (data.uploadedBytes || 0);
                    this._loaded += loaded - (data.loaded || data.uploadedBytes || 0);
                    data.lengthComputable = true;
                    data.loaded = loaded;
                    data.total = total;
                    data.bitrate = data._bitrateTimer.getBitrate(
                        now,
                        loaded,
                        data.bitrateInterval
                    );
                    // Trigger a custom progress event with a total data property set
                    // to the file size(s) of the current upload and a loaded data
                    // property calculated accordingly:
                    this._trigger('progress', e, data);
                    // Trigger a global progress event for all current file uploads,
                    // including ajax calls queued for sequential file uploads:
                    this._trigger('progressall', e, {
                        lengthComputable: true,
                        loaded: this._loaded,
                        total: this._total,
                        bitrate: this._bitrateTimer.getBitrate(
                            now,
                            this._loaded,
                            data.bitrateInterval
                        )
                    });
                }
            },

            _initProgressListener: function (options) {
                var that = this,
                    xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
                // Accesss to the native XHR object is required to add event listeners
                // for the upload progress event:
                if (xhr.upload) {
                    $(xhr.upload).bind('progress', function (e) {
                        var oe = e.originalEvent;
                        // Make sure the progress event properties get copied over:
                        e.lengthComputable = oe.lengthComputable;
                        e.loaded = oe.loaded;
                        e.total = oe.total;
                        that._onProgress(e, options);
                    });
                    options.xhr = function () {
                        return xhr;
                    };
                }
            },

            _initXHRData: function (options) {
                var formData,
                    file = options.files[0],
                    // Ignore non-multipart setting if not supported:
                    multipart = options.multipart || !$.support.xhrFileUpload,
                    paramName = options.paramName[0];
                if (!multipart || options.blob) {
                    // For non-multipart uploads and chunked uploads,
                    // file meta data is not part of the request body,
                    // so we transmit this data as part of the HTTP headers.
                    // For cross domain requests, these headers must be allowed
                    // via Access-Control-Allow-Headers or removed using
                    // the beforeSend callback:
                    options.headers = $.extend(options.headers, {
                        'X-File-Name': file.name,
                        'X-File-Type': file.type,
                        'X-File-Size': file.size
                    });
                    if (!options.blob) {
                        // Non-chunked non-multipart upload:
                        options.contentType = file.type;
                        options.data = file;
                    } else if (!multipart) {
                        // Chunked non-multipart upload:
                        options.contentType = 'application/octet-stream';
                        options.data = options.blob;
                    }
                }
                if (multipart && $.support.xhrFormDataFileUpload) {
                    if (options.postMessage) {
                        // window.postMessage does not allow sending FormData
                        // objects, so we just add the File/Blob objects to
                        // the formData array and let the postMessage window
                        // create the FormData object out of this array:
                        formData = this._getFormData(options);
                        if (options.blob) {
                            formData.push({
                                name: paramName,
                                value: options.blob
                            });
                        } else {
                            $.each(options.files, function (index, file) {
                                formData.push({
                                    name: options.paramName[index] || paramName,
                                    value: file
                                });
                            });
                        }
                    } else {
                        if (options.formData instanceof FormData) {
                            formData = options.formData;
                        } else {
                            formData = new FormData();
                            $.each(this._getFormData(options), function (index, field) {
                                formData.append(field.name, field.value);
                            });
                        }
                        if (options.blob) {
                            formData.append(paramName, options.blob, file.name);
                        } else {
                            $.each(options.files, function (index, file) {
                                // File objects are also Blob instances.
                                // This check allows the tests to run with
                                // dummy objects:
                                if (file instanceof Blob) {
                                    formData.append(
                                        options.paramName[index] || paramName,
                                        file,
                                        file.name
                                    );
                                }
                            });
                        }
                    }
                    options.data = formData;
                }
                // Blob reference is not needed anymore, free memory:
                options.blob = null;
            },

            _initIframeSettings: function (options) {
                // Setting the dataType to iframe enables the iframe transport:
                options.dataType = 'iframe ' + (options.dataType || '');
                // The iframe transport accepts a serialized array as form data:
                options.formData = this._getFormData(options);
                // Add redirect url to form data on cross-domain uploads:
                if (options.redirect && $('<a></a>').prop('href', options.url)
                        .prop('host') !== location.host) {
                    options.formData.push({
                        name: options.redirectParamName || 'redirect',
                        value: options.redirect
                    });
                }
            },

            _getRequestProgress: function(options){
                var self = this,
                    file = options.files[0],
                    timeout;
                return function(){
                    if(!file.stop){
                        var fileId = file.id,
                            timestamp = +(new Date()),
                            url = options.progressUrl + (options.progressUrl.indexOf("?") < 0 ? "?" : "&") + "fileId=" + fileId + "&timestamp=" + timestamp;

                        $.getJSON(url, function (json) {
                            options.loaded = json.bytesRead;
                            options.total = json.contentLength;
                            if(file.size == null){
                                file.size = json.contentLength;
                                self._trigger('complement', null, options);
                            }
                            self._trigger('progress', null, options);
                        });
                        setTimeout(self._getRequestProgress(options), options.progressInterval);
                    }
                };
            },

            _initProgressRequest: function(options) {
                var url = this.options.progressUrl;
                if(url){
                    setTimeout(this._getRequestProgress(options), options.progressInterval);
                }

            },

            _initUploadFileId: function (options) {
                var fileId = options.files[0].id,
                    url = options.url;
                if(url){
                    options.url += (url.indexOf("?") < 0 ? "?" : "&") + "fileId=" + fileId;
                }
            },

            _initDataSettings: function (options) {
                if (this._isXHRUpload(options)) {
                    if (!this._chunkedUpload(options, true)) {
                        if (!options.data) {
                            this._initXHRData(options);
                        }
                        this._initProgressListener(options);
                    }
                    if (options.postMessage) {
                        // Setting the dataType to postmessage enables the
                        // postMessage transport:
                        options.dataType = 'postmessage ' + (options.dataType || '');
                    }
                } else {
                    this._initIframeSettings(options, 'iframe');
                    this._initProgressRequest(options);
                }
                this._initUploadFileId(options);
            },

            _getParamName: function (options) {
                var fileInput = $(options.fileInput),
                    paramName = options.paramName;
                if (!paramName) {
                    paramName = [];
                    fileInput.each(function () {
                        var input = $(this),
                            name = input.prop('name') || 'files[]',
                            i = (input.prop('files') || [1]).length;
                        while (i) {
                            paramName.push(name);
                            i -= 1;
                        }
                    });
                    if (!paramName.length) {
                        paramName = [fileInput.prop('name') || 'files[]'];
                    }
                } else if (!$.isArray(paramName)) {
                    paramName = [paramName];
                }
                return paramName;
            },

            _initFormSettings: function (options) {
                // Retrieve missing options from the input field and the
                // associated form, if available:
                if (!options.form || !options.form.length) {
                    options.form = $(options.fileInput.prop('form'));
                }
                options.paramName = this._getParamName(options);
                if (!options.url) {
                    options.url = options.form.prop('action') || location.href;
                }
                // The HTTP request method must be "POST" or "PUT":
                options.type = (options.type || options.form.prop('method') || '')
                    .toUpperCase();
                if (options.type !== 'POST' && options.type !== 'PUT') {
                    options.type = 'POST';
                }
            },

            _getAJAXSettings: function (data) {
                var options = $.extend({}, this.options, data);
                this._initFormSettings(options);
                this._initDataSettings(options);
                return options;
            },

            // Maps jqXHR callbacks to the equivalent
            // methods of the given Promise object:
            _enhancePromise: function (promise) {
                promise.success = promise.done;
                promise.error = promise.fail;
                promise.complete = promise.always;
                return promise;
            },

            // Creates and returns a Promise object enhanced with
            // the jqXHR methods abort, success, error and complete:
            _getXHRPromise: function (resolveOrReject, context, args) {
                var dfd = $.Deferred(),
                    promise = dfd.promise();
                context = context || this.options.context || promise;
                if (resolveOrReject === true) {
                    dfd.resolveWith(context, args);
                } else if (resolveOrReject === false) {
                    dfd.rejectWith(context, args);
                }
                promise.abort = dfd.promise;
                return this._enhancePromise(promise);
            },

            // Uploads a file in multiple, sequential requests
            // by splitting the file up in multiple blob chunks.
            // If the second parameter is true, only tests if the file
            // should be uploaded in chunks, but does not invoke any
            // upload requests:
            _chunkedUpload: function (options, testOnly) {
                var that = this,
                    file = options.files[0],
                    fs = file.size,
                    ub = options.uploadedBytes = options.uploadedBytes || 0,
                    mcs = options.maxChunkSize || fs,
                    // Use the Blob methods with the slice implementation
                    // according to the W3C Blob API specification:
                    slice = file.webkitSlice || file.mozSlice || file.slice,
                    upload,
                    n,
                    jqXHR,
                    pipe;
                if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||
                        options.data) {
                    return false;
                }
                if (testOnly) {
                    return true;
                }
                if (ub >= fs) {
                    file.error = 'uploadedBytes';
                    return this._getXHRPromise(
                        false,
                        options.context,
                        [null, 'error', file.error]
                    );
                }
                // n is the number of blobs to upload,
                // calculated via filesize, uploaded bytes and max chunk size:
                n = Math.ceil((fs - ub) / mcs);
                // The chunk upload method accepting the chunk number as parameter:
                upload = function (i) {
                    if (!i) {
                        return that._getXHRPromise(true, options.context);
                    }
                    // Upload the blobs in sequential order:
                    return upload(i -= 1).pipe(function () {
                        // Clone the options object for each chunk upload:
                        var o = $.extend({}, options);
                        o.blob = slice.call(
                            file,
                            ub + i * mcs,
                            ub + (i + 1) * mcs
                        );
                        // Expose the chunk index:
                        o.chunkIndex = i;
                        // Expose the number of chunks:
                        o.chunksNumber = n;
                        // Store the current chunk size, as the blob itself
                        // will be dereferenced after data processing:
                        o.chunkSize = o.blob.size;
                        // Process the upload data (the blob and potential form data):
                        that._initXHRData(o);
                        // Add progress listeners for this chunk upload:
                        that._initProgressListener(o);
                        jqXHR = ($.ajax(o) || that._getXHRPromise(false, o.context))
                            .done(function () {
                                // Create a progress event if upload is done and
                                // no progress event has been invoked for this chunk:
                                if (!o.loaded) {
                                    that._onProgress($.Event('progress', {
                                        lengthComputable: true,
                                        loaded: o.chunkSize,
                                        total: o.chunkSize
                                    }), o);
                                }
                                options.uploadedBytes = o.uploadedBytes +=
                                    o.chunkSize;
                            });
                        return jqXHR;
                    });
                };
                // Return the piped Promise object, enhanced with an abort method,
                // which is delegated to the jqXHR object of the current upload,
                // and jqXHR callbacks mapped to the equivalent Promise methods:
                pipe = upload(n);
                pipe.abort = function () {
                    return jqXHR.abort();
                };
                return this._enhancePromise(pipe);
            },

            _beforeSend: function (e, data) {
                if (this._active === 0) {
                    // the start callback is triggered when an upload starts
                    // and no other uploads are currently running,
                    // equivalent to the global ajaxStart event:
                    this._trigger('start');
                    // Set timer for global bitrate progress calculation:
                    this._bitrateTimer = new this._BitrateTimer();
                }
                this._active += 1;
                // Initialize the global progress values:
                this._loaded += data.uploadedBytes || 0;
                this._total += this._getTotal(data.files);
            },

            _onDone: function (result, textStatus, jqXHR, options) {
                if (!this._isXHRUpload(options)) {
                    // Create a progress event for each iframe load:
                    this._onProgress($.Event('progress', {
                        lengthComputable: true,
                        loaded: 1,
                        total: 1
                    }), options);
                }
                options.result = result;
                options.textStatus = textStatus;
                options.jqXHR = jqXHR;
                this._trigger('done', null, options);
            },

            _onFail: function (jqXHR, textStatus, errorThrown, options) {
                options.jqXHR = jqXHR;
                options.textStatus = textStatus;
                options.errorThrown = errorThrown;
                this._trigger('fail', null, options);
                if (options.recalculateProgress) {
                    // Remove the failed (error or abort) file upload from
                    // the global progress calculation:
                    this._loaded -= options.loaded || options.uploadedBytes || 0;
                    this._total -= options.total || this._getTotal(options.files);
                }
            },

            _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {
                this._active -= 1;
                options.textStatus = textStatus;
                if (jqXHRorError && jqXHRorError.always) {
                    options.jqXHR = jqXHRorError;
                    options.result = jqXHRorResult;
                } else {
                    options.jqXHR = jqXHRorResult;
                    options.errorThrown = jqXHRorError;
                }
                if (options.context && options.dataType &&
                        options.dataType.substr(0, 6) === 'iframe') {
                        options.files[0].stop = true;
                }

                this._trigger('always', null, options);
                if (this._active === 0) {
                    // The stop callback is triggered when all uploads have
                    // been completed, equivalent to the global ajaxStop event:
                    this._trigger('stop');
                    // Reset the global progress values:
                    this._loaded = this._total = 0;
                    this._bitrateTimer = null;
                }
            },

            _onSend: function (e, data) {
                var that = this,
                    jqXHR,
                    slot,
                    pipe,
                    options = that._getAJAXSettings(data),
                    send = function (resolve, args) {
                        that._sending += 1;
                        // Set timer for bitrate progress calculation:
                        options._bitrateTimer = new that._BitrateTimer();
                        jqXHR = jqXHR || (
                            (resolve !== false &&
                            that._trigger('send', e, options) !== false &&
                            (that._chunkedUpload(options) || $.ajax(options))) ||
                            that._getXHRPromise(false, options.context, args)
                        ).done(function (result, textStatus, jqXHR) {
                            that._onDone(result, textStatus, jqXHR, options);
                        }).fail(function (jqXHR, textStatus, errorThrown) {
                            that._onFail(jqXHR, textStatus, errorThrown, options);
                        }).always(function (jqXHRorResult, textStatus, jqXHRorError) {
                            that._sending -= 1;
                            that._onAlways(
                                jqXHRorResult,
                                textStatus,
                                jqXHRorError,
                                options
                            );
                            if (options.limitConcurrentUploads &&
                                    options.limitConcurrentUploads > that._sending) {
                                // Start the next queued upload,
                                // that has not been aborted:
                                var nextSlot = that._slots.shift();
                                while (nextSlot) {
                                    if (!nextSlot.isRejected()) {
                                        nextSlot.resolve();
                                        break;
                                    }
                                    nextSlot = that._slots.shift();
                                }
                            }
                        });
                        return jqXHR;
                    };
                this._beforeSend(e, options);
                if (this.options.sequentialUploads ||
                        (this.options.limitConcurrentUploads &&
                        this.options.limitConcurrentUploads <= this._sending)) {
                    if (this.options.limitConcurrentUploads > 1) {
                        slot = $.Deferred();
                        this._slots.push(slot);
                        pipe = slot.pipe(send);
                    } else {
                        pipe = (this._sequence = this._sequence.pipe(send, send));
                    }
                    // Return the piped Promise object, enhanced with an abort method,
                    // which is delegated to the jqXHR object of the current upload,
                    // and jqXHR callbacks mapped to the equivalent Promise methods:
                    pipe.abort = function () {
                        var args = [undefined, 'abort', 'abort'];
                        if (!jqXHR) {
                            if (slot) {
                                slot.rejectWith(args);
                            }
                            return send(false, args);
                        }
                        return jqXHR.abort();
                    };
                    return this._enhancePromise(pipe);
                }
                return send();
            },

            _onAdd: function (e, data) {
                var that = this,
                    result = true,
                    options = $.extend({}, this.options, data),
                    limit = options.limitMultiFileUploads,
                    paramName = this._getParamName(options),
                    paramNameSet,
                    paramNameSlice,
                    fileSet,
                    i;
                if (!(options.singleFileUploads || limit) ||
                        !this._isXHRUpload(options)) {
                    fileSet = [data.files];
                    paramNameSet = [paramName];
                } else if (!options.singleFileUploads && limit) {
                    fileSet = [];
                    paramNameSet = [];
                    for (i = 0; i < data.files.length; i += limit) {
                        fileSet.push(data.files.slice(i, i + limit));
                        paramNameSlice = paramName.slice(i, i + limit);
                        if (!paramNameSlice.length) {
                            paramNameSlice = paramName;
                        }
                        paramNameSet.push(paramNameSlice);
                    }
                } else {
                    paramNameSet = paramName;
                }
                data.originalFiles = data.files;
                $.each(fileSet || data.files, function (index, element) {
                    var newData = $.extend({}, data);
                    newData.files = fileSet ? element : [element];
                    newData.paramName = paramNameSet[index];
                    newData.submit = function () {
                        newData.jqXHR = this.jqXHR =
                            (that._trigger('submit', e, this) !== false) &&
                            that._onSend(e, this);
                        return this.jqXHR;
                    };
                    return (result = that._trigger('add', e, newData));
                });
                return result;
            },

            // File Normalization for Gecko 1.9.1 (Firefox 3.5) support:
            _normalizeFile: function (index, file) {

                if (file.name === undefined && file.size === undefined) {
                    file.name = file.fileName;
                    file.size = file.fileSize;
                }

                file.id = (new Date()).getTime() + "_" + index;
            },

            _replaceFileInput: function (input) {
                var inputClone = input.clone(true);
                $('<form></form>').append(inputClone)[0].reset();
                // Detaching allows to insert the fileInput on another form
                // without loosing the file input value:
                input.after(inputClone).detach();
                // Avoid memory leaks with the detached file input:
                $.cleanData(input.unbind('remove'));
                // Replace the original file input element in the fileInput
                // collection with the clone, which has been copied including
                // event handlers:
                this.options.fileInput = this.options.fileInput.map(function (i, el) {
                    if (el === input[0]) {
                        return inputClone[0];
                    }
                    return el;
                });
                // If the widget has been initialized on the file input itself,
                // override this.element with the file input clone:
                if (input[0] === this.element[0]) {
                    this.element = inputClone;
                }
            },

            _getFileInputFiles: function (fileInput) {
                fileInput = $(fileInput);
                var files = $.each($.makeArray(fileInput.prop('files')), this._normalizeFile),
                    value;
                if (!files.length) {
                    value = fileInput.prop('value');
                    if (!value) {
                        return [];
                    }
                    // If the files property is not available, the browser does not
                    // support the File API and we add a pseudo File object with
                    // the input value as name with path information removed:
                    //files = [{name: value.replace(/^.*\\/, '')}];
                    files = $.each([{name: value.replace(/^.*\\/, '')}], this._normalizeFile);
                }
                return files;
            },

            _onChange: function (e) {
                var that = e.data.fileupload,
                    data = {
                        fileInput: $(e.target),
                        form: $(e.target.form)
                    };
                data.files = that._getFileInputFiles(data.fileInput);
                if (that.options.replaceFileInput) {
                    that._replaceFileInput(data.fileInput);
                }
                if (that._trigger('change', e, data) === false ||
                        that._onAdd(e, data) === false) {
                    return false;
                }
            },

            _onPaste: function (e) {
                var that = e.data.fileupload,
                    cbd = e.originalEvent.clipboardData,
                    items = (cbd && cbd.items) || [],
                    data = {files: []};
                $.each(items, function (index, item) {
                    var file = item.getAsFile && item.getAsFile();
                    if (file) {
                        data.files.push(file);
                    }
                });
                if (that._trigger('paste', e, data) === false ||
                        that._onAdd(e, data) === false) {
                    return false;
                }
            },

            _onDrop: function (e) {
                var that = e.data.fileupload,
                    dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer,
                    data = {
                        files: $.each(
                            $.makeArray(dataTransfer && dataTransfer.files),
                            that._normalizeFile
                        )
                    };
                if (that._trigger('drop', e, data) === false ||
                        that._onAdd(e, data) === false) {
                    return false;
                }
                e.preventDefault();
            },

            _onDragOver: function (e) {
                var that = e.data.fileupload,
                    dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer;
                if (that._trigger('dragover', e) === false) {
                    return false;
                }
                if (dataTransfer) {
                    dataTransfer.dropEffect = 'copy';
                }
                e.preventDefault();
            },

            _initEventHandlers: function () {
                var ns = this.options.namespace;
                if (this._isXHRUpload(this.options)) {
                    this.options.dropZone
                        .bind('dragover.' + ns, {fileupload: this}, this._onDragOver)
                        .bind('drop.' + ns, {fileupload: this}, this._onDrop)
                        .bind('paste.' + ns, {fileupload: this}, this._onPaste);
                }
                this.options.fileInput
                    .bind('change.' + ns, {fileupload: this}, this._onChange);
            },

            _destroyEventHandlers: function () {
                var ns = this.options.namespace;
                this.options.dropZone
                    .unbind('dragover.' + ns, this._onDragOver)
                    .unbind('drop.' + ns, this._onDrop)
                    .unbind('paste.' + ns, this._onPaste);
                this.options.fileInput
                    .unbind('change.' + ns, this._onChange);
            },

            _setOption: function (key, value) {
                var refresh = $.inArray(key, this._refreshOptionsList) !== -1;
                if (refresh) {
                    this._destroyEventHandlers();
                }

                if(key == 'disabled'){
                    this._destroyEventHandlers();
                    if(!value){
                        this._initEventHandlers();
                    }
                }

                $.Widget.prototype._setOption.call(this, key, value);
                if (refresh) {
                    this._initSpecialOptions();
                    this._initEventHandlers();
                }
            },

            _initSpecialOptions: function () {
                var options = this.options;
                if (options.fileInput === undefined) {
                    options.fileInput = this.element.is('input:file') ?
                            this.element : this.element.find('input:file');
                } else if (!(options.fileInput instanceof $)) {
                    options.fileInput = $(options.fileInput);
                }
                if (!(options.dropZone instanceof $)) {
                    options.dropZone = $(options.dropZone);
                }
            },

            _create: function () {
                var options = this.options;
                // Initialize options set via HTML5 data-attributes:
                $.extend(options, $(this.element[0].cloneNode(false)).data());
                options.namespace = options.namespace || this.widgetName;
                this._initSpecialOptions();
                this._slots = [];
                this._sequence = this._getXHRPromise(true);
                this._sending = this._active = this._loaded = this._total = 0;
            },

            destroy: function () {
                this._destroyEventHandlers();
                $.Widget.prototype.destroy.call(this);
            },

            // This method is exposed to the widget API and allows adding files
            // using the fileupload API. The data parameter accepts an object which
            // must have a files property and can contain additional options:
            // .fileupload('add', {files: filesList});
            add: function (data) {
                if (!data || this.options.disabled) {
                    return;
                }
                if (data.fileInput && !data.files) {
                    data.files = this._getFileInputFiles(data.fileInput);
                } else {
                    data.files = $.each($.makeArray(data.files), this._normalizeFile);
                }
                this._onAdd(null, data);
            },

            // This method is exposed to the widget API and allows sending files
            // using the fileupload API. The data parameter accepts an object which
            // must have a files property and can contain additional options:
            // .fileupload('send', {files: filesList});
            // The method returns a Promise object for the file upload call.
            send: function (data) {
                if (data && !this.options.disabled) {
                    if (data.fileInput && !data.files) {
                        data.files = this._getFileInputFiles(data.fileInput);
                    } else {
                        data.files = $.each($.makeArray(data.files), this._normalizeFile);
                    }
                    if (data.files.length) {
                        return this._onSend(null, data);
                    }
                }
                return this._getXHRPromise(false, data && data.context);
            }

        });

    }(jQuery));
//});
//mod.defineModule("fileUpload", ["base","waf","progressBar","fileUploadBase","fileuploadui_i18n"], function() {
    /*******************************************************************************
     * jQuery FileUploadUI
     *
     * @version 1.0
     * @author peng_zhou1
     * @Depends:
     *         jquery.ui.core.js
     *         jquery.ui.widget.js
     ******************************************************************************/
    (function ($) {
        $.widget('ui.wafFileUploadUI', $.ui.wafFileUpload, {

            options: {
                // By default, files added to the widget are uploaded as soon
                // as the user clicks on the start buttons. To enable automatic
                // uploads, set the following option to true:
                autoUpload: false,
                // The following option limits the number of files that are
                // allowed to be uploaded using this widget:
                maxNumberOfFiles: null,
                // The maximum allowed file size:
                maxFileSize: null,
                // The minimum allowed file size:
                minFileSize: null,
                // The regular expression for allowed file types, matches
                // against either file type or file name:
                acceptFileTypes:  /.+$/i,
                // The container for the list of files. If undefined, it is set to
                // an element with class "files" inside of the widget element:
                filesContainer: undefined,
                // By default, files are appended to the files container.
                // Set the following option to true, to prepend files instead:
                prependFiles: false,
                // The expected data type of the upload response, sets the dataType
                // option of the $.ajax upload requests:
                dataType: 'json',
                // The method of render upload result
                renderUpload: renderUpload,
                // The method of render download result
                renderDownload: renderDownload,
                // The progress bar options
                progressBar: {width: 100, position: 'center'},
                // select multiple files once
                multiSelect: false,

                width: null,
                height: null,
                tagClass: null,
                style: null,
                hidden: false,

                cancelUrl: null,

                // The add callback is invoked as soon as files are added to the fileupload
                // widget (via file input selection, drag & drop or add API call).
                // See the basic file upload widget for more information:
                add: function (e, data) {
                    var that = $(this).data('wafFileUploadUI'),
                        options = that.options,
                        files = data.files;
                    $(this).wafFileUploadUI('process', data).done(function () {
                        if(that.maxNumberOfFiles>=files.length && (that._trigger('beforeAdd', e, data) !== false)) {
                            that._adjustMaxNumberOfFiles(-files.length);
                            data.maxNumberOfFilesAdjusted = true;
                            data.files.valid = data.isValidated = that._validate(files);
                            data.context = that._renderUpload(files).data('data', data);
                            options.filesContainer[
                                options.prependFiles ? 'prepend' : 'append'
                            ](data.context);
                            if(files[0].progress){
                                files[0].progress.wafProgressBar(options.progressBar);
                            }
                            that._forceReflow(data.context);
                            that._transition(data.context).done(
                                function () {
                                    if ((that._trigger('onAdd', e, data) !== false) &&
                                            (options.autoUpload || data.autoUpload) &&
                                            data.autoUpload !== false && data.isValidated) {
                                        data.submit();
                                    }
                                }
                            );
                        }
                    });
                },
                // Callback for the start of each file upload request:
                send: function (e, data) {
                    var that = $(this).data('wafFileUploadUI');
                    if (!data.isValidated) {
                        if (!data.maxNumberOfFilesAdjusted) {
                            that._adjustMaxNumberOfFiles(-data.files.length);
                            data.maxNumberOfFilesAdjusted = true;
                        }
                        if (!that._validate(data.files)) {
                            return false;
                        }
                    }
                    return that._trigger('onSend', e, data);
                },
                // Callback for successful uploads:
                done: function (e, data) {
                    var that = $(this).data('wafFileUploadUI'),
                        template;
                    if (data.context) {
                        data.context.each(function (index) {
                            var file = ($.isArray(data.result) &&
                                    data.result[index]) || {error: 'emptyResult'};
                            if (file.error) {
                                that._adjustMaxNumberOfFiles(1);
                                data.errorThrown = 'error';
                                data.files[index].error = file.error;
                                data.files[index].size = file.size;
                                that._trigger("fail", e, data);
                            }else{
                                that._transition($(this)).done(
                                    function () {
                                        var node = $(this);
                                        template = that._renderDownload([file])
                                            .replaceAll(node);
                                        that._forceReflow(template);
                                        that._transition(template).done(
                                            function () {
                                                data.context = $(this);
                                                that._trigger('onComplete', e, data);
                                            }
                                        );
                                    }
                                );
                            }
                        });
                    } else {
                        if ($.isArray(data.result)) {
                            $.each(data.result, function (index, file) {
                                if (data.maxNumberOfFilesAdjusted && file.error) {
                                    that._adjustMaxNumberOfFiles(1);
                                } else if (!data.maxNumberOfFilesAdjusted &&
                                        !file.error) {
                                    that._adjustMaxNumberOfFiles(-1);
                                }
                            });
                            data.maxNumberOfFilesAdjusted = true;
                        }
                        template = that._renderDownload(data.result)
                            .appendTo(that.options.filesContainer);
                        that._forceReflow(template);
                        that._transition(template).done(
                            function () {
                                data.context = $(this);
                                that._trigger('onComplete', e, data);
                            }
                        );
                    }
                },
                // Callback for failed (abort or error) uploads:
                fail: function (e, data) {
                    var that = $(this).data('wafFileUploadUI'),
                        template;
                    if (data.maxNumberOfFilesAdjusted) {
                        that._adjustMaxNumberOfFiles(data.files.length);
                    }
                    if (data.context) {
                        data.context.each(function (index) {
                            var file = data.files[index];
                            if (data.errorThrown !== 'abort') {
                                file.error = file.error || data.errorThrown ||
                                    true;
                                that._transition($(this)).done(
                                    function () {
                                        var node = $(this);
                                        template = that._renderUpload([file]).replaceAll(node);
                                        template.data('data', data);
                                        that._forceReflow(template);
                                        that._transition(template).done(
                                            function () {
                                                data.context = $(this);
                                                that._trigger('onFail', e, data);
                                            }
                                        );
                                    }
                                );
                            } else {
                                that._transition($(this)).done(
                                    function () {
                                        $(this).remove();
                                        that._trigger('onAbort', e, data);
                                    }
                                );
                            }
                        });
                    } else if (data.errorThrown !== 'abort') {
                        data.context = that._renderUpload(data.files)
                            .appendTo(that.options.filesContainer)
                            .data('data', data);
                        that._forceReflow(data.context);
                        that._transition(data.context).done(
                            function () {
                                data.context = $(this);
                                that._trigger('onFail', e, data);
                            }
                        );
                    } else {
                        that._trigger('onFail', e, data);
                    }
                },
                // Callback for upload progress events:
                progress: function (e, data) {
                    if (data.context) {
                        var progress = parseInt(data.loaded / data.total * 100, 10),
                            progressbar = data.files[0].progress;

                        if(progressbar && progressbar.wafProgressBar){
                            progressbar.wafProgressBar("setValue", progress);
                        }
                    }
                },
                // Callback for uploads start, equivalent to the global ajaxStart event:
                start: function (e) {
                    var that = $(this).data('wafFileUploadUI');
                    that._transition($(this).find('.fileupload-progress')).done(
                        function () {
                            that._trigger('onStart', e);
                        }
                    );
                },
                // Callback for uploads stop, equivalent to the global ajaxStop event:
                stop: function (e) {
                    var that = $(this).data('wafFileUploadUI');
                    that._transition($(this).find('.fileupload-progress')).done(
                        function () {
                            $(this).find('.progress')
                                .attr('aria-valuenow', '0')
                                .find('.bar').css('width', '0%');
                            $(this).find('.progress-extended').html('&nbsp;');
                            that._trigger('onStop', e);
                        }
                    );
                },
                // Callback for file deletion:
                destroy: function (e, data) {
                    var that = $(this).data('wafFileUploadUI');
                    data.success = function(){
                        that._transition(data.context).done(
                            function () {
                                $(this).remove();
                                that._trigger('onRemove', e, data);
                            }
                        );
                        that._adjustMaxNumberOfFiles(1);
                    };
                    if (data.url) {
                        $.doPost(data);
                    }
                },
                complement: function(e, data){
                    var that = $(this).data('wafFileUploadUI'),
                        file = data.files[0],
                        filesize = that._formatFileSize(file.size),
                        jqXHR = data.context.data("data")==null?null:data.context.data("data").jqXHR;

                    data.files.valid = data.isValidated = that._validate(data.files);
                    if(!data.files.valid && jqXHR){
                        jqXHR.abort("error");
                    }else{
                        data.context.find(".size").text(filesize);
                    }
                }
            },

            _adjustMaxNumberOfFiles: function (operand) {
                if (typeof this.options.maxNumberOfFiles === 'number') {
                    this.maxNumberOfFiles += operand;
                    if (this.maxNumberOfFiles < 1) {
                        this._disableFileInputButton();
                    } else {
                        this._enableFileInputButton();
                    }
                }
            },

            _formatFileSize: function (bytes) {
                return $.wafFileUploadUI.formatFileSize(bytes);
            },

            _hasError: function (file) {
                if (file.error) {
                    return file.error;
                }
                // The number of added files is subtracted from
                // maxNumberOfFiles before validation, so we check if
                // maxNumberOfFiles is below 0 (instead of below 1):
                if (this.maxNumberOfFiles < 0) {
                    return 'maxNumberOfFiles';
                }
                // Files are accepted if either the file type or the file name
                // matches against the acceptFileTypes regular expression, as
                // only browsers with support for the File API report the type:
                if (!(this.options.acceptFileTypes.test(file.type) ||
                        this.options.acceptFileTypes.test(file.name))) {
                    return 'acceptFileTypes';
                }
                if (this.options.maxFileSize &&
                        file.size > this.options.maxFileSize) {
                    return 'maxFileSize';
                }
                if (typeof file.size === 'number' &&
                        file.size < this.options.minFileSize) {
                    return 'minFileSize';
                }
                return null;
            },

            _validate: function (files) {
                var that = this,
                    valid = !!files.length;
                $.each(files, function (index, file) {
                    file.error = that._hasError(file);
                    if (file.error) {
                        valid = false;
                    }
                });
                return valid;
            },

            _renderUpload: function (files) {
                return this.options.renderUpload.call(this, this.options, files);
            },

            _renderDownload: function (files) {
                return this.options.renderDownload.call(this, this.options, files);
            },

            _uploadHandler: function (e) {
                e.preventDefault();
                var button = $(this),
                    data = button.closest('.ui-fileupload-upload-info').data('data');

                if (data && data.submit && !data.jqXHR && data.submit()) {
                    //button.prop('disabled', true);
                    button.hide();
                }
            },

            _cancelHandler: function (e) {
                e.preventDefault();
                var fileupload = e.data.fileupload,
                    options = fileupload.options,
                    data = $(this).closest('.ui-fileupload-upload-info').data('data'),
                    fileId = data.files[0].id,
                    cancelUrl = options.cancelUrl;


                var doCancel = function(){
                    if (!data.jqXHR || data.errorThrown == 'error') {
                        data.errorThrown = 'abort';
                        fileupload._trigger('fail', e, data);
                    } else {
                        data.jqXHR.abort();
                    }
                }

                if(cancelUrl){
                    $.doPost({
                        url: cancelUrl,
                        async: true,
                        data: {
                            "fileId": fileId
                        },
                        success: function(content) {
                            if(content.fileId == fileId){
                                doCancel();
                            }
                        }
                    });
                }else{
                    doCancel();
                }
            },

            _removeHandler: function (e, force) {
                e.preventDefault();
                force = !!force;
                var button = $(this);
                if(force) {
                    e.data.fileupload._trigger('destroy', e, {
                        context: button.closest('.ui-fileupload-download-info'),
                        url: button.attr('data-url'),
                        type: button.attr('data-type') || 'DELETE',
                        dataType: e.data.fileupload.options.dataType
                    });
                }else{
                    waf.msgBox.showConfirm({
                        title : $.wafFileUploadUI.removeDialog.title,
                        summaryMsg : $.wafFileUploadUI.removeDialog.msg,
                        buttonCallBack : [
                            function(dialog){
                                e.data.fileupload._trigger('destroy', e, {
                                    context: button.closest('.ui-fileupload-download-info'),
                                    url: button.attr('data-url'),
                                    type: button.attr('data-type') || 'DELETE',
                                    dataType: e.data.fileupload.options.dataType
                                });
                            },$.noop]
                    });
                }
            },

            _forceReflow: function (node) {
                return $.support.transition && node.length &&
                    node[0].offsetWidth;
            },

            _transition: function (node) {
                var dfd = $.Deferred();
                if ($.support.transition && node.hasClass('fade')) {
                    node.bind(
                        $.support.transition.end,
                        function (e) {
                            // Make sure we don't respond to other transitions events
                            // in the container element, e.g. from button elements:
                            if (e.target === node[0]) {
                                node.unbind($.support.transition.end);
                                dfd.resolveWith(node);
                            }
                        }
                    ).toggleClass('in');
                } else {
                    node.toggleClass('in');
                    dfd.resolveWith(node);
                }
                return dfd;
            },

            _initButtonBarEventHandlers: function () {
                var fileUploadButtonBar = this.element.find('.ui-fileupload-buttonbar'),
                    filesList = this.options.filesContainer,
                    ns = this.options.namespace,
                    self = this;

                fileUploadButtonBar.find('.ui-fileupload-uploadAll a')
                    .bind('click.' + ns, function (e) {
                        e.preventDefault();
                        filesList.find('.upload a').click();
                    });
                fileUploadButtonBar.find('.ui-fileupload-cancelAll a')
                    .bind('click.' + ns, function (e) {
                        e.preventDefault();
                        filesList.find('.cancel a').click();
                    });
                fileUploadButtonBar.find('.ui-fileupload-removeAll a')
                    .bind('click.' + ns, function (e) {
                        e.preventDefault();
                        waf.msgBox.showConfirm({
                            title : $.wafFileUploadUI.removeAllDialog.title,
                            summaryMsg : $.wafFileUploadUI.removeAllDialog.msg,
                            buttonCallBack:[
                                function(dialog){
                                    filesList.find('.remove a').trigger('click', true);
                                },$.noop]
                        });
                    });
            },

            _destroyButtonBarEventHandlers: function () {
                this.element.find('.ui-fileupload-buttonbar a')
                    .unbind('click.' + this.options.namespace);
            },

            _initEventHandlers: function () {
                $.ui.wafFileUpload.prototype._initEventHandlers.call(this);
                var eventData = {fileupload: this};
                this.options.filesContainer
                    .delegate(
                        '.upload a',
                        'click.' + this.options.namespace,
                        eventData,
                        this._uploadHandler
                    )
                    .delegate(
                        '.cancel a',
                        'click.' + this.options.namespace,
                        eventData,
                        this._cancelHandler
                    )
                    .delegate(
                        '.remove a',
                        'click.' + this.options.namespace,
                        eventData,
                        this._removeHandler
                    );
                this._initButtonBarEventHandlers();
            },

            _destroyEventHandlers: function () {
                var options = this.options;
                this._destroyButtonBarEventHandlers();
                options.filesContainer
                    .undelegate('.upload a', 'click.' + options.namespace)
                    .undelegate('.cancel a', 'click.' + options.namespace)
                    .undelegate('.remove a', 'click.' + options.namespace);
                $.ui.wafFileUpload.prototype._destroyEventHandlers.call(this);
            },

            _enableFileInputButton: function () {
                this.element.find('.ui-fileupload-input')
                    .prop('disabled', false)
                    .parent().removeClass('ui-state-disabled');
            },

            _disableFileInputButton: function () {
                this.element.find('.ui-fileupload-input')
                    .prop('disabled', true)
                    .parent().addClass('ui-state-disabled');
            },

            _initFilesContainer: function () {
                var options = this.options;
                if (options.filesContainer === undefined) {
                    options.filesContainer = this.element.find('.ui-fileupload-list');
                } else if (!(options.filesContainer instanceof $)) {
                    options.filesContainer = $(options.filesContainer);
                }
            },

            _stringToRegExp: function (str) {
                var parts = str.split('/'),
                    modifiers = parts.pop();
                parts.shift();
                return new RegExp(parts.join('/'), modifiers);
            },

            _initMulitSelect: function (){
                var multiSelect = this.options.multiSelect;
                if(multiSelect){
                    this.options.fileInput.prop("multiple", true);
                }else{
                    this.options.fileInput.removeAttr("multiple");
                }
            },

            _initRegExpOptions: function () {
                var options = this.options;
                if ($.type(options.acceptFileTypes) === 'string') {
                    options.acceptFileTypes = this._stringToRegExp(
                        options.acceptFileTypes
                    );
                }
            },

            _initSpecialOptions: function () {
                $.ui.wafFileUpload.prototype._initSpecialOptions.call(this);
                this._initFilesContainer();
                this._initMulitSelect();
                this._initRegExpOptions();
            },

            _initButtonbar: function(){
                var fileUploadButtonBar = this.element.find('.ui-fileupload-buttonbar');
                if(_isVeiwOperateState()){
                    fileUploadButtonBar.hide();
                }else{
                    fileUploadButtonBar.find('.ui-fileupload-addFile>a').text($.wafFileUploadUI.defaults.addFile);
                    fileUploadButtonBar.find('.ui-fileupload-uploadAll>a').text($.wafFileUploadUI.defaults.uploadAll);
                    fileUploadButtonBar.find('.ui-fileupload-cancelAll>a').text($.wafFileUploadUI.defaults.cancelAll);
                    fileUploadButtonBar.find('.ui-fileupload-removeAll>a').text($.wafFileUploadUI.defaults.removeAll);
                }
            },

            _initUploadFileId: function (options) {
                $.ui.wafFileUpload.prototype._initUploadFileId.call(this, options);
                var url = options.url,
                    maxFileSize = options.maxFileSize,
                    minFileSize = options.minFileSize;

                if(url && maxFileSize != null){
                    options.url += (url.indexOf("?") < 0 ? "?" : "&") + "maxFileSize=" + maxFileSize;
                }
                if(url && minFileSize != null){
                    options.url += (url.indexOf("?") < 0 ? "?" : "&") + "minFileSize=" + minFileSize;
                }
            },

            _setOption: function (key, value) {
                switch(key){
                    case 'disabled':
                        if(value){
                            this._disableFileInputButton();
                        }else if (this.maxNumberOfFiles > 0) {
                            this._enableFileInputButton();
                        }
                        break;
                    case 'width':
                    case 'height':
                        this.element.css(key, value ? value : '');
                        break;
                    case 'tagClass':
                        this.element.removeClass(this.options.tagClass).addClass(value);
                        break;
                    case 'style':
                        this.element.attr(key, value);
                        break;
                    case 'hidden':
                        this.element[value ? "hide" : "show"]();
                        break;
                }
                $.ui.wafFileUpload.prototype._setOption.call(this, key, value);
            },
            _create: function () {
                $.ui.wafFileUpload.prototype._create.call(this);
                this._initButtonbar();
                this._refreshOptionsList.push(
                    'filesContainer',
                    'autoUpload',
                    'acceptFileTypes',
                    'multiSelect'
                );
                this._processingQueue = $.Deferred().resolveWith(this).promise();
                this.process = function () {
                    return this._processingQueue;
                };
                this._initByOptions('disabled', 'style', 'tagClass', 'hidden', 'width', 'height');

                if(typeof this.options.maxNumberOfFiles === 'number'){
                    this.maxNumberOfFiles = this.options.maxNumberOfFiles;
                }else{
                    this.maxNumberOfFiles = Number.MAX_VALUE;
                }
                this.element.attr("data-domcreated","true");
            },

            downloads: function(data){
                if (data && !$.isArray(data)) {
                    data = [data];
                }
                for(var i = 0, length = data.length;i < length;i++){
                    if (this.maxNumberOfFiles > 0) {
                        this._renderDownload(data[i]).appendTo(this.options.filesContainer);
                        this._adjustMaxNumberOfFiles(-1);
                    }
                }
            },

            sendAll: function(){
                this.element.find('.ui-fileupload-buttonbar .ui-fileupload-uploadAll a').click();
            },

            cancelAll: function(){
                this.element.find('.ui-fileupload-buttonbar .ui-fileupload-cancelAll a').click();
            },

            removeAll: function(){
                this.element.find('.ui-fileupload-buttonbar .ui-fileupload-removeAll a').click();
            }
        });

        var icons = [{"icon":"ui-fileupload-icon-word", "regExp":/.+\.(doc|docx)$/i},
                     {"icon":"ui-fileupload-icon-excel", "regExp":/.+\.(xls|xlsx)$/i},
                     {"icon":"ui-fileupload-icon-ppt", "regExp":/.+\.(ppt|pptx)$/i},
                     {"icon":"ui-fileupload-icon-zip", "regExp":/.+\.zip$/i},
                     {"icon":"ui-fileupload-icon-rar", "regExp":/.+\.rar$/i},
                     {"icon":"ui-fileupload-icon-pdf", "regExp":/.+\.pdf$/i},
                     {"icon":"ui-fileupload-icon-txt", "regExp":/.+\.txt$/i}]

        function _isVeiwOperateState(){
            return $.wafutil.isViewOperateState();
        }

        function getIconClass(filename){
            var icon;
            $.each(icons, function(i, v){
                if(v.regExp.test(filename)){
                    icon = v.icon;
                }
            });
            return icon || "ui-fileupload-icon-default";
        }

        function renderUpload(options, files){
            var file = $.isArray(files) ? files[0] : files,
                filename = file.name,
                filesize = $.wafFileUploadUI.formatFileSize(file.size),
                fileerror = $.wafFileUploadUI.errors[file.error] || file.error,
                li$ = $('<li class="ui-fileupload-upload-info"></li>')
                        .append('<span class="ui-fileupload-icon '+$.wafFileUploadUI.getIconClass(filename)+'"></span>')
                        .append('<span class="name">'+filename+'</span>')
                        .append('<span class="size">'+filesize+'</span>')
                        .append(function(){if(fileerror)return '<span class="errormsg">'+fileerror+'</span>';})
                        .append(function(){if(!fileerror)return '<span class="progress"><div></div></span>';})
                        .append(function(){if(!options.autoUpload && !fileerror)return '<span class="upload"><a>'+$.wafFileUploadUI.defaults.upload+'</a></span>';})
                        .append('<span class="cancel"><a>'+$.wafFileUploadUI.defaults.cancel+'</a></span>');

            file.progress = li$.find('.progress div');

            return li$;
        }

        function renderDownload(options, files){

            var file = $.isArray(files) ? files[0] : files,
                filename = file.name,
                filesize = $.wafFileUploadUI.formatFileSize(file.size),
                fileerror = $.wafFileUploadUI.errors[file.error] || file.error,
                fileurl = file.url,
                filedeleteurl = file.delete_url,
                filedeletetype = file.delete_type,
                isView = _isVeiwOperateState(),
                li$ = $('<li class="ui-fileupload-download-info"></li>')
                    .append('<span class="ui-fileupload-icon '+$.wafFileUploadUI.getIconClass(filename)+'"></span>')
                    .append(function(){
                        if(!fileerror && fileurl){
                            return '<span class="name"><a href="'+fileurl+'" title="'+filename+'" download="'+filename+'">'+filename+'</a></span>';
                        }
                        return '<span class="name">'+filename+'</span>';
                    })
                    .append('<span class="size">'+filesize+'</span>')
                    .append(function(){if(fileerror)return '<span class="errormsg">'+fileerror+'</span>';})
                    .append(function(){
                        if(!isView){
                            return '<span class="remove"><a data-type="'+filedeletetype+'" data-url="'+filedeleteurl+'">'+$.wafFileUploadUI.defaults.remove+'</a></span>';
                        }
                    })
                    .find('a[download]').each($.wafFileUploadUI.enableDragToDesktop).end();

            return li$;
        }

        $.wafFileUploadUI = $.wafFileUploadUI || {};
        $.extend($.wafFileUploadUI, {
            formatFileSize: function (bytes) {
                if (typeof bytes !== 'number') {
                    return '';
                }
                if (bytes >= 1073741824) {
                    return (bytes / 1073741824).toFixed(2) + ' GB';
                }
                if (bytes >= 1048576) {
                    return (bytes / 1048576).toFixed(2) + ' MB';
                }
                return (bytes / 1024).toFixed(2) + ' KB';
            },
            renderUpload: renderUpload,
            renderDownload: renderDownload,
            enableDragToDesktop: function () {
                var link = $(this),
                    url = link.prop('href'),
                    name = link.prop('download'),
                    type = 'application/octet-stream';
                link.bind('dragstart', function (e) {
                    try {
                        e.originalEvent.dataTransfer.setData(
                            'DownloadURL',
                            [type, name, url].join(':')
                        );
                    } catch (err) {}
                });
            },
            getIconClass: getIconClass,
            createFileUploadDOM: function(opts){
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    return $('<div id="' + opts.id + '" name="' + opts.name + '" class="ui-fileupload ui-widget ui-corner-all" ctrlrole="fileUpload">' +
                        '<div class="ui-fileupload-files cf">' +
                        '<ul class="ui-fileupload-list">' +
                        '</ul>' +
                        '</div>' +
                        '<div class="ui-fileupload-buttonbar">' +
                        '<span class="ui-fileupload-addFile"><a></a><input type="file" name="files[]" class="ui-fileupload-input"></span>' +
                        '</div>'+
                        '</div>');
                }else{
                   return obj;
                }
            },
            initFileUpload: function(opts, el){
                addContextPath(opts);
                el.wafFileUploadUI(opts);
            },
            removeFileUpload: function(opts){
                var el = $("#" + opts.id);

                if(el.length){
                    el.wafFileUploadUI('destroy');
                    el.remove();
                }
            },
            modifyFileUpload: function(opts){
                addContextPath(opts);
                $("#" + opts.id).wafFileUploadUI('option', opts);
            }
        });
        $(function () {
            if (waf.registerComponent)
                waf.registerComponent("fileUpload",{createDOMFun: $.wafFileUploadUI.createFileUploadDOM,
                                                   initFun: $.wafFileUploadUI.initFileUpload,
                                                   deleteFun: $.wafFileUploadUI.removeFileUpload,
                                                   modifyFun: $.wafFileUploadUI.modifyFileUpload,lazyInit:true});
        });

        function addContextPath(opts){
            $.dynamicutil.addContextPath(opts, "url");
            $.dynamicutil.addContextPath(opts, "cancelUrl");
            $.dynamicutil.addContextPath(opts, "progressUrl", "/fileUpload/progress.do?method=initalize");
        }
    }(jQuery));
//});
//mod.defineModule("datePicker",["base","waf","slider","datePicker_inner","timePicker_i18n"],function(){
    /*
    * jQuery timepicker addon
    * By: Trent Richardson [http://trentrichardson.com]
    * Version 1.0.1
    * Last Modified: 07/01/2012
    *
    * Copyright 2012 Trent Richardson
    * You may use this project under MIT or GPL licenses.
    * http://trentrichardson.com/Impromptu/GPL-LICENSE.txt
    * http://trentrichardson.com/Impromptu/MIT-LICENSE.txt
    *
    * HERES THE CSS:
    * .ui-timepicker-div .ui-widget-header { margin-bottom: 8px; }
    * .ui-timepicker-div dl { text-align: left; }
    * .ui-timepicker-div dl dt { height: 25px; margin-bottom: -25px; }
    * .ui-timepicker-div dl dd { margin: 0 10px 10px 65px; }
    * .ui-timepicker-div td { font-size: 90%; }
    * .ui-tpicker-grid-label { background: none; border: none; margin: 0; padding: 0; }
    */

    /*jslint evil: true, maxlen: 300, white: false, undef: false, nomen: false, onevar: false */

    (function($) {

    // Prevent "Uncaught RangeError: Maximum call stack size exceeded"
    $.ui.timepicker = $.ui.timepicker || {};
    if ($.ui.timepicker.version) {
        return;
    }

    $.extend($.ui, { timepicker: { version: "1.0.1" } });

    /* Time picker manager.
       Use the singleton instance of this class, $.timepicker, to interact with the time picker.
       Settings for (groups of) time pickers are maintained in an instance object,
       allowing multiple different settings on the same page. */

    function Timepicker() {
        this.regional = []; // Available regional settings, indexed by language code
        this.regional[''] = { // Default regional settings
            currentText: 'Now',
            closeText: 'Done',
            ampm: false,
            amNames: ['AM', 'A'],
            pmNames: ['PM', 'P'],
            timeFormat: 'hh:mm tt',
            timeSuffix: '',
            timeOnlyTitle: 'Choose Time',
            timeText: 'Time',
            hourText: 'Hour',
            minuteText: 'Minute',
            secondText: 'Second',
            millisecText: 'Millisecond',
            timezoneText: 'Time Zone'
        };
        this._defaults = { // Global defaults for all the datetime picker instances
            showButtonPanel: true,
            timeOnly: false,
            showHour: true,
            showMinute: true,
            showSecond: true,
            showMillisec: false,
            showTimezone: false,
            showTime: true,
            stepHour: 1,
            stepMinute: 1,
            stepSecond: 1,
            stepMillisec: 1,
            hour: 0,
            minute: 0,
            second: 0,
            millisec: 0,
            timezone: "+0000",
            useLocalTimezone: false,
            defaultTimezone: "+0000",
            hourMin: 0,
            minuteMin: 0,
            secondMin: 0,
            millisecMin: 0,
            hourMax: 23,
            minuteMax: 59,
            secondMax: 59,
            millisecMax: 999,
            minDateTime: null,
            maxDateTime: null,
            onSelect: null,
            hourGrid: 0,
            minuteGrid: 0,
            secondGrid: 0,
            millisecGrid: 0,
            alwaysSetTime: true,
            separator: ' ',
            altFieldTimeOnly: false,
            showTimepicker: true,
            timezoneIso8601: false,
            timezoneList: null,
            addSliderAccess: false,
            sliderAccessArgs: null,
            altSeparator: ' ',
            altTimeFormat: 'hh:mm:ss',
            currentHour: 0,
            currentMinute: 0,
            currentSecond: 0,
            currentMillisec: 0
        };
        $.extend(this._defaults, this.regional['']);
    }

    $.extend(Timepicker.prototype, {
        $input: null,
        $altInput: null,
        $timeObj: null,
        inst: null,
        hour_slider: null,
        minute_slider: null,
        second_slider: null,
        millisec_slider: null,
        timezone_select: null,
        hour: 0,
        minute: 0,
        second: 0,
        millisec: 0,
        timezone: "+0000",
        defaultTimezone: "+0000",
        hourMinOriginal: null,
        minuteMinOriginal: null,
        secondMinOriginal: null,
        millisecMinOriginal: null,
        hourMaxOriginal: null,
        minuteMaxOriginal: null,
        secondMaxOriginal: null,
        millisecMaxOriginal: null,
        ampm: '',
        formattedDate: '',
        formattedTime: '',
        formattedDateTime: '',
        altFormattedDate: '',
        altFormattedTime: '',
        altFormattedDateTime: '',
        timezoneList: null,

        /* Override the default settings for all instances of the time picker.
           @param  settings  object - the new settings to use as defaults (anonymous object)
           @return the manager object */
        setDefaults: function(settings) {
            extendRemove(this._defaults, settings || {});
            return this;
        },

        //########################################################################
        // Create a new Timepicker instance
        //########################################################################
        _newInst: function($input, o) {
            var tp_inst = new Timepicker(),
                inlineSettings = {};

            if ($.wafDatepicker.timeResource) {
                $.timepicker.setDefaults($.wafDatepicker.timeResource);
            }

            for (var attrName in this._defaults) {
                var attrValue = $input.attr('time:' + attrName);
                if (attrValue) {
                    try {
                        inlineSettings[attrName] = eval(attrValue);
                    } catch (err) {
                        inlineSettings[attrName] = attrValue;
                    }
                }
            }
            tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, o, {
                beforeShow: function(input, dp_inst) {
                    if ($.isFunction(o.beforeShow)) {
                        return o.beforeShow(input, dp_inst, tp_inst);
                    }
                },
                /*
                onChangeMonthYear: function(year, month, dp_inst) {
                    // Update the time as well : this prevents the time from disappearing from the $input field.
                    tp_inst._updateDateTime(dp_inst);
                    if ($.isFunction(o.onChangeMonthYear)) {
                        o.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
                    }
                },
                */
                onClose: function(dateText, dp_inst) {
                    if (tp_inst.timeDefined === true && $input.val() !== '') {
                        //tp_inst._updateDateTime(dp_inst);
                    }
                    if ($.isFunction(o.onClose)) {
                        o.onClose.call($input[0], dateText, dp_inst, tp_inst);
                    }
                },
                timepicker: tp_inst // add timepicker as a property of datepicker: $.datepicker._get(dp_inst, 'timepicker');
            });
            tp_inst.amNames = $.map(tp_inst._defaults.amNames, function(val) { return val.toUpperCase(); });
            tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function(val) { return val.toUpperCase(); });

            if (tp_inst._defaults.timezoneList === null) {
                var timezoneList = [];
                for (var i = -11; i <= 12; i++) {
                    timezoneList.push((i >= 0 ? '+' : '-') + ('0' + Math.abs(i).toString()).slice(-2) + '00');
                }
                if (tp_inst._defaults.timezoneIso8601) {
                    timezoneList = $.map(timezoneList, function(val) {
                        return val == '+0000' ? 'Z' : (val.substring(0, 3) + ':' + val.substring(3));
                    });
                }
                tp_inst._defaults.timezoneList = timezoneList;
            }

            tp_inst.timezone = tp_inst._defaults.timezone;
            tp_inst.hour = tp_inst._defaults.hour;
            tp_inst.minute = tp_inst._defaults.minute;
            tp_inst.second = tp_inst._defaults.second;
            tp_inst.millisec = tp_inst._defaults.millisec;
            tp_inst.ampm = '';
            tp_inst.$input = $input;
    /*
            if (o.altField) {
                tp_inst.$altInput = $(o.altField)
                    .css({ cursor: 'pointer' })
                    .focus(function(){ $input.trigger("focus"); });
            }
    */
            if(o.altField){tp_inst.$altInput = $(o.altField);}
            if(tp_inst._defaults.minDate===0 || tp_inst._defaults.minDateTime===0)
            {
                tp_inst._defaults.minDate=new Date();
            }
            if(tp_inst._defaults.maxDate===0 || tp_inst._defaults.maxDateTime===0)
            {
                tp_inst._defaults.maxDate=new Date();
            }

            // datepicker needs minDate/maxDate, timepicker needs minDateTime/maxDateTime..
            if(tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date) {
                tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime());
            }
            if(tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date) {
                tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime());
            }
            if(tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date) {
                tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime());
            }
            if(tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date) {
                tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime());
            }
            return tp_inst;
        },

        //########################################################################
        // add our sliders to the calendar
        //########################################################################
        _addTimePicker: function(dp_inst) {
            var currDT = (this.$altInput && this._defaults.altFieldTimeOnly) ?
                    this.$input.val() + ' ' + this.$altInput.val() :
                    this.$input.val();

            //this.timeDefined = this._parseTime(currDT);
            this.inst = this.inst ||$.datepicker._getInst(this.$input[0]);
            this._limitMinMaxDateTime(dp_inst, false);
            this._injectTimePicker();
        },

        //########################################################################
        // parse the time string from input value or _setTime
        //########################################################################
        _parseTime: function(timeString, withDate) {
            if (!this.inst) {
                this.inst = $.datepicker._getInst(this.$input[0]);
            }

            if (withDate || !this._defaults.timeOnly)
            {
                var dp_dateFormat = $.datepicker._get(this.inst, 'dateFormat');
                try {
                    var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults);
                    if (!parseRes.timeObj) { return false; }
                    $.extend(this, parseRes.timeObj);
                } catch (err)
                {
                    return false;
                }
                return true;
            }
            else
            {
                var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults);
                if(!timeObj) { return false; }
                $.extend(this, timeObj);
                return true;
            }
        },

        //########################################################################
        // generate and inject html for timepicker into ui datepicker
        //########################################################################
        _injectTimePicker: function() {
            var $dp = this.inst.dpDiv,
                o = this._defaults,
                inst = this.inst,
                tp_inst = this,
                // Added by Peter Medeiros:
                // - Figure out what the hour/minute/second max should be based on the step values.
                // - Example: if stepMinute is 15, then minMax is 45.
                hourMax = parseInt((o.hourMax - ((o.hourMax - o.hourMin) % o.stepHour)) ,10),
                minMax  = parseInt((o.minuteMax - ((o.minuteMax - o.minuteMin) % o.stepMinute)) ,10),
                secMax  = parseInt((o.secondMax - ((o.secondMax - o.secondMin) % o.stepSecond)) ,10),
                millisecMax  = parseInt((o.millisecMax - ((o.millisecMax - o.millisecMin) % o.stepMillisec)) ,10),
                dp_id = this.inst.id.toString().replace(/([^A-Za-z0-9_])/g, ''),
                showSecond = $.datepicker._get(this.inst, "showSecond");

            // Prevent displaying twice
            //if ($dp.find("div#ui-timepicker-div-"+ dp_id).length === 0) {
            if ($dp.find("div#ui-timepicker-div-"+ dp_id).length === 0 && o.showTimepicker) {
                var noDisplay = ' style="display:none;"',
                    html =    '<div class="ui-timepicker-div" id="ui-timepicker-div-' + dp_id + '"><dl>' +
                            '<dt class="ui_tpicker_time_label" id="ui_tpicker_time_label_' + dp_id + '"' +
                            ((o.showTime) ? '' : noDisplay) + '>' + o.timeText + '</dt>' +
                            '<dd class="ui_tpicker_time" id="ui_tpicker_time_' + dp_id + '"' +
                            ((o.showTime) ? '' : noDisplay) + '></dd>' +
                            '<dt class="ui_tpicker_hour_label" id="ui_tpicker_hour_label_' + dp_id + '"' +
                            ((o.showHour) ? '' : noDisplay) + '>' + o.hourText + '</dt>',
                    hourGridSize = 0,
                    minuteGridSize = 0,
                    secondGridSize = 0,
                    millisecGridSize = 0,
                    size = null;

                // Hours
                html += '<dd class="ui_tpicker_hour"><div id="ui_tpicker_hour_' + dp_id + '"' +
                            ((o.showHour) ? '' : noDisplay) + '></div>';
                if (o.showHour && o.hourGrid > 0) {
                    html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

                    for (var h = o.hourMin; h <= hourMax; h += parseInt(o.hourGrid,10)) {
                        hourGridSize++;
                        var tmph = (o.ampm && h > 12) ? h-12 : h;
                        if (tmph < 10) { tmph = '0' + tmph; }
                        if (o.ampm) {
                            if (h === 0) {
                                tmph = 12 +'a';
                            } else {
                                if (h < 12) { tmph += 'a'; }
                                else { tmph += 'p'; }
                            }
                        }
                        html += '<td>' + tmph + '</td>';
                    }

                    html += '</tr></table></div>';
                }
                html += '</dd>';

                // Minutes
                html += '<dt class="ui_tpicker_minute_label" id="ui_tpicker_minute_label_' + dp_id + '"' +
                        ((o.showMinute) ? '' : noDisplay) + '>' + o.minuteText + '</dt>'+
                        '<dd class="ui_tpicker_minute"><div id="ui_tpicker_minute_' + dp_id + '"' +
                                ((o.showMinute) ? '' : noDisplay) + '></div>';

                if (o.showMinute && o.minuteGrid > 0) {
                    html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

                    for (var m = o.minuteMin; m <= minMax; m += parseInt(o.minuteGrid,10)) {
                        minuteGridSize++;
                        html += '<td>' + ((m < 10) ? '0' : '') + m + '</td>';
                    }

                    html += '</tr></table></div>';
                }
                html += '</dd>';

                // Seconds
                html += '<dt class="ui_tpicker_second_label" id="ui_tpicker_second_label_' + dp_id + '"' +
                        ((showSecond) ? '' : noDisplay) + '>' + o.secondText + '</dt>'+
                        '<dd class="ui_tpicker_second"><div id="ui_tpicker_second_' + dp_id + '"'+
                                ((showSecond) ? '' : noDisplay) + '></div>';

                if (showSecond && o.secondGrid > 0) {
                    html += '<div style="padding-left: 1px"><table><tr>';

                    for (var s = o.secondMin; s <= secMax; s += parseInt(o.secondGrid,10)) {
                        secondGridSize++;
                        html += '<td>' + ((s < 10) ? '0' : '') + s + '</td>';
                    }

                    html += '</tr></table></div>';
                }
                html += '</dd>';

                // Milliseconds
                html += '<dt class="ui_tpicker_millisec_label" id="ui_tpicker_millisec_label_' + dp_id + '"' +
                        ((o.showMillisec) ? '' : noDisplay) + '>' + o.millisecText + '</dt>'+
                        '<dd class="ui_tpicker_millisec"><div id="ui_tpicker_millisec_' + dp_id + '"'+
                                ((o.showMillisec) ? '' : noDisplay) + '></div>';

                if (o.showMillisec && o.millisecGrid > 0) {
                    html += '<div style="padding-left: 1px"><table><tr>';

                    for (var l = o.millisecMin; l <= millisecMax; l += parseInt(o.millisecGrid,10)) {
                        millisecGridSize++;
                        html += '<td>' + ((l < 10) ? '0' : '') + l + '</td>';
                    }

                    html += '</tr></table></div>';
                }
                html += '</dd>';

                // Timezone
                html += '<dt class="ui_tpicker_timezone_label" id="ui_tpicker_timezone_label_' + dp_id + '"' +
                        ((o.showTimezone) ? '' : noDisplay) + '>' + o.timezoneText + '</dt>';
                html += '<dd class="ui_tpicker_timezone" id="ui_tpicker_timezone_' + dp_id + '"'    +
                                ((o.showTimezone) ? '' : noDisplay) + '></dd>';

                html += '</dl></div>';
                var $tp = $(html);

                    // if we only want time picker...
                if (o.timeOnly === true) {
                    $tp.prepend(
                        '<div class="ui-widget-header ui-helper-clearfix ui-corner-all">' +
                            '<div class="ui-datepicker-title">' + o.timeOnlyTitle + '</div>' +
                        '</div>');
                    $dp.find('.ui-datepicker-header, .ui-datepicker-calendar').hide();
                }

                this.hour_slider = $tp.find('#ui_tpicker_hour_'+ dp_id).slider({
                    orientation: "horizontal",
                    value: this.hour,
                    min: o.hourMin,
                    max: hourMax,
                    step: o.stepHour,
                    slide: function(event, ui) {
                        tp_inst.hour_slider.slider( "option", "value", ui.value);
                        tp_inst._onTimeChange();
                    }
                });
                this.hour_slider.find('a').attr('tabindex',0);


                // Updated by Peter Medeiros:
                // - Pass in Event and UI instance into slide function
                this.minute_slider = $tp.find('#ui_tpicker_minute_'+ dp_id).slider({
                    orientation: "horizontal",
                    value: this.minute,
                    min: o.minuteMin,
                    max: minMax,
                    step: o.stepMinute,
                    slide: function(event, ui) {
                        tp_inst.minute_slider.slider( "option", "value", ui.value);
                        tp_inst._onTimeChange();
                    }
                });
                this.minute_slider.find('a').attr('tabindex',0);

                this.second_slider = $tp.find('#ui_tpicker_second_'+ dp_id).slider({
                    orientation: "horizontal",
                    value: this.second,
                    min: o.secondMin,
                    max: secMax,
                    step: o.stepSecond,
                    slide: function(event, ui) {
                        tp_inst.second_slider.slider( "option", "value", ui.value);
                        tp_inst._onTimeChange();
                    }
                });
                this.second_slider.find('a').attr('tabindex',0);

                this.millisec_slider = $tp.find('#ui_tpicker_millisec_'+ dp_id).slider({
                    orientation: "horizontal",
                    value: this.millisec,
                    min: o.millisecMin,
                    max: millisecMax,
                    step: o.stepMillisec,
                    slide: function(event, ui) {
                        tp_inst.millisec_slider.slider( "option", "value", ui.value);
                        tp_inst._onTimeChange();
                    }
                });
                this.millisec_slider.find('a').attr('tabindex',0);

                this.timezone_select = $tp.find('#ui_tpicker_timezone_'+ dp_id).append('<select></select>').find("select");
                $.fn.append.apply(this.timezone_select,
                    $.map(o.timezoneList, function(val, idx) {
                        return $("<option />")
                            .val(typeof val == "object" ? val.value : val)
                            .text(typeof val == "object" ? val.label : val);
                    })
                );
                if (typeof(this.timezone) != "undefined" && this.timezone !== null && this.timezone !== "") {
                    var local_date = new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12);
                    var local_timezone = timeZoneString(local_date);
                    if (local_timezone == this.timezone) {
                        selectLocalTimeZone(tp_inst);
                    } else {
                        this.timezone_select.val(this.timezone);
                    }
                } else {
                    if (typeof(this.hour) != "undefined" && this.hour !== null && this.hour !== "") {
                        this.timezone_select.val(o.defaultTimezone);
                    } else {
                        selectLocalTimeZone(tp_inst);
                    }
                }
                this.timezone_select.change(function() {
                    tp_inst._defaults.useLocalTimezone = false;
                    tp_inst._onTimeChange();
                });

                // Add grid functionality
                if (o.showHour && o.hourGrid > 0) {
                    size = 100 * hourGridSize * o.hourGrid / (hourMax - o.hourMin);

                    $tp.find(".ui_tpicker_hour table").css({
                        width: size + "%",
                        marginLeft: (size / (-2 * hourGridSize)) + "%",
                        borderCollapse: 'collapse'
                    }).find("td").each( function(index) {
                        $(this).click(function() {
                            var h = $(this).html();
                            if(o.ampm)    {
                                var ap = h.substring(2).toLowerCase(),
                                    aph = parseInt(h.substring(0,2), 10);
                                if (ap == 'a') {
                                    if (aph == 12) { h = 0; }
                                    else { h = aph; }
                                } else if (aph == 12) { h = 12; }
                                else { h = aph + 12; }
                            }
                            tp_inst.hour_slider.slider("option", "value", h);
                            tp_inst._onTimeChange();
                            tp_inst._onSelectHandler();
                        }).css({
                            cursor: 'pointer',
                            width: (100 / hourGridSize) + '%',
                            textAlign: 'center',
                            overflow: 'hidden'
                        });
                    });
                }

                if (o.showMinute && o.minuteGrid > 0) {
                    size = 100 * minuteGridSize * o.minuteGrid / (minMax - o.minuteMin);
                    $tp.find(".ui_tpicker_minute table").css({
                        width: size + "%",
                        marginLeft: (size / (-2 * minuteGridSize)) + "%",
                        borderCollapse: 'collapse'
                    }).find("td").each(function(index) {
                        $(this).click(function() {
                            tp_inst.minute_slider.slider("option", "value", $(this).html());
                            tp_inst._onTimeChange();
                            tp_inst._onSelectHandler();
                        }).css({
                            cursor: 'pointer',
                            width: (100 / minuteGridSize) + '%',
                            textAlign: 'center',
                            overflow: 'hidden'
                        });
                    });
                }

                if (o.showSecond && o.secondGrid > 0) {
                    $tp.find(".ui_tpicker_second table").css({
                        width: size + "%",
                        marginLeft: (size / (-2 * secondGridSize)) + "%",
                        borderCollapse: 'collapse'
                    }).find("td").each(function(index) {
                        $(this).click(function() {
                            tp_inst.second_slider.slider("option", "value", $(this).html());
                            tp_inst._onTimeChange();
                            tp_inst._onSelectHandler();
                        }).css({
                            cursor: 'pointer',
                            width: (100 / secondGridSize) + '%',
                            textAlign: 'center',
                            overflow: 'hidden'
                        });
                    });
                }

                if (o.showMillisec && o.millisecGrid > 0) {
                    $tp.find(".ui_tpicker_millisec table").css({
                        width: size + "%",
                        marginLeft: (size / (-2 * millisecGridSize)) + "%",
                        borderCollapse: 'collapse'
                    }).find("td").each(function(index) {
                        $(this).click(function() {
                            tp_inst.millisec_slider.slider("option", "value", $(this).html());
                            tp_inst._onTimeChange();
                            tp_inst._onSelectHandler();
                        }).css({
                            cursor: 'pointer',
                            width: (100 / millisecGridSize) + '%',
                            textAlign: 'center',
                            overflow: 'hidden'
                        });
                    });
                }

                var $buttonPanel = $dp.find('.ui-datepicker-buttonpane');
                if ($buttonPanel.length) { $buttonPanel.before($tp); }
                else { $dp.append($tp); }

                this.$timeObj = $tp.find('#ui_tpicker_time_'+ dp_id);

                if (this.inst !== null) {
                    var timeDefined = this.timeDefined;
                    this._onTimeChange();
                    this.timeDefined = timeDefined;
                }

                //Emulate datepicker onSelect behavior. Call on slidestop.
                var onSlideStopDelegate = function() {
                    var selectedDate = $.datepicker._getSelectedDate(inst);
                    $.datepicker._triggerOnSelect(inst, selectedDate);
                };
                this.hour_slider.bind('slidestop',onSlideStopDelegate);
                this.minute_slider.bind('slidestop',onSlideStopDelegate);
                this.second_slider.bind('slidestop',onSlideStopDelegate);
                this.millisec_slider.bind('slidestop',onSlideStopDelegate);

                // slideAccess integration: http://trentrichardson.com/2011/11/11/jquery-ui-sliders-and-touch-accessibility/
                if (this._defaults.addSliderAccess){
                    var sliderAccessArgs = this._defaults.sliderAccessArgs;
                    setTimeout(function(){ // fix for inline mode
                        if($tp.find('.ui-slider-access').length === 0){
                            $tp.find('.ui-slider:visible').sliderAccess(sliderAccessArgs);

                            // fix any grids since sliders are shorter
                            var sliderAccessWidth = $tp.find('.ui-slider-access:eq(0)').outerWidth(true);
                            if(sliderAccessWidth){
                                $tp.find('table:visible').each(function(){
                                    var $g = $(this),
                                        oldWidth = $g.outerWidth(),
                                        oldMarginLeft = $g.css('marginLeft').toString().replace('%',''),
                                        newWidth = oldWidth - sliderAccessWidth,
                                        newMarginLeft = ((oldMarginLeft * newWidth)/oldWidth) + '%';

                                    $g.css({ width: newWidth, marginLeft: newMarginLeft });
                                });
                            }
                        }
                    },0);
                }
                // end slideAccess integration

            }
        },

        //########################################################################
        // This function tries to limit the ability to go outside the
        // min/max date range
        //########################################################################
        _limitMinMaxDateTime: function(dp_inst, adjustSliders){
            var o = this._defaults,
                dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);

            if(!this._defaults.showTimepicker) { return; } // No time so nothing to check here

            if($.datepicker._get(dp_inst, 'minDateTime') !== null && $.datepicker._get(dp_inst, 'minDateTime') !== undefined && dp_date){
                var minDateTime = $.datepicker._get(dp_inst, 'minDateTime'),
                    minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);

                if(this.hourMinOriginal === null || this.minuteMinOriginal === null || this.secondMinOriginal === null || this.millisecMinOriginal === null){
                    this.hourMinOriginal = o.hourMin;
                    this.minuteMinOriginal = o.minuteMin;
                    this.secondMinOriginal = o.secondMin;
                    this.millisecMinOriginal = o.millisecMin;
                }

                if(dp_inst.settings.timeOnly || minDateTimeDate.getTime() == dp_date.getTime()) {
                    this._defaults.hourMin = minDateTime.getHours();
                    if (this.hour <= this._defaults.hourMin) {
                        this.hour = this._defaults.hourMin;
                        this._defaults.minuteMin = minDateTime.getMinutes();
                        if (this.minute <= this._defaults.minuteMin) {
                            this.minute = this._defaults.minuteMin;
                            this._defaults.secondMin = minDateTime.getSeconds();
                        } else if (this.second <= this._defaults.secondMin){
                            this.second = this._defaults.secondMin;
                            this._defaults.millisecMin = minDateTime.getMilliseconds();
                        } else {
                            if(this.millisec < this._defaults.millisecMin) {
                                this.millisec = this._defaults.millisecMin;
                            }
                            this._defaults.millisecMin = this.millisecMinOriginal;
                        }
                    } else {
                        this._defaults.minuteMin = this.minuteMinOriginal;
                        this._defaults.secondMin = this.secondMinOriginal;
                        this._defaults.millisecMin = this.millisecMinOriginal;
                    }
                }else{
                    this._defaults.hourMin = this.hourMinOriginal;
                    this._defaults.minuteMin = this.minuteMinOriginal;
                    this._defaults.secondMin = this.secondMinOriginal;
                    this._defaults.millisecMin = this.millisecMinOriginal;
                }
            }

            if($.datepicker._get(dp_inst, 'maxDateTime') !== null && $.datepicker._get(dp_inst, 'maxDateTime') !== undefined && dp_date){
                var maxDateTime = $.datepicker._get(dp_inst, 'maxDateTime'),
                    maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);

                if(this.hourMaxOriginal === null || this.minuteMaxOriginal === null || this.secondMaxOriginal === null){
                    this.hourMaxOriginal = o.hourMax;
                    this.minuteMaxOriginal = o.minuteMax;
                    this.secondMaxOriginal = o.secondMax;
                    this.millisecMaxOriginal = o.millisecMax;
                }

                if(dp_inst.settings.timeOnly || maxDateTimeDate.getTime() == dp_date.getTime()){
                    this._defaults.hourMax = maxDateTime.getHours();
                    if (this.hour >= this._defaults.hourMax) {
                        this.hour = this._defaults.hourMax;
                        this._defaults.minuteMax = maxDateTime.getMinutes();
                        if (this.minute >= this._defaults.minuteMax) {
                            this.minute = this._defaults.minuteMax;
                            this._defaults.secondMax = maxDateTime.getSeconds();
                        } else if (this.second >= this._defaults.secondMax) {
                            this.second = this._defaults.secondMax;
                            this._defaults.millisecMax = maxDateTime.getMilliseconds();
                        } else {
                            if(this.millisec > this._defaults.millisecMax) { this.millisec = this._defaults.millisecMax; }
                            this._defaults.millisecMax = this.millisecMaxOriginal;
                        }
                    } else {
                        this._defaults.minuteMax = this.minuteMaxOriginal;
                        this._defaults.secondMax = this.secondMaxOriginal;
                        this._defaults.millisecMax = this.millisecMaxOriginal;
                    }
                }else{
                    this._defaults.hourMax = this.hourMaxOriginal;
                    this._defaults.minuteMax = this.minuteMaxOriginal;
                    this._defaults.secondMax = this.secondMaxOriginal;
                    this._defaults.millisecMax = this.millisecMaxOriginal;
                }
            }

            if(adjustSliders !== undefined && adjustSliders === true){
                var hourMax = parseInt((this._defaults.hourMax - ((this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour)) ,10),
                    minMax  = parseInt((this._defaults.minuteMax - ((this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute)) ,10),
                    secMax  = parseInt((this._defaults.secondMax - ((this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond)) ,10),
                    millisecMax  = parseInt((this._defaults.millisecMax - ((this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec)) ,10);

                if(this.hour_slider) {
                    this.hour_slider.slider("option", { min: this._defaults.hourMin, max: hourMax }).slider('value', this.hour);
                }
                if(this.minute_slider) {
                    this.minute_slider.slider("option", { min: this._defaults.minuteMin, max: minMax }).slider('value', this.minute);
                }
                if(this.second_slider){
                    this.second_slider.slider("option", { min: this._defaults.secondMin, max: secMax }).slider('value', this.second);
                }
                if(this.millisec_slider) {
                    this.millisec_slider.slider("option", { min: this._defaults.millisecMin, max: millisecMax }).slider('value', this.millisec);
                }
            }

        },


        //########################################################################
        // when a slider moves, set the internal time...
        // on time change is also called when the time is updated in the text field
        //########################################################################
        _onTimeChange: function() {
            var hour   = (this.hour_slider) ? this.hour_slider.slider('value') : false,
                minute = (this.minute_slider) ? this.minute_slider.slider('value') : false,
                second = (this.second_slider) ? this.second_slider.slider('value') : false,
                millisec = (this.millisec_slider) ? this.millisec_slider.slider('value') : false,
                timezone = (this.timezone_select) ? this.timezone_select.val() : false,
                o = this._defaults;

            if (typeof(hour) == 'object') { hour = false; }
            if (typeof(minute) == 'object') { minute = false; }
            if (typeof(second) == 'object') { second = false; }
            if (typeof(millisec) == 'object') { millisec = false; }
            if (typeof(timezone) == 'object') { timezone = false; }

            if (hour !== false) { hour = parseInt(hour,10); }
            if (minute !== false) { minute = parseInt(minute,10); }
            if (second !== false) { second = parseInt(second,10); }
            if (millisec !== false) { millisec = parseInt(millisec,10); }

            var ampm = o[hour < 12 ? 'amNames' : 'pmNames'][0];

            // If the update was done in the input field, the input field should not be updated.
            // If the update was done using the sliders, update the input field.
            var hasChanged = (hour != this.hour || minute != this.minute ||
                    second != this.second || millisec != this.millisec ||
                    (this.ampm.length > 0 &&
                        (hour < 12) != ($.inArray(this.ampm.toUpperCase(), this.amNames) !== -1)) ||
                    timezone != this.timezone);

            if (hasChanged) {
                if (hour !== false) { this.hour = hour; }
                if (minute !== false) { this.minute = minute; }
                if (second !== false) { this.second = second; }
                if (millisec !== false) { this.millisec = millisec; }
                if (timezone !== false) { this.timezone = timezone; }

                if (!this.inst) { this.inst = $.datepicker._getInst(this.$input[0]); }

                this._limitMinMaxDateTime(this.inst, true);
            }
            if (o.ampm) { this.ampm = ampm; }

            var inst = this.inst || $.datepicker._getInst(this.$input[0]),
                timeFormat = $.datepicker._get(inst, 'timeFormat'),
                showSecond = $.datepicker._get(inst, 'showSecond');

            if(!showSecond){
                timeFormat = timeFormat.substring(0,5);
            }

            this.formattedTime = $.datepicker.formatTime(timeFormat, this, this._defaults);
            this.altFormattedTime = $.datepicker.formatTime($.datepicker._get(inst, 'altTimeFormat'), this, this._defaults);
            if (this.$timeObj) { this.$timeObj.text(this.formattedTime + o.timeSuffix); }
            this.timeDefined = true;
            //if (hasChanged) { this._updateDateTime(this.inst); }
        },

        //########################################################################
        // call custom onSelect.
        // bind to sliders slidestop, and grid click.
        //########################################################################
        _onSelectHandler: function() {
            /*
            var onSelect = this._defaults.onSelect;
            var inputEl = this.$input ? this.$input[0] : null;
            if (onSelect && inputEl) {
                onSelect.apply(inputEl, [this.formattedDateTime, this]);
            }
            */
        },

        //########################################################################
        // left for any backwards compatibility
        //########################################################################
        /*
        _formatTime: function(time, format) {
            time = time || { hour: this.hour, minute: this.minute, second: this.second, millisec: this.millisec, ampm: this.ampm, timezone: this.timezone };
            var tmptime = (format || this._defaults.timeFormat).toString();

            tmptime = $.datepicker.formatTime(tmptime, time, this._defaults);

            if (arguments.length) { return tmptime; }
            else { this.formattedTime = tmptime; }
        },
        */
        //########################################################################
        // update our input with the new date time..
        //########################################################################
        _updateDateTime: function(inst) {
            $.datepicker._updateInput(inst);
            $.datepicker._updateAlternate(inst);
        }
    });

    $.fn.extend({
        //########################################################################
        // shorthand just to use timepicker..
        //########################################################################
        timepicker: function(o) {
            o = o || {};
            var tmp_args = arguments;

            if (typeof o == 'object') { tmp_args[0] = $.extend(o, { timeOnly: true }); }

            return $(this).each(function() {
                $.fn.datetimepicker.apply($(this), tmp_args);
            });
        },

        //########################################################################
        // extend timepicker to datepicker
        //########################################################################
        datetimepicker: function(o) {
            o = o || {};
            var tmp_args = arguments;

            if (typeof(o) == 'string'){
                if(o == 'getDate') {
                    return $.fn.datepicker.apply($(this[0]), tmp_args);
                }
                else {
                    return this.each(function() {
                        var $t = $(this);
                        $t.datepicker.apply($t, tmp_args);
                    });
                }
            }
            else {
                return this.each(function() {
                    var $t = $(this);
                    $t.datepicker($.timepicker._newInst($t, o)._defaults);
                });
            }
        },
        wafDatePicker: function(o) {
            o = o || {};
            var tmp_args = arguments;

            if (typeof(o) == 'string'){
                if(!$(this).data("datepicker")){
                    var op = $.wafutil.getLazyOption($(this).attr("id"));
                    if(op.type == "datetime"){
                        this.datetimepicker(op);
                    }else{
                        this.datepicker(op);
                    }
                }
                return this.datepicker.apply(this, tmp_args);
            }
            else {
                if(o.type == "datetime"){
                    return this.datetimepicker(o);
                }else{
                    return this.datepicker(o);
                }
            }
        }
    });

    $.datepicker.parseDateTime = function(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
        if(!dateTimeString){
            return null;
        }
        var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings);
        if (parseRes.timeObj)
        {
            var t = parseRes.timeObj;
            if(t.hour>23 || t.minute>59 || t.second>59 || t.millisec>999){
                throw 'Invalid date'
            }
            parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec);
        }

        return parseRes.date;
    };

    $.datepicker.parseTime = function(timeFormat, timeString, options) {

        //########################################################################
        // pattern for standard and localized AM/PM markers
        //########################################################################
        var getPatternAmpm = function(amNames, pmNames) {
            var markers = [];
            if (amNames) {
                $.merge(markers, amNames);
            }
            if (pmNames) {
                $.merge(markers, pmNames);
            }
            markers = $.map(markers, function(val) { return val.replace(/[.*+?|()\[\]{}\\]/g, '\\$&'); });
            return '(' + markers.join('|') + ')?';
        };

        //########################################################################
        // figure out position of time elements.. cause js cant do named captures
        //########################################################################
        var getFormatPositions = function( timeFormat ) {
            var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|t{1,2}|z)/g),
                orders = { h: -1, m: -1, s: -1, l: -1, t: -1, z: -1 };

            if (finds) {
                for (var i = 0; i < finds.length; i++) {
                    if (orders[finds[i].toString().charAt(0)] == -1) {
                        orders[finds[i].toString().charAt(0)] = i + 1;
                    }
                }
            }
            return orders;
        };

        var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {});

        var regstr = '^' + timeFormat.toString()
                .replace(/h{1,2}/ig, '(\\d?\\d)')
                .replace(/m{1,2}/ig, '(\\d?\\d)')
                .replace(/s{1,2}/ig, '(\\d?\\d)')
                .replace(/l{1}/ig, '(\\d?\\d?\\d)')
                .replace(/t{1,2}/ig, getPatternAmpm(o.amNames, o.pmNames))
                .replace(/z{1}/ig, '(z|[-+]\\d\\d:?\\d\\d)?')
                .replace(/\s/g, '\\s?') + o.timeSuffix + '$',
            order = getFormatPositions(timeFormat),
            ampm = '',
            treg;

        treg = timeString.match(new RegExp(regstr, 'i'));

        var resTime = {hour: 0, minute: 0, second: 0, millisec: 0};

        if (treg) {
            if (order.t !== -1) {
                if (treg[order.t] === undefined || treg[order.t].length === 0) {
                    ampm = '';
                    resTime.ampm = '';
                } else {
                    ampm = $.inArray(treg[order.t], o.amNames) !== -1 ? 'AM' : 'PM';
                    resTime.ampm = o[ampm == 'AM' ? 'amNames' : 'pmNames'][0];
                }
            }

            if (order.h !== -1) {
                if (ampm == 'AM' && treg[order.h] == '12') {
                    resTime.hour = 0; // 12am = 0 hour
                } else {
                    if (ampm == 'PM' && treg[order.h] != '12') {
                        resTime.hour = parseInt(treg[order.h],10) + 12; // 12pm = 12 hour, any other pm = hour + 12
                    }
                    else { resTime.hour = Number(treg[order.h]); }
                }
            }

            if (order.m !== -1) { resTime.minute = Number(treg[order.m]); }
            if (order.s !== -1) { resTime.second = Number(treg[order.s]); }
            if (order.l !== -1) { resTime.millisec = Number(treg[order.l]); }
            if (order.z !== -1 && treg[order.z] !== undefined) {
                var tz = treg[order.z].toUpperCase();
                switch (tz.length) {
                    case 1:    // Z
                        tz = o.timezoneIso8601 ? 'Z' : '+0000';
                        break;
                    case 5:    // +hhmm
                        if (o.timezoneIso8601) {
                            tz = tz.substring(1) == '0000' ?
                                'Z' :
                                tz.substring(0, 3) + ':' + tz.substring(3);
                        }
                        break;
                    case 6:    // +hh:mm
                        if (!o.timezoneIso8601) {
                            tz = tz == 'Z' || tz.substring(1) == '00:00' ?
                                '+0000' :
                                tz.replace(/:/, '');
                        } else {
                            if (tz.substring(1) == '00:00') {
                                tz = 'Z';
                            }
                        }
                        break;
                }
                resTime.timezone = tz;
            }


            return resTime;
        }

        return false;
    };

    $.datepicker.formatDateTime = function(dateFormat, timeFormat, date, dateSettings, timeSettings){
        if(!date){
            return null;
        }
        var time = {};

        dateSettings = $.extend({}, $.datepicker._defaults, dateSettings);
        timeSettings = $.extend({}, $.timepicker._defaults, timeSettings);

        time.hour = date.getHours();
        time.minute = date.getMinutes();
        time.second = date.getSeconds();
        time.millisec = date.getMilliseconds();

        return $.datepicker.formatDate(dateFormat, date, dateSettings) + " " + $.datepicker.formatTime(timeFormat, time, timeSettings);
    }

    //########################################################################
    // format the time all pretty...
    // format = string format of the time
    // time = a {}, not a Date() for timezones
    // options = essentially the regional[].. amNames, pmNames, ampm
    //########################################################################
    $.datepicker.formatTime = function(format, time, options) {
        options = options || {};
        options = $.extend({}, $.timepicker._defaults, options);
        time = $.extend({hour:0, minute:0, second:0, millisec:0, timezone:'+0000'}, time);

        var tmptime = format;
        var ampmName = options.amNames[0];

        var hour = parseInt(time.hour, 10);
        if (options.ampm) {
            if (hour > 11){
                ampmName = options.pmNames[0];
                if(hour > 12) {
                    hour = hour % 12;
                }
            }
            if (hour === 0) {
                hour = 12;
            }
        }
        tmptime = tmptime.replace(/(?:hh?|mm?|ss?|[tT]{1,2}|[lz])/g, function(match) {
            switch (match.toLowerCase()) {
                case 'hh': return ('0' + hour).slice(-2);
                case 'h':  return hour;
                case 'mm': return ('0' + time.minute).slice(-2);
                case 'm':  return time.minute;
                case 'ss': return ('0' + time.second).slice(-2);
                case 's':  return time.second;
                case 'l':  return ('00' + time.millisec).slice(-3);
                case 'z':  return time.timezone;
                case 't': case 'tt':
                    if (options.ampm) {
                        if (match.length == 1) {
                            ampmName = ampmName.charAt(0);
                        }
                        return match.charAt(0) == 'T' ? ampmName.toUpperCase() : ampmName.toLowerCase();
                    }
                    return '';
            }
        });

        tmptime = $.trim(tmptime);
        return tmptime;
    };

    $.datepicker._base_formatOutput = $.datepicker._formatOutput;
    $.datepicker._formatOutput = function(inst, date){
        if(!inst || !date){
            return '';
        }
        var tp_inst = this._get(inst, 'timepicker');

        if(tp_inst){
            var dateFormat = this._get(inst, 'dateFormat'),
                timeFormat = this._get(inst, 'timeFormat'),
                showSecond = this._get(inst, 'showSecond');

            if(!showSecond){
                timeFormat = timeFormat.substring(0,5);
            }

            return $.datepicker.formatDateTime(dateFormat, timeFormat, date, $.datepicker._getFormatConfig(inst), inst.settings);
        }else{
            return $.datepicker._base_formatOutput.call(this, inst, date);
        }
    };

    $.datepicker._base_setDate = $.datepicker._setDate;
    $.datepicker._setDate = function (inst, date, noChange) {
        var tp_inst = this._get(inst, 'timepicker');

        $.datepicker._base_setDate.call(this, inst, date, noChange);
        if(tp_inst){
            this._setTime(inst, date, true);
        }
    };

    $.datepicker._base_getDate = $.datepicker._getDate;
    $.datepicker._getDate = function (inst, onlyByInst) {
        var tp_inst = this._get(inst, 'timepicker'),
            date = $.datepicker._base_getDate(inst, onlyByInst);

        if(tp_inst && date){
            date.setHours(tp_inst.currentHour, tp_inst.currentMinute, tp_inst.currentSecond, tp_inst.currentMillisec);
        }
        return date;
    };

    $.datepicker._base_getSelectedDate = $.datepicker._getSelectedDate;
    $.datepicker._getSelectedDate = function (inst, year, month, day) {
        var tp_inst = this._get(inst, 'timepicker'),
            date = this._base_getSelectedDate(inst, year, month, day);

        if (tp_inst) {
            if (date) { date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec); }
        }
        return date;
    };

    $.datepicker._base_setDateFromField = $.datepicker._setDateFromField;
    $.datepicker._setDateFromField = function(inst, noDefault) {
        var tp_inst = this._get(inst, "timepicker");

        if(tp_inst){
            var dates = inst.lastVal = inst.input ? inst.input.val() : null,
                dateFormat = this._get(inst, 'dateFormat'),
                timeFormat = this._get(inst, 'timeFormat'),
                showSecond = this._get(inst, 'showSecond');

            if(!showSecond){
                timeFormat = timeFormat.substring(0,5);
            }

            try {
                this._setDate(inst, $.datepicker.parseDateTime(dateFormat, timeFormat, dates, $.datepicker._getFormatConfig(inst), inst.settings), true);
            } catch (event) {
                this.log(event);
            }
        }else{
            $.datepicker._base_setDateFromField(inst, noDefault);
        }
    };

    $.datepicker._base_getDateFromField = $.datepicker._getDateFromField;
    $.datepicker._getDateFromField = function(inst) {
        var tp_inst = this._get(inst, "timepicker");

        if(tp_inst){
            var inputStr = inst.input.val(),
                dateFormat = this._get(inst, "dateFormat"),
                timeFormat = this._get(inst, "timeFormat"),
                showSecond = this._get(inst, 'showSecond');

            if(!showSecond){
                timeFormat = timeFormat.substring(0,5);
            }

            return $.datepicker.parseDateTime(dateFormat, timeFormat, inputStr, $.datepicker._getFormatConfig(inst), inst.settings);
        }else{
            return $.datepicker._base_getDateFromField.call(this, inst);
        }
    };

    $.datepicker._base_isEqual = $.datepicker._isEqual;
    $.datepicker._isEqual = function (inst, prev, cur) {
        var tp_inst = this._get(inst, "timepicker");

        if(tp_inst){
            var orgYear = prev != null ? prev.getFullYear() : null,
                orgMonth = prev != null ? prev.getMonth() : null,
                orgDate = prev != null ? prev.getDate() : null,
                orgHour = prev != null ? prev.getHours() : null,
                orgMinute = prev != null ? prev.getMinutes() : null,
                orgSecond = prev != null ? prev.getSeconds() : null,
                orgMillisec = prev != null ? prev.getMilliseconds() : null,
                currentYear = cur != null ? cur.getFullYear() : null,
                currentMonth = cur != null ? cur.getMonth() : null,
                currentDate = cur != null ? cur.getDate() : null,
                currentHour = cur != null ? cur.getHours() : null,
                currentMinute = cur != null ? cur.getMinutes() : null,
                currentSecond = cur != null ? cur.getSeconds() : null,
                currentMillisec = cur != null ? cur.getMilliseconds() : null;

            return (orgYear == currentYear) && (orgMonth == currentMonth) && (orgDate == currentDate)
                    && (orgHour == currentHour) && (orgMinute == currentMinute) && (orgSecond == currentSecond)
                    && (orgMillisec == currentMillisec);
        }
        return $.datepicker._base_isEqual.call(this, inst, prev, cur);
    };

    //########################################################################
    // the bad hack :/ override datepicker so it doesnt close on select
    // inspired: http://stackoverflow.com/questions/1252512/jquery-datepicker-prevent-closing-picker-when-clicking-a-date/1762378#1762378
    //########################################################################

    $.datepicker._base_selectDay = $.datepicker._selectDay;
    $.datepicker._selectDay = function(id, month, year, td, fromEnter) {
        fromEnter = !!fromEnter;
        var inst = this._getInst($(id)[0]),
            tp_inst = this._get(inst, 'timepicker');

        if (tp_inst && !fromEnter) {
            tp_inst._limitMinMaxDateTime(inst, true);
            inst.inline = inst.stay_open = true;
            //This way the onSelect handler called from calendarpicker get the full dateTime
            this._base_selectDay(id, month, year, td, fromEnter);
            inst.inline = inst.stay_open = false;
            //this._notifyChange(inst);
            this._updateDatepicker(inst);
        }
        else { this._base_selectDay(id, month, year, td, fromEnter); }
    };

    $.datepicker._base_flushDate = $.datepicker._flushDate;
    $.datepicker._flushDate = function(inst, date, fromEnter) {
        fromEnter = !!fromEnter;
        var tp_inst = this._get(inst, 'timepicker');
        if(!tp_inst || fromEnter){
            this._base_flushDate(inst, date, fromEnter);
        }
    };

    //#############################################################################################
    // second bad hack :/ override datepicker so it triggers an event when changing the input field
    // and does not redraw the datepicker on every selectDate event
    //#############################################################################################
    $.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker;
    $.datepicker._updateDatepicker = function(inst) {
        // don't popup the datepicker if there is another instance already opened
        var input = inst.input[0];
        if($.datepicker._curInst &&
           $.datepicker._curInst != inst &&
           $.datepicker._datepickerShowing &&
           $.datepicker._lastInput != input) {
            return;
        }

        if (typeof(inst.stay_open) !== 'boolean' || inst.stay_open === false) {

            this._base_updateDatepicker(inst);

            // Reload the time control when changing something in the input text field.
            var tp_inst = this._get(inst, 'timepicker');
            if(tp_inst) {
                tp_inst._addTimePicker(inst);

                if (tp_inst._defaults.useLocalTimezone) { //checks daylight saving with the new date.
                    var date = new Date(inst.selectedYear, inst.selectedMonth, inst.selectedDay, 12);
                    selectLocalTimeZone(tp_inst, date);
                    tp_inst._onTimeChange();
                }
            }
        }
    };

    //#######################################################################################
    // third bad hack :/ override datepicker so it allows spaces and colon in the input field
    //#######################################################################################
    $.datepicker._base_doKeyPress = $.datepicker._doKeyPress;
    $.datepicker._doKeyPress = function(event) {
        var inst = $.datepicker._getInst(event.target),
            tp_inst = $.datepicker._get(inst, 'timepicker');

        if (tp_inst) {
            if ($.datepicker._get(inst, 'constrainInput')) {
                var ampm = tp_inst._defaults.ampm,
                    dateChars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat')),
                    datetimeChars = tp_inst._defaults.timeFormat.toString()
                                    .replace(/[hms]/g, '')
                                    .replace(/TT/g, ampm ? 'APM' : '')
                                    .replace(/Tt/g, ampm ? 'AaPpMm' : '')
                                    .replace(/tT/g, ampm ? 'AaPpMm' : '')
                                    .replace(/T/g, ampm ? 'AP' : '')
                                    .replace(/tt/g, ampm ? 'apm' : '')
                                    .replace(/t/g, ampm ? 'ap' : '') +
                                    " " +
                                    tp_inst._defaults.separator +
                                    tp_inst._defaults.timeSuffix +
                                    (tp_inst._defaults.showTimezone ? tp_inst._defaults.timezoneList.join('') : '') +
                                    (tp_inst._defaults.amNames.join('')) +
                                    (tp_inst._defaults.pmNames.join('')) +
                                    dateChars,
                    chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
                return event.ctrlKey || (chr < ' ' || !dateChars || datetimeChars.indexOf(chr) > -1);
            }
        }

        return $.datepicker._base_doKeyPress(event);
    };

    //#######################################################################################
    // Override key up event to sync manual input changes.
    //#######################################################################################
    $.datepicker._base_doKeyUp = $.datepicker._doKeyUp;
    $.datepicker._doKeyUp = function (event) {
        /*
        console.log('time KeyUp', event, event.keyCode);
        if(event.keyCode == 9)return;
        */
        var inst = $.datepicker._getInst(event.target),
            text = inst.input ? inst.input.val() : null,
            tp_inst = $.datepicker._get(inst, 'timepicker');

        if (tp_inst) {
            if (tp_inst._defaults.timeOnly && (inst.input.val() != inst.lastVal)) {
                try {
                    $.datepicker._updateDatepicker(inst);
                }
                catch (err) {
                    $.datepicker.log(err);
                }
            }else{
                return $.datepicker._base_doKeyUp(event);
            }
            return true;
        }

        return $.datepicker._base_doKeyUp(event);
    };

    //#######################################################################################
    // override "Today" button to also grab the time.
    //#######################################################################################
    $.datepicker._base_gotoToday = $.datepicker._gotoToday;
    $.datepicker._gotoToday = function(id) {
        var inst = this._getInst($(id)[0]),
            tp_inst = this._get(inst, 'timepicker'),
            $dp = inst.dpDiv;

        if(tp_inst){
            var origMonth = inst.selectedMonth,
                origYear = inst.selectedYear;

            this._setDateDatepicker($(id)[0], new Date());

            if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear))
                this._notifyChange(inst);
        }else{
            this._base_gotoToday(id);
        }
    };

    //#######################################################################################
    // Disable & enable the Time in the datetimepicker
    //#######################################################################################
    $.datepicker._disableTimepickerDatepicker = function(target) {
        var inst = this._getInst(target);
        if (!inst) { return; }

        var tp_inst = this._get(inst, 'timepicker');
        $(target).datepicker('getDate'); // Init selected[Year|Month|Day]
        if (tp_inst) {
            tp_inst._defaults.showTimepicker = false;
            tp_inst._updateDateTime(inst);
        }
    };

    $.datepicker._enableTimepickerDatepicker = function(target) {
        var inst = this._getInst(target);
        if (!inst) { return; }

        var tp_inst = this._get(inst, 'timepicker');
        $(target).datepicker('getDate'); // Init selected[Year|Month|Day]
        if (tp_inst) {
            tp_inst._defaults.showTimepicker = true;
            tp_inst._addTimePicker(inst); // Could be disabled on page load
            tp_inst._updateDateTime(inst);
        }
    };

    //#######################################################################################
    // Create our own set time function
    //#######################################################################################
    $.datepicker._setTime = function(inst, date, onlySetTime) {
        var tp_inst = this._get(inst, 'timepicker'),
            onlySetTime = !!onlySetTime;
        if (tp_inst) {
            var defaults = tp_inst._defaults,
                // calling _setTime with no date sets time to defaults
                hour = date ? date.getHours() : defaults.hour,
                minute = date ? date.getMinutes() : defaults.minute,
                second = date ? date.getSeconds() : defaults.second,
                millisec = date ? date.getMilliseconds() : defaults.millisec;
            //check if within min/max times..
            // correct check if within min/max times.
            // Rewritten by Scott A. Woodward
            var hourEq = hour === defaults.hourMin,
                minuteEq = minute === defaults.minuteMin,
                secondEq = second === defaults.secondMin;
            var reset = false;
            if(hour < defaults.hourMin || hour > defaults.hourMax)
                reset = true;
            else if( (minute < defaults.minuteMin || minute > defaults.minuteMax) && hourEq)
                reset = true;
            else if( (second < defaults.secondMin || second > defaults.secondMax ) && hourEq && minuteEq)
                reset = true;
            else if( (millisec < defaults.millisecMin || millisec > defaults.millisecMax) && hourEq && minuteEq && secondEq)
                reset = true;
            if(reset) {
                hour = defaults.hourMin;
                minute = defaults.minuteMin;
                second = defaults.secondMin;
                millisec = defaults.millisecMin;
            }
            tp_inst.hour = hour;
            tp_inst.minute = minute;
            tp_inst.second = second;
            tp_inst.millisec = millisec;

            tp_inst.currentHour = hour;
            tp_inst.currentMinute = minute;
            tp_inst.currentSecond = second;
            tp_inst.currentMillisec = millisec;


            if (tp_inst.hour_slider) tp_inst.hour_slider.slider('value', hour);
            if (tp_inst.minute_slider) tp_inst.minute_slider.slider('value', minute);
            if (tp_inst.second_slider) tp_inst.second_slider.slider('value', second);
            if (tp_inst.millisec_slider) tp_inst.millisec_slider.slider('value', millisec);

            tp_inst._onTimeChange();

            if(!onlySetTime){
                tp_inst._updateDateTime(inst);
            }
        }
    };

    //#######################################################################################
    // Create new public method to set only time, callable as $().datepicker('setTime', date)
    //#######################################################################################
    $.datepicker._setTimeDatepicker = function(target, date, withDate) {
        var inst = this._getInst(target);
        if (!inst) { return; }

        var tp_inst = this._get(inst, 'timepicker');

        if (tp_inst) {
            this._setDateFromField(inst);
            var tp_date;
            if (date) {
                if (typeof date == "string") {
                    tp_inst._parseTime(date, withDate);
                    tp_date = new Date();
                    tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
                }
                else { tp_date = new Date(date.getTime()); }
                if (tp_date.toString() == 'Invalid Date') { tp_date = undefined; }
                this._setTime(inst, tp_date);
            }
        }

    };

    //#######################################################################################
    // override setDate() to allow setting time too within Date object
    //#######################################################################################
    $.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker;
    $.datepicker._setDateDatepicker = function(target, date, nochange) {
        var inst = this._getInst(target),
            tp_inst = this._get(inst, "timepicker"),
            tp_date;
        if (!inst) { return; }

        try{
            if(date instanceof Date){
                tp_date = new Date(date.getTime());
            }else{
                tp_date = $.datepicker.parseDateTime("yy-mm-dd", "hh:mm:ss", date, $.datepicker._getFormatConfig(inst), tp_inst._defaults);
            }
        }catch(e){
            tp_date = date;
        }

        this._base_setDateDatepicker.call(this, target, tp_date, nochange);
    };

    //#######################################################################################
    // override getDate() to allow getting time too within Date object
    //#######################################################################################
    $.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker;
    $.datepicker._getDateDatepicker = function(target, noDefault) {
        var inst = this._getInst(target);
        if (!inst) { return; }

        var tp_inst = this._get(inst, 'timepicker');

        if (tp_inst) {
            this._setDateFromField(inst, noDefault);
            var date = this._getDate(inst);
            //if (date && tp_inst._parseTime($(target).val(), tp_inst.timeOnly)) { date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec); }
            return date;
        }
        return this._base_getDateDatepicker(target, noDefault);
    };

    //#######################################################################################
    // override parseDate() because UI 1.8.14 throws an error about "Extra characters"
    // An option in datapicker to ignore extra format characters would be nicer.
    //#######################################################################################
    $.datepicker._base_parseDate = $.datepicker.parseDate;
    $.datepicker.parseDate = function(format, value, settings) {
        var splitRes = splitDateTime(format, value, settings);
        return $.datepicker._base_parseDate(format, splitRes[0], settings);
    };

    //#######################################################################################
    // override formatDate to set date with time to the input
    //#######################################################################################
    $.datepicker._base_formatDate = $.datepicker._formatDate;
    $.datepicker._formatDate = function(inst, day, month, year){
        var tp_inst = this._get(inst, 'timepicker');
        if(tp_inst) {
            tp_inst._updateDateTime(inst);
            return tp_inst.$input.val();
        }
        return this._base_formatDate(inst);
    };

    //#######################################################################################
    // override options setter to add time to maxDate(Time) and minDate(Time). MaxDate
    //#######################################################################################
    $.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker;
    $.datepicker._optionDatepicker = function(target, name, value) {
        var inst = this._getInst(target);
        if (!inst) { return null; }

        var tp_inst = this._get(inst, 'timepicker');
        if (tp_inst) {
            var min = null, max = null, onselect = null;
            if (typeof name == 'string') { // if min/max was set with the string
                if (name === 'minDate' || name === 'minDateTime' ) {
                    min = value;
                }
                else {
                    if (name === 'maxDate' || name === 'maxDateTime') {
                        max = value;
                    }
                    else {
                        if (name === 'onSelect') {
                            onselect = value;
                        }
                    }
                }
            } else {
                if (typeof name == 'object') { //if min/max was set with the JSON
                    if (name.minDate) {
                        min = name.minDate;
                    } else {
                        if (name.minDateTime) {
                            min = name.minDateTime;
                        } else {
                            if (name.maxDate) {
                                max = name.maxDate;
                            } else {
                                if (name.maxDateTime) {
                                    max = name.maxDateTime;
                                }
                            }
                        }
                    }
                }
            }
            if(min) { //if min was set
                if (min === 0) {
                    min = new Date();
                } else {
                    min = new Date(min);
                }

                tp_inst._defaults.minDate = min;
                tp_inst._defaults.minDateTime = min;
            } else if (max) { //if max was set
                if(max===0) {
                    max=new Date();
                } else {
                    max= new Date(max);
                }
                tp_inst._defaults.maxDate = max;
                tp_inst._defaults.maxDateTime = max;
            } else if (onselect) {
                tp_inst._defaults.onSelect = onselect;
            }
        }
        if (value === undefined) {
            return this._base_optionDatepicker(target, name);
        }
        return this._base_optionDatepicker(target, name, value);
    };

    //#######################################################################################
    // jQuery extend now ignores nulls!
    //#######################################################################################
    function extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
            if (props[name] === null || props[name] === undefined) {
                target[name] = props[name];
            }
        }
        return target;
    }

    //#######################################################################################
    // Splits datetime string into date ans time substrings.
    // Throws exception when date can't be parsed
    // If only date is present, time substring eill be ''
    //#######################################################################################
    var splitDateTime = function(dateFormat, dateTimeString, dateSettings)
    {
        try {
            var date = $.datepicker._base_parseDate(dateFormat, dateTimeString, dateSettings);
        } catch (err) {
            if (err.indexOf(":") >= 0) {
                // Hack!  The error message ends with a colon, a space, and
                // the "extra" characters.  We rely on that instead of
                // attempting to perfectly reproduce the parsing algorithm.
                var dateStringLength = dateTimeString.length-(err.length-err.indexOf(':')-2);
                var timeString = dateTimeString.substring(dateStringLength);

                return [dateTimeString.substring(0, dateStringLength), dateTimeString.substring(dateStringLength)];

            } else {
                throw err;
            }
        }
        return [dateTimeString, ''];
    };

    //#######################################################################################
    // Internal function to parse datetime interval
    // Returns: {date: Date, timeObj: Object}, where
    //   date - parsed date without time (type Date)
    //   timeObj = {hour: , minute: , second: , millisec: } - parsed time. Optional
    //#######################################################################################
    var parseDateTimeInternal = function(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings)
    {
        var date;
        var splitRes = splitDateTime(dateFormat, dateTimeString, dateSettings);
        date = $.datepicker._base_parseDate(dateFormat, splitRes[0], dateSettings);
        if (splitRes[1] !== '')
        {
            var timeString = splitRes[1];
            var separator = timeSettings && timeSettings.separator ? timeSettings.separator : $.timepicker._defaults.separator;
            if ( timeString.indexOf(separator) !== 0) {
                throw 'Missing time separator';
            }
            timeString = timeString.substring(separator.length);
            var parsedTime = $.datepicker.parseTime(timeFormat, timeString, timeSettings);
            if (parsedTime === null) {
                throw 'Wrong time format';
            }
            return {date: date, timeObj: parsedTime};
        } else {
            return {date: date};
        }
    };

    //#######################################################################################
    // Internal function to set timezone_select to the local timezone
    //#######################################################################################
    var selectLocalTimeZone = function(tp_inst, date)
    {
        if (tp_inst && tp_inst.timezone_select) {
            tp_inst._defaults.useLocalTimezone = true;
            var now = typeof date !== 'undefined' ? date : new Date();
            var tzoffset = timeZoneString(now);
            if (tp_inst._defaults.timezoneIso8601) {
                tzoffset = tzoffset.substring(0, 3) + ':' + tzoffset.substring(3);
            }
            tp_inst.timezone_select.val(tzoffset);
        }
    };

    // Input: Date Object
    // Output: String with timezone offset, e.g. '+0100'
    var timeZoneString = function(date)
    {
        var off = date.getTimezoneOffset() * -10100 / 60;
        var timezone = (off >= 0 ? '+' : '-') + Math.abs(off).toString().substr(1);
        return timezone;
    };

    $.timepicker = new Timepicker(); // singleton instance
    $.timepicker.version = "1.0.1";

    })(jQuery);
//});
//mod.defineModule("progressBar",["base","waf","boxUtil"],function(){
    /*
     name:ProgressBar
     author:Zhang Yanfang
     department:BOS Web Platform Department
     date:2012-7-27 10:49:35

     important instruction:
     1.the order of options has a big influence on the method "_setOption"
     */


    (function ($, undefined) {
        $.wafProgressBar = $.wafProgressBar || {};
        $.widget("ui.wafProgressBar", {
            options:{
                min:0,
                max:100,
                value:0,
                round:0,
                showText:true,
                textFormat:"percent",
                width:345,
                height:8,
                foregroundClass:'',
                backgroundClass:'',
                style:'',
                position:"bottom"
            },
            _create:function () {
                var o = this.options,
                    value = o.value,
                    el = this.element;

                el.attr("ctrlrole", "progressBar")
                        .addClass("ui-progressbar-container");
                this.outDiv = el.find(".ui-progressbar");
                if (this.outDiv.length == 0) {
                    this.outDiv = $("<div class='ui-progressbar ui-widget ui-widget-content ui-corner-all'></div>")
                            .appendTo(el);
                }
                this.valueDiv = this.outDiv.find(".ui-progressbar-value");
                if (this.valueDiv.length == 0) {
                    this.valueDiv = $("<div class='ui-progressbar-value ui-widget-header ui-corner-all'></div>")
                            .appendTo(this.outDiv);
                }
                this.span = el.find(".ui-progressbar-text");
                if (this.span.length == 0) {
                    this.span = $("<span class='ui-progressbar-text'></span>").appendTo(el);
                }
                el.attr('data-domcreated', "true");

                this._setOptions(this.options);
                var self = this;
                $.ieHack.hackResize(function (e) {
                    self._setPosition();
                }, el);
            },
            _handleValue:function (value) {
                if ($.isNaN(value)) {
                    value = 0;
                }
                return Math.min(this.options.max, Math.max(this.options.min, value));
            },
            _refreshValue:function () {
                var newValue, oldValue, self = this, o = this.options;

                newValue = this._handleValue(o.value);
                this.options.value = newValue;
                oldValue = this._handleValue(this.oldValue);

                var percentage = this._percentage(newValue),
                    fixedPercentage = percentage.toFixed(o.round) + "%";

                this.valueDiv
                    .toggle(newValue > o.min)
                    .toggleClass("ui-corner-right", newValue === o.max)
                    .width(fixedPercentage);
                self._setText(newValue);
                self._setPosition();

                if (newValue !== oldValue) {
                    self._trigger("onchange", "onchange", {"previous":oldValue, "current":newValue});
                }
                if (newValue === o.max) {
                    self._trigger("oncomplete");
                }
            },
            _setPosition:function () {
                var pp = this.options.position, showText = this.options.showText, json,
                    spanWidth = $.boxLayoutUtil.getElementWidth(this.span),
                    divWidth = $.boxLayoutUtil.getElementWidth(this.outDiv),
                    spanHeight = $.boxLayoutUtil.getElementHeight(this.span),
                    divHeight = $.boxLayoutUtil.getElementHeight(this.outDiv),
                    el = this.element;
                if (!showText) {
                    spanWidth = 0;
                    spanHeight = 0;
                }
                switch (pp) {
                    case "center":
                        json = {
                            my:"center",
                            at:"center"
                        };
                        el.width(Math.max(spanWidth, divWidth));
                        el.height(Math.max(spanHeight, divHeight));
                        this.outDiv.position($.extend({of:el}, json));
                        this.span.position($.extend({of:el}, json));
                        break;
                    case "top":

                        el.width(Math.max(spanWidth, divWidth));
                        el.height(spanHeight + divHeight);
                        this.span.position({
                            my:"center top", at:"center top", of:el
                        });
                        this.outDiv.position({
                            my:"center bottom", at:"center bottom", of:el
                        });
                        break;
                    case "left":
                        el.width(spanWidth + divWidth);
                        el.height(Math.max(spanHeight, divHeight));
                        this.span.position({
                            my:"left center", at:"left center", of:el
                        });
                        this.outDiv.position({
                            my:"right center", at:"right center", of:el
                        });
                        break;
                    case "right":
                        el.width(spanWidth + divWidth);
                        el.height(Math.max(spanHeight, divHeight));
                        this.span.position({
                            my:"right center", at:"right center", of:el
                        });
                        this.outDiv.position({
                            my:"left center", at:"left center", of:el
                        });
                        break;
                    default:
                        el.width(Math.max(spanWidth, divWidth));
                        el.height(spanHeight + divHeight);
                        this.span.position({
                            my:"center bottom", at:"center bottom", of:el
                        });
                        this.outDiv.position({
                            my:"center top", at:"center top", of:el
                        });
                        break;
                }

            },
            _setText:function (value) {
                var o = this.options, textSpan = this.span;
                var percentage = this._percentage(value),
                    fixedPercentage = percentage.toFixed(o.round) + "%";
                if (o.textFormat == "fraction") {
                    textSpan.text(value + "/" + o.max);
                } else if (o.textFormat == "percent") {
                    textSpan.text(fixedPercentage);
                } else {
                    textSpan.text(o.textFormat);
                }
            },
            _setOptions:function (options) {
                var self = this;
                this.oldValue = this.options.value;
                $.each(options, function (key, value) {
                    self._setOption(key, value);
                });
    //            this._refreshValue($.extend(this.options, options));
                this._refreshValue();
                return this;
            },
            _setOption:function (key, value) {
                switch (key) {
                    case 'max':
                        if ($.isNaN(value) || value <= 0) {
                            value = 100;
                        }
                        break;
                    case"showText":
                        this.span.toggle(value);
                        break;
                    case'height':
                        this.outDiv.height(value);
                        break;
                    case'width':
                        this.outDiv.width(value);
                        break;
                    case'foregroundClass':
                        this.valueDiv.removeClass(this.options.foregroundClass).addClass(value);
                        break;
                    case'backgroundClass':
                        this.outDiv.removeClass(this.options.backgroundClass).addClass(value);
                        break;
                    case'style':
                        this.element.attr("style", value);
                        break;
                }
                $.Widget.prototype._setOption.apply(this, arguments);
            },
            _percentage:function (value) {
                return 100 * value / this.options.max;
            },
            setValue:function (obj) {
                if (obj) {
                    if (typeof obj === "number") {
                        obj = {value:obj};
                    }
                    this._setOptions(obj);
                    return this;
                }
            },
            getValue:function () {
                return this.options.value;
            }
        });

        /*
         operate ProgressBar Tag dynamically
         autor : Zhang Yanfang
         date:2012-12-10
         */
        $.extend($.wafProgressBar, {
            createProgressBarDOM:function (opts) {
                var progressBar = opts && opts.id && $("#" + opts.id);
                if (!(progressBar && progressBar.data("domcreated")))  {
                    progressBar = $("<div id='" + opts.id + "'></div>");
                }
                return progressBar;
            },
            initProgressBar:function (opts, el) {
                if (el && opts) {
                    el.wafProgressBar(opts);
                    return el;
                }
            },
            modifyProgressBar:function (opts) {
                var progressBar = $("#" + opts.id);
                progressBar.wafProgressBar("option", opts);
                return  progressBar;
            },
            deleteProgressBar:function (opts) {
                var progressBar = $("#" + opts.id);
                progressBar.remove();
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("progressBar", {
                    createDOMFun:$.wafProgressBar.createProgressBarDOM,
                    initFun:$.wafProgressBar.initProgressBar,
                    deleteFun:$.wafProgressBar.deleteProgressBar,
                    modifyFun:$.wafProgressBar.modifyProgressBar,lazyInit:true});
        });
    })(jQuery);
//});
//mod.defineModule("block",["base","waf"],function(){
    ;
    (function ($, undefined) {
        $.widget("ui.block", {
            options:{
                addClass:'',
                beforeShow:'',
                afterShow:'',
                hPos:'center',
                vPos:'center',
                indicatorZIndex:5001,
                overlayZIndex:5000,
                parent:'',
                marginTop:0,
                marginLeft:0,
                overlayWidth:null,
                overlayHeight:null,
                textTopOffest:0,
                text:null
            },
            _create:function () {
                var self = this;
                self._showBlock(self.options);
            },

            widget:function () {
                return this.element;
            },
            hide:function () {
                var self = this;
                if (self.options.indicatorID) {
                    indicatorID = self.options.indicatorID;
                } else {
                    indicatorID = jQuery(this.element).attr('id');
                    if (indicatorID == undefined) indicatorID = '';
                }

                jQuery(document.body).find('#loading-indicator-' + indicatorID).remove();
                jQuery(document.body).find('#loading-indicator-' + indicatorID + '-overlay').remove();

                $.Widget.prototype.destroy.call(this);
            },
            getIndicatDiv:function () {
                var self = this;
                //self.element.hideLoading();

                if (self.options.indicatorID) {
                    indicatorID = self.options.indicatorID;
                }else {
                    indicatorID = jQuery(this.element).attr('id');
                    if (indicatorID == undefined) indicatorID = '';
                }
                return jQuery(document.body).find('#loading-indicator-' + indicatorID);
            },
            _setOption:function (key, value) {
                if (key === "text") {
                    if (this.element[0].id || this.element[0].nodeName == "BODY" || this.element.hasClass("page_margins")) {
                        var textSpan = jQuery("<span class='loading-text'>" + value + "</span>");
                        jQuery(document.body).append(textSpan);

                        var textSpanWidth = textSpan.width();

                        var loadingDiv = $('#loading-indicator-' + this.element[0].id);
                        var textSpan2 = $("#span_" + this.element[0].id);
                        if (textSpan2 && textSpan2.length > 0) {
                            textSpan.remove();
                            textSpan = textSpan2;
                        } else {
                            jQuery(loadingDiv).append(textSpan);
                        }
                        //var oldTextSpanWidth = textSpan.width();
                        textSpan.text(value);
                        //var textSpanWidth=textSpan.width();


                        var oldLoadingDivWidth = jQuery(loadingDiv).width();

                        var loadingDivWidth = this.element.block("option", "loadingDivWidth");
                        if (loadingDivWidth <= 0) loadingDivWidth = 80;
                        jQuery(loadingDiv).width(loadingDivWidth);

                        jQuery(textSpan).css('margin-left', 0);

                        var offset = 0;
                        if (textSpanWidth > loadingDivWidth)
                            offset = parseInt(textSpanWidth - oldLoadingDivWidth) / 2;
                        else
                            offset = parseInt(loadingDivWidth - oldLoadingDivWidth) / 2;
                        var pxIndex = jQuery(loadingDiv).css('left').indexOf('px');
                        var leftNum = -1;
                        if (pxIndex > 0 && offset != 0) {
                            leftNum = jQuery(loadingDiv).css('left').substring(0, pxIndex);
                            if (leftNum != -1)
                                jQuery(loadingDiv).css('left', (leftNum - offset) + 'px');
                        }

                        if (textSpanWidth > loadingDivWidth) {
                            jQuery(loadingDiv).width(textSpanWidth);
                        } else {
                            var textLeftOffset = parseInt(loadingDivWidth - textSpanWidth) / 2;
                            jQuery(textSpan).css('margin-left', textLeftOffset);
                        }
                    }
                }
                $.Widget.prototype._setOption.apply(this, arguments);
            },
            _showBlock:function (options) {
                //create loadingDIV and overlayDIV
                var indicatorID;
                var loadingDiv = jQuery('<div></div>');
                var overlayDiv = jQuery('<div></div>');

                jQuery(overlayDiv).css('position', 'absolute');
                jQuery(overlayDiv).css('left', '0px');

                // Set up ID and classes
                if (options.indicatorID) {
                    indicatorID = options.indicatorID;
                }else {
                    indicatorID = jQuery(this.element).attr('id');
                    if (indicatorID == undefined) indicatorID = '';
                }
                jQuery(loadingDiv).attr('id', 'loading-indicator-' + indicatorID);
                jQuery(loadingDiv).addClass('ui_loading-indicator');
                if (options.addClass) {
                    jQuery(loadingDiv).addClass(options.addClass);
                }

                // Create the overlay
                jQuery(overlayDiv).css('display', 'none');
                // Append to body, otherwise position() doesn't work on Webkit-based browsers
                if (this.element[0].nodeName == "BODY" || this.element.hasClass("page_margins")) {
                    jQuery(document.body).append(overlayDiv);
                } else {
                    var pageDiv = jQuery("div.page");
                    if (pageDiv && pageDiv.length == 1) {
                        jQuery(pageDiv).append(overlayDiv);
                    } else {
                        jQuery(document.body).append(overlayDiv);
                    }
                }

                jQuery(overlayDiv).show();
                jQuery(loadingDiv).show();

                // Set overlay classes
                jQuery(overlayDiv).attr('id', 'loading-indicator-' + indicatorID + '-overlay');
                jQuery(overlayDiv).addClass('loading-indicator-overlay');

                if (options.addClass) {
                    jQuery(overlayDiv).addClass(options.addClass + '-overlay');
                }

                // Set overlay position
                var overlay_width;
                var overlay_height;

                var border_top_width = jQuery(this.element).css('border-top-width');
                var border_left_width = jQuery(this.element).css('border-left-width');
                // IE will return values like 'medium' as the default border, but we need a number
                border_top_width = isNaN(parseInt(border_top_width)) ? 0 : border_top_width;
                border_left_width = isNaN(parseInt(border_left_width)) ? 0 : border_left_width;

                var overlay_left_pos = jQuery(this.element).offset().left + parseInt(border_left_width);
                var overlay_top_pos = jQuery(this.element).offset().top + parseInt(border_top_width);
                if(this.element[0].nodeName!="BODY" && this.element.hasClass("page_margins") && jQuery('div.page_margins').length==1){
                    overlay_left_pos += jQuery('div.page_margins').scrollLeft();
                    overlay_top_pos += jQuery('div.page_margins').scrollTop();
                }

                if (options.overlayWidth !== null) {
                    overlay_width = options.overlayWidth;
                }else {
                    overlay_width = parseInt(jQuery(this.element).width()) + parseInt(jQuery(this.element).css('padding-right')) + parseInt(jQuery(this.element).css('padding-left'));
                }

                if (options.overlayHeight !== null) {
                    overlay_height = options.overlayHeight;
                }else {
                    overlay_height = parseInt(jQuery(this.element).height()) + parseInt(jQuery(this.element).css('padding-top')) + parseInt(jQuery(this.element).css('padding-bottom'));
                }

                jQuery(overlayDiv).css('width', overlay_width.toString() + 'px');
                jQuery(overlayDiv).css('height', overlay_height.toString() + 'px');
                if (this.element[0].nodeName == "BODY" || this.element.hasClass("page_margins"))
                    jQuery(overlayDiv).css('left', overlay_left_pos.toString() + 'px');
                else
                    jQuery(overlayDiv).css('left', overlay_left_pos.toString() + 'px');

                jQuery(overlayDiv).css('position', 'absolute');
                if (this.element[0].nodeName == "BODY" || this.element.hasClass("page_margins"))
                    jQuery(overlayDiv).css('top', overlay_top_pos.toString() + 'px');
                else
                    jQuery(overlayDiv).css('top', overlay_top_pos.toString() + 'px');

                var  overlayZIndex = options.overlayZIndex;
                if($(this.element).zIndex()>overlayZIndex){
                    overlayZIndex = $(this.element).zIndex() + 10;
                }
                jQuery(overlayDiv).css('z-index', overlayZIndex);


                // Set any custom overlay CSS
                if (options.overlayCSS) {
                    jQuery(overlayDiv).css(options.overlayCSS);
                }


                // We have to append the element to the body first or .width() won't work in Webkit-based browsers (e.g. Chrome, Safari)
                //jQuery(loadingDiv).css('display', 'none');
                if (pageDiv && pageDiv.length == 1) {
                    jQuery(pageDiv).append(loadingDiv);
                } else {
                    jQuery(document.body).append(loadingDiv);
                }

                jQuery(loadingDiv).css('position', 'absolute');
                jQuery(loadingDiv).css('z-index', overlayZIndex+5);

                // Set top margin
                var indicatorTop = overlay_top_pos;

                if (options.marginTop) {
                    indicatorTop += parseInt(options.marginTop);
                }

                var indicatorLeft = overlay_left_pos;

                if (options.marginLeft) {
                    indicatorLeft += parseInt(options.marginTop);
                }

                var topOffset = 0;
                var loadingDivWidth = jQuery(loadingDiv).width();
                this.element.block("option", "loadingDivWidth", loadingDivWidth);
                if (options.text) {
                    var textSpan = jQuery("<span class='loading-text'>" + options.text + "</span>");
                    jQuery(document.body).append(textSpan);
                    var textSpanWidth = textSpan.width();
                    topOffset = parseInt(jQuery(textSpan).height());

                    if (textSpanWidth > loadingDivWidth) {
                        jQuery(loadingDiv).width(textSpanWidth);
                    } else {
                        var textLeftOffset = parseInt(loadingDivWidth - textSpanWidth) / 2;
                        jQuery(textSpan).css('margin-left', textLeftOffset);
                    }
                    jQuery(textSpan).attr('id', 'span_' + indicatorID);
                    jQuery(loadingDiv).append(textSpan);


                    if (options.textTopOffest != 0) {
                        var marginTopIndex = textSpan.css("margin-top").indexOf('px');
                        if (marginTopIndex > 0) {
                            var newMarginTop = options.textTopOffest + parseInt(textSpan.css("margin-top").substring(0, marginTopIndex));
                            textSpan.css("margin-top", newMarginTop + 'px');
                        }
                    }

                }

                // set horizontal position
                if (options.hPos.toString().toLowerCase() == 'center') {
                    jQuery(loadingDiv).css('left', (indicatorLeft + ((jQuery(overlayDiv).width() - parseInt(jQuery(loadingDiv).width())) / 2)).toString() + 'px');
                }
                else if (options.hPos.toString().toLowerCase() == 'left') {
                    jQuery(loadingDiv).css('left', (indicatorLeft + parseInt(jQuery(overlayDiv).css('margin-left'))).toString() + 'px');
                }
                else if (options.hPos.toString().toLowerCase() == 'right') {
                    jQuery(loadingDiv).css('left', (indicatorLeft + (jQuery(overlayDiv).width() - parseInt(jQuery(loadingDiv).width()))).toString() + 'px');
                }
                else {
                    jQuery(loadingDiv).css('left', (indicatorLeft + parseInt(options.hPos)).toString() + 'px');
                }

                // set vertical position
                if (options.vPos.toString().toLowerCase() == 'center') {
                    if (this.element[0].nodeName == "BODY" || this.element.hasClass("page_margins"))
                        jQuery(loadingDiv).css('top', (indicatorTop + ((jQuery(overlayDiv).height() - parseInt(jQuery(loadingDiv).height())) / 2) - topOffset).toString() + 'px');
                    else
                        jQuery(loadingDiv).css('top', (indicatorTop + ((jQuery(overlayDiv).height() - parseInt(jQuery(loadingDiv).height())) / 2) - topOffset).toString() + 'px');
                }
                else if (options.vPos.toString().toLowerCase() == 'top') {
                    jQuery(loadingDiv).css('top', (indicatorTop - topOffset).toString() + 'px');
                }
                else if (options.vPos.toString().toLowerCase() == 'bottom') {
                    jQuery(loadingDiv).css('top', (indicatorTop + (jQuery(overlayDiv).height() - parseInt(jQuery(loadingDiv).height())) - topOffset).toString() + 'px');
                }
                else {
                    jQuery(loadingDiv).css('top', (indicatorTop + parseInt(options.vPos) - topOffset).toString() + 'px');
                }

                // Set any custom css for loading indicator
                if (options.css) {
                    jQuery(loadingDiv).css(options.css);
                }


                // Set up callback options
                var callback_options =
                {
                    'overlay':overlayDiv,
                    'indicator':loadingDiv,
                    'element':this.element
                };

                // beforeShow callback
                if (typeof(options.beforeShow) == 'function') {
                    options.beforeShow(callback_options);
                }

                // Show the overlay
                jQuery(overlayDiv).show();

                // Show the loading indicator
                jQuery(loadingDiv).show();

                // afterShow callback
                if (typeof(options.afterShow) == 'function') {
                    options.afterShow(callback_options);
                }

                return this.element;
            }
        });

        $.block = $.block || {};
        $.extend($.block, {
            show:function (opts) {
                opts = opts || {};
                if (opts.target && opts.target.length == 1) {
                    opts.target.block(opts);
                } else if (waf('div.page_margins').length == 1) {
                    waf('div.page_margins').block(opts);
                } else {
                    waf('body').block(opts);
                }
            },
            hide:function (target) {
                if (target && target.length == 1) {
                    target.block('hide');
                } else if (waf('div.page_margins').length == 1) {
                    waf('div.page_margins').block('hide');
                } else {
                    waf('body').block('hide');
                }
            },
            text:function (target, text) {
                if (arguments.length == 1) {
                    waf('body').block("option", "text", arguments[0]);
                } else {
                    target.block("option", "text", text);
                }
            },
            getIndicatDiv:function (target) {
                if (target && target.length == 1) {
                    return target.block('getIndicatDiv');
                } else {
                    return waf('body').block('getIndicatDiv');
                }
            }
        });
    }(jQuery));
//});

    //(function ($, undefined) {
    //
    //$.block = $.block || {};
    //    $.extend($.block, {
    //        show:function (opts) {
    //            this.showLoading(opts);
    //        },
    //        hide:function (opts) {
    //            jQuery('#activity_pane').hideLoading();
    //        }
    //    });
    //}(jQuery));
//mod.defineModule("radioGroup", ["base","waf"], function() {

    /*
     * author: Zhang Yanfang
     * date: 2012-8-22
     * introduction: this tag can generate some radios  at runtime the count of which is decided by property 'items'
     */

    (function ($, undefined) {
        $.wafRadioGroup = $.wafRadioGroup || {};
        $.widget("ui.wafRadioGroup", $.ui.wafctrl, {
            options:{
                vertical:false,
                hidden:false,
                disabled:false,
                value:null,
                tabindex:0
            },
            _create:function () {
                var el = this.element, o = this.options, self = this;
                //value""null
                if (String(o.value).length == 0) {
                    o.value = null;
                }
                //
                this.oldValue = null;

                //setItems
                this.initFlag = true;

                //hidden
                var hidden = $("<input name='" + o.name + "' type='hidden'>");
                hidden.attr("id", o.id + "_el");
                this.element.after(hidden);
                //ctrlrole
                el.attr("ctrlrole", "radioGroup");
                el.addClass("ui-radiogroup-div");
                //
                this.setItems(el,o.items);
                el.attr('data-domcreated', "true");
                
                //
                $("input:radio[name='" + o.name + "_el']").live("click", function (event) {
                    var radio = $(this);
                    if (radio[0].checked) {
                        o.value = radio[0].value;
                        self._trigger("onclick", event, o.value);
                        radio.focus();
                    }
                    self._handleChangeEvent(self.oldValue, o.value);
                });

                // formreset, .
                el.closest("form").bind('reset.wafRadioGroup', function () {
                    setTimeout($.proxy(self._reset, self), 10);
                });
                this.defaultValue = o.value;
                //view
                this._operateState();
            },
            _reset:function () {
                var el = this.element, flag = false, self = this,
                        hidden = $("#" + this.options.id + "_el");
                el.children("input:radio").each(function () {
                    if ($(this).attr("value") != String(self.defaultValue)) {
                        $(this).attr("checked", false);
                    } else {
                        $(this).attr("checked", true);
                        hidden.val(self.defaultValue);
                        flag = true;
                    }
                });
                if (!flag) {
                    hidden.val(null);
                }

            },
            _handleChangeEvent:function (prevValue, newValue) {
                var el = this.element, o = this.options, hidden = $("#" + o.id + "_el");
                hidden.val(newValue);
                if (prevValue != newValue
                        && !this._trigger("onchange", "onchange", {"previous":prevValue, "current":newValue})) {
                    var flag = false;
                    el.children("input:radio").each(function () {
                        if ($(this).attr("value") != String(prevValue)) {
                            $(this).attr("checked", false);
                        } else {
                            $(this).attr("checked", true);
                            flag = true;
                            o.value = prevValue;
                        }
                    });
                    if (!flag) {
                        o.value = null;
                    }
                } else {
                    this.oldValue = newValue;
                    o.value = newValue;
                }
                hidden.val(o.value);
                return o.value;
            },
            setItems:function (el,items) {
                  if ($.isArray(items) && items.length > 0) {
                        var el = this.element, o = this.options, id = el.attr("id"), self = this;
                        el.html("");
                        o.index = 0;
                        var temp = "";
                        $.each(items, function (index, value) {
                            var r = self._initRadio(value, index, index, items.length);
                            if (r != undefined && r.length > 0) {
                                temp += $.map(r,
                                        function (item) {
                                            return item[0].outerHTML;
                                        }).join("");
                            }
                        });
                        el.html(temp);
                  this._setOptions(o);
                }
            },
            _initRadio:function (item, index, pos, length) {
                if (item != undefined && $.type.isJson(item)) {
                    if (item.value == undefined && item.alias == undefined) {
                        return;
                    }
                    //index=posradio
                    var result = [];
                    var el = this.element, o = this.options, id = el[0].id;
                    //id
                    var radioId = id + "_" + index;
                    var radio = $("<input type='radio' name='" + o.name + "_el' id='" + radioId + "'>");
                    if (item.value != undefined) {
                        radio.attr("value", item.value);
                    }
                    if ($.fn.enter2tab) {
                        radio.enter2tab();
                    }
                    result.push(radio);

                    var label = $("<label for='" + radioId + "'></label>");
                    if (item.alias != undefined && label.text().length == 0) {
                        label.append(item.alias);
                    }
                    result.push(label);

                    //<br/>
                    if (o.vertical && pos < length - 1) {
                        result.push($("<br/>"));
                    }
                    o.index++;
                    return result;
                }
            },
            _setOption:function (key, value) {
                if (value === undefined) {
                    return;
                }
                var el = this.element,
                        radios = el.find("input:radio");
                switch (key) {
                    case "value":
                        var flag = false;
                        radios.each(function () {
                            var radio = $(this);
                            if (radio.attr("value") == String(value)) {
                                radio.attr("checked", true);
                                flag = true;
                            } else {
                                radio.attr("checked", false);
                            }
                        });
                        if (!flag) {
                            value = null;
                        }
                        if (this.initFlag) {
                            var hidden = $("#" + this.options.id + "_el");
                            hidden.val(value);
                            this.initFlag = false;
                        } else {
                            value = this._handleChangeEvent(this.oldValue, value);
                        }
                        break;
                    case "hidden":
                        el.toggle(!value);
                        break;
                    case "disabled":
                        radios.attr("disabled", value);
                        break;
                    case "style":
                        radios.attr("style", value);
                        break;
                    case"tagClass":
                        radios.removeClass(this.options.tagClass).addClass(value);
                        break;
                    case"tabindex":
                        radios.attr("tabindex", value);
                        break;
                }
                this.options[ key ] = value;
                return this;
            },
            _operateState: function() {
                var isView = $.wafutil.isViewOperateState(this.options);
                var el = this.element,
                        radios = el.find("input:radio"),canOpr = this.options.disabled || isView;
                if (canOpr) {
                    radios.attr("disabled", canOpr);
                } else {
                    radios.removeAttr("disabled");
                }
            },
            getValue:function () {
                return $("#" + this.options.id + "_el").val();
            },
            setValue:function (value) {
                this._setOption('value', value);
            },
            hideItem:function (itemValue, value) {
                if (arguments.length == 0) {
                    return false;
                }
                if (value == undefined) {
                    value = true;
                }
                var el = this.element, o = this.options;
                el.find("input:radio").each(function (index) {
                    var radio = $(this);
                    if (this.value == String(itemValue)) {
                        radio.toggle(!value);
                        var label = $("label[for='" + this.id + "']");
                        label.toggle(!value);
                        if (o.vertical) {
                            var br = label.next("br");
                            if (br.length == 0) {
                                br = radio.prev("br");
                            }
                            br.toggle(!value);
                        }
                    }
                });
            },
            disableItem:function (itemValue, value) {
                if (arguments.length == 0) {
                    return;
                }
                if (value == undefined) {
                    value = true;
                }
                var el = this.element;
                el.find("input:radio").each(function () {
                    if (this.value == String(itemValue)) {
                        this.disabled = value;
                    }
                });
            },
            addItem:function (item, pos) {
                if (arguments.length == 0) {
                    return false;
                }
                if ($.type.isJson(item)) {
                    var el = this.element,
                            o = this.options,
                            id = el[0].id,
                            length = el.find("input:radio").length;
                    var result = this._initRadio(item, o.index, pos, length + 1);
                    if (result != undefined && result.length > 0) {
                        if ($.type.isNumber(pos)) {
                            if (pos <= 0) {
                                result = result.reverse();
                                $.each(result, function (index, aitem) {
                                    el.prepend(aitem);
                                });

                            } else if (pos >= length) {
                                if (o.vertical) {
                                    el.append($("<br/>"));
                                }
                                $.each(result, function (index, aitem) {
                                    el.append(aitem);
                                });
                            } else {
                                var insertEl = el.children("label:eq(" + (pos - 1) + ")");
                                if (insertEl.next().is("br")) {
                                    insertEl = insertEl.next();
                                }
                                $.each(result, function (index, aitem) {
                                    insertEl.after(aitem);
                                    insertEl = aitem;
                                });
                            }
                        } else {
                            if (o.vertical) {
                                el.append($("<br/>"));
                            }
                            $.each(result, function (index, aitem) {
                                el.append(aitem);
                            });
                        }
                    }
                }
            },
            removeItemByPosition:function (pos) {
                if (pos != undefined && $.type.isNumber(pos)) {
                    var el = this.element,
                            radio = el.find("input:eq(" + pos + ")"),
                            label = radio.next("label"),
                            length = el.find("input").length;
                    if (radio.length > 0) {
                        if (pos == length - 1) {
                            var br = radio.prev("br");
                            br.remove();
                        } else {
                            var br = label.next("br");
                            br.remove();
                        }
                        radio.remove();
                        label.remove();
                    }
                }
            },
            removeItemByValue:function (value) {
                if (value != undefined) {
                    var el = this.element;
                    el.find("input:radio").each(function () {
                        var radio = $(this);
                        if (this.value == String(value)) {
                            var label = radio.next("label"),
                                    br = label.next("br");
                            if (br.length > 0) {
                                br.remove();
                            } else {
                                br = radio.prev("br");
                                br.remove();
                            }
                            radio.remove();
                            label.remove();
                        }
                    });
                }
            }
        });

        /*
         *radioGroup
         * authorZhang yanfang
         * date20121123
         */
        $.extend($.wafRadioGroup, {
            createRadioGroupDom:function (opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated")))  {
                    var el = $("<div></div>");
                    if (opts) {
                        el.attr("id", opts.id);
                    }
                    return el;
                } else {
                    return obj;
                }
            },
            initRadioGroup:function (opts, el) {
                if (el && opts && el.length > 0) {
                    if ($.wafutil.isViewOperateState(opts)) {
                        opts.disabled = true;
                    }
                    el.wafRadioGroup(opts);
                    return el;
                }
            },
            modifyRadioGroup:function (opts) {
                if (opts && opts.id) {
                    var el = $("#" + opts.id), value = opts.value;
                    delete opts.value;
                    el.wafRadioGroup("option", opts);
                    el.wafRadioGroup("setValue", value);
                    opts.value = value;
                    return el;
                }
            },
            removeRadioGroup:function (opts) {
                if (opts && opts.id) {
                    var el = $("#" + opts.id),
                            hidden = $("#" + opts.id + "_el");
                    hidden.remove();
                    el.remove();
                }
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("radioGroup", {createDOMFun:$.wafRadioGroup.createRadioGroupDom, initFun:$.wafRadioGroup.initRadioGroup,
                    deleteFun:$.wafRadioGroup.removeRadioGroup, modifyFun:$.wafRadioGroup.modifyRadioGroup,lazyInit:true});
        });
    })(jQuery);
//});
//mod.defineModule("img",["base","waf"],function(){
    /*
     * author: Zhang Yanfang
     * date: 2012-11-5
     * introduction: this tag shows image whose source is controlled by the attribute 'src'
     */

    (function ($, undefined) {
        $.wafImg = $.wafImg || {};
        $.widget("ui.wafImg", {
            options:{
                src:null,
                title:null,
                alt:null,
                style:null,
                tagClass:null,
                height:null,
                width:null,
                hidden:false
            },
            _create:function () {
                var el = this.element,
                    o = this.options,
                    self = this;
                el.attr("ctrlrole", "img");
                el.attr('data-domcreated', "true");

                $.each(o, function (key, value) {
                    self._setOption(key, value);
                });
                el.bind("click", function () {
                    self._trigger("onclick")
                });
            },
            _setOption:function (key, value) {
                if (value === undefined) {
                    return;
                }
                var el = this.element;
                switch (key) {
                    case 'src':
                        this.setSrc(value);
                        break;
                    case 'title':
                        el.attr(key, value);
                        break;
                    case 'alt':
                        el.attr(key, value);
                        break;
                    case'height':
                        el.css(key, value);
                        break;
                    case 'width':
                        el.css(key, value);
                        break;
                    case 'hidden':
                        el.toggle(!value);
                        break;
                    case 'style':
                        el.attr(key, value);
                        break;
                    case 'tagClass':
                        el.removeClass(this.options.tagClass).addClass(value);
                        break;
                }
                this.options[ key ] = value;
                return this;
            },
            setSrc:function (value) {
                var el = this.element, o = this.options, self = this;
                if (o.type == "string" || !(o.type)) {
                    if (value) {
                        if (value.substring(0, 1) != "?") {
                            var path = $.getContextPath();
                            value = path + value;
                        }
                        el.attr("src", value);
                    }
                    else {
                        el.attr("src", "");
                    }
                } else if (o.type == "byte") {
                    var conversationId = waf.getConversationID();
                    el.attr("src", "?method=getImageField&property=" + o.name + "&conversationid=" + conversationId + "&v="+Math.random()*1000);
                }
            }
        });

        $.extend($.wafImg, {
            createImgDOM:function (opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    var img = $("<img>");
                    img.attr("id", opts.id);
                    return img;
                } else {
                    return obj;
                }
            },
            initImg:function (opts, el) {
                if (el && opts) {
                    el.wafImg(opts);
                    return el;
                }
            },
            modifyImg:function (opts) {
                var img = $("#" + opts.id);
                img.wafImg("option", opts);
                return img;
            },
            deleteImg:function (opts) {
                var img = $("#" + opts.id);
                img.remove();
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("img", {
                    createDOMFun:$.wafImg.createImgDOM,
                    initFun:$.wafImg.initImg,
                    deleteFun:$.wafImg.deleteImg,
                    modifyFun:$.wafImg.modifyImg,
                    lazyInit:true});
        });
    })(jQuery);
//});
//mod.defineModule("timePicker",["base","waf","position","timePicker_i18n"],function(){
    /*******************************************************************************
     * WAF2 Timepicker
     *
     * @version 1.0
     * @author peng_zhou1                                                     *
     ******************************************************************************/
    (function($, undefined){

        var frameClass = "ui-timepicker-frame",
            defaultClass = "ui-timepicker",
            layoutClass = "ui-timepicker-layout",
            triggerClass = "ui-timepicker-trigger",
            panelClass = "ui-timepicker-panel ui-widget ui-widget-content ui-corner-all",
            handleFunctions = ["onclick", "onblur", "ondblclick", "onfocus",
                              "onkeyup", "onkeypress", "onkeydown", "onmouseover", "onmouseup",
                              "onmouseout", "onmousemove", "onmousedown"];

        function completion(val){
            return val < 10 ? '0' + val : "" + val;
        }

        function parse(value){
            var hour, minute, second;

            if(value && typeof value === 'object' && value.constructor == Date){
                hour = value.getHours();
                minute = value.getMinutes();
                second = value.getSeconds();
            }else if(value && typeof value === 'string'){
                var times = value.split(":");
                hour = parseInt(times[0], 10);
                minute = parseInt(times[1], 10);
                second = parseInt(times[2], 10);
            }else if(value && $.isPlainObject(value)){
                hour = parseInt(value.hour, 10);
                minute = parseInt(value.minute, 10);
                second = parseInt(value.second, 10);
            }else{
                return null;
            }

            return {'hour':hour, 'minute':minute, 'second':second};
        }

        function format(value, opts){
            if(!value){
                return '';
            }
            opts = $.extend({}, defaultOptions, opts);
            var text,
                showMeridian = opts.showMeridian
                hour = completion(value.hour % (showMeridian ? 12 : 24)),
                minute = completion(value.minute),
                second = completion(value.second),
                meridian = showMeridian ? $.wafTimePicker.meridian[(value.hour < 12 ? 'am' : 'pm')] : '';

            text = hour + ":" + minute;
            if(opts.showSecond){
                text += (":" + second);
            }
            if(opts.showMeridian){
                text += (" " + meridian);
            }

            return text;
        }

        var defaultOptions = {
            coordinate: false,
            editable: true,
            height: null,
            hidden: false,
            id: null,
            minuteStep: 1,
            name: null,
            onchange: null,
            onselect: null,
            position: {
                my : "left top",
                at : "left bottom"
            },
            readonly: false,
            secondStep: 1,
            showMeridian: false,
            showSecond: true,
            style: null,
            submitField: null,
            tabindex: 0,
            tagClass: null,
            width: null,
            format: format
        };

        $.widget("ui.wafTimePicker", $.ui.wafctrl, {
            options: defaultOptions,
            hour: 0,
            minute: 0,
            second: 0,
            meridian: null,
            value: null,
            _create: function() {
                $.ui.wafctrl.prototype._create.apply(this, arguments);
                var self = this,
                    suppressBlur;

                this._enter2tab();

                this.options.submitField = this.options.submitField || ("#" + this.options.id + "_el");

                if(this.element.data('domcreated')) {
                    this.frame = this.element.closest("." + frameClass).eq(0);
                    this.button = this.frame.find("." + triggerClass);
                } else {
                    this.element.addClass(defaultClass)
                        .attr("ctrlrole", "timePicker")
                        .wrap('<div class="' + frameClass + '"></div>')
                        .wrap('<div class="' + layoutClass + '"></div>');
                    this.frame = this.element.closest("." + frameClass).eq(0);
                    this.button = $("<span class='" + triggerClass + "'></span>").appendTo(this.frame);
                    this.element.attr('data-domcreated', "true");
                }

                this.button.bind("click.wafTimePicker", function(e){
                        if(self.options.disabled || self.options.readonly || waf.wafutil.isViewOperateState(self.options)){
                            return;
                        }
                        self.element.focus();
                        if(!self._hasOpen()){
                            self._open();
                        }
                    });

                this.element.bind("keydown.wafTimePicker", function(e){
                        if(self.options.disabled || self.options.readonly){
                            return;
                        }
                        var keyCode = $.ui.keyCode;
                        switch(e.keyCode){
                            case keyCode.DOWN:
                                if(!self._hasOpen()){
                                    self._open();
                                }else{
                                    self._decrease();
                                }
                                e.preventDefault();
                                break;
                            case keyCode.UP:
                                if(self._hasOpen()){
                                    self._increase();
                                    e.preventDefault();
                                }
                                break;
                            case keyCode.LEFT:
                                if(self._hasOpen()){
                                    self._moveLeft();
                                    e.preventDefault();
                                }
                                break;
                            case keyCode.RIGHT:
                                if(self._hasOpen()){
                                    self._moveRight();
                                    e.preventDefault();
                                }
                                break;
                            case keyCode.ESCAPE:
                            case keyCode.TAB:
                                if(self._hasOpen()){
                                    self._close();
                                    e.preventDefault();
                                }
                                break;
                            case keyCode.ENTER:
                            case keyCode.NUMPAD_ENTER:
                                if(self._hasOpen()){
                                    self.setValue(self._getRealTimesFromDisplay());
                                    self._close();
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                                break;
                        }
                    })
                    .bind("keyup.wafTimePicker", function(e){
                        if(self.options.disabled || self.options.readonly){
                            return;
                        }
                        //
                        if(8 == e.keyCode || $.ui.keyCode.DELETE == e.keyCode){
                            if(self.element.val() === ""){
                                self.setValue(null);
                            }
                        }
                    }).bind("blur.wafTimePicker", function(e){
                        if(!self._hasOpen()){
                            self._updateInput();
                        }
                        self.button.removeClass("triggerFocus");
                    }).bind("focus.wafTimePicker",function(e){
                        self.button.addClass("triggerFocus");
                    });

                if(this.options.submitField){
                    $(this.options.submitField).insertAfter(this.element);
                }

                this._initByOptions("disabled", "readonly", "editable", "style", "tagClass", "tabindex", "width", "height", "hidden");
                //setTimeout
                $(this.element[0].form).bind('reset.wafTimePicker', function(){
                    setTimeout($.proxy(self._reset, self), 10);
                });

                $.each(handleFunctions, function(i, v){
                    self.element.handleFunction(v.substr(2) + ".wafTimePickerInner", self.options[v]);
                });

                var value = parse(this.options.value);
                this._setValue(value);
                this._setDefaultValue(value);
                this._updateInput();

                this._operateState();
            },

            _moveLeft: function(){
                this._initActive();
                var idx = $.inArray(this.active[0], this.items),
                    length = this.items.length,
                    nextIdx = idx - 1;

                this._activate(this.items.eq(nextIdx));
            },

            _moveRight: function(){
                this._initActive();
                var idx = $.inArray(this.active[0], this.items),
                    length = this.items.length,
                    nextIdx = (idx + 1) % length;

                this._activate(this.items.eq(nextIdx));
            },

            _increase: function(){
                var field = this._getActiveFieldName(),
                    command = field == "Meridian" ? "toggle" + field : "increment" + field;

                this[command]();
            },

            _decrease: function(){
                var field = this._getActiveFieldName(),
                    command = field == "Meridian" ? "toggle" + field : "decrement" + field;

                this[command]();
            },

            _getActiveFieldName: function(){
                var active = this.active;

                if(active.is(".ui-timepicker-hour")){
                    return "Hour";
                }else if(active.is(".ui-timepicker-minute")){
                    return "Minute";
                }else if(active.is(".ui-timepicker-second")){
                    return "Second";
                }else{
                    return "Meridian";
                }
            },

            destroy: function(){
                this.button.remove();
                this.element.removeClass(defaultClass)
                    .unwrap()
                    .unwrap()
                    .removeAttr("ctrlrole");
                $.Widget.prototype.destroy.call( this );
            },

            widget: function(){
                return this.frame;
            },

            _enter2tab: function(){
                if($.fn.enter2tab){
                    this.element.enter2tab();
                }
            },

            _reset: function(){
                this._setValue(this.defaultValue);
                this._updateInput();
            },

            _setOption: function( key, value ){
                if(key === "disabled" || key === "tabindex"){
                    this.element.attr(key, value);
                }else if(key === "width" || key === "height"){
                    this.frame.css(key, value ? value : '');
                }else if(key === "tagClass"){
                    this.frame.removeClass(this.options.tagClass).addClass(value);
                }else if(key === "style"){
                    this.frame.attr(key, value);
                }else if(key === "hidden"){
                    this.frame[value ? "hide" : "show"]();
                }

                $.Widget.prototype._setOption.apply( this, arguments );

                if(key === "readonly" || key === "editable"){
                    this._setReadonly();
                }else if(key === "disabled"){
                    this.frame[ value ? "addClass" : "removeClass"]("ui-state-disabled").attr( "aria-disabled", value );
                }else if(key === "value"){
                    this.setValue(value);
                }else if(key === "showSecond" || key === "showMeridian"){
                    this._update();
                    this._updateInput();
                }
            },

            _setReadonly: function(){
                if(this.options.readonly || !this.options.editable){
                    this.element.attr("readonly", true);
                }else{
                    this.element.attr("readonly", false);
                }
            },

            _setDefaultValue: function(value){
                this.defaultValue = value;
            },

            setValue: function(value){
                value = parse(value);

                var previous = this.getValue();

                if(!this._isEqual(previous, value)){
                    this._setValue(value);

                    if(this._change(previous, value)){
                        this.element.trigger('change');
                    }else{
                        this._setValue(previous);
                    }
                }
                this._update();
                this._updateInput();
            },

            getValue: function(){
                return this.value || null;
            },

            disable: function(){
                this._setOption("disabled", true);
            },

            enable: function(){
                this._setOption("disabled", false);
            },

            _open: function(){
                var self = this;
                if(!this.panel){
                    this.panel = $('<div class="' + panelClass + '"></div>')
                                    .appendTo("body");

                    $(document).bind("mousedown.wafTimePicker", function(e){
                        var $target = $(e.target);
                        if($target.closest(self.panel).length == 0 && $target.closest(self.frame).length == 0){
                            self.setValue(self._getRealTimesFromDisplay());
                            self._close();
                        }
                    });
                }

                this._setDisplayTime(this.value);
                this.panel.empty().append(this._getTemplate());
                this._update();
                this._refresh();
                this._initActive();

                this.panel.delegate(".ui-timepicker-button", "click.wafTimePicker", function(e){
                    self[$(this).data('action')]();
                    self.element.focus();
                })
                .delegate(".ui-timepicker-button", "mouseenter.wafTimePicker", function(e){
                    $(this).addClass("ui-state-hover");
                })
                .delegate(".ui-timepicker-button", "mouseleave.wafTimePicker", function(e){
                    $(this).removeClass("ui-state-hover");
                })
                .bind("click.wafTimePicker", function(e){
                    e.stopPropagation();
                });

                var pWidth = this.panel.outerWidth(),
                    fWidth = this.frame.outerWidth();

                if(pWidth < fWidth){
                    this.panel.width(fWidth - pWidth + this.panel.width());
                }

                this._trigger('onshow', 'onshow', this.panel);
                this.panel.zIndex(this.element.zIndex() + 100)
                          .show()
                          .position($.extend({of: this.frame}, this.options.position));
            },

            _refresh: function(){
                var self = this,
                    items = this.panel.find(".ui-timepicker-time")
                            .attr("tabindex", -1);
                this.items = items;
            },

            _initActive: function(){
                if(!this.active){
                    this._activate(this.items.eq(0));
                }
            },

            _activate: function(item){
                this._deactivate();
                item.addClass('ui-timepicker-hover');
                this.active = item;
            },

            _deactivate: function(){
                this.items.each(function(idx, ele){
                    $(ele).removeClass('ui-timepicker-hover');
                });
            },

            _close: function(){
                if(this.panel){
                    $(document).unbind("mousedown.wafTimePicker");
                    this.panel.remove();
                    this.panel = null;
                    this.items = null;
                    this.active = null;
                }
            },

            _getTemplate: function(){
                var showSecond = this.options.showSecond,
                    showMeridian = this.options.showMeridian,
                    hourTemplate = '<span class="ui-timepicker-hour ui-corner-all ui-timepicker-time"></span>',
                    minuteTemplate = '<span class="ui-timepicker-minute ui-corner-all ui-timepicker-time"></span>',
                    secondTemplate = '<span class="ui-timepicker-second ui-corner-all ui-timepicker-time"></span>',
                    meridianTemplate = '<span class="ui-timepicker-meridian ui-corner-all ui-timepicker-time"></span>',
                    templateContent = '<table>'+
                                           '<tr>'+
                                               '<td><a href="javascript:void(null)" data-action="incrementHour" class="ui-corner-all ui-timepicker-button"><i class="ui-icon ui-icon-carat-1-n"></i></a></td>'+
                                               '<td class="separator"></td>'+
                                               '<td><a href="javascript:void(null)" data-action="incrementMinute" class="ui-corner-all ui-timepicker-button"><i class="ui-icon ui-icon-carat-1-n"></i></a></td>'+
                                               (showSecond ?
                                                   '<td class="separator"></td>'+
                                                   '<td><a href="javascript:void(null)" data-action="incrementSecond" class="ui-corner-all ui-timepicker-button"><i class="ui-icon ui-icon-carat-1-n"></i></a></td>'
                                               : '') +
                                               (showMeridian ?
                                                   '<td class="separator"></td>'+
                                                   '<td class="meridian-column"><a href="javascript:void(null)" data-action="toggleMeridian" class="ui-corner-all ui-timepicker-button"><i class="ui-icon ui-icon-carat-1-n"></i></a></td>'
                                               : '') +
                                           '</tr>'+
                                           '<tr>'+
                                               '<td>'+ hourTemplate +'</td> '+
                                               '<td class="separator">:</td>'+
                                               '<td>'+ minuteTemplate +'</td> '+
                                               (showSecond ?
                                                    '<td class="separator">:</td>'+
                                                    '<td>'+ secondTemplate +'</td>'
                                               : '') +
                                               (showMeridian ?
                                                    '<td class="separator">&nbsp;</td>'+
                                                    '<td>'+ meridianTemplate +'</td>'
                                               : '') +
                                           '</tr>'+
                                           '<tr>'+
                                               '<td><a href="javascript:void(null)" data-action="decrementHour" class="ui-corner-all ui-timepicker-button"><i class="ui-icon ui-icon-carat-1-s"></i></a></td>'+
                                               '<td class="separator"></td>'+
                                               '<td><a href="javascript:void(null)" data-action="decrementMinute" class="ui-corner-all ui-timepicker-button"><i class="ui-icon ui-icon-carat-1-s"></i></a></td>'+
                                               (showSecond ?
                                                    '<td class="separator">&nbsp;</td>'+
                                                    '<td><a href="javascript:void(null)" data-action="decrementSecond" class="ui-corner-all ui-timepicker-button"><i class="ui-icon ui-icon-carat-1-s"></i></a></td>'
                                               : '') +
                                               (showMeridian ?
                                                    '<td class="separator">&nbsp;</td>'+
                                                    '<td><a href="javascript:void(null)" data-action="toggleMeridian" class="ui-corner-all ui-timepicker-button"><i class="ui-icon ui-icon-carat-1-s"></i></a></td>'
                                               : '') +
                                           '</tr>'+
                                       '</table>';

                return templateContent;
            },

            _change: function(previous, current){
                return this._trigger("onchange", "onchange", {
                    "previous" : previous,
                    "current" : current
                });
            },

            _onselect: function(){
                this._trigger('onselect', 'onselect', this._getRealTimesFromDisplay());
            },

            _setValue: function(value){
                this.value = value;
                this._setDisplayTime(value);
            },

            _isEqual: function(val1, val2){
                return $.type.isEquals(val1, val2);
            },
            incrementHour: function() {
                var coordinateable = false;
                this.hour += 1;
                if(this.hour === (this.options.showMeridian ? 12 : 24)){
                    this.hour = 0;
                    coordinateable = true;
                }
                if (coordinateable && this.options.coordinate && this.options.showMeridian){
                    this.toggleMeridian();
                }else{
                    this._onselect();
                    this._update();
                }
            },

            decrementHour: function() {
                var coordinateable = false;
                this.hour -= 1;
                if(this.hour < 0){
                    this.hour = (this.options.showMeridian ? 11 : 23);
                    coordinateable = true;
                }

                if (coordinateable && this.options.coordinate && this.options.showMeridian){
                    this.toggleMeridian();
                }else{
                    this._onselect();
                    this._update();
                }
            },

            incrementMinute: function() {
                var coordinateable = false;
                this.minute += this.options.minuteStep;
                if(this.minute > 59){
                    this.minute %= 60;
                    coordinateable = true;
                }
                if (coordinateable && this.options.coordinate){
                    this.incrementHour();
                }else{
                    this._onselect();
                    this._update();
                }
            },

            decrementMinute: function() {
                var coordinateable = false;
                this.minute -= this.options.minuteStep;
                if(this.minute < 0){
                    this.minute += 60;
                    coordinateable = true;
                }
                if (coordinateable && this.options.coordinate){
                    this.decrementHour();
                }else{
                    this._onselect();
                    this._update();
                }
            },

            incrementSecond: function() {
                var coordinateable = false;
                this.second += this.options.secondStep;
                if(this.second > 59){
                    this.second %= 60;
                    coordinateable = true;
                }
                if (coordinateable && this.options.coordinate){
                    this.incrementMinute();
                }else{
                    this._onselect();
                    this._update();
                }
            },

            decrementSecond: function() {
                var coordinateable = false;
                this.second -= this.options.secondStep;
                if(this.second < 0){
                    this.second += 60;
                    coordinateable = true;
                }
                if (coordinateable && this.options.coordinate){
                    this.decrementMinute();
                }else{
                    this._onselect();
                    this._update();
                }
            },

            toggleMeridian: function() {
                if(this.options.showMeridian){
                    this.meridian = this.meridian === 'am' ? 'pm' : 'am';
                    this._onselect();
                    this._update();
                }
            },

            _update: function(){
                if(this.panel){
                    this.panel.find('span.ui-timepicker-hour').text(this._getDisplayString('hour'));
                    this.panel.find('span.ui-timepicker-minute').text(this._getDisplayString('minute'));
                    if(this.options.showSecond){
                        this.panel.find('span.ui-timepicker-second').text(this._getDisplayString('second'));
                    }
                    if(this.options.showMeridian){
                        this.panel.find('span.ui-timepicker-meridian').text(this._getDisplayString('meridian'));
                    }
                }
            },

            _getDisplayString: function(type, obj){
                obj = obj || this;
                var val = obj[type];
                if(type == 'meridian'){
                    return $.wafTimePicker.meridian[val];
                }
                return completion(val);
            },

            _updateInput: function(){
                var inputVal = this._format();
                this.element.val(inputVal);
                this._setDisplayValue(inputVal);
                this._updateSubmitField();
            },

            _updateSubmitField: function(){
                if(this.options.submitField){
                    $(this.options.submitField).val(this._formatSubmit());
                }
            },

            _format: function(value, opts){
                return this.options.format.call(this, this.value, this.options);
            },

            _formatSubmit: function(){
                if(!this.value){
                    return '';
                }
                var hour = completion(this.value.hour),
                    minute = completion(this.value.minute),
                    second = completion(this.value.second);

                return hour + ':' + minute + ':' + second;
            },

            _setDisplayTime: function(val){
                var showMeridian = this.options.showMeridian;

                if(val){
                    this.hour = val.hour % (showMeridian ? 12 : 24);
                    this.minute = val.minute;
                    this.second = val.second;
                    this.meridian = showMeridian ? (val.hour < 12 ? 'am' : 'pm') : null;
                }else{
                    this.hour = 0;
                    this.minute = 0;
                    this.second = 0;
                    this.meridian = showMeridian ? 'am' : null;
                }
            },

            _getRealTimesFromDisplay: function(){
                var hour = this.hour;
                if(this.options.showMeridian && this.meridian == "pm"){
                    hour += 12;
                }
                return {'hour':hour, 'minute':this.minute, 'second':this.second};
            },

            _hasOpen: function(){
                return this.panel != null;
            },

            _viewDisable: function(isDisable) {
                $.ui.wafctrl.prototype._viewDisable.apply( this, arguments );
                this.element.attr('disabled', isDisable);
            }
        });

        $.wafTimePicker = $.wafTimePicker || {};
        $.extend($.wafTimePicker, {
        format: function(value, opts) {
            return format(parse(value), opts);
        },
        createTimePickerDOM: function(opts) {
             var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    return [$('<input id="' + opts.id + '" name="' + opts.name + '_el" type="text">'),
                    $('<input id="' + opts.id + '_el" name="' + opts.name + '" type="hidden">'),
                    $('<label class="viewStatus" id="' + opts.id + '_view"></label>')];
                } else {
                    return obj;
                }
        },
        initTimePicker: function(opts, el) {
            el=$.isArray(el)?el[0]:el;
            el.wafTimePicker(opts);
        },
        removeTimePicker: function(opts) {
            var el = $("#" + opts.id),
                subel = $("#" + opts.id + "_el"),
                view = $("#" + opts.id + "_view");

            if(el.length) {
                el.wafTimePicker("destroy");
                el.remove();
            }
            if(subel.length) {
                subel.remove();
            }
            if(view.length) {
                view.remove();
            }

        },
        modifyTimePicker: function(opts) {
            var option = $.extend(true, {}, opts);
            _value = option.value, el = $("#" + option.id);
            delete option.value;
            el.wafTimePicker("option", option);
            if(_value != null) {
                el.wafTimePicker("setValue", _value);
            }
        }
    });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("timePicker",{createDOMFun: $.wafTimePicker.createTimePickerDOM,
                                                    initFun: $.wafTimePicker.initTimePicker,
                                                    deleteFun: $.wafTimePicker.removeTimePicker,
                                                    modifyFun: $.wafTimePicker.modifyTimePicker,lazyInit:true});
        });
    }(jQuery));
//});
//mod.defineModule("label",["base","waf"],function(){
    (function ($, undefined) {
        $.wafLabel = $.wafLabel||{};
        $.widget("ui.wafLabel", {
            options:{
                tagClass:null,
                style:null,
                caption:null,
                height:null,
                width:null,
                hidden:false
            },
            _create:function () {
                var label = this.element,
                    o = this.options,
                    self = this;
                $(this.element).attr("ctrlrole","label");
                $.each(this.options, function (key, value) {
                    self._setOption(key, value);
                });
            } ,
            _setOption:function(key,value){
                var lbl = $(this.element);
                switch(key){
                    case "caption":
                        lbl.html(value);
                        break;
                    case "tagClass":
                        lbl.removeClass(this.options.tagClass).addClass(value);
                        break;
                    case "style":
                        lbl.attr("style",value);
                        break;
                    case "height":
                        lbl.height(value);
                        break;
                    case "width":
                        lbl.width(value);
                        break;
                    case "hidden":
                        lbl.toggle(!value);
                        break;
                }
                $.Widget.prototype._setOption.apply( this, arguments );
            }
        });

        /*
         * wafLabel
         * author:Zhang yanfang
         * 2012-11-13
         */
        $.extend($.wafLabel, {
            createLabelDOM:function (opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!obj || obj.length == 0) {
                    var elem = $("<label id='"+opts.id+"'></label>");
                    return elem;
                } else {
                    return obj;
                }
            },
            initLabel:function (opts, el) {
                if(el && el instanceof jQuery){
                    $(el).wafLabel(opts);
                }
            },
            removeLabel:function (opts) {
                $("#"+opts.id).remove();
            },
            modifyLabel:function (opts) {
                $("#"+opts.id).wafLabel("option",opts);
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("label", {createDOMFun:$.wafLabel.createLabelDOM, initFun:$.wafLabel.initLabel,
                    deleteFun:$.wafLabel.removeLabel, modifyFun:$.wafLabel.modifyLabel,lazyInit:true});
        });
    }((jQuery)));
//});
//mod.defineModule("hidden",["base","waf"],function(){
    (function ($, undefined) {
        $.wafHidden = $.wafHidden||{};
        $.widget("ui.wafHidden", {
            options:{
                name:null,
                value:null
            },
            _create:function () {
                var hidden = this.element,
                    o = this.options,
                    self = this;
                $(this.element).attr("ctrlrole","hidden");
                //name
                if(o.name) $(this.element).attr("name",o.name);
                $.each(this.options, function (key, value) {
                    self._setOption(key, value);
                });
            } ,
            _setOption:function(key,value){
                switch(key){
                    case "value":
                        if(value){
                            $(this.element).attr("value",value);
                        }else{
                            $(this.element).attr("value","");
                        }
                        break;
                }
                $.Widget.prototype._setOption.apply( this, arguments );
            },
            getValue:function(){
                return $(this.element).val();
            },
            setValue:function(val){
                $(this.element).val(val);
            }
        });

        /*
         * wafHidden
         * author:Zhang yanfang
         * 2012-11-13
         */
        $.extend($.wafHidden, {
            createHiddenDOM:function (opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!obj ||obj.length==0) {
                    var elem = $("<input type='hidden' id='"+opts.id+"' name='"+opts.name+"' value='"+opts.value+"' />");
                    return elem;
                } else {
                    return obj;
                }
            },
            initHidden:function (opts, el) {
                //
                if(el){
                    $("#"+opts.id).wafHidden(opts);
                }
            },
            removeHidden:function (opts) {
                $("#"+opts.id).remove();
            },
            modifyHidden:function (opts) {
                $("#"+opts.id).wafHidden("option",opts);
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("hidden", {createDOMFun:$.wafHidden.createHiddenDOM, initFun:$.wafHidden.initHidden,
                    deleteFun:$.wafHidden.removeHidden, modifyFun:$.wafHidden.modifyHidden,lazyInit:true});
        });
    }((jQuery)));
//});
//mod.defineModule("panel",["base","waf"],function(){
    (function ($, undefined) {
            $.wafPanel = $.wafPanel||{};
            $.widget("ui.wafPanel", {
                options:{
                    tagClass:null,
                    style:null,
                    hidden:null
                },
                _create:function () {
                    var self = this;
                    if(!this.element.data("domcreated")){
                        $(this.element).attr("ctrlrole","panel").attr("data-domcreated","true");
                    }

                    $.each(this.options, function (key, value) {
                        self._setOption(key, value);
                    });
                } ,
                _setOption:function(key,value){
                    var panel = $(this.element);
                    switch(key){
                        case "tagClass":
                            if(value){
                                panel.removeClass(this.options.tagClass).addClass(value);
                            }
                            break;
                        case "style":
                            if(value){
                                panel.attr("style",value);
                            }
                            break;
                        case "hidden":
                            if(value){
                                panel.toggle(!value);
                            }
                            break;
                    }
                    $.Widget.prototype._setOption.apply( this, arguments );
                },
                appendChildren: function(source, pos){
                    $.dynamicutil.appendChildren(this.element, source, pos);
                },

                removeChildren: function(source){
                    $.dynamicutil.removeChildren(this.element, source);
                }
            });

            /*
             * wafPanel
             * 2012-11-13
             */
            $.extend($.wafPanel, {
                createPanelDOM:function (opts) {
                    var obj = opts && opts.id && $("#" + opts.id);
                    if (!(obj && obj.data("domcreated"))) {
                        var str;
                        if(opts.layout && "column" == opts.layout){
                            str = "<div ctrlrole='panel' class='ui-panel ui-columnLayout border-sizing'></div>";
                        }else{
                            str = "<div ctrlrole='panel' class='ui-panel'></div>";
                        }
                        var elem = $(str);
                        elem.attr("id",opts.id);
                        return elem;
                    }else{
                        return obj;
                    }

                },
                initPanel:function (opts, el) {
                    if(el && el instanceof jQuery){
                        $(el).wafPanel(opts);
                    }
                },
                removePanel:function (opts) {
                    $("#"+opts.id).remove();
                },
                modifyPanel:function (opts) {
                    $("#"+opts.id).wafPanel("option",opts);
                }
            });
            $(function () {
                if ($.registerComponent)
                    $.registerComponent("panel", {createDOMFun:$.wafPanel.createPanelDOM, initFun:$.wafPanel.initPanel,
                        deleteFun:$.wafPanel.removePanel, modifyFun:$.wafPanel.modifyPanel,lazyInit:true});
            });
        }((jQuery)));
//});

//mod.defineModule("iframe",["base","waf","block"],function(){
(function ($, undefined) {
        var requiredSpanWidth = 0;
        $.widget("ui.wafIframe", {
            options:{
                id:null,
                name:null,
                src:null,
                method:'GET',
                data:null,
                frameborder:"0",
                height:'100%',
                width:'100%',
                scrolling:'auto',
                style:null,
                tagClass:null,
                heightSelfAdaption:true,
                onLoad:null,
                autoLoadBlock:true,
                of:"div.page_margins"
            },
            _create:function () {
                var self = this;
                this.options.create = true;
                //iframenameid
                if(!this.options.name) this.options.name = this.options.id;
                $(this.element).attr("ctrlrole", "iframe").addClass("ui-iframe");
                $.each(this.options, function (key, value) {
                    self._setOption(key, value);
                });
                if(this.options.style){
                    if(this.options.height)
                        self._setOption("height", this.options.height);
                    if(this.options.width)
                        self._setOption("width", this.options.width);
                }
                this.options.create = false;
                this.element.attr('data-domcreated', "true");
            },
            destory:function () {
                this.element.removeClass("ui-iframe").removeAttr("ctrlrole");
                $.Widget.prototype.destroy.call(this);
            },

            widget:function () {
                return this.element;
            },
            _getOfElem:function () {
                //
                var elem = $(this.element[0].contentWindow.document.body).children(this.options.of);
                if (elem.length > 0) {
                    elem = elem[0];
                } else {
                    elem = this.element[0].contentWindow.document.body;
                }
                return elem;
            },
            autoAdjustHeight:function () {
                if (this.options.heightSelfAdaption) {
                    var elem = this._getOfElem();
                    var scrollHeight = elem.scrollHeight;
                    //var clientHeight = elem.clientHeight;
                    this.element.height(scrollHeight);
                    this._setScroll();
                }
            },
            _setOption:function (key, value) {
                var iframe = this.element, o = this.options;

                switch (key) {
                    case "width":
                    case "height":
                        if(value){

                            this.element.css(key, value);
                            var loaded = $(this.element).data("loaded");
                            if(loaded==true){
                                this._setScroll(value);
                            }
                        }
                        break;
                    case "tagClass":
                        this.element.removeClass(this.options.tagClass).addClass(value);
                        break;
                    case "scrolling":
                        var elem = $(this.element[0].contentWindow.document.body);
                        if(value=='yes') elem.css('overflowY','scroll');
                        else if(value=='no') elem.css('overflowY','hidden');
                        else if(value=='auto') elem.css('overflowY','auto');
                    case "method":
                    case "style":
                    case "frameborder":
                    case "name":
                        if(value)this.element.attr(key, value);
                        break;
                    case "heightSelfAdaption":
                        if(!o.create){
                            if (value) {
                                this.autoAdjustHeight();
                            } else {
                                this.element.css("height", "");
                            }
                        }
                        break;
                    case "src":
                        this.buildSrc(value);
                        break;
                    case "onLoad":
                    case "of":
                        this.options[key] = value;
                        break;
                }
                $.Widget.prototype._setOption.apply(this, arguments);
            },
            _setScroll:function(value){
                var elem = $(this.element[0].contentWindow.document.body);
                if(elem[0].scrollHeight!=undefined){
                    if(value){
                        if(elem[0].scrollHeight>value)
                            elem.css('overflowY','scroll');
                        else
                            elem.css('overflowY','hidden');
                    }else{
                        elem.css('overflowY','hidden');
                    }
                }
            },
            buildSrc:function (src) {
                $(this.element).data("loaded",false);
                if (src.indexOf("?") >= 0)
                    src = src + '&cur_iframeId=' + this.options.id+"&cur_iframeName="+this.options.name;
                else
                    src = src + '?cur_iframeId=' + this.options.id+"&cur_iframeName="+this.options.name;

                if (this.options.autoLoadBlock) {
                    waf.block.show({
                        target:$("#" + this.options.id),
                        text:'...'
                    });
                }

                if (this.options.method.toLowerCase() == "post") {
                    if (typeof this.options.data == 'string')
                        this.options.data = eval('(' + this.options.data + ')');
                    var helpHtml = "<form id='iframe_postForm" + this.options.id + "' method='post' target='" + $("#" + this.options.id).attr("name") + "' action='" + src + "'>" +
                        "<input id='data_input' type='hidden' name='params' value='" + $.toJSON(this.options.data) + "'></form>"
                    //$(helpHtml).appendTo(this.element.parent());
                        $(helpHtml).appendTo(document.body);

                    this._afterLoad(this.options);
                    $("#iframe_postForm" + this.options.id).submit();
                    $("#iframe_postForm" + this.options.id).remove();
                }else{
                    this.element.attr("src", src);
                    this._afterLoad(this.options);
                }
            },
            _afterLoad:function () {
                var self = this,options = self.options;
                $('#' + options.id).unbind("load");
                var canBind = options.heightSelfAdaption ||
                    options.autoLoadBlock ||
                    (options.onLoad != undefined && $.isFunction(options.onLoad));
                if(canBind){
                    $('#' + options.id).bind("load", (function () {
                        $('#' + options.id).data("loaded",true);
                        self.autoAdjustHeight();
                        if(options.heightSelfAdaption==false && options.scrolling){
                            //$('#' + options.id).wafIframe('options','scrolling',options.scrolling);
                            var elem = $($('#' + options.id)[0].contentWindow.document.body);
                            if(options.scrolling=='yes') elem.css('overflowY','scroll');
                            else if(options.scrolling=='no') elem.css('overflowY','hidden');
                            else if(options.scrolling=='auto') elem.css('overflowY','auto');
                        }

                        if(options.autoLoadBlock) {
                            waf.block.hide($('#' + options.id));
                        }
                        if (options.onLoad != undefined && $.isFunction(options.onLoad)) {
                            options.onLoad(self.options);
                        }
                    }));
                }
            }
        });
        $.wafIframe = $.wafIframe || {};
        $.extend($.wafIframe, {
            createIframeDOM:function (data) {
                var obj = data && data.id && $("#" + data.id);
                if (!(obj && obj.data("domcreated"))) {
                    return $("<iframe id='" + data.id + "' name='" + data.name + "'></iframe>");
                } else {
                    return obj;
                }
            },
            initIframe:function (options, el) {
                return el.wafIframe(options);
            },
            removeIframe:function (opts) {
            },
            modifyIframe:function (opts) {
                var iframe = waf('#' + opts.id);
                iframe.wafIframe('option', opts);
            },
            getUrlRequestParam:function (paras) {
                var obj = waf.getUrlParams(paras);
                if(obj) return obj[paras];
                return "";
            },
            adapteHeight:function (iframeId) {
                var elem = null;
                if (!iframeId) {
                    iframeId = $.wafIframe.getUrlRequestParam('cur_iframeId');
                }
                elem = $("#"+iframeId,$(parent.document.body));
                if (elem && elem.length > 0) {
                    //jquerydocumentiframedata
                    parent.$.data(parent.document.getElementById(iframeId)).wafIframe.autoAdjustHeight();
                }
            },
            getCurIframe:function () {
                var iframeId = $.wafIframe.getUrlRequestParam('cur_iframeId');
                return parent.document.getElementById(iframeId);
            },
            getCurIframeName:function(){
                return $.wafIframe.getUrlRequestParam('cur_iframeName');
            },
            setOption:function(opts,iframeId){
                var ownerIframe;
                if(!iframeId)
                    ownerIframe = $.wafIframe.getCurIframe();
                parent.waf(ownerIframe).wafIframe('option',opts);
            },
            getIframeTarget:function(iframeLevel){
                var target;
                if(iframeLevel==1){
                    if(parent && window!=parent && parent.$.wafutil){
                        //chromeiframeparent
                        target = parent.window.document;
                    }else{
                        target = window.document;
                    }
                }else if(iframeLevel==2){
                    //
                    if(parent && parent!=parent.parent && parent.$.wafutil){
                        //
                        target = parent.parent.window.document;
                    }else{
                        target = window.document;
                    }
                }else if(iframeLevel ==0){
                    //top, parent.$.wafutil
                    if(parent && parent!=parent.parent  && parent.$.wafutil){
                        target = parent.parent.window.document;
                    }else if(parent && window!=parent && parent.$.wafutil){
                        target = parent.window.document;
                    }else{
                        target = window.document;
                    }
                }
                return target;
            },
            getIframeTargetOffset:function(iframeLevel){
                var target,left=0,top=0;

                function firstLevelOffset(){
                    var iframe = $.wafIframe.getCurIframe();
                    var offset = parent.$(iframe).offset();
                    return offset;
                }

                function secondLevelOffset(){
                    //
                    var iframe = $.wafIframe.getCurIframe();
                    var offset = parent.$(iframe).offset();
                    var top = offset.top;
                    var left = offset.left;
                    //
                    iframe = parent.$.wafIframe.getCurIframe();
                    offset = parent.parent.$(iframe).offset();
                    top = top + offset.top;
                    left = left + offset.left;
                    return {"left":left,"top":top};
                }


                if(iframeLevel==1){
                    if(parent && window!=parent && parent.$.wafutil){
                        return firstLevelOffset();
                    }
                }else if(iframeLevel==2){
                    if(parent && parent!=parent.parent  && parent.$.wafutil){
                        return secondLevelOffset();
                    }
                }else if(iframeLevel===0){
                    if(parent && parent!=parent.parent  && parent.$.wafutil){
                        return secondLevelOffset();
                    }else if(parent && window!=parent && parent.$.wafutil){
                        return firstLevelOffset();
                    }
                }
                return {"left":left,"top":top};
            },
            getIframeNames:function(iframeLevel){
                var names=[];
                if(iframeLevel==1){
                    if(parent && window!=parent && parent.$.wafutil){
                        names.push($.wafIframe.getCurIframeName());
                    }
                }else if(iframeLevel==2){
                    if(parent && parent!=parent.parent  && parent.$.wafutil){
                        names.push(parent.$.wafIframe.getCurIframeName());
                        names.push($.wafIframe.getCurIframeName());
                    }
                }else if(iframeLevel===0){
                    if(parent && parent!=parent.parent  && parent.$.wafutil){
                        names.push(parent.$.wafIframe.getCurIframeName());
                        names.push($.wafIframe.getCurIframeName());
                    }else if(parent && window!=parent && parent.$.wafutil){
                        names.push($.wafIframe.getCurIframeName());
                    }
                }
                return names;
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("iframe", {createDOMFun:$.wafIframe.createIframeDOM,
                    initFun:$.wafIframe.initIframe, modifyFun:$.wafIframe.modifyIframe,
                    lazyInit:true});
        });

    }(jQuery));
//});
    /*******************************************************************************
     * dataView
     * 
     * @version 1.0
     * @author jinglg
     * @Depends:
     *         jquery.ui.core.js
     *         jquery.ui.widget.js
     *         this.rows
               this.currentSeq
               this.currentRowId
               this.bpv
               this.rsv
               this._index
               this.pRTemplate
               this.pRWrapTemplate
               this.form
               this.metadata
               this.rowMeta
               this.colModel
               this.rowButtonIds
               this.loading
               this.psv
               this.lastpage
               this.page,
               this.template
               this.header
               this.title
               this.switcher
     ******************************************************************************/
//mod.defineModule("dataView",["base","waf","block","jlinq","hogan","dataView_i18n"],function(){
    (function($) {

        var dv_dTemplate =    "<div class='header cf'>" +
                                    "<span class='title'>{{title}}</span>" +
                                 "</div>" +
                                 "<div class='rows'></div>" +
                                 "<div class='footer buttonPanel cf' id='buttonPanel_{{id}}'>" +
                              "</div>";


        var keys = {
            mainClass: 'ui-dataView',
            ctrlRole: 'dataView',
            domCreated:"domcreated"
        };




        $.widget("ui.wafDataView", $.ui.wafctrl, {
            //
                options : {
                id:null,
                width:null,
                height:null,
                loadInit:true,//
                postData:null,//
                cell:false, //cell
                cellGap:false, //cell
                url:null,//url
                mtype:"post",
                datatype:"local",
                data:[],//
                template:null,
                pager:false,//
                pagerModel:"block",//
                rowNum:5, //
                pgbuttons:5,//
                scrollTarget:null,
                multiselect:false,//
                tagClass:null,
                style:null,
                seq:null,//
                move:null,//move
                rowTemplate:null,//
                colModel:[],//
                hidden:false,
                key:"id",//
                title:"",//
                switcher:false,//
                //
                beforeRequest:null,
                beforeProcessing:null,
                loadComplete:null,
                afterInsertRow:null,
                serializeGridData:null,
                afterRefreshIndex:null,
                afterCreateSwitcher:null,
                onRowClick:null
            },
            _create : function() {
                var self = this,op = this.options;
                //id
                if(!op.id) op.id=this.element.attr("id");
                this.te = this._getTemplateEngine();
                //
                this._parseTemplate();
                //DOM
                this._buildElement(op);
                //
                this._initDataPageView(op);
                //option
                this.create=true;
                self._setOptions(this.options);
                delete this.create;
                //
                this._bindEvents();
                //_index,currentSeqcurrentIndexindex
                this._index = 0;this.currentSeq = [];this.currentRowId=[];this.rows=[];
                //
                if(op.loadInit){
                    //
                    this.dataPageView.populate();
                }
            },
            _buildElement:function(op){
                //dom
                if(!this.element.data(this._getKeys().domCreated)){
                    //
                    var template = dv_dTemplate;
                    if(op.template instanceof jQuery || ($.type.isString(op.template) && op.template.indexOf("#")==0)){
                        template = $(op.template).html();
                    }
                    template = this.te.compile(template);
                    var ret = this.te.render(template,op);
                    this.element.append(ret);
                    this.element.addClass(this._getKeys().mainClass).attr("ctrlrole",this._getKeys().ctrlRole);
                    template = null;
                    this.element.attr("data-domcreated","true");
                }else{
                    this.domcreated = true;
                }
                //domtag,
                this.header = $(this.element).children(".header");
                this.title = this.header.find(".title");
                this.rsv = $(this.element).children(".rows");
                this.bpv = $(this.element).children(".footer");
                if(op.cell) this.rsv.addClass("ui-columnLayout");
                if(op.cellGap) this.rsv.addClass("gap");
                if(!op.title) this.title.hide();
            },
            _initDataPageView:function(op){
                var self =this;
                this.dataPageView = new DataPageView($.extend(op,{callback:function(data){
                    var start,end;
                    if(self.dataPageView.needClearVal()){
                        self._emptyRow();
                    }
                    if(data.rows && $.isArray(data.rows)){
                        len = data.rows.length;
                        for(var i=0;i<len;i++){
                            self.addRow(data.rows[i]);
                        }
                    }
                }}));
                this.dataPageView.init();
            },
            _getKeys:function(){
                return keys;
            },
            _handlerSelect:function(e){
                var self=this,row = $(e.target).closest(".row");
                if(row.length==0) return;
                if(self.options.multiselect && e.ctrlKey){
                    row.addClass("ui-state-highlight");
                    self.currentSeq.push(row.attr("seq"));
                    self.currentRowId.push(row.attr("id"));
                }else{
                    $(self.rows).removeClass("ui-state-highlight");
                    self.currentSeq.length=0;
                    self.currentRowId.length=0;

                    row.addClass("ui-state-highlight");
                    self.currentSeq.push(row.attr("seq"));
                    self.currentRowId.push(row.attr("id"));
                }
                $(self.element).triggerHandler("onRowClick",[self.element,row.attr("id")]);
                if(self.options.onRowClick!=null && $.isFunction(self.options.onRowClick)){
                    self.options.onRowClick.call(this,self.element,row.attr("id"));
                }
            },
            _bindEvents:function(){
                var self = this;
                //DOM,click
                this.element.bind("mousedown.dataView",function(e){
                    self._handlerSelect(e);
                });
            },
            _setOption : function(key, value) {
                switch(key){
                    case "width":
                        if(value) {
                            this.element.css(key,value);
                        }
                        break;
                    case "tagClass":
                        this.element.removeClass(this.options.tagClass).addClass(value);
                        break;
                    case "style":
                        if(value) this.element.attr(key,value);
                        break;
                    case "hidden":
                        this.element[value?"hide":"show"]();
                        break;
                    case "seq":
                        if(value){
                            $(".seq",this.element).show();
                            $(".rowCtrls",this.element).addClass("seqLine");
                        }else{
                            $(".seq",this.element).hide();
                            $(".rowCtrls",this.element).removeClass("seqLine");
                        }
                        break;
                    case "url":
                        if(value){
                            this.dataPageView.setOption(key,value);
                        }
                        break;
                    case "rowNum":
                        if(value) this.dataPageView.setOption(key,value);
                        break;
                    case "title":
                        this.title.text(value);
                        break;
                    case "pager":
                    case "pagerModel":
                    case "postData":
                        this.dataPageView.setOption(key,value);
                        break;
                    case "switcher":
                        if(value!=undefined) {
                            this.options[key] = value;
                            this._createSwitcher();
                        }
                        break;
                    case "move":
                        if(value!=undefined && value!=null){
                            this.element.find(".move")[value?"show":"hide"]();
                        }
                        break;
                }
                $.Widget.prototype._setOption.apply( this, arguments );
            },
            _setOptions:function(options){
                var self = this;
                $.each( options, function( key, value ) {
                    self._setOption( key, value );
                });
                //rows
                if(options.height){
                    var childrens = this.element.children(),len=childrens.length,tH=0,item;
                    for(var i=0;i<len;i++){
                        item = childrens[i];
                        if(!$(item).hasClass("rows")){
                            tH += $(item).outerHeight(true);
                        }
                    }
                    this.element.children(".rows").height(parseFloat(options.height) - tH);
                }

                return this;
            },
            widget : function(){
                return this.element;
            },
            destroy : function(){
                this.clearData();
                this.rows = null;
                this.currentSeq = null;
                this.currentRowId = null;
                this.pRTemplate = null;
                this.te = null;
                this.colModel = null;
                $(this.rsv).remove();
                $(this.bpv).remove();
                $(this.psv).remove();
                $(this.header).remove();
                this.element.removeClass(this._getKeys().mainClass);
                $.Widget.prototype.destroy.call( this );
            },
            _emptyRow:function(){
                //idid
                $.each(this.rows,function(){
                    $(this).remove();
                });
                $.wafutil.clear(this.rows);
                $.wafutil.clear(this.currentSeq);
                $.wafutil.clear(this.currentRowId);
                this._index = 0;
            },
            reload : function(){
                //Slice
                var preSelectedRowId = this.currentRowId.slice();
                //reload
                this._emptyRow();
                //
                this.dataPageView.populate();
                //rowId
                this.setSelection(preSelectedRowId);
            },
            loadPage:function(e){
                this.dataPageView.loadPage(e);
            },
            getDataIDs: function(){
                var ret = [],len = this.rows.length;
                if(len>0){
                    for(var i=0;i<len;i++){
                        ret.push($(this.rows[i]).attr("id"));
                    }
                }
                return ret;
            },
            _createSwitcher:function(){
                var op = this.options, self = this;
                if(op.switcher){
                    this.switcher = this.element.find(".switcher");
                    if(this.switcher&&this.switcher.length>0){
                        this.switcher.remove();
                        if(this.switcherClickHandlers)this.switcherClickHandlers.length=0;
                    }
                    this.switcher = $("<div class='switcher cf'></div>")
                        .appendTo(this.header);
                    var ul = $("<ul></ul>")
                        .append("<li><a data-type='default' class='default ui-state-active' href='javascript:void(null)'>"+$.wafDataView.switcher.defaultText+"</a></li>")
                        .append("<li><a data-type='grid' class='grid' href='javascript:void(null)'>"+$.wafDataView.switcher.gridText+"</a></li>")
                        .appendTo(this.switcher);
                    this.switcherClickHandlers = this.switcherClickHandlers || new Map();
                    this.switcherClickHandlers.put("grid",function(element,switcher){
                        self._callWidgetFunction("toGrid");
                    });
                    this.switcherClickHandlers.put("default",function(element,switcher){
                            var elements = self.switcherClickHandlers.keys(),len = elements.length;
                            for(var i=0;i<len;i++){
                                $(element).removeClass(elements[i]);
                            }
                            self._callWidgetFunction("cancelGrid");
                        });
                    if(op.afterCreateSwitcher && $.isFunction(op.afterCreateSwitcher)){
                        var lists = op.afterCreateSwitcher.call(this);
                        if(lists && lists.length>0){
                            var len = lists.length;
                            for(var i=0;i<len;i++){
                                if(lists[i].id==="grid" || lists[i].id ==="default" ){
                                    this.switcherClickHandlers.remove(lists[i].id);
                                }else{
                                    ul.append("<li><a data-type='"+lists[i].id+"' class='"+lists[i].id+"' href='javascript:void(null)'>"+lists[i].name+"</a></li>");
                                }
                                this.switcherClickHandlers.put(lists[i].id,lists[i].handler);
                            }
                        }
                    }
                    $(".switcher li a",this.element).click(function(e){
                        $(".switcher li a",self.element).removeClass("ui-state-active");
                        $(e.target).addClass("ui-state-active");
                        var handler = self.switcherClickHandlers.get($(e.target).data("type"));
                        if(handler && $.isFunction(handler)){
                            handler.call(self,self.element,self.switcher);
                        }
                    });
                }else{
                    $(this.switcher).remove();
                    if(this.switcherClickHandlers)this.switcherClickHandlers.length=0;
                }
            },
            getViewType:function(){
                return $(".switcher .ui-state-active",this.element).data("type");
            },
            refreshIndex:function(){
                //
                var self = this;
                //
                this.rows = [];
                $.each(this.element.find(".row"),function(i){
                    $(this).attr("seq",(i+1));
                    self._setRowSeq((i+1),$(this));
                    self.rows.push(this);
                })
            },
            _setRowSeq:function(seq,rowElem){
                var op = this.options;
                if(op.seq){
                    rowElem.find(".seq").find(".rowNum").html(seq);
                }
                $(this.element).triggerHandler("afterRefreshIndex",[seq,rowElem]);
                if(op.afterRefreshIndex && $.isFunction(op.afterRefreshIndex)){
                    op.afterRefreshIndex.call(this,(seq),rowElem);
                }
            },
            getCurrentRowId:function(){
                if(this.options.multiselect){
                    return this.currentRowId;
                }else{
                    return this.currentRowId.length>0?this.currentRowId[0]:null;
                }
            },
            getRowIdByEvent:function(e){
                if(e instanceof jQuery.Event){
                    var row = $(e.target).closest(".row");
                    return row.attr("id");
                }else{
                    return this.getCurrentRowId();
                }
            },
            getCurrentSeq:function(){
                if(this.options.multiselect){
                    return this.currentSeq;
                }else{
                    return this.currentSeq.length>0?this.currentSeq[0]:null;
                }
            },
            _getSeqByEvent:function(e){
                //SEQ,SEQrows1
                if(e instanceof jQuery.Event){
                    var row = $(e.target).closest(".row");
                    return parseInt(row.attr("seq"));
                }
            },
            clearData:function(){
                this._emptyRow();
            },
            setData:function(data,reload){
                if(data && $.isArray(data)){
                    this.options.data = data;
                    this.dataPageView.setOption("data",data);
                    if(reload==undefined || reload){
                        this.reload();
                    }
                }
            },
            getData:function(){
                return this.dataPageView.data;
            },
            addRow : function(data,pos){
                var op = this.options,newRow;
                //_index1
                this._index++;
                //seqrows.length.
                var seq = this.rows.length+1;
                //pospos1
                if(pos instanceof jQuery.Event){
                    pos = this._getSeqByEvent(pos);
                }
                if(pos && !$.isNaN(pos)){
                    pos = parseInt(pos);
                    if(pos>0 && pos<=this.rows.length){
                        seq = pos + 1;
                        newRow = this.te.render(this.pRTemplate,$.extend(data||{},{seq:seq,index:this._index,rowId:data[op.key]||this._index}));
                        $(newRow).insertAfter(this.rows[pos-1]);
                        //rows
                        newRow = this.rsv.children().eq(seq-1)[0];
                        this.rows.splice(pos,0,newRow);
                    }else{
                        newRow = this.te.render(this.pRTemplate,$.extend(data||{},{seq:seq,index:this._index,rowId:data[op.key]||this._index}));
                        //
                        this.rsv.append(newRow);
                        newRow = this.rsv.children()[this.rsv.children().length-1];
                        this.rows.push(newRow);
                    }
                }else{
                    //
                    newRow = this.te.render(this.pRTemplate,$.extend(data||{},{seq:seq,index:this._index,rowId:data[op.key]||this._index}));
                    this.rsv.append(newRow);
                    newRow = this.rsv.children()[this.rsv.children().length-1];
                    this.rows.push(newRow);
                }
                if(op.seq){
                    $(newRow).find(".rowCtrls").addClass("seqLine");
                }
                //moveseq
                $(newRow).find(".seq")[op.seq?"show":"hide"]();
                $(newRow).find(".move")[op.move?"show":"hide"]();
                //index
                this.refreshIndex();
                var key = data[op.key] || this._index;
                $(this.element).triggerHandler("afterInsertRow",[this._index,data,newRow]);
                //
                if(op.afterInsertRow && $.isFunction(op.afterInsertRow)){
                    op.afterInsertRow.call(this.element,this._index,data,newRow);
                }
                //keyrowId
                return key;
            },
            delRow: function(rowId){
                if(rowId){
                    var row,seq;
                    if(rowId instanceof jQuery.Event){
                        seq = this._getSeqByEvent(rowId);
                        if(seq) row = this.rows[seq-1];
                        rowId = row.id;
                    }else{
                        row = $.wafutil.namedItem(this.rows,rowId);
                        seq = $(row).attr("seq");
                    }
                    $.wafutil.removeAt(this.rows,(seq-1));
                    $.wafutil.remove(this.currentSeq,seq);
                    $.wafutil.remove(this.currentRowId,rowId);
                    $(row).remove();
                    this.refreshIndex();
                }
            },
            getRowId:function(seq){
                if(seq>0 && seq<=this.rows.length){
                    return $(this.rows[seq-1]).attr("id");
                }
            },
            getRowData:function(rowId){
                var ret = {},colLen=this.colModel.length,
                    op = this.options,
                    meta,builder,field,value;
                var row = $.wafutil.namedItem(this.rows,rowId);
                ret = this.dataPageView.getRowData(rowId)||{};
                if(op.seqSave){
                    ret[op.seqProp] = parseInt(this.getSeq(rowId));
                }
                return ret;
            },
            setRowData:function(rowId,data){
                //data
                if(!data) return;
                //colModeldata
                //dataidrow
                var op = this.options,
                    index = this.getRowIndex(rowId),
                    seq = this.getSeq(rowId),
                    row =this.rows[seq-1];
                if(index>-1){
                    $(row).empty();
                    var rowContent = this.pRTemplate.render($.extend(data||{},{index:index,rowId:data[op.key]||rowId}));
                    $(row).append($(rowContent).html());
                }
                //
                if(data[op.key] && rowId !== data[op.key]){
                    //rowId
                    var id;
                    if($(row).hasClass("ui-state-highlight")){
                        id = $(row).attr("id");
                        $.wafutil.remove(this.currentRowId,id);
                    }
                    //rowId
                    if(data[op.key]){
                        $(row).attr("id",data[op.key]);
                    }else{
                        $(row).attr("id",index);
                    }
                    if($(row).hasClass("ui-state-highlight")){
                        id = $(row).attr("id");
                        this.currentRowId.push(id);
                    }
                    //update row seq
                    this._setRowSeq(seq,$(row));
                }
            },
            getSeq:function(rowId){
                var row = $.wafutil.namedItem(this.rows,rowId);
                return $(row).attr("seq");
            },
            moveRowDown:function(rowId){
                var row = $.wafutil.namedItem(this.rows,rowId);
                var prev = $(row).next(".row");
                if(prev.length>0){
                    $(row).insertAfter(prev);
                    this.refreshIndex();
                }
            },
            moveRowUp:function(rowId){
                var row = $.wafutil.namedItem(this.rows,rowId);
                var prev = $(row).prev(".row");
                if(prev.length>0){
                    $(row).insertBefore(prev);
                    this.refreshIndex();
                }
            },
            getRowIndex:function(rowId){
                if(rowId){
                    var row = $.wafutil.namedItem(this.rows,rowId);
                    return parseInt($(row).attr("index"));
                }
                return -1;
            },
            setSelection:function(rowIds){
                var self=this,row;
                //
                $(self.rows).removeClass("ui-state-highlight");
                self.currentSeq.length=0;
                self.currentRowId.length=0;

                var ids = [];
                if(!$.isArray(rowIds)) {
                    ids.push(rowIds)
                } else {
                    if(this.options.multiselect){
                        ids = rowIds;
                    }else{
                        ids.push(rowIds[0]);
                    }
                }
                for(var i=0;i<ids.length;i++){
                    if(ids[i]){
                        row = $.wafutil.namedItem(this.rows,ids[i]);
                        $(row).addClass("ui-state-highlight");
                        self.currentSeq.push($(row).attr("seq"));
                        self.currentRowId.push($(row).attr("id"));
                    }
                }
            },
            removeSelection:function(rowIds){
                var ids = [],row;
                if(!$.isArray(rowIds)) {
                    ids.push(rowIds)
                } else {
                    ids = rowIds;
                }
                for(var i=0;i<ids.length;i++){
                    row = $.wafutil.namedItem(this.rows,ids[i]);
                    $(row).removeClass("ui-state-highlight");
                    $.wafutil.remove(this.currentSeq,$(row).attr("seq"));
                    $.wafutil.remove(this.currentRowId,ids[i]);
                }
            },
            _getColModel:function(){
                return this.options.colModel;
            },
            toGrid:function(p){
                //colModel
                var colModel = this._getColModel(),
                    len = colModel.length,
                    op=this.options,meta,build,model,gridOptions={},self=this;
                if($("#grid_"+op.id).length>0) return;
                //Key
                gridOptions.colModel = colModel;
                gridOptions.id = "grid_"+op.id;
                if(op.pager){
                    //
                    gridOptions.pager = "#pager"+gridOptions.id;
                    gridOptions.rowNum = op.rowNum;
                    var defaultRowList = [5, 10, 20, 40, 50];
                    if($.inArray(gridOptions.rowNum,defaultRowList)==-1){
                        defaultRowList.push(op.rowNum);
                        defaultRowList.sort(function(a,b){
                            return a-b;
                        });
                    }
                    gridOptions.rowList = defaultRowList;
                }
                $.extend(gridOptions,{id:"grid_"+op.id,url:this.dataPageView.url,datatype:op.datatype,multiselect:op.multiselect,data:op.data,height:"auto"});
                if(p){
                    $.extend(gridOptions,p);
                }
                //DOM
                var gridDom = waf.createDOM("grid", gridOptions);
                //DOM
                //waf.appendDOM($(this.element).parent(), gridDom);
                if(gridDom){
                    for(var i=0;i<gridDom.length;i++){
                        gridDom[i].insertAfter(this.header);
                    }
                    $(this.rows).hide();
                    $(this.bpv).hide();
                    $(this.dataPageView.psv).hide();
                }
                //
                waf.initComponent("grid", gridOptions, gridDom);
            },
            cancelGrid:function(){
                var op = this.options;
                $("#grid_"+op.id).wafGrid("gridDestroy");
                $(this.rows).show();
                $(this.bpv).show();
                $(this.dataPageView.psv).show();
            },
            _parseTemplate:function(){
                var op = this.options;
                if(!op.hasParsed && op.rowTemplate){
                    var rowTemplate = op.rowTemplate;
                    if(rowTemplate instanceof jQuery || ($.type.isString(rowTemplate) && rowTemplate.indexOf("#")==0)){
                        rowTemplate = $(rowTemplate).html();
                    }
                    this.colModel=[];
                    this.pRTemplate = this.te.compile(rowTemplate);
                    op.hasParsed = true;
                }
            }
        });

        var DataPageView = (function(){
            function DataPageView(o){
                this.id = o.id;
                this.element = o.element || $("#"+this.id);
                this.rowNum = o.rowNum || 5;
                this.pager = o.pager || false;
                this.pgbuttons = o.pgbuttons || 5;
                this.scrollTarget = o.scrollTarget;
                this.pagerModel = o.pagerModel || "block";
                this.sidx = o.sortname || "";
                this.sord = o.sord || "asc";
                this.callback = o.callback;
                this.data = o.data||[];
                this.url = o.url;
                this.datatype=o.datatype||"local";
                this.mtype=o.mtype||"post";
                this.postData=o.postData||{};
                this.page = 1;
                this.key = o.key || "id";
                this.offset = o.offset || 10;
                this.lastpage = 1;
                this.loading = false;
                this.beforeRequest = o.beforeRequest;
                this.serializeGridData = o.serializeGridData;
                this.beforeProcessing = o.beforeProcessing;
                this.loadComplete = o.loadComplete;
            }
            $.extend(DataPageView.prototype,{
                populate: function(npage){
                    if(!this.loading){
                        var prm = {},bfr,dt,ib=this;
                        if(!this.page || this.page<=0) this.page = 1;
                        prm.rows = this.pager?this.rowNum:-1;
                        prm.page = this.page;
                        prm.sidx = this.sidx;
                        prm.sord = this.sord;
                        prm["nd"] = new Date().getTime();
                        npage = npage || 1;
                        $.extend(prm,this.postData);
                        if(this.beforeRequest && $.isFunction(this.beforeRequest)){
                            bfr = this.beforeRequest.call(this);
                            if(bfr === undefined) { bfr = true; }
                            if ( bfr === false ) { return; }
                        }
                        dt = this.datatype.toLowerCase();
                        switch(dt){
                            case "json":
                                $.ajax({
                                    url:this.url,
                                    type:this.mtype,
                                    dataType: dt ,
                                    data: $.isFunction(this.serializeGridData)? this.serializeGridData.call(this,this.postData) : prm,
                                    success:function(data,st, xhr) {
                                        if ($.isFunction(ib.beforeProcessing)) {
                                            if (ib.beforeProcessing.call(ib, data, st, xhr) === false) {
                                                this._endReq();
                                                return;
                                            }
                                        }
                                        ib.addJSONData(data,npage);
                                        $(ib.element).triggerHandler("loadComplete",[data]);
                                        if ($.isFunction(ib.loadComplete)) {
                                            ib.loadComplete.call(this,data);
                                        }
                                        ib.endReq();
                                        data=null;
                                    },
                                    error:function(xhr,st,err){
                                        if($.isFunction(this.loadError)) { ib.loadError.call(ib,xhr,st,err); }
                                        ib.endReq();
                                        xhr=null;
                                    },
                                    beforeSend: function(xhr, settings ){
                                        ib.beginReq();
                                    }
                                });
                                break;
                            case "local":
                                this.beginReq();
                                var req = this.addLocalData();
                                if ($.isFunction(this.beforeProcessing)) {
                                    if (this.beforeProcessing.call(this, req) === false) {
                                        this.endReq();
                                        return;
                                    }
                                }
                                this.addJSONData(req,npage);
                                if ($.isFunction(this.loadComplete)) {
                                    this.loadComplete.call(this,this.data);
                                }
                                this.endReq();
                                break;
                        }
                    }
                },
                beginReq:function(){
                    this.loading = true;
                    waf.block.show({target:this.element,text:$.wafDataView.data.loadingText});
                },
                endReq:function(){
                    this.loading = false;
                    waf.block.hide(this.element);
                },
                addLocalData:function(){
                    var st,
                        op=this,
                        data=this.data,
                        query;
                    if(!$.isArray(data)) {
                        return;
                    }
                    query = jlinq.from(data);
                    if (op.ignoreCase) { query = query.ignoreCase(); }

                    if (op.sortorder) {
                        if(op.sortorder.toUpperCase() == "DESC") {
                            query.orderBy(op.sortname, "d");
                        } else {
                            query.orderBy(op.sortname, "a");
                        }
                    }
                    var queryResults = query.select(),
                        recordsperpage = parseInt(op.rowNum||5),
                        total = queryResults.length,
                        page = parseInt(this.page||1),
                        retresult = {},
                        totalpages,
                        hasPager = op.pager;
                    if(hasPager){
                        totalpages = Math.ceil(total / recordsperpage);
                        queryResults = queryResults.slice( (page-1)*recordsperpage , page*recordsperpage );
                    }else{
                        totalpages = 1;
                    }
                    query = null;
                    retresult["total"] = totalpages;
                    retresult["page"] = page;
                    retresult["records"] = total;
                    retresult["rows"] = queryResults;
                    queryResults = null;
                    return  retresult;
                },
                updatePager:function(){
                    if(this.pager){
                        var cp = this.intNum(this.page,1),
                            last = this.intNum(this.lastpage,1),
                            pageModel = this.pagerModel,
                            timer,self=this;
                        if(cp<=0) {cp = last = 0;}
                        switch(pageModel){
                            case "block":
                                var range = this.getShowPage(this.page,last),
                                    previous = this.element.find(".prev").parent("li"),
                                    fp = false,lp=false,active;
                                this.psv.find(".pn,.omit").remove();
                                if($.inArray(1,range)==-1){
                                    previous = $("<li><span  class='ui-pg-button pn first'>"+1+"</span></li>").insertAfter(previous);
                                    previous = $("<li><span  class='ui-pg-button omit'>...</span></li>").insertAfter(previous);
                                }
                                for(var i=0;i<range.length;i++){
                                    if(range[i]==this.page) {
                                        active="active"
                                    }else{
                                        active = "";
                                    }
                                    previous = $("<li><span  class='ui-pg-button pn "+active+"'>"+range[i]+"</span></li>").insertAfter(previous);
                                }
                                if($.inArray(last,range)==-1){
                                    previous = $("<li><span  class='ui-pg-button omit'>...</span></li>").insertAfter(previous);
                                    previous = $("<li><span  class='ui-pg-button pn last'>"+last+"</span></li>").insertAfter(previous);
                                }
                                if(cp==1 || cp === 0) {
                                    $(".prev",this.psv).hide();
                                } else {
                                    $(".prev",this.psv).show();
                                }
                                if(cp==last || cp === 0) {
                                    $(".next",this.psv).hide();
                                } else {
                                    $(".next",this.psv).show();
                                }
                                break;
                            case "more":
                                if(cp==last || cp==0){
                                    $(this.psv).hide();
                                }else{
                                    $(this.psv).show();
                                }
                                break;
                            case "scroll":
                                if(cp==last || cp==0){
                                    $(this.psv).addClass("noMore").append($.wafDataView.pager.noMoreDataText);
                                    window.clearTimeout(timer);
                                    timer = window.setTimeout(function(){self.psv.hide();},3000);
                                }
                                break;
                        }
                    }
                },
                getShowPage:function(currentPage,total){
                    var ret = [],index,buttons = this.pgbuttons,avg=Math.round(buttons/2)-1,i;
                    this.psv.find(".pn").each(function(i){
                        if($(this).hasClass("active")){
                            index = i+1;
                        }
                    });
                    if(currentPage==1||currentPage<=avg){
                        for(i=0;i<total && ret.length<buttons;i++){
                            ret.push(i+1);
                        }
                    }else{
                        if((currentPage)>avg){
                            //avg
                            for(i=1;i<=avg;i++){
                                ret.push(currentPage-i);
                            }
                            ret.reverse();
                        }
                        if((total-currentPage)>avg){
                            //avg
                            for(i=0;i<=avg;i++){
                                ret.push(currentPage+i);
                            }
                        }else{
                            for(i=currentPage;i<=total;i++){
                                ret.push(i);
                            }
                            if(ret.length<buttons){
                                //currentPagebuttons-ret.legnth
                                i = ret[0];
                                for(;(ret.length<buttons) && i>1;i--){
                                    ret.splice(0,0,(i-1));
                                }
                            }
                        }
                    }
                    return ret;
                },
                intNum : function(val,defval) {
                    val = parseInt(val,10);
                    if (isNaN(val)) { return defval ? defval : 0;}
                    else {return val;}
                },
                addJSONData:function(data,npage){
                    //,
                    var len,op=this.options;
                    this.lastpage = data.total;
                    this.records = data.records;
                    if(data.rows && $.isArray(data.rows)){
                        if(this.callback && $.isFunction(this.callback)){
                            this.callback.call(this,data);
                        }
                    }
                    this.updatePager();
                },
                initPager:function(){
                    var self=this;
                    if(this.pager){
                        if(this.psv) {
                            this.psv.remove();
                            this.page = 1;
                            this.lastpage=1;
                        }
                        //pager
                        $(".pagePanel",this.element).remove();
                        this.psv = $("<div class='pagePanel cf'></div>").insertBefore($(".footer",this.element));
                        switch(this.pagerModel){
                            case "block":
                                var ul = $("<ul class='pager'></ul>").appendTo(this.psv),
                                    previous = $("<li><span  class='ui-pg-button prev'>"+$.wafDataView.pager.prePageText+"</span></li>").appendTo(ul),
                                    next = $("<li><span  class='ui-pg-button next'>"+$.wafDataView.pager.nextPageText+"</span></li>").appendTo(ul);
                                $(this.element).undelegate(".ui-pg-button","click");
                                $(this.element).delegate(".ui-pg-button","click",function(e){
                                    self.loadPage(e);
                                    return false;
                                });
                                break;
                            case "more":
                                var moreSpan =
                                    $("<a class='more next' href='javascript:void(null)'>"+$.wafDataView.pager.moreButtonText+"</a>")
                                        .appendTo(this.psv);
                                moreSpan.unbind("click").bind("click",function(e){
                                    self.loadPage(e);
                                    return false;
                                });
                                break;
                            case "scroll":
                                var target = this.scrollTarget||this.element.find(".rows");
                                target.unbind("scroll");
                                $(target).scroll(function(){
                                    var timer,
                                        rh = $(this)[0].scrollHeight,
                                        ch = $(this).height(),
                                        offset = self.offset||10,
                                        scrollTop = $(this).scrollTop(),
                                        span = rh - ch - offset;
                                    if(span<scrollTop && self.page<self.lastpage){
                                        window.clearTimeout(timer);
                                        window.setTimeout(self.loadPage(true),500);
                                    }
                                })
                                break;
                        }
                    }else{
                        //pager
                        if(this.psv){
                            this.psv.remove();
                            this.page = 1;
                            this.lastpage=1;
                        }
                    }
                },
                loadPage:function(e){
                    var cp = this.intNum(this.page,1),last = this.intNum(this.lastpage,1),
                        fp=true,np=true,pp=true,lp=true,load=false;
                    if(last ===0 || last===1) {
                        fp=false;pp=false;np=false;lp=false;
                    }else if( last>1 && cp >=1) {
                        if( cp === 1) { fp=false; pp=false; }
                        else if( cp===last){ np=false;lp=false; }
                    } else if( last>1 && cp===0 ) {
                        np=false;lp=false; cp=last-1;
                    }
                    if( $(e.target).hasClass("first") && fp ) { this.page=1; load=true;}
                    if( $(e.target).hasClass("prev") && pp ) { this.page=(cp-1); load=true;}
                    if( ($(e.target).hasClass("next")|| ($.type.isBoolean(e) && e)) && np ) { this.page=(cp+1); load=true;}
                    if( $(e.target).hasClass("last") && lp ) { this.page=last; load=true;}
                    if( $(e.target).hasClass("pn")) {
                        this.psv.find(".pn").removeClass("active");
                        this.page=parseInt($(e.target).text()); load=true;
                        $(e.target).addClass("active");
                    }
                    if(load){
                        //
                        this.populate();
                    }
                },
                needClearVal:function(){
                    return (!this.pager) || (this.pager && "block"==this.pagerModel);
                },
                init:function(){
                },
                setOption:function(key,value){
                    switch(key){
                        case "data":
                            if(value && $.isArray(value)) this.data = value;
                            break;
                        case "pager":
                        case "pagerModel":
                            this.initPager();
                            break;
                        case "rowNum":
                            if(value){
                                this.page =1;
                                this.lastpage=1;
                                this.rowNum = value;
                            }
                            break;
                        case "url":
                            if(value){
                                if(value.indexOf(waf.getContextPath())==-1){
                                    value = waf.getContextPath()+value;
                                    this.url = value;
                                }
                            }
                            break;
                        case "postData":
                            if(value) this.postData = value;
                            break;
                    }
                },
                getRowData:function(rowId){
                    var len = this.data.length;
                    for(var i=0;i<len;i++){
                        if(rowId == this.data[i][this.key]){
                            return this.data[i];
                        }
                    }
                }
            });
            return DataPageView;
        })();



        /*
         * DataView
         */
        $.wafDataView = $.wafDataView || {};
        $.extend($.wafDataView, {
            createDataViewDOM:function (opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    return [$("<div id='"+opts.id+"'></div>")];
                }else{
                    return obj;
                }
            },
            initDataView:function (opts, el) {
                el=$.isArray(el)?el[0]:el;
                $(el).wafDataView(opts);
            },
            removeDataView:function (opts) {
                var dataView = $("#" + opts.id);
                dataView.remove();
            },
            modifyDataView:function (opts) {
                var dataView = $("#" + opts.id);
                dataView.wafDataView("option", opts);
                var reload = (
                        opts.datatype ||
                        opts.url ||
                        opts.data ||
                        opts.pager!=null ||
                        opts.pagerModel!=null ||
                        opts.rowNum!=null ||
                        opts.seq!=null ||
                        opts.rowTitle!=null
                    ) ;
                if(reload) dataView.wafDataView("reload");
                return dataView;
            }
        });

        $(function () {
            if ($.registerComponent && !waf.wafPageComponentLib.get("dataView"))
                $.registerComponent("dataView", {createDOMFun:$.wafDataView.createDataViewDOM, initFun:$.wafDataView.initDataView,
                    deleteFun:$.wafDataView.removeDataView, modifyFun:$.wafDataView.modifyDataView,lazyInit:true});
        });

    })(jQuery);
//});
/*******************************************************************************
 * infoBlock
 * 
 * @version 1.0
 * @author jinglg
 * @Depends: 
 *         jquery.ui.core.js 
 *         jquery.ui.widget.js
 *         this.rows
           this.currentSeq
           this.currentRowId
           this.bpv
           this.rsv
           this._index
           this.form
           this.metadata
           this.rowMeta
           this.colModel
           this.rowButtonIds
           this.loading
           this.psv
           this.lastpage
           this.page,
           this.template
           this.header
           this.title
           this.switcher
 ******************************************************************************/
//mod.defineModule("infoBlock",["base","waf","promptBox","promptUtil","block","dataView","pagerBuilder"],function(){
    (function($) {


        var keys = {
            mainClass: 'ui-infoBlock',
            ctrlRole: 'infoBlock',
            domCreated:"domcreated",
            rowButtonClass:"ibrb",
            rowFieldClass:"ibrf"
        };

        $.widget("ui.wafInfoBlock", $.ui.wafDataView, {
            //
            options : {
                entryProp:"entrys",//
                saveWhenSubmit:true,//
                rowMeta:{},//
                seqProp:"seq",//
                seqSave:true,//
                rowTitle:false,//
                rowTitleTemplate:null,//
                operateState:"EDIT", //
                viewDisplayType:"wordonly", //VIEW
                form:null,
                //
                afterProcessRowContentMeta:null,
                afterProcessRowButtonMeta:null
            },
            _create : function() {
                //seqtrue
                if(this.options.move==null||this.options.move==undefined) this.options.move = true;
                if(this.options.seq==null||this.options.seq==undefined) this.options.seq = true;
                $.ui.wafDataView.prototype._create.apply(this, arguments);
                //form submit
                this._bindFormSubmit();
            },
            _setOptions:function(options){
                $.ui.wafDataView.prototype._setOptions.apply(this, arguments);
                if(options.rowMeta){
                    this.options.hasParsed=false;
                    this._parseTemplate();
                }
            },
            _bindEvents:function(){
                $.ui.wafDataView.prototype._bindEvents.apply(this, arguments);
                var self = this;
                if(this.options.seq){
                    $(this.element).undelegate(".up,.down","click");
                    $(this.element).delegate(".up,.down","click",function(e){
                        var rowId = $(e.target).closest(".row").attr("id");
                        if($(e.target).hasClass("up")){
                            self.moveRowUp(rowId);
                        }else if($(e.target).hasClass("down")){
                            self.moveRowDown(rowId);
                        }
                    });
                }
            },
            _buildElement:function(){
                $.ui.wafDataView.prototype._buildElement.apply(this, arguments);
                //buttonPanel
                if(!this.domcreated) this._createButtonPanel();
            },
            _bindFormSubmit:function(){
                //form submit,form
                var op = this.options;
                if(op && op.form!=null){
                    op.form = op.form.indexOf("#")>-1?op.form:"#"+op.form;
                    this.form = $(op.form);
                }else{
                    this.form = this.element.closest("form");
                }
                if(!this.form) return;
                //formform
                var blocks = $(this.form).data("infoBlocks") || [];
                blocks.push(op.id);
                $(this.form).data("infoBlocks",blocks);
                //form
                this.form.bind("onSubmit",function (cur, data) {
                    var infoBlock = $(this).data("infoBlocks");
                    if (infoBlock && infoBlock.length>0) {
                        for (var index = 0; index < infoBlock.length; index++) {
                            var id = infoBlock[index];
                            var t = $("#" + id);
                            var saveWhenSubmit = $(t).wafInfoBlock("option","saveWhenSubmit");
                            var entryProp = $(t).wafInfoBlock("option","entryProp");
                            if (saveWhenSubmit) {
                                var datas = $(t).wafInfoBlock("getData",true);
                                var hidden = $("#" + entryProp);
                                if (hidden.length == 0) {
                                    var hidden = document.createElement("input");
                                    hidden.type = "hidden";
                                    hidden.id = entryProp;
                                    hidden.name = entryProp;
                                    $(this).append(hidden);
                                }
                                $(hidden).attr("value", waf.toJSONString(datas));
                            }
                        }
                    }
                });
            },
            _getKeys:function(){
                return keys;
            },
            destroy : function(){
                this.clearData();
                this.form = null;
                this.metadata = null;
                this.rowMeta = null;
                $.Widget.prototype.destroy.call( this );
            },
            _createButtonPanel:function(){
                var op = this.options,meta=op.hasParsed?this.metadata.buttonPanelMeta:undefined;
                if(meta){
                    var len = meta.childrens.length,child;
                    for(var i=0;len>0 && i<len;i++){
                        child = meta.childrens[i];
                        child.parent = "buttonPanel_"+op.id;
                        child.parentEl = child.parent;
                    }
                    waf.pageBuilder._buildComponent(meta,null,null);
                }
            },
            buildRowElement:function(newRow,index,seq,status){
                var op = this.options;
                if(op.rowTemplate){
                    if(this.pRTemplate){
                        newRow = this.te.render(this.pRTemplate,{seq:seq,index:index});
                    }
                }else{
                    var rowTitle = $("<span class='title'></span>");
                    var rowButtonPanel = $("<div class='rowButtonPanel cf'></div>");
                    var rowContent = $("<div class='rowContent'></div>");
                    //index,idindex
                    newRow.attr("seq",index).attr("index",index).attr("id",index).addClass("create").addClass(status);
                    //rowButtonPanel,rowContentid
                    rowButtonPanel.attr("id",op.id+"_rb_"+index);
                    rowContent.attr("id",op.id+"_rt_"+index);
                    newRow.append(rowTitle).append(rowButtonPanel).append(rowContent);
                    //rowMetarow
                    this._createRowButtonPanel(index,rowButtonPanel);
                    this._createRowContent(index,rowContent,seq,status);
                    this._setRowTitle(seq,rowTitle);
                }
                return $(newRow);
            },
            _createRow:function(rowMeta,status,pos){
                var newRow = $("<div class='row'></div>");
                //seqrows.length.
                var seq = this.rows.length+1;
                //pospos1
                if(pos instanceof jQuery.Event){
                    pos = this._getSeqByEvent(pos);
                }
                if(pos && !$.isNaN(pos)){
                    pos = parseInt(pos);
                    if(pos>0 && pos<=this.rows.length){
                        newRow.insertAfter(this.rows[pos-1]);
                        seq = pos + 1;
                    }else{
                        this.rsv.append(newRow);
                        this.rows.push(newRow[0]);
                    }
                }else{
                    this.rsv.append(newRow);
                    this.rows.push(newRow[0]);
                }
                this._index++;
                newRow = this.buildRowElement(newRow,this._index,seq,status);
                //index
                this.refreshIndex();
                return {newRow:newRow,index:this._index,seq:seq};
            },
            _createRowContent:function(index,rowContent,seq,status){
                var op = this.options,meta=op.hasParsed?this.metadata.rowObjectMeta:undefined,rowCtrlsId,rowObjectId,seqLine=false;
                if(meta){
                    if(op.seq){
                        rowContent.append("<span class='seq'><span class='rowNum'>"+seq+"</span><span class='move'><span class='up'></span><span class='down'></span></span></span>");
                        $(rowContent).find(".move")[op.move?"show":"hide"]();
                        seqLine = true;
                    }
                    var rowObjectMeta = $.extend(true,{},meta);
                    rowObjectId = $(rowContent).attr("id");
                    rowCtrlsId = op.id+"_rcs_"+rowObjectId;
                    rowContent.append("<div class='rowCtrls "+(seqLine?"seqLine":"")+"' id='"+rowCtrlsId+"'></div>");
                    rowObjectMeta.id = rowCtrlsId;
                    //rowId
                    rowObjectMeta.parent = rowObjectId;
                    rowObjectMeta.parentEl = rowObjectId;
                    //id
                    this._parseNewRowMeta(rowObjectMeta,index,op.id,status);
                    if(op.afterProcessRowContentMeta && $.isFunction(op.afterProcessRowContentMeta)){
                        rowObjectMeta = op.afterProcessRowContentMeta.call(this,rowObjectMeta,index) || rowObjectMeta;
                    }
                    waf.pageBuilder._buildComponent(rowObjectMeta,null,null);
                    rowObjectMeta=null;
                }
            },
            _createRowButtonPanel:function(index,rowButtonPanel){
                var op = this.options,meta=op.hasParsed?this.metadata.rowButtonPanelMeta:undefined;
                if(meta){
                    var buttonMeta = $.extend(true,{},meta);
                    buttonMeta.id=$(rowButtonPanel).attr("id");
                    //rowId
                    buttonMeta.parent = index;
                    buttonMeta.parentEl = index;
                    //linkButtonid
                    this._parseNewRowMeta(buttonMeta,index,op.id);
                    if(op.afterProcessRowButtonMeta && $.isFunction(op.afterProcessRowButtonMeta)){
                        buttonMeta = op.afterProcessRowButtonMeta.call(this,buttonMeta,index) || buttonMeta;
                    }
                    waf.pageBuilder._buildComponent(buttonMeta,null,null);
                    buttonMeta = null;
                }
            },
            _setRowTitle:function(seq,rowTitle){
                //Title
                var op = this.options;
                if(op.rowTitle){
                    if(op.rowTitleTemplate){
                        rowTitle.html($.wafutil.replaceAll(op.rowTitleTemplate,"{0}",seq));
                    }else{
                        rowTitle.html(seq);
                    }
                }
            },
            getData:function(){
                var datas = [],rowLen=this.rows.length,
                    rowId,id=this.options.id;
                if(rowLen>0){
                    for(var i=0;i<rowLen;i++){
                        rowId = $(this.rows[i]).attr("id");
                        datas.push(this.getRowData(rowId));
                    }
                }
                return datas;
            },
            _getControlValue:function(ctrlId,componentType){
                return eval("waf('#" +ctrlId+ "')." + waf.wafCmpTypeLib.get(componentType) + "('"+"getValue"+"')");
            },
            _setControlValue:function(ctrlId,componentType,value){
                if(value==undefined) return;
                var js;
                if($.type.isObject(value)){
                    js = "waf('#" + ctrlId + "')." + waf.wafCmpTypeLib.get(componentType) + "('setValue',value)";
                }else{
                    js = "waf('#" + ctrlId + "')." + waf.wafCmpTypeLib.get(componentType) + "('setValue',value)";
                }
                eval(js);
            },
            addRow : function(data,pos,status){
                var rowInfo = this._createRow(this.rowMeta,status || this.options.operateState,pos),
                    op = this.options,
                    index = rowInfo.index,
                    rowElem = rowInfo.newRow,
                    key = index;
                //
                this.setSelection([key]);
                if(data && $.type.isObject(data) && !$.isArray(data)){
                    this.setRowData(key,data);
                    key = data[op.key] || index;
                }
                //
                if(op.afterInsertRow && $.isFunction(op.afterInsertRow)){
                    op.afterInsertRow.call(this.element,index,data,rowElem,key);
                }
                this._afterAddRow(rowElem,key);
                //keyrowId
                return key;
            },
            _afterAddRow:function(rowElem,key){
                //enter2tab
                $(rowElem).find(".ibrb").removeClass("enter2tab");
                //onfocu
                var colLen=this.colModel.length,meta,field,ctrl,self=this;
                for(var j=0;j<colLen;j++){
                    meta = this.colModel[j].meta;
                    if(meta){
                        field = meta.field;
                        if(field){
                            ctrl = this.getControlId(key,field);
                            $("#"+ctrl).enter2tab({onFocus:function(e){
                                 $.ui.wafDataView.prototype._handlerSelect.call(self,e);
                            }});
                        }
                    }
                }
            },
            getAccessor : function(obj, expr) {
                return $.wafutil.getAccessor(obj,expr);
            },
            getRowData:function(rowId){
                var ret = {},colLen=this.colModel.length,
                    op = this.options,
                    meta,builder,field,value;
                for(var j=0;j<colLen;j++){
                    meta = this.colModel[j].meta;
                    builder = this.colModel[j].build;
                    if(meta){
                        field = meta.field;
                        if(field){
                            value = this._getControlValue(this.getControlId(rowId,meta.field),builder.componentType);
                            if(builder.componentType && builder.componentType=="datePicker"){
                                if("datetime" === meta.properties.type){
                                    value = waf.datepicker.formatDateTime("yy-mm-dd","hh:mm:ss",value);
                                }else{
                                    value = waf.datepicker.formatDate("yy-mm-dd",value);
                                }
                            }
                            if(value!=undefined) ret[field] = value;
                        }
                    }
                }
                var row = $.wafutil.namedItem(this.rows,rowId);
                if(op.key && $(row).hasClass("update")){
                    ret[op.key] = rowId;
                }
                if(op.seqSave){
                    ret[op.seqProp] = parseInt(this.getSeq(rowId));
                }
                return ret;
            },
            setRowData:function(rowId,data){
                //data
                if(!data) return;
                //colModeldata
                //dataidrow
                var op = this.options,
                    index = this.getRowIndex(rowId),
                    seq = this.getSeq(rowId),
                    len = this.colModel.length,cm,build,js;
                if(index>-1){
                    for(var i=0; i< len; i++){
                        cm = this.colModel[i];
                        if(cm && cm.meta && cm.meta.field && cm.build && cm.build.componentType){
                            this._setControlValue(
                                this.getControlId(rowId,cm.meta.field),
                                cm.build.componentType,
                                this.getAccessor(data,cm.meta.field));
                        }

                    }
                }
                //
                if(data[op.key] && rowId !== data[op.key]){
                    //rowId
                    var row =this.rows[seq-1],id;
                    if($(row).hasClass("ui-state-highlight")){
                        id = $(row).attr("id");
                        $.wafutil.remove(this.currentRowId,id);
                    }
                    //rowId
                    if(data[op.key]){
                        $(row).attr("id",data[op.key]);
                        $(row).removeClass("create").removeClass("update").addClass("update");
                    }else{
                        $(row).attr("id",index);
                    }
                    if($(row).hasClass("ui-state-highlight")){
                        id = $(row).attr("id");
                        this.currentRowId.push(id);
                    }
                }
            },
            getControlId:function(rowId,prop){
                var op = this.options, index = this.getRowIndex(rowId);
                if(index>-1){
                    return op.id+"_"+$.wafutil.replaceAll(prop,".","_")+"_"+index;
                }
            },
            _changeStatus:function(rowId,state,viewDisplayType){
                var index = this.getRowIndex(rowId),
                    op = this.options,
                    len = this.colModel.length;
                var cm,meta,build,ctrlId,js="";
                for(var i=0;i<len;i++){
                    js="";
                    meta = this.colModel[i].meta;
                    build = this.colModel[i].build;
                    if(meta.field && build.componentType){
                        ctrlId = op.id+"_"+meta.field+"_"+index;
                        if(viewDisplayType && "view".toUpperCase()==state.toUpperCase()){
                            js = "waf('#" +ctrlId+ "')." + waf.wafCmpTypeLib.get(build.componentType) + "('option','viewDisplayType','"+viewDisplayType+"');";
                        }
                        js += "waf('#" +ctrlId+ "')." + waf.wafCmpTypeLib.get(build.componentType) + "('option','operateState','"+state+"');";
                        eval(js);
                    }
                }
                //class
                var row = $.wafutil.namedItem(this.rows,rowId);
                if(row){
                    $(row).removeClass("edit").removeClass("view").addClass(state);
                }
            },
            edit:function(rowId){
                if(rowId){
                    this._changeStatus(rowId,"EDIT");
                }else{
                    var len = this.rows.length;
                    for(var i=0;i<len;i++){
                        rowId = $(this.rows[i]).attr("id");
                        this._changeStatus(rowId,"EDIT");
                    }
                }
            },
            view:function(rowId,viewDisplayType){
                if(rowId){
                    this._changeStatus(rowId,"VIEW",viewDisplayType);
                }else{
                    var len = this.rows.length;
                    for(var i=0;i<len;i++){
                        rowId = $(this.rows[i]).attr("id");
                        this._changeStatus(rowId,"VIEW",viewDisplayType);
                    }
                }
            },
            getFieldValue:function(rowId,field){
                var ctrlId = this.getControlId(rowId,field);
                var componentType = this._getComponentType(field);
                if(componentType){
                    return this._getControlValue(ctrlId,componentType);
                }
            },
            setFieldValue:function(rowId,field,value){
                var ctrlId = this.getControlId(rowId,field);
                var componentType = this._getComponentType(field);
                if(componentType&&value){
                    this._setControlValue(ctrlId,componentType,value);
                }
            },
            _getColModel:function(){
                if(this.options.colModel && this.options.colModel.length>0) {
                    return this.options.colModel;
                }else{
                    //colModel
                    var colModel = [],len = this.colModel.length,op=this.options,meta,build,model,gridOptions={},self=this;
                    //Key
                    colModel.push({index:op.key,width:50,label:op.key,align:"center",name:op.key,key:true,hidden:true});
                    for(var i=0;i<len;i++){
                        meta = this.colModel[i].meta;
                        build = this.colModel[i].build;
                        if(meta.field && build.componentType){
                            model={index:meta.field,width:80,label:meta.properties.title,name:meta.field};
                            if("numberField" == build.componentType){
                                model.align="right";
                            }else{
                                model.align="center";
                            }
                            if("select" == build.componentType && meta.properties.enumSource){
                                model.formatter="wafenum";
                            }else if("checkbox"==build.componentType){
                                model.formatter = "wafcheckbox";
                            }
                            colModel.push(model);
                        }
                    }
                    if(this.metadata.rowButtonPanelMeta &&
                        this.metadata.rowButtonPanelMeta.childrens &&
                        this.metadata.rowButtonPanelMeta.childrens.length>0){
                        var buttons = [],len = this.metadata.rowButtonPanelMeta.childrens.length,item;
                        for(var i=0;i<len;i++){
                            item = this.metadata.rowButtonPanelMeta.childrens[i].properties;
                            buttons.push({actionBindingName:item.actionBindingName,onclick:item.onclick,visible:true,linkJson:item});
                        }
                        //
                        colModel.push({
                            index: op.id+"_operatorColumn",
                            label: $.wafDataView.toGrid.operationColumnLable,
                            name: op.id+"operatorColumn",
                            resizable: true,
                            width: 80,
                            formatter: "operations",
                            formatoptions: buttons
                        });
                    }
                    return colModel;
                }
            },
            _parseTemplate:function(){
                var op = this.options;
                if(!op.hasParsed && op.rowMeta){
                    this.colModel=[];
                    this.rowButtonIds=[];
                    var metadata = {},len;
                    metadata.buttonPanelMeta = op.rowMeta.childrens[0].buttonPanel;
                    metadata.rowButtonPanelMeta = op.rowMeta.childrens[0].rowButtonPanel;
                    metadata.rowObjectMeta = op.rowMeta.childrens[0].rowObject;
                    this._parseColModelAndButtons(metadata.rowObjectMeta);
                    this._parseColModelAndButtons(metadata.rowButtonPanelMeta);
                    this.metadata = metadata;
                    //
                    if(op.rowTemplate) this.pRTemplate = this._getTemplateEngine().compile(op.rowTemplate);
                    op.hasParsed = true;
                }
            },
            _parseColModelAndButtons:function(rowMeta){
                if(rowMeta && rowMeta.childrens && rowMeta.childrens.length>0){
                    var len = rowMeta.childrens.length,self=this;
                    //builderbuild
                    waf.pageBuilder._initComponentBuilder();
                    var callback = function(componentBuilder,metaComponent,parentId){
                        //
                        if(metaComponent.field!=undefined && metaComponent.field!=null) {
                            self.colModel.push({meta:metaComponent,build:componentBuilder});
                        }
                        //componentids
                        if(metaComponent.componentType=="com.kingdee.bos.ctrl.web.Button"){
                            self.rowButtonIds.push(metaComponent.id);
                        }
                    }
                    //rowObject
                    for(var i=0;i<len;i++){
                        this._loopParse(rowMeta.childrens[i],callback);
                    }
                }
            },
            _parseNewRowMeta:function(metadata,index,parentId,status){
                //parentrowButtonrowObjectid
                if(metadata && metadata.childrens && metadata.childrens.length>0){
                    var len = metadata.childrens.length,op = this.options,self=this;
                    //builderbuild
                    waf.pageBuilder._initComponentBuilder();
                    var callback=function(componentBuilder,metaComponent,parentId){
                        //idid
                        metaComponent.id = op.id+"_"+$.wafutil.replaceAll(metaComponent.id,".","_")+"_"+index;
                        metaComponent.properties.id = metaComponent.id;
                        metaComponent.parent = parentId;
                        metaComponent.parentEl = parentId;
                        //
                        if(status){
                            metaComponent.properties.operateState = status;
                            if(self.options.viewDisplayType){
                                metaComponent.properties.viewDisplayType = self.options.viewDisplayType;
                            }
                        }

                        //fieldtagClass,field
                        var isButton = metaComponent.componentType=="com.kingdee.bos.ctrl.web.Button";
                        if((isButton) || (metaComponent.field!=undefined && metaComponent.field!=null)) {
                            if(!metaComponent.properties.tagClass) {
                                metaComponent.properties.tagClass=isButton?keys.rowButtonClass:keys.rowFieldClass;
                            }else{
                                metaComponent.properties.tagClass=metaComponent.properties.tagClass+" "+(isButton?keys.rowButtonClass:keys.rowFieldClass);
                            }
                            if(!isButton){
                                metaComponent.id = op.id+"_"+$.wafutil.replaceAll(metaComponent.field,".","_")+"_"+index;
                                if(metaComponent.properties.name){
                                    metaComponent.properties.name = op.id+"_"+$.wafutil.replaceAll(metaComponent.properties.name,".","_")+"_"+index;
                                }
                                metaComponent.properties.id = metaComponent.id;
                            }
                        }
                    }
                    //rowObject
                    this._loopParse(metadata,callback,metadata.id,false);
                }
            },
            _loopParse:function(metaComponent,callback,parentId,calc){
                //callbackcolModel,rowid.
                if(metaComponent==null || !callback){
                    return ;
                }
                //idcolModel
                var componentBuilder;
                var componentBuildElement=waf.pageBuilder._getComponentBuilder(metaComponent.componentType);
                if(componentBuildElement!=undefined || componentBuildElement!=null) {
                    if(componentBuildElement.componentBuilder!=null && componentBuildElement.componentBuilder!=undefined) {
                        componentBuilder=componentBuildElement.componentBuilder;
                    }
                }
                if($.isFunction(callback) && calc){
                    callback.call(this.element,componentBuilder,metaComponent,parentId);
                }
                //idcolModel
                for(var index in metaComponent.childrens){
                    var tmp = metaComponent.childrens[index];
                    this._loopParse(tmp,callback,metaComponent.id,true);
                }
            },
            getFieldValues:function(fieldName,methodOpr){
                var ret = [],sum=0,len = this.rows.length,ctrlId,ctrlIndex,value,v,min,max,
                    op = this.options,
                    componentType = this._getComponentType(fieldName);
                if(!componentType) return;
                for(var i=0;i<len;i++){
                    ctrlIndex = $(this.rows[i]).attr("index");
                    ctrlId = op.id+"_"+fieldName+"_"+ctrlIndex;
                    value = this._getControlValue(ctrlId,componentType);
                    if(value){
                        if(methodOpr){
                            if($.isNaN(value)) value="0";
                            v = parseFloat(value);
                            sum += v;
                            if(i===0) {
                                min = v;
                                max = v;
                            } else {
                                min = Math.min(min, v);
                                max = Math.max(max, v);
                            }
                        }else{
                            ret.push(value);
                        }
                    }
                }
                if(methodOpr) {
                    switch(methodOpr.toLowerCase()){
                        case 'sum': ret =sum; break;
                        case 'avg': ret = sum/len; break;
                        case 'count': ret = len; break;
                        case 'min': ret = min; break;
                        case 'max': ret = max; break;
                    }
                }
                return ret;
            },
            _getComponentType:function(fieldName){
                var len = this.colModel.length,builder,meta;
                for(var i=0;i<len;i++){
                    meta = this.colModel[i].meta;
                    if(meta && meta.field === fieldName){
                        builder = this.colModel[i].build;
                        return builder.componentType;
                    }
                }
            },
            getFooterPanel:function(){
               return this.bpv[0];
            },
            getRowPanel:function(rowId){
               return $.wafutil.namedItem(this.rows,rowId);
            },
            getRowButtonPanel:function(rowId){
               var row =  $.wafutil.namedItem(this.rows,rowId);
               return $(row).children(".rowButtonPanel")
            }
        });


        /*
         * INFOBLOCK
         */
        $.wafInfoBlock = $.wafInfoBlock || {};
        $.extend($.wafInfoBlock, {
            createInfoBlockDOM:function (opts) {
                var obj = opts && opts.id && $("#" + opts.id);
                if (!(obj && obj.data("domcreated"))) {
                    return [$("<div id='"+opts.id+"'></div>")];
                }else{
                    return obj;
                }
            },
            initInfoBlock:function (opts, el) {
                el=$.isArray(el)?el[0]:el;
                $(el).wafInfoBlock(opts);
            },
            removeInfoBlock:function (opts) {
                var infoBlock = $("#" + opts.id);
                infoBlock.remove();
            },
            modifyInfoBlock:function (opts) {
                var infoBlock = $("#" + opts.id);
                infoBlock.wafInfoBlock("option", opts);
                var reload = (
                        opts.datatype ||
                        opts.url ||
                        opts.data ||
                        opts.pager!=null ||
                        opts.pagerModel!=null ||
                        opts.rowNum!=null ||
                        opts.seq!=null ||
                        opts.rowTitle!=null
                    ) ;
                if(reload) infoBlock.wafInfoBlock("reload");
                return infoBlock;
            }
        });

        $(function () {
            if ($.registerComponent  && !waf.wafPageComponentLib.get("infoBlock"))
                $.registerComponent("infoBlock", {createDOMFun:$.wafInfoBlock.createInfoBlockDOM, initFun:$.wafInfoBlock.initInfoBlock,
                    deleteFun:$.wafInfoBlock.removeInfoBlock, modifyFun:$.wafInfoBlock.modifyInfoBlock,lazyInit:true});
        });

    })(jQuery);
//});
//mod.defineModule("autoComplete",["base","waf","autoCompleteBase","text"],function(){
    /*
     * jQuery UI Autocomplete 1.8.16
     *
     * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
     * Dual licensed under the MIT or GPL Version 2 licenses.
     * http://jquery.org/license
     *
     * http://docs.jquery.com/UI/Autocomplete
     *
     * Depends:
     *	jquery.ui.core.js
     *	jquery.ui.widget.js
     *	jquery.ui.position.js
     */
    //
    //ononopen
    //optionarraySourceurlSource
    //maxlength 2012-6-11
    //  $(".page_margins .page")[0] this.options.appendTo 2012-8-22
    //querySourcebim querychangeinputhidden 2012-11-13
    //_changehidden 2012-12-13
    // 2012-12-13
    (function ($, undefined) {

        // used to prevent race conditions with remote data sources
        var requestIndex = 0;

        $.widget("ui.autocomplete", $.ui.wafAutoCompleteTemplate, {
            options:{
                disabled:false,
                formatter: null
            },

            pending:0,

            _create: function() {
                //inputhiddenctrlrole
                var self = this,
                    el = this.element,
                    id = el[0].id;
                el.attr("ctrlrole", "autoComplete");
                $("#" + id + "_el").attr("ctrlrole", "autoComplete");
                this.options["inMenuFlag"] = false;

                $.ui.wafAutoCompleteTemplate.prototype._create.call(this);

                if(this.options.height) {
                    this.menu.element
                        .css("height", this.options.height)
                        .css("overflow", "auto");
                }
            },

            _setValue: function(item, type) {
                this.element.val(item.label);
                this.element.next("input").val(item.value);
            },

            _setOption:function (key, value) {
                $.ui.wafAutoCompleteTemplate.prototype._setOption.apply(this, arguments);
                //source
                if (key === "arraySource" || key === "urlSource" || key === "functionSource") {
                    $.ui.wafAutoCompleteTemplate.prototype._setOption.call(this, "source", value);
                }
                if (key == "height") {
                    this.menu.element.css(key, value).css("overflow", "auto");
                }
            },

            _initSource:function () {
                if(this.options.source == null){
                    if(this.options.arraySource && $.isArray(this.options.arraySource)){
                        this.options.source = this.options.arraySource;
                    }else if(this.options.urlSource && typeof this.options.urlSource === "string"){
                        this.options.source = this.options.urlSource;
                    }else if(this.options.functionSource && $.isFunction(this.options.functionSource)){
                        this.options.source = this.options.functionSource;
                    }
                }
                if (typeof this.options.source === "string") {
                    var url = this.options.source;
                    if (url.substring(0, 1) != "?") {
                        url = $.getContextPath() + url;
                    }
                    //urlurlSource
                    this.options.source = url;
                    this.options.urlSource = url;
                }
                $.ui.wafAutoCompleteTemplate.prototype._initSource.apply(this, arguments);
            },

            _response:function (content) {
                if (!this.options.disabled && content && content.length) {
                    this.setEditItem(content);
                }
                $.ui.wafAutoCompleteTemplate.prototype._response.apply(this, arguments);
            },

            setEditItem:function (content) {
                var inputValue = this.element.val(), that = this;
                this.options.editItem = null;
                if (content && content.length > 0) {
                    $.each(content, function (index, item) {
                        if (inputValue == item.label) {
                            that.options.editItem = item;
                            return false;
                        }
                    });
                }
            },

            _change:function (event) {
                //hidden
                var el = this.element, hidden = $("#" + el[0].id + "_el");
                if (this.previous && this.previous.label != el.val()) {
                    var result = this._trigger("onchange", event, {"previous":this.previous, "current":this.options.current });
                    if (!result) {
                        el.val(this.previous.label);
                        hidden.val(this.previous.value);
                    } else {
                        if (this.selectedItem) {
                            //
                            hidden.val(this.selectedItem.value);
                        } else if (this.options.editItem != null) {
                            //labelvalue
                            hidden.val(this.options.editItem.value);
                            this.options.editItem = null;
                        } else if (el.val().length > 0) {
                            //labelvalueinMenuFlaghidden
                            //inMenuFlagtruehidden
                            //objFlaghiddeninput
                            //objFlagtruehidden
                            //hiddeninput
                            if (this.options["inMenuFlag"] === true) {
                                hidden.val("");
                                el.val("");
                            } else if (this.options.objFlag === true) {
                                hidden.val("");
                                el.val("");
                            } else {
                                hidden.val(el.val());
                            }
                        } else {
                            hidden.val("");
                        }
                    }
                }
            },

            _normalize:function (items) {
                if (items.length && items[0].label && items[0].value) {
                    this.options.objFlag = true;
                }
                return $.ui.wafAutoCompleteTemplate.prototype._normalize.apply(this, arguments);
            },

            _renderItem: function( ul, item) {
                var formatter = this.options.formatter,
                    output = formatter!=null && $.isFunction(formatter) ? formatter.call(this, item, this.options, ul) : item.label;
                return $( "<li></li>" )
                    .data( "item.wafAutoCompleteTemplate", item )
                    .append( $( "<a></a>" ).html(output) )
                    .appendTo( ul );
            }
        });

        //wafAutoCompleteautocomplete
        $.wafAutoComplete = $.wafAutoComplete || {};
        $.fn.wafAutoComplete = $.fn.autocomplete;

        /*
         * autocomplete
         * author:Zhang yanfang
         * 2012-12-6
         */
        $.extend($.wafAutoComplete, {
            createAcDOM:function (opts) {
                return null;
            },
            initAc:function (opts, el) {
                if (!$.wafutil.isViewOperateState(opts)) {
                    opts.source = opts.arraySource || opts.urlSource || opts.functionSource;
                    if (!opts.source && opts["querySource"]) {
                        opts.source = "/component/autocomplete.do?method=initalize&querySource=" + opts["querySource"] +
                            "&displayName=" + opts["displayName"];
                    }
                    var element = $("#" + opts.id),
                        textOpts = element.wafText("option"),
                        onchangeEvent = textOpts.onchange;
                    if (onchangeEvent) {
                        element.unbind("change.wafText");
                        opts.onchange = onchangeEvent;
                    }
                    opts.maxlength = textOpts.maxlength;
                    element.attr("ctrlrole", "autoComplete");
                    $("#" + opts.id + "_el").attr("ctrlrole", "autoComplete");
                    //objFlagsourcejson
                    element.wafAutoComplete(opts);
                }
            },
            removeAc:function (opts) {
                var element = $("#" + opts.id);
                element.wafAutoComplete("destroy");
                element.attr("ctrlrole", "text");
                $("#" + opts.id + "_el").attr("ctrlrole", "text");
            },
            modifyAc:function (opts) {
                var element = $("#" + opts.id);
                element.wafAutoComplete("option", opts);
            }
        });
        $(function () {
            if ($.registerComponent)
                $.registerComponent("autoComplete", {createDOMFun:$.wafAutoComplete.createAcDOM, initFun:$.wafAutoComplete.initAc,
                    deleteFun:$.wafAutoComplete.removeAc, modifyFun:$.wafAutoComplete.modifyAc,lazyInit:true});
        });
    }(jQuery));
//});
/*******************************************************************************
 * jQuery UI promptAutoComplete
 *
 * @version 1.0
 * @author peng_zhou1
 * @Depends:
 *         jquery.ui.core.js
 *         jquery.ui.widget.js
 ******************************************************************************/
//mod.defineModule("promptAutoComplete",["base","waf","promptBox","position","block","promptUtil","autoCompleteBase"],function(){
    (function ($, undefined) {

        // used to prevent race conditions with remote data sources
        var requestIndex = 0,
            defaultClass = "ui-wafPromptAutoComplete";

        $.widget("ui.wafPromptAutoComplete", $.ui.wafAutoCompleteTemplate, {
            options: {
                arraySource: null,
                autoChoose: true,
                autoCompleteItem: "name",
                beforeOpen: null,
                filteritem: null,
                focusText: true,
                formatter: null,
                functionSource: null,
                maxHeight: null,
                query: null,
                sidx: null,
                sord: "asc",
                style: null,
                tagClass: null,
                urlSource: null,
                serializePromptData: null
            },

            _create: function() {
                var self = this,
                    suppressKeyPress;

                if(this.element.hasClass(defaultClass)) return;
                this.frame = this.element.wafPromptBox("getFrame");

                this.element.wafPromptBox('option', 'subWidgetName', 'wafPromptAutoComplete');

                $.ui.wafAutoCompleteTemplate.prototype._create.call(this);

                this.menu.element.bind("click.wafPromptAutoComplete", function(event) {return false;});
            },

            _initElement: function() {
                var self = this,
                    suppressKeyPress;

                this.element.bind("keydown.wafPromptAutoComplete", function(event) {
                    if(self.options.disabled || self.element.propAttr("readOnly")) {
                        return;
                    }

                    suppressKeyPress = false;
                    var keyCode = $.ui.keyCode;
                    switch(event.keyCode) {
                    case keyCode.PAGE_UP:
                        self._move("previousPage", event);
                        event.preventDefault();
                        break;
                    case keyCode.PAGE_DOWN:
                        self._move("nextPage", event);
                        event.preventDefault();
                        break;
                    case keyCode.UP:
                        self._move("previous", event);
                        // prevent moving cursor to beginning of text field in some browsers
                        event.preventDefault();
                        break;
                    case keyCode.DOWN:
                        self._move("next", event);
                        // prevent moving cursor to end of text field in some browsers
                        event.preventDefault();
                        break;
                    case keyCode.ENTER:
                    case keyCode.NUMPAD_ENTER:
                        // when menu is open and has focus
                        if(self.hasOpen()) {
                            if(self.menu.active) {
                                // #6055 - Opera still allows the keypress to occur
                                // which causes forms to submit
                                suppressKeyPress = true;
                            } else {
                                self.close();
                            }
                            event.preventDefault();
                            event.stopPropagation();
                        }
                        //passthrough - ENTER and TAB both select the current element
                    case keyCode.TAB:
                        // when menu is open and has focus
                        if(self.hasOpen()) {
                            if(self.menu.active) {
                                self.menu.select(event);
                            } else {
                                self.close();
                            }
                        }
                        break;
                    case keyCode.ESCAPE:
                        self.element.val(self.term);
                        self.close(event);
                        break;
                    default:
                        // keypress is triggered before the input value is changed
                        clearTimeout(self.searching);
                        self.searching = setTimeout(function() {
                            // only search if the value has changed
                            if(self.term != self.element.val()) {
                                self.selectedItem = null;
                                self.search(null, event);
                            }
                        }, self.options.delay);
                        break;
                    }
                }).bind("keypress.wafPromptAutoComplete", function(event) {
                    if(suppressKeyPress) {
                        suppressKeyPress = false;
                        event.preventDefault();
                    }
                }).bind("focus.wafPromptAutoComplete", function() {
                    if(self.options.disabled) {
                        return;
                    }

                    self.selectedItem = null;
                    self.term = self.previous = self.element.val();
                });
            },

            _setValue: function(item, type) {
                if(type == "select") {
                    this.element.wafPromptBox('setValue', item);
                } else if(type == "focus" && this.options.focusText){
                    this.element.val(item[this.options.autoCompleteItem]);
                }
            },

            _setOption: function(key, value) {
                if(key === "tagClass") {
                    this.menu.element.removeClass(this.options.tagClass).addClass(value);
                }
                $.ui.wafAutoCompleteTemplate.prototype._setOption.apply(this, arguments);
                //source
                if(key === "arraySource" || key === "urlSource" || key === "functionSource") {
                    $.ui.wafAutoCompleteTemplate.prototype._setOption.call(this, "source", value);
                } else if(key === "query") {
                    this._initSource();
                }
            },

            _initSource: function() {
                var self = this,
                    arraySource = this.options.arraySource,
                    functionSource = this.options.functionSource,
                    urlSource = this.options.urlSource;

                if($.isArray(arraySource)) {
                    this.source = function(request, response) {
                        response($.wafPromptAutoComplete.filter(arraySource, request.term, self.options.autoCompleteItem));
                    };
                } else if($.isFunction(functionSource)) {
                    this.source = functionSource;
                } else {
                    this.source = function(request, response) {
                        if(self.xhr) {
                            self.xhr.abort();
                        }
                        request = $.extend({}, request, {
                            cu: self.options.cu,
                            filteritem: self.options.filteritem || "",
                            item: self.options.autoCompleteItem || "",
                            query: self.options.query || "",
                            sidx: self.options.sidx || "",
                            sord: self.options.sord || ""
                        });
                        self.xhr = $.ajax({
                            url: urlSource,
                            data: (self.options.serializePromptData&&$.isFunction(self.options.serializePromptData))?self.options.serializePromptData.call(self,request):request,
                            dataType: "json",
                            autocompleteRequest: ++requestIndex,
                            success: function(data, status) {
                                if(this.autocompleteRequest === requestIndex) {
                                    response(data);
                                }
                            },
                            error: function() {
                                if(this.autocompleteRequest === requestIndex) {
                                    response([]);
                                }
                            }
                        });
                    };
                }
            },

            _response: function(content) {
                var self = this;
                if(!this.options.disabled && content && content.length) {
                    if(this.options.autoChoose && content && content.length === 1) {
                        this.element.wafPromptBox('setValue', content[0]);
                        this.close();
                    } else {
                        this._suggest(content);
                        $(document).bind("mousedown.wafPromptAutoComplete", function(event){
                            var $target = $(event.target);
                            if($target.closest(self.menu.element).length == 0 && $target.closest(self.frame).length == 0){
                                self.close();
                            }
                        });
                        this._trigger("onopen");
                    }
                } else {
                    this.close();
                }
                this._block(false);
            },

            _suggest: function(items) {
                this.menu.element.attr('style', this.options.style).addClass(this.options.tagClass);
                if(this.options.maxHeight != null) {
                    this.menu.element.css({
                        "maxHeight": this.options.maxHeight,
                        "overflow": "auto"
                    });
                }
                $.ui.wafAutoCompleteTemplate.prototype._suggest.apply(this, arguments);
            },

            _renderItem: function(ul, item) {
                var formatter = this.options.formatter,
                    output = formatter!=null && $.isFunction(formatter) ?
                        formatter.call(this, item, this.options, ul) : item[this.options.autoCompleteItem];

                return $("<li></li>")
                        .data("item.wafAutoCompleteTemplate", item)
                        .append("<a>" + output + "</a>")
                        .appendTo(ul);
            },

            open: function() {
                this._search("");
            },

            _search: function(value) {
                if(!this.hasOpen()) {
                    this._trigger('beforeOpen', 'beforeOpen', this.options);
                }
                $.ui.wafAutoCompleteTemplate.prototype._search.apply(this, arguments);
            },

            _getPosition: function(){
                return $.extend({
                    of: this.frame
                }, this.options.position );
            },

            _resizeMenu: function() {
                var ul = this.menu.element;
                ul.outerWidth( Math.max(
                    ul.width( "" ).outerWidth(),
                    this.frame.outerWidth()
                ) );
            },

            hasOpen: function(){
                return this.menu.element.is(":visible");
            },

            close: function(){
                $(document).unbind("mousedown.wafPromptAutoComplete");
                $.ui.wafAutoCompleteTemplate.prototype.close.apply(this, arguments);
            },

            _move: function(direction, event) {
                if(!this.menu.element.is(":visible")) {
                    return;
                }
                if(this.menu.first() && /^previous/.test(direction) || this.menu.last() && /^next/.test(direction)) {
                    this.element.val(this.term);
                    this.menu.deactivate();
                    return;
                }
                this.menu[direction](event);
            }
        });

        $.wafPromptAutoComplete = $.wafPromptAutoComplete || {};
        $.extend($.wafPromptAutoComplete, {
            escapeRegex: function(value) {
                return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
            },
            filter: function(array, term, key) {
                var matcher = new RegExp($.wafPromptAutoComplete.escapeRegex(term), "i");
                return $.grep(array, function(value) {
                    return matcher.test(value[key]);
                });
            },
            createPromptAutoCompleteDOM: function(opts) {
                return null;
            },
            initPromptAutoComplete: function(opts, el) {
                if(!$.wafutil.isViewOperateState(opts)) {
                    $.dynamicutil.addContextPath(opts, "dataUrl", "/component/promptAutoComplete.do?method=getData");
                    $("#" + opts.parentId).wafPromptAutoComplete(opts);
                }
            },
            removePromptAutoComplete: function(opts) {
                if(!$.wafutil.isViewOperateState(opts)) {
                    $("#" + opts.parentId).wafPromptAutoComplete("destroy");
                }
            },
            modifyPromptAutoComplete: function(opts) {
                if(!$.wafutil.isViewOperateState(opts)) {
                    $.dynamicutil.addContextPath(opts, "dataUrl", "/component/promptAutoComplete.do?method=getData");
                    $("#" + opts.parentId).wafPromptAutoComplete('option', opts);
                }
            }
        });

        $(function() {
            if($.registerComponent)
                $.registerComponent("promptAutoComplete", {
                    createDOMFun: $.wafPromptAutoComplete.createPromptAutoCompleteDOM,
                    initFun: $.wafPromptAutoComplete.initPromptAutoComplete,
                    deleteFun: $.wafPromptAutoComplete.removePromptAutoComplete,
                    modifyFun: $.wafPromptAutoComplete.modifyPromptAutoComplete,
                    lazyInit:true
                });
        });
    }(jQuery));
//});
/*
 * bootstrap
 */
(function( $, undefined ) {

    $.widget("ui.wafTooltip",{
        enabled: true,
        timeout: null,
        hoverState: null,
        type: 'tooltip',
        options:{
            animation: true,
            placement: 'top',
            selector: false,
            template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
            trigger: 'hover focus',
            title: '',
            delay: 0,
            html: false,
            container: false
        },
        widget:function () {
            return this.element;
        },
        _create: function(){
            this.initialize()
        },
        initialize: function () {
            var triggers = this.options.trigger.split(' ')

            for (var i = triggers.length; i--;) {
                var trigger = triggers[i]

                if (trigger == 'click') {
                    this.element.bind('click.' + this.type,  $.proxy(this.toggle, this))
                } else if (trigger != 'manual') {
                    var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focus'
                    var eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'

                    this.element.bind(eventIn  + '.' + this.type, $.proxy(this.enter, this))
                    this.element.bind(eventOut + '.' + this.type, $.proxy(this.leave, this))
                }
            }

            this.options.selector ?
                (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
                this.fixTitle()


        },

        enter: function (obj) {
            var self = this;
            clearTimeout(self.timeout)

            self.hoverState = 'in'

            if (!self.options.delay || !self.options.delay.show) return self.show()

            self.timeout = setTimeout(function () {
                if (self.hoverState == 'in') self.show()
            }, self.options.delay.show)
        },

        leave: function (obj) {
            var self = this;

            clearTimeout(self.timeout)

            self.hoverState = 'out'

            if (!self.options.delay || !self.options.delay.hide) return self.hide()

            self.timeout = setTimeout(function () {
                if (self.hoverState == 'out') self.hide()
            }, self.options.delay.hide)
        },

        show: function () {
            var e = $.Event('show.bs.'+ this.type)

            if (this.hasContent() && this.enabled) {
                this.element.trigger(e)

                if (e.isDefaultPrevented()) return

                var $tip = this.tip()

                this.setContent()

                if (this.options.animation) $tip.addClass('fade')

                var placement = typeof this.options.placement == 'function' ?
                    this.options.placement.call(this, $tip[0], this.element[0]) :
                    this.options.placement

                var autoToken = /\s?auto?\s?/i
                var autoPlace = autoToken.test(placement)
                if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

                $tip
                    .detach()
                    .css({ top: 0, left: 0, display: 'block' })
                    .addClass(placement)

                this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.element)

                var pos          = this.getPosition()
                var actualWidth  = $tip[0].offsetWidth
                var actualHeight = $tip[0].offsetHeight

                if (autoPlace) {
                    var $parent = this.element.parent()

                    var orgPlacement = placement
                    var docScroll    = document.documentElement.scrollTop || document.body.scrollTop
                    var parentWidth  = this.options.container == 'body' ? window.innerWidth  : $parent.outerWidth()
                    var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight()
                    var parentLeft   = this.options.container == 'body' ? 0 : $parent.offset().left

                    placement = placement == 'bottom' && pos.top   + pos.height  + actualHeight - docScroll > parentHeight  ? 'top'    :
                        placement == 'top'    && pos.top   - docScroll   - actualHeight < 0                         ? 'bottom' :
                            placement == 'right'  && pos.right + actualWidth > parentWidth                              ? 'left'   :
                                placement == 'left'   && pos.left  - actualWidth < parentLeft                               ? 'right'  :
                                    placement

                    $tip
                        .removeClass(orgPlacement)
                        .addClass(placement)
                }

                var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

                this.applyPlacement(calculatedOffset, placement)
                this.element.trigger('shown.bs.' + this.type)
            }
        },

        applyPlacement: function(offset, placement) {
            var replace
            var $tip   = this.tip()
            var width  = $tip[0].offsetWidth
            var height = $tip[0].offsetHeight

            // manually read margins because getBoundingClientRect includes difference
            var marginTop = parseInt($tip.css('margin-top'), 10)
            var marginLeft = parseInt($tip.css('margin-left'), 10)

            // we must check for NaN for ie 8/9
            if (isNaN(marginTop))  marginTop  = 0
            if (isNaN(marginLeft)) marginLeft = 0

            offset.top  = offset.top  + marginTop
            offset.left = offset.left + marginLeft

            $tip
                .offset(offset)
                .addClass('in')

            // check to see if placing tip in new offset caused the tip to resize itself
            var actualWidth  = $tip[0].offsetWidth
            var actualHeight = $tip[0].offsetHeight

            if (placement == 'top' && actualHeight != height) {
                replace = true
                offset.top = offset.top + height - actualHeight
            }

            if (/bottom|top/.test(placement)) {
                var delta = 0

                if (offset.left < 0) {
                    delta       = offset.left * -2
                    offset.left = 0

                    $tip.offset(offset)

                    actualWidth  = $tip[0].offsetWidth
                    actualHeight = $tip[0].offsetHeight
                }

                this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
            } else {
                this.replaceArrow(actualHeight - height, actualHeight, 'top')
            }

            if (replace) $tip.offset(offset)
        },

        replaceArrow: function(delta, dimension, position) {
            this.arrow().css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
        },

        setContent: function () {
            var $tip  = this.tip()
            var title = this.getTitle()

            $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
            $tip.removeClass('fade in top bottom left right')
        },

        hide: function () {
            var that = this
            var $tip = this.tip()
            var e    = $.Event('hide.bs.' + this.type)

            function complete() {
                if (that.hoverState != 'in') $tip.detach()
            }

            this.element.trigger(e)

            if (e.isDefaultPrevented()) return

            $tip.removeClass('in')

            $.support.transition && this.$tip.hasClass('fade') ?
                $tip
                    .one($.support.transition.end, complete)
                    .emulateTransitionEnd(150) :
                complete()

            this.element.trigger('hidden.bs.' + this.type)

            return this
        },

        fixTitle: function () {
            var $e = this.element
            if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
                $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
            }
        },

        hasContent: function () {
            return this.getTitle()
        },

        getPosition: function () {
            var el = this.element[0]
            return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
                width: el.offsetWidth
                , height: el.offsetHeight
            }, this.element.offset())
        },

        getCalculatedOffset: function (placement, pos, actualWidth, actualHeight) {
            return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
                placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
                    placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
                        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }
        },

        getTitle: function () {
            var title
            var $e = this.element
            var o  = this.options

            title = $e.attr('data-original-title')
                || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

            return title
        },

        tip: function () {
            return this.$tip = this.$tip || $(this.options.template)
        },


        arrow: function () {
            return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow')
        },


        validate:  function () {
            if (!this.element[0].parentNode) {
                this.hide()
                this.element = null
                this.options  = null
            }
        },

        enable: function () {
            this.enabled = true
        },

        disable: function () {
            this.enabled = false
        },

        toggleEnabled: function () {
            this.enabled = !this.enabled
        },

        toggle: function (e) {
            //var self = e ? $(e.currentTarget)[this.type](this.options).data('bs.' + this.type) : this
            var self = this; //
            self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
        },

        destroy: function () {
            this.hide().element.off('.' + this.type).removeData('bs.' + this.type)
        }
    });
    //end widget



}(jQuery));
/*
 * bootstrap
 */
(function( $, undefined ) {
    $.widget("ui.wafPopover", $.ui.wafTooltip ,{

        options:{
            animation: true,
            placement: 'right',
            selector: false,
            template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>',
            trigger: 'click',
            title: '',
            delay: 0,
            html: false,
            container: false,
            content: ''
        },

        setContent: function () {
            var $tip    = this.tip()
            var title   = this.getTitle()
            var content = this.getContent()

            $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
            $tip.find('.popover-content')[this.options.html ? 'html' : 'text'](content)

            $tip.removeClass('fade top bottom left right in')

            // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
            // this manually by checking the contents.
            if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
        },

        hasContent: function () {
            return this.getTitle() || this.getContent()
        },

        getContent: function () {
            var $e = this.element
            var o  = this.options

            return $e.attr('data-content')
                || (typeof o.content == 'function' ?
                o.content.call($e[0]) :
                o.content)
        },

        arrow: function () {
            return this.$arrow = this.$arrow || this.tip().find('.arrow')
        },

        tip: function () {
            if (!this.$tip) this.$tip = $(this.options.template)
            return this.$tip
        }
    });
    //end widget

}(jQuery));
/*
 * bootstrap
 */
(function( $, undefined ) {
    // support for jQuery 1.3.2 - handle common attrFn methods for dialog
    attrFn = $.attrFn || {
        val: true,
        css: true,
        html: true,
        text: true,
        data: true,
        width: true,
        height: true,
        offset: true,
        click: true
    };

    $.widget("ui.wafPopoverMsgbox", $.ui.wafPopover ,{

        options:{
            animation: true,
            placement: 'right',
            selector: false,
            width:null,
            height:null,
            template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>',
            trigger: 'click',
            title: '',
            delay: 0,
            html: true,
            container: false,
            content: '',
            buttons: null
        },

        setContent: function () {
            var $tip    = this.tip()
            var title   = this.getTitle()
            var content = this.getContent()

            $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
            $tip.find('.popover-content')[this.options.html ? 'html' : 'text'](content)
            this._createButtons(this.options.buttons);

            $tip.removeClass('fade top bottom left right in')

            // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
            // this manually by checking the contents.
            if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()


            //
            if(!$.isNaN(this.options.width)) $tip.css('width',this.options.width);
            if(!$.isNaN(this.options.height)) $tip.css('height',this.options.height);

        },

        hasContent: function () {
            return this.getTitle() || this.getContent()
        },

        getContent: function () {
            var $e = this.element
            var o  = this.options

            return $e.attr('data-content')
                || (typeof o.content == 'function' ?
                o.content.call($e[0]) :
                o.content)
        },

        arrow: function () {
            return this.$arrow = this.$arrow || this.tip().find('.arrow')
        },

        tip: function () {
            if (!this.$tip) this.$tip = $(this.options.template)
            return this.$tip
        },

        _createButtons: function(buttons) {
            var self = this,
            hasButtons = false,
            uiDialogButtonPane = $('<div style="border: 0px; border-top:1px solid #aaaaaa;text-align: right;margin: 5px;padding: 3px"></div>')
                .addClass(
                'ui-dialog-buttonpane ' +
                    'ui-widget-content ' +
                    'ui-helper-clearfix'
            ),
            uiButtonSet = $( "<div></div>" )
                .addClass( "ui-dialog-buttonset" )
                .appendTo( uiDialogButtonPane );

            // if we already have a button pane, remove it
            self.tip().find('.ui-dialog-buttonpane').remove();

            if (typeof buttons === 'object' && buttons !== null) {
                $.each(buttons, function() {
                    return !(hasButtons = true);
                });
            }
            if (hasButtons) {
                $.each(buttons, function(name, props) {
                    props = $.isFunction( props ) ?
                    { click: props, text: name } :
                        props;
                    var button = $('<button type="button"></button>')
                        .click(function() {
                            props.click.apply(self.element[0], arguments);
                        })
                        .appendTo(uiButtonSet);
                    // can't use .attr( props, true ) with jQuery 1.3.2.
                    $.each( props, function( key, value ) {
                        if ( key === "click" ) {
                            return;
                        }
                        if ( key in attrFn ) {
                            button[ key ]( value );
                        } else {
                            button.attr( key, value );
                        }
                    });
                    if ($.fn.button) {
                        button.button();
                    }
                });
                uiDialogButtonPane.appendTo(self.tip());
            }
        }
    });
    //end widget

    $.popMsgBox = $.popMsgBox || {};

    $.extend($.popMsgBox, {
        showInfo: function(elem, opts, func) {
            var infoButton = {};

            //TODO  $.msgbox.buttonText.ok
            infoButton[""] =  function(){
                var f = null;
                if ($.isFunction(func)){
                    if(func() === false) return;
                }
                $(elem).wafPopoverMsgbox('toggle');
            };

            $(elem).wafPopoverMsgbox($.extend(opts,{
                trigger: 'manual',
                buttons: infoButton
            }));
            $(elem).wafPopoverMsgbox('show');
        },

        showConfirm: function(elem, opts, funcOk, funcCancel) {
            var confirmButtons = {};

            //TODO  $.msgbox.buttonText.ok
            confirmButtons[""] =  function(){
                if ($.isFunction(funcOk)) {
                    if(funcOk() === false) return;
                }
                $(elem).wafPopoverMsgbox('toggle');
            };

            //TODO  $.msgbox.buttonText.cancel
            confirmButtons[''] = function(){
                if($.isFunction(funcCancel)){
                    if(funcCancel() === false) return;
                }
                $(elem).wafPopoverMsgbox('toggle');
            };

            $(elem).wafPopoverMsgbox($.extend(opts,{
                trigger: 'manual',
                buttons: confirmButtons
            }));
            $(elem).wafPopoverMsgbox('show');
        }
    });


    $.popMsg = $.popMsg || {};

    $.extend($.popMsg, {
        show: function(elem, opts) {
            var hideOnBlur =  true;
            if(opts && opts.hideOnBlur === false){
                hideOnBlur = false;
            }

            $(elem).wafPopover($.extend(opts,{
                trigger: 'manual',
                placement:"auto"
            }));
            $(elem).wafPopover('show');

            if(opts && hideOnBlur){
                $(elem).blur(function(){
                    $(elem).wafPopover('hide');
                });
            }
        },

        hide: function(elem) {
            $(elem).wafPopover('hide');
        },

        toggle: function(elem) {
            $(elem).wafPopover('toggle');
        }
    });



}(jQuery));


;
/* Chinese initialisation for the jQuery UI date picker plugin. */
/* Written by Cloudream (cloudream@gmail.com). */
jQuery(function($){
	$.datepicker.regional['zh-CN'] = {
		closeText: '',
		prevText: '&#x3c;',
		nextText: '&#x3e;',
		currentText: '',
		monthNames: ['','','','','','',
		'','','','','',''],
		monthNamesShort: ['','','','','','',
		'','','','','',''],
		dayNames: ['','','','','','',''],
		dayNamesShort: ['','','','','','',''],
		dayNamesMin: ['','','','','','',''],
		weekHeader: '',
		dateFormat: 'yy-mm-dd',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['zh-CN']);
});

//mod.defineModule("msgbox-i18n",["base"],function(){
;(function($){
        $.msgbox = {
            buttonText : {
                ok: "",
                cancel: "",
                yes: "",
                no : "",
                detail:""
            },
            other : {
                title : ""
            }
        }
    })(jQuery);
//});
    /*
     * Translated default messages for the jQuery validation plugin.
     * Locale: CN
     */
//mod.defineModule("validator_i18n", ["base","validator_inner"], function() {
    $.validator = $.validator || {};
    jQuery.extend(jQuery.validator.messages, {
            required: "",
            remote: "",
            email: "",
            url: "",
            date: "",
            dateISO: " (ISO).",
            number: "",
            digits: "",
            creditcard: "",
            equalTo: "",
            accept: "",
            maxlength: jQuery.validator.format(" {0} "),
            minlength: jQuery.validator.format(" {0} "),
            rangelength: jQuery.validator.format(" {0}  {1} "),
            range: jQuery.validator.format(" {0}  {1} "),
            max: jQuery.validator.format(" {0} "),
            min: jQuery.validator.format(" {0} "),
            summaryMsg:"{0}"
    });
//});
//mod.defineModule("select_i18n",["base"],function(){
    (function($) {
        $.wafSelect = $.wafSelect || {};
        $.wafSelect.textOptions =   {
            header: false,
            selectedList: 1,
            multiple: false,
            checkAllText: '',
            uncheckAllText: '',
            noneSelectedText: '',
            selectedText: '# ',
            label: ":",
            placeholder: ""
        }
    }(jQuery));
//});

/* Simplified Chinese initialisation for the jQuery UI multiselect plugin. */
/* Written by Ben (ben@zfben.com). */

$.extend($.ech.multiselect.prototype.options, {
	header: false,
	selectedList: 1,
	multiple: false,
	checkAllText: '',
	uncheckAllText: '',
	noneSelectedText: '',
	selectedText: '# '
});

/* Simplified Chinese initialisation for the jQuery UI multiselect plugin. */
/* Written by Ben (ben@zfben.com). */

$.extend($.ech.multiselectfilter.prototype.options, {
	label: ":",
	placeholder: ""		
});

//mod.defineModule("promptGrid_i18n",["base"],function(){
    ;(function($){
    $.wafPromptGrid = $.wafPromptGrid || {};
    $.extend($.wafPromptGrid, {
        defaults : {
            searchInResultText : "",
            recordtext: "{0} - {1}\u3000 {2} ",	// 
            pgtext : " {0}  {1} ",
            numberOrName : " + "
        },
        button : {
            submit: "",
            cancel: "",
            search: ""
        },
        bool : {
            yes : "",
            no : ""
        }
    });
    })(jQuery);
//});
//mod.defineModule("promptQuick_i18n",["base"],function(){
    ;(function($){
    $.wafPromptQuick = $.wafPromptQuick || {};
    $.extend($.wafPromptQuick, {
        defaults : {
            searchInResultText : "",
            recordtext: "{0} - {1}\u3000 {2} ",	// 
            pgtext : " {0}  {1} "
        },
        button : {
            submit: "",
            cancel: "",
            search: ""
        },
        bool : {
            yes : "",
            no : ""
        }
    });
    })(jQuery);
//});
//mod.defineModule("promptTree_i18n",["base"],function(){
    ;(function($){
    $.wafPromptTree = $.wafPromptTree || {};
    $.extend($.wafPromptTree, {
        button : {
            submit: "",
            cancel: "",
            search: ""
        }
    });
    })(jQuery);
//});


//mod.defineModule("promptTable_i18n",["base"],function(){
;(function($){
    $.wafPromptTable = $.wafPromptTable || {};
    $.extend($.wafPromptTable, {
        defaults : {
            searchInResultText : "",
            numberOrName : " + "
        },
        button : {
            submit: "",
            cancel: "",
            search: ""
        }
    });
    })(jQuery);
//});
//mod.defineModule("grid_i18n", ["base"],function(){
    (function($){
        $.jgrid = $.jgrid || {};
        $.extend($.jgrid,{
            defaults : {
                recordtext: "{0} - {1}\u3000 {2} ",	// 
                emptyrecords: "",
                loadtext: "...",
                pgtext : " {0}  {1} "
            },
            errors : {
                errcap : "",
                nourl : "url",
                norecords: "",
                model : "colNames  colModel "
            },
            formatter : {
                integer : {thousandsSeparator: ",", defaultValue: '0'},//modify by jlg
                number : {decimalSeparator:".", thousandsSeparator: " ", decimalPlaces: 2, defaultValue: '0.00'},
                currency : {decimalSeparator:".", thousandsSeparator: ",", decimalPlaces: 2, prefix: "", suffix:"", defaultValue: '0.00'},//modify by jlg
                date : {
                    dayNames:   [
                        "Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat",
                        "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
                    ],
                    monthNames: [
                        "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
                        "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
                    ],
                    AmPm : ["am","pm","AM","PM"],
                    S: function (j) {return j < 11 || j > 13 ? ['st', 'nd', 'rd', 'th'][Math.min((j - 1) % 10, 3)] : 'th'},
                    srcformat: 'Y-m-d',
                    newformat: 'm-d-Y',
                    masks : {
                        ISO8601Long:"Y-m-d H:i:s",
                        ISO8601Short:"Y-m-d",
                        ShortDate: "Y/j/n",
                        LongDate: "l, F d, Y",
                        FullDateTime: "l, F d, Y g:i:s A",
                        MonthDay: "F d",
                        ShortTime: "g:i A",
                        LongTime: "g:i:s A",
                        SortableDateTime: "Y-m-d\\TH:i:s",
                        UniversalSortableDateTime: "Y-m-d H:i:sO",
                        YearMonth: "F, Y"
                    },
                    reformatAfterEdit : false
                },
                baseLinkUrl: '',
                showAction: '',
                target: '',
                checkbox : {disabled:false},
                idName : 'id'
            },
            booleanCaption:{
                yes:"",
                no:""
            },
            pager:{
                rowListCaption:"",
                moreButtonText:"...",
                noMoreDataText : "",
                nextPageText : "",
                prePageText : ""
            },
            pageNav:{
                first:"",
                next:"",
                prev:"",
                end:""
            },
            noquerydata:{
                info:""
            }
        });
    })(jQuery);
//});


//mod.defineModule("fileuploadui_i18n", ["base"], function() {
    ;
    (function($) {
        $.wafFileUploadUI = $.wafFileUploadUI || {};
        $.extend($.wafFileUploadUI, {
            defaults : {
                "upload" : "",
                "cancel" : "",
                "remove" : "",
                "addFile" : "",
                "uploadAll" : "",
                "cancelAll" : "",
                "removeAll" : ""
            },
            errors : {
                "acceptFileTypes" : "",
                "maxFileSize": "",
                "minFileSize": "",
                "maxNumberOfFiles": ""
            },
            removeDialog : {
                "title" : "",
                "msg" : "?"
            },
            removeAllDialog : {
                "title" : "",
                "msg" : "?"
            }
        });
    })(jQuery);
//});

//mod.defineModule("timePicker_i18n",["base","waf"],function(){
    /* Chinese initialisation for the jQuery UI date picker plugin. */
    /* Written by Cloudream (cloudream@gmail.com). */
    jQuery(function($){
        $.wafDatepicker = $.wafDatepicker || {};
        $.wafDatepicker.timeResource = {
            timeOnlyTitle: '',
            timeText: '',
            hourText: '',
            minuteText: '',
            secondText: '',
            millisecText: '',
            currentText: '',
            closeText: '',
            ampm: false,
            timeFormat: 'hh:mm:ss'
        }
    });
//});
//mod.defineModule("timePicker_i18n",["base"],function(){
    ;(function($){
    $.wafTimePicker = $.wafTimePicker || {};
    $.extend($.wafTimePicker, {
        meridian: {
            am: "",
            pm: ""
        }
    });
    })(jQuery);
//});

//mod.defineModule("dataView_i18n", ["base"], function() {
    ;(function($){
    $.wafDataView = $.wafDataView || {};
    $.extend($.wafDataView, {
        pager : {
            moreButtonText : "...",
            noMoreDataText : "",
            nextPageText : "",
            prePageText : ""
        },
        switcher:{
            gridText:"",
            defaultText:""
        },
        toGrid:{
            operationColumnLable:""
        },
        data:{
            loadingText:"..."
        }
    });
    })(jQuery);
//});

//mod.defineModule("window-i18n",["base"],function(){
    ;(function($){
        $.window = $.window || {};
        $.window.loadding = {
            min: "!",
            max: "!",
            move: "!",
            close : "!",
            loadingText:"..."
        }
    })(jQuery);
//});


/**
* WAFJS
* @author JASON LIU
* @class WAFJS
* @constructor
*/
waf.defineClass("waf.framework.WafCore",null,{
	/**
	 * :wafJS
	 * @type String
	 */
	wafPageLogic:"waf page logic",
	/**
	 * :conversation
	 * @type boolean
	 */
	conversationSupport:false,
	/**
	 * :conversationID
	 * @deprecated
	 */
	conversationID:null,
	/**
	 * :UI PK
	 * @type String
	 */
	uiMetadataPK:null,
	/**
	 * :
	 * @type waf.framework.WafCore_Locale_Lx's subclass
	 */
	localeStr:null,
	/**
	 * 
	 * @param {} value
	 */
	mockdata:{},
	/**
	 * :/conversation
	 * @param value of boolean conversation
	 * @deprecated
	 */
	setConversationSupport:function(value){
		_self.conversationSupport=value;
	},
	/**
	 * conversation
	 * @deprecated
	 * @return conversation
	 */
	getConversationSupport:function(){		
		return _self.conversationSupport;
	},
	/**
	 * :conversationid
	 * @param value of boolean trueconversation,falseconversationid
	 * @deprecated
	 */
	setConversationID:function(value){		
		_self.conversationID=value;
	},
	/**
	 * :conversation id
	 * @return conversation id
	 */
	getConversationID:function(){			
		return _self.conversationID;
	},
	/**
	 * UIPK
	 * @param value of String UIPK
	 */
	setUIMetadataPK:function(value){		
		_self.uiMetadataPK=value;
	},
	/**
	 * : UI PK
	 * @return UIPK
	 */
	getUIMetadataPK:function(){
		return _self.uiMetadataPK;
	},
	/**
	 * : 
	 * @deprecated
	 */
	getMessages:function(){
		
	},
	/**
	 * :JS
	 */
	initalizeAction:function(){				
		
	},
	/**
	 * :DOMDOM,JS
	 */
	initalizeDOM:function(){				
		
	},
	/**
	 * :
	 */
	initalizeEvent:function(){				
		
	},
	/**
	 * :
	 * @return truefalse.
	 */
	closeAction:function(){				
		return true;
	},
	/**
	 * :
	 * @return truefalse.
	 */
	destroyAction:function(){				
		waf.doPost(
			{
				action:'destroy',
				showBlock:false,
				async:false,
				success:function(data){
					return true;
				},
				error:function(response, textStatus, errorThrown){
					return true;
				}
			}
		);
	}
});

/**
* WAFJS_
* @author JASON LIU
* @class WAFJS_
* @constructor
*/
waf.defineClass("waf.framework.WafCore_LocaleStr_l1",null,{
	
});
waf.defineClass("waf.framework.WafCore_LocaleStr_l2",null,{
	
});
waf.defineClass("waf.framework.WafCore_LocaleStr_l3",null,{
	
});
/****WafPageDeclareBegin************/
waf.defineClass("waf.framework.wafPage",waf.framework.WafCore,{
    _pageMain:null,
    _minIframeHeight:800,
    iframes:new Array(),
    tabNum:0,
    isInFramePage:true,
	/**
	 * 
	 */
	initalizeAction:function(){
	    var source = decodeURIComponent(_self.getUrlParam("source"));
	    _self._pageMain = waf("#wafpagemain");
	    var options = {source:source};
	    _self.addPageTab(options);
	    waf("#breadCrumbs").breadCrumbs("option","onclick",function() {
	        var id = this.id;
	        _self.returnPageTab(id);
	    });
	},
	
	/**
	 * url
	 */
	getUrlParam:function(param){
	    var args=new Object();
        var query=location.search.substring(1);//
        args.tabpk=query.substring(query.indexOf("tabpk=")+6,query.indexOf("&"));
        args.source=query.substring(query.indexOf("source=")+7,query.length);
	    return args[param];
	},
	 
	/**
     * :wafpageiframe
     */
    addPageTab:function (options) {
        var tabpk = "tab_"+_self.tabNum,
            source = options.source,
            onRemove = options.onRemove;
        for (var i=0;i<_self.iframes.length;i++) {
    	    if (_self.iframes[i].tabpk!=tabpk) 
    	        waf("#div_"+_self.iframes[i].tabpk).hide();
    	}
    	_self.tabNum++;
    	var div = waf("<div id='div_"+tabpk+"'></div>");
    	waf.appendDOM(_self._pageMain, div);
        //iframe
    	var breadCrumbsHeight = waf("#breadCrumbs").height();
        _self._minIframeHeight = window.document.body.clientHeight-breadCrumbsHeight-35;
        var iframe = waf("<iframe id='frame_"+tabpk+"' name='frame_"+tabpk+"' "
	             +"width='100%' height='"+_self._minIframeHeight+"' frameborder=0 scrolling='no'>"
	             +"</iframe>");
    	iframe.attr("src",source);
    	waf.appendDOM(div, iframe);
    	
    	iframe.load(function(e){
    	    _self.autoHeight(this);
    	    
    	    var title=iframe.contents().attr("title");
    	    _self.iframes.push({tabpk:tabpk,title:title,onRemove:onRemove});
    	    
    	    waf("#breadCrumbs").breadCrumbs("setCrumb",{title:title, tabpk:tabpk});
            waf("#breadCrumbs").breadCrumbs("cleanCrumbs");
    	    waf("#breadCrumbs").breadCrumbs("createCrumbs",title,tabpk);
        });
        
        window.setInterval("_self.autoHeightIframe()", 500);
     },
     
    /**
     * :wafpageiframe
     */
    removePageTab:function (tabpk) {
        var nowTab=null,
            index=_self.iframes.length;
        for (var i=0;i<_self.iframes.length;i++) {
    	    if (_self.iframes[i].tabpk==tabpk) {
    	        waf("#div_"+_self.iframes[i].tabpk).empty();
    	        waf("#div_"+_self.iframes[i].tabpk).remove();
    	        nowTab = _self.iframes[i-1];
    	        index=i;
    	        if (_self.iframes[i].onRemove!=null)
    	            _self.iframes[i].onRemove();
    	        
    	        break;
     	    }
    	}
    	
    	waf("#div_"+nowTab.tabpk).show();
    	_self.iframes.splice(index, (_self.iframes.length - index));
    	waf("#breadCrumbs").breadCrumbs("removeCrumb",index);
    	waf("#breadCrumbs").breadCrumbs("cleanCrumbs");
    	waf("#breadCrumbs").breadCrumbs("createCrumbs",nowTab.title,nowTab.tabpk);
    },
     
    /**
     * :wafpageiframe
     */
    returnPageTab:function (tabpk) {
        var nowTab=null,
            length=_self.iframes.length,
            index=length;
        for (var i=length-1;i>=0;i--) {
            var iframe=_self.iframes[i];
    	    if (iframe.tabpk!=tabpk) {
    	        waf("#div_"+iframe.tabpk).empty();
    	        waf("#div_"+iframe.tabpk).remove();
    	        if (iframe.onRemove!=null)
    	            iframe.onRemove();
    	    } else {
    	        nowTab = iframe;
    	        index=i+1;
    	        break;
     	    }
    	}
    	
    	waf("#div_"+nowTab.tabpk).show();
    	_self.iframes.splice(index, (length - index));
    	waf("#breadCrumbs").breadCrumbs("removeCrumb",index);
    	waf("#breadCrumbs").breadCrumbs("cleanCrumbs");
    	waf("#breadCrumbs").breadCrumbs("createCrumbs",nowTab.title,nowTab.tabpk);
    },
    
    /**
     * :iframe
     */
    closeCurPageTab:function () {
        var length = _self.iframes.length;
        if (length>1) {
            var tabpk = _self.iframes[length-1].tabpk;
            _self.removePageTab(tabpk);
        } else {
            if (waf.windowMgr.getTargetObj()){
        		waf.window.close();
        	} else{ 
			   	window.close();
			}
		}
    },
     
    /**
     *  
     */
    autoHeight:function (iframe) {
        try{
            var height = iframe.contentWindow.document.body.scrollHeight;
            if(height < _self._minIframeHeight){
                height = _self._minIframeHeight;
            }
            iframe.height = height;
        }catch (ex){
            if(iframe.height < _self._minIframeHeight){
                iframe.height = _self._minIframeHeight;
            }
        }
    },
    
    autoHeightIframe:function () {
        var length=_self.iframes.length;
        for (var i=0;i<length;i++) {
            var display=waf("#div_"+_self.iframes[i].tabpk).css("display");
            if (display!=null&&display!="none")
               _self.autoHeight(waf("#frame_"+_self.iframes[i].tabpk)[0]); 
        }
    }
	
	
});

/****WafPageDeclareEnd************/
/**
* WAFJS
* @author JASON LIU
* @class WAFJS
* @constructor
* @see superclass waf.framework.core
*/
waf.defineClass("waf.framework.List",waf.framework.WafCore,{
	/**
	 * :
	 * @type waf.window 
	 */
	editWin:null,
	/**
	 * :
	 * @action
	 */
	initalizeAction:function(){
		waf.framework.List.superClass.initalizeAction.call(_self);
		var urlParams=waf.getUrlParams(document.location.href);
		if(urlParams.hasToolbar=="false"){
			waf("#toolBarUp").wafToolBar("option","style","display:none;");
		}
	},
	/**
	 * :
	 * @action 
	 */
	firstPageAction:function(){
		if(waf("#grid").dataGrid("option","page")<=1){
			waf.msgBox.showInfo({
				summaryMsg:_self.localeStr.FIRSTPAGE_ALERT
			});
			
			return ;
		}
		waf.doPost(
			{
				action:'firstPage',
				param:"page=1",
				data:null,
				success:function(data){
					waf("#grid").dataGrid("option","page",1);
					waf("#grid").dataGrid("reloadGrid");
				}
			}
		);
	},
	/**
	 * 
	 * @action
	 */
	previewPageAction:function(){	
		if(waf("#grid").dataGrid("option","page")<=1){
			waf.msgBox.showInfo({
				summaryMsg:_self.localeStr.FIRSTPAGE_ALERT
			});
			
			return ;
		}
		
		waf.doPost(
			{
				action:'previewPage',
				param:"page=" + (parseInt(waf("#grid").dataGrid("option","page")) -1 ),
				success:function(data){
					waf("#grid").dataGrid("option","page",parseInt(parseInt(waf("#grid").dataGrid("option","page")) - 1));
					waf("#grid").dataGrid("reloadGrid");
				}
			}
		);
	},
	/**
	 * 
	 * @action
	 */
	nextPageAction:function(){		
		if(waf("#grid").dataGrid("option","page")>=waf("#grid").dataGrid("option","totalPages")){
			waf.msgBox.showInfo({
				summaryMsg:_self.localeStr.LASTTPAGE_ALERT
			});
			
			return ;
		}

		waf.doPost(
			{
				action:'nextPage',
				param:"page=" + (parseInt(waf("#grid").dataGrid("option","page")) + 1 ),
				success:function(data){
					waf("#grid").dataGrid("option","page",parseInt(parseInt(waf("#grid").dataGrid("option","page")) + 1));
					waf("#grid").dataGrid("reloadGrid");
				}
			}
		);
	},
	/**
	 * 
	 * @action
	 */
	lastPageAction:function(){		
		if(waf("#grid").dataGrid("option","page")>=waf("#grid").dataGrid("option","totalPages")){
			waf.msgBox.showInfo({
				summaryMsg:_self.localeStr.LASTTPAGE_ALERT
			});
			
			return ;
		}
	
		waf.doPost(
			{
				action:'lastPage',
				param:"page=" + parseInt(waf("#grid").dataGrid("option","totalPages")),
				success:function(data){
					waf("#grid").dataGrid("option","page",parseInt(waf("#grid").dataGrid("option","totalPages")));
					waf("#grid").dataGrid("reloadGrid");
				}
			}
		);
	},
	/**
	 * 
	 * @action
	 */
	advanceSearchAction:function(){
		waf("#commonQuery").commonQuery("showCommonQueryDialog",
			    {confirm:function(data){
			    	if (data!=null) {
			    	    waf("#grid").dataGrid("option","filterItems",data.filter);
			    	    waf("#grid").dataGrid("option","sorterItems",data.sorter);
			    	    waf("#grid").dataGrid("option","page",1);
		                waf("#grid").dataGrid("reloadGrid");
		                waf("#grid_native").jqGrid("setGridParam",{page:1});
		            }
			    },
			    cancel:function(){
				    
				}
			}
		);
	},
	/**
	 * :
	 * @action 
	 */
	addNewAction:function(){
		var winProperties=_self.getEditWinStyle();
		winProperties.url="?method=addNew";
		winProperties.close=function(event,ui){
			waf("#grid").dataGrid("reloadGrid");
		}
		winProperties.title=_self.localeStr.ADDNEW_TITLE;
		winProperties.onOpenCompleted=function(event,ui){
			waf(window).unbind("resize",$.window.doResize);
            waf(window).bind("resize",$.window.doResize);
		} 
		
		_self.editWin = waf.window.open(winProperties);
	},
	/**
	 * :
	 * @action 
	 */
	editAction:function(){			
		var selectedIds = waf("#grid").dataGrid("getSelectedRows");
        if(selectedIds.length>0){
            var modelID = $("#grid").wafGrid("getCell",selectedIds[0],"id");
            _self.editRecord(modelID);
        }else{
            waf.msgBox.showWarning({
                summaryMsg:_self.localeStr.NO_ROW_SELECTED
            });
        }
	},
	/**
	 * :
	 * @action 
	 */
	viewAction:function(){			
	    var selectedIds = waf("#grid").dataGrid("getSelectedRows");
        if(selectedIds.length>0){
            var modelID = $("#grid").wafGrid("getCell",selectedIds[0],"id");
            var winProperties=_self.getEditWinStyle();
            winProperties.title=_self.localeStr.VIEW_TITLE;
            winProperties.url="?method=view&modelID=" + waf.encodeURIComponent(modelID);
            winProperties.onOpenCompleted=function(event,ui){
                waf(window).unbind("resize",$.window.doResize);
                waf(window).bind("resize",$.window.doResize);
            }
            _self.editWin = waf.window.open(winProperties);
        }else{
            waf.msgBox.showWarning({
                summaryMsg:_self.localeStr.NO_ROW_SELECTED
            });
        }
	},
	/**
	 * :
	 * @action 
	 */
	deleteAction:function(){
		var selectedIds = waf("#grid").dataGrid("getSelectedRows");
	    if (selectedIds.length>0) {
	        var modelIDs = new Map();
	        for (var i=0;i<selectedIds.length;i++) {
	            var modelID = $("#grid").wafGrid("getCell",selectedIds[i],"id");
	            if (!modelIDs.containsKey(modelID))
	                modelIDs.put(modelID,modelID);
	        }
	        _self.deleteRecord(modelIDs.keys());
	    } else {
	        waf.msgBox.showWarning({
				summaryMsg:_self.localeStr.NO_ROW_SELECTED
			});
			return ;
	    }
	},
	/**
	 * : 
	 */
	deleteRecord:function(selectedIds){
		waf.msgBox.showConfirm({
					autoBtnClose:false,
		        	summaryMsg:_self.localeStr.DELETE_CONFIRM,   					
		        	buttonType:"ok-cancel",   					
		        	buttonCallBack:[
			        	function(dialog){
			        		waf.msgBox.close(dialog);
							waf.doPost(
								{
									action:'delete',
									param:"modelID=" + waf.encodeURIComponent(selectedIds.toString()),
									success:function(data){
										//
									waf("#grid").dataGrid("reloadGrid");
										//
										waf.msgBox.showInfo({
											summaryMsg:_self.localeStr.DELETE_SUCCESS
										});
									}
								}
							);
			        	},
			        	function(){
			        		//waf.msgBox.close(dialog);
			        	}
		        	]
		});
	},
	/**
	 * : 
	 */
	editRecord:function(selectedIds){
		var winProperties=_self.getEditWinStyle();
		winProperties.title=_self.localeStr.EDIT_TITLE;
		winProperties.url="?method=edit&modelID=" + waf.encodeURIComponent(selectedIds);
		winProperties.close=function(event,ui){
			var currentPage=waf("#grid").dataGrid("getGridParam","page");
			waf("#grid").dataGrid("setGridParam",{page:currentPage});
			waf("#grid").dataGrid("reloadGrid");
		}
		winProperties.onOpenCompleted=function(event,ui){
			waf(window).unbind("resize",$.window.doResize);
            waf(window).bind("resize",$.window.doResize);
		}

		_self.editWin = waf.window.open(winProperties);
	},
	/**
	 * : 
	 * @action
	 */
	refreshAction:function(){		
		waf.doPost(
			{
						action:'refresh',
						success:function(data){
							//
							waf("#grid").dataGrid("reloadGrid");
						}
			}
		);
	},
	/**
	 * 
	 * @action
	 */
	printAction:function(){			
		waf.doPost("print",null,null,
			function(data){
				document.location.reload();
			}
		);
	},
	/**
	 * 
	 */
	editRow:function(iRow){
		_self.editRecord(iRow);
	},
	/**
	 * 
	 */
	deleteRow:function(iRow){
		_self.deleteRecord(iRow);
	},
	/**
	 * 
	 */
	updateFieldStatus:function(field,viewable,editable){
		if(field==null)
			return ;

		if(viewable==false){
			waf("#grid").wafGrid("hideCol",field);
		}

		if(editable==false){
			var column = $("#grid").wafGrid("optionColumn",field);
			column.editable = false;
			$("#grid").wafGrid("optionColumn",field,column);
		}
	},
	/**
	 * :
	 * @return truefalse.
	 */
	destroyAction:function(){		
		if(_self.editWin!=null){
			var winIFrame=_self.editWin.children()[0];
			winIFrame.contentWindow._self.destroyAction();
		}
		waf.framework.List.superClass.destroyAction.call(_self);
	},
	/**
	 * '','',''
	 */
	 getEditWinStyle:function(){
	 	var winStyle={
	 				OpenType:"iframe",
				    //bgiframe: false,
				    method:'POST',
				    modal:true,
				    openFromParent:false,
				    position:'center',
				    showTitleBar : true,
					autoMax : false,
				    width: 850,
				    height: 600,
				    minHeight:600,
				    minWidth:850,
				    iconCls:"ui-icon-winIcon",
				    draggable: true,
				    resizable: false
				    //hideCloseBtn:true,
				    //showEffect:"slide",
//				    hideEffect: "slide"
		};
		return winStyle;
	 }
});
/**
* WAFJS_
* @author JASON LIU
* @class WAFJS_
* @constructor
* @see superclass waf.framework.core
*/
waf.defineClass("waf.framework.List_LocaleStr_l1",waf.framework.WafCore_LocaleStr_l1,{
	FIRSTPAGE_ALERT:"Already to the first page.",
	LASTTPAGE_ALERT:"Already to the last page.",
	NO_ROW_SELECTED:"No record is selected.",
	DELETE_CONFIRM:"Are you sure you want to delete the selected record?",
	DELETE_SUCCESS:"Deleted successfully.",
	SELECTONEROW:"Only one record can be selected.",
	ADDNEW_TITLE:"New",
	VIEW_TITLE:"View",
	EDIT_TITLE:"Edit",
	EXIT_CONFIRM:"Are you sure you want to close?"
});
waf.defineClass("waf.framework.List_LocaleStr_l2",waf.framework.WafCore_LocaleStr_l2,{
	FIRSTPAGE_ALERT:"",
	LASTTPAGE_ALERT:"",
	NO_ROW_SELECTED:"",
	DELETE_CONFIRM:"?",
	DELETE_SUCCESS:"",
	SELECTONEROW:"",
	ADDNEW_TITLE:"",
	VIEW_TITLE:"",
	EDIT_TITLE:"",
	EXIT_CONFIRM:"?"	
});
waf.defineClass("waf.framework.List_LocaleStr_l3",waf.framework.WafCore_LocaleStr_l3,{
	FIRSTPAGE_ALERT:"",
	LASTTPAGE_ALERT:"",
	NO_ROW_SELECTED:"",
	DELETE_CONFIRM:"?",
	DELETE_SUCCESS:"",
	SELECTONEROW:"",
	ADDNEW_TITLE:"",
	VIEW_TITLE:"",
	EDIT_TITLE:"",
	EXIT_CONFIRM:"?"	
});
/**
* WAFJS
* @author JASON LIU
* @class WAFJS
* @constructor
* @see superclass waf.framework.core
*/
waf.defineClass("waf.framework.Edit",waf.framework.WafCore,{
	/**
	 * :model ID
	 */
	getCurrentModelID:function(){
		return document.getElementById("id")==null?"":document.getElementById("id").value;
	},
	/**
	 * :
	 */
	getOperateState:function(){
		//URLoperateState
		var operateState = "";
		var url = document.location.search.substring(1);
		var qs = url.split("&");
		for (var i=0;i<qs.length;i++) {   
            var pos = qs[i].indexOf('=');
            var argname = qs[i].substring(0,pos); 
            if (argname == "operateState") {
                operateState = qs[i].substring(pos+1,qs[i].length); 
                break;
            }
        }
        return operateState;
	},
	/**
	 * :
	 * @action
	 */
	initalizeAction:function(){
		waf.framework.Edit.superClass.initalizeAction.call(_self);
		//dialogbeforeclose
		var target = waf.windowMgr.getTargetObj();
		if (target!=null) {
		    target.unbind("dialogbeforeclose");
            target.bind("dialogbeforeclose", function(event, ui) {  
	            return _self.closeAction();
            });
        }
	},
	/**
	 * 
	 * @action
	 */
	printAction:function(){						
		waf.doSubmit(
			{
				action:'print',
				success:function(data){
				
				}
			}
		);
	},
	/**
	 * :
	 * @action
	 */ 
	editAction:function(){
	    var modelID = document.getElementById("id").value;
		waf.doSubmit(
			{
				action:'edit',
				success:function(data){
					waf.redirect("?method=initalize&operateState=edit&modelID=" + waf.encodeURIComponent(modelID));
					var target = waf.windowMgr.getTargetObj();
					if (target!=null)
                        waf.window.changeTitle(_self.localeStr.EDIT_TITLE,target);
				}
			}
		);
	},
	/**
	 * :,,true,false,()
	 */
	shouldValidatorFormBeforeSave:function(){
		return true;
	},
	/**
	 * :
	 */
	shouldSaveFormAfterRefresh:function(){
		return true;
	},
	/**
	 * 
	 * @action 
	 */
	submitAction:function(){
	    var result=waf("#form").wafFormValidator("validateForm");
		if(result==true) {
			waf.doSubmit(
				{
					action:'submit',
					success:function(modelID){
						waf.window.close();
					}
				}
			);
		}
	},
	/**
	 * 
	 * @action 
	 */
	addNewAction:function(){
		waf.msgBox.showConfirm({
					autoBtnClose:false,
		        	summaryMsg:"?",   					
		        	buttonType:"yes-no",   					
		        	buttonCallBack:[
			        	function(dialog){
			        		waf.msgBox.close(dialog);
							waf.doSubmit(
							{
								action:'save',
								success:function(modelID){
									document.getElementById("id").value=modelID;
									if(_self.shouldSaveFormAfterRefresh()){
										waf.redirect("?method=initalize&operateState=ADDNEW");
									}
								}
							});
							
			        	},
			        	function(){
			        		waf.msgBox.close(dialog);
			        		waf.redirect("?method=initalize&operateState=ADDNEW");
			        	}
		        	]
		});
	},
	/**
	 * 
	 * @action 
	 */
	saveAction:function(){
	    var args = waf.getUrlParams();
		//
		if(_self.shouldValidatorFormBeforeSave()) {
		    var result=waf("#form").wafFormValidator("validateForm");
			if(result==true) {
				waf.doSubmit(
					{
						action:'save',
						success:function(modelID){
							waf.msgBox.showInfo({
								summaryMsg:_self.localeStr.SAVE_SUCCESS,
								buttonType:"ok",   					
					        	buttonCallBack:[
						        	function(dialog){
										if(_self.shouldSaveFormAfterRefresh()){
											var operateState=args.operateState;
											if(document.getElementById("id").value==null || document.getElementById("id").value==""
											   || (document.getElementById("id").value!=null && operateState.toLowerCase()=="addnew")) {
												operateState="edit";
											}
											waf.redirect("?method=initalize&operateState=" + operateState + "&fromList="+args.fromList+"&modelID=" + waf.encodeURIComponent(modelID));
										}
						        	}
					        	]
							});
						}
					}
				);
			}
		}
		else {
			waf.doSubmit(
					{
						action:'save',
						success:function(modelID){
							waf.msgBox.showInfo({
								summaryMsg:_self.localeStr.SAVE_SUCCESS,
								buttonType:"ok",   					
					        	buttonCallBack:[
						        	function(dialog){
										var operateState=args.operateState;
										if(document.getElementById("id").value==null || document.getElementById("id").value==""
											   || (document.getElementById("id").value!=null && operateState.toLowerCase()=="addnew")) {
											operateState="edit";
										}
										waf.redirect("?method=initalize&operateState=" + operateState + "&fromList="+args.fromList+"&modelID=" + waf.encodeURIComponent(modelID));
						        	}
					        	]
							});
						}
					}
				);
		}
	},
	/**
	 * 
	 * @action 
	 */
	saveAndAddNewAction:function(){
	    var args = waf.getUrlParams();
		//
		if(_self.shouldValidatorFormBeforeSave()) {
		    var result=waf("#form").wafFormValidator("validateForm");
			if(result==true) {
				waf.doSubmit(
					{
						action:'save',
						success:function(modelID){
							document.getElementById("id").value=modelID;
							if(_self.shouldSaveFormAfterRefresh()){
								waf.redirect("?method=initalize&operateState=ADDNEW&fromList="+args.fromList+"&random=" + Math.random());
							}
						}
					}
				);
			}
		}
		else {
			waf.doSubmit(
					{
						action:'save',
						success:function(modelID){
							waf.redirect("?method=initalize&operateState=ADDNEW&fromList="+args.fromList+"&random=" + Math.random());
						}
					}
				);
		}
	},
	/**
	 * 
	 * @action
	 */
	refreshAction:function(){
		document.location.reload();
	},
	/**
	 * 
	 * @action
	 */
	showListAction:function(){					
		waf.window.close();
	},
	/**
	 * :
	 * @return truefalse.
	 */
	destroyAction:function(){	
		var modelID = _self.getCurrentModelID();
		waf.doPost(
			{
				action:'destroy',
				showBlock:false,
				data:{modelID:modelID},
				async:false,
				success:function(data){
					return true;
				},
				error:function(response, textStatus, errorThrown){
					return true;
				}
			}
		);
	},
	/**
	 * 
	 * @action
	 */
	closeAction:function(){
	    var target = waf.windowMgr.getTargetObj();
	    var modelID = _self.getCurrentModelID();	
	    var operateState = _self.getOperateState();
	    if (operateState==="view") {
	        waf.doPost(
			    {action:'close',
			     data:{modelID:modelID,operateState:operateState},
			     success:function(data){
			        if (target!=null)
			            target.unbind("dialogbeforeclose");
					waf.window.close();
				 }
			});
	    } else {
	        waf.msgBox.showConfirm({
					autoBtnClose:false,
		        	summaryMsg:_self.localeStr.EXIT_CONFIRM,   					
		        	buttonType:"ok-cancel",   					
		        	buttonCallBack:[
			        	function(dialog){
		                    waf.doPost(
			                    {action:'close',
			                     data:{modelID:modelID,operateState:operateState},
			    	             success:function(data){
			    	                 if (target!=null)
			    	                     target.unbind("dialogbeforeclose");
					                 waf.window.close();
				                }
			                });
			        	},
			        	function(){
			        	}
		        	]
		    });	
		    return false;
		}					
	},
	/**
	 * 
	 */
	updateFieldStatus:function(field,viewable,editable){
		if(field==null)
			return ;
		
		/*
		 * 
		 */
		var levelField=field.split(".");
		
		/*
		 * ,
		 */
		if(levelField.size<=0){
			return ;
		}
		
		var ctrl=waf.dynamicutil.getElementByName(levelField[0]);		
		
		if(ctrl==undefined || ctrl==null){
			ctrl=waf.dynamicutil.getGridByPropName(levelField[0]);
		}
		
		/*
		 * 
		 */
		if(ctrl==undefined || ctrl==null)
			return ;

		var wafCmp=waf(ctrl[0]);

		var strScript="";
		
		if(wafCmp.attr("ctrlrole")=="grid"){
			//
			if(viewable==false){
				waf(wafCmp).wafGrid("hideCol",levelField[1]);
			}
			
			if(editable==false){
				var column = waf(wafCmp).wafGrid("optionColumn",levelField[1]);
				column.editable = false;
				waf(wafCmp).wafGrid("optionColumn",levelField[1],column);
			}
		}
		else if(wafCmp.attr("ctrlrole")=="datePicker"){
			/**/
			strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','readonly',!editable);";
			strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','disabled',!editable);";

			/* */
			if(viewable==false) {
				strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','hidden',!viewable);";
				var maskDisplay=document.createElement("span");
				maskDisplay.innerHTML="<a style='font-size:12px;color:red;' title='" + _self.localeStr.CANNOT_VIEW_FIELD + "'>##############</a>";
				ctrl[0].parentNode.parentNode.parentNode.parentNode.appendChild(maskDisplay);
			}

			/**/
			eval(strScript);
		}
		else if(wafCmp.attr("ctrlrole")=="promptBox"){
			/**/
			strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','readonly',!editable);";
			strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','disabled',!editable);";

			/* */
			if(viewable==false) {
				strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','hidden',!viewable);";
				var maskDisplay=document.createElement("span");
				maskDisplay.innerHTML="<a style='font-size:12px;color:red;' title='" + _self.localeStr.CANNOT_VIEW_FIELD + "'>##############</a>";
				ctrl[0].parentNode.parentNode.parentNode.parentNode.appendChild(maskDisplay);
			}

			/**/
			eval(strScript);
		}
		else {
			/**/
			strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','readonly',!editable);";
			strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','disabled',!editable);";

			/* */
			if(viewable==false) {
				strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','hidden',!viewable);";
				var maskDisplay=document.createElement("span");
				maskDisplay.innerHTML="<a style='font-size:12px;color:red;' title='" + _self.localeStr.CANNOT_VIEW_FIELD + "'>##############</a>";
				ctrl[0].parentNode.parentNode.appendChild(maskDisplay);
			}

			/**/
			eval(strScript);
		}
	},
	/**
	 * 
	 */
	updateComponentStatus:function(ctrl,viewable,editable){
		var wafCmp=waf("#" + ctrl);

		var strScript="";

		if(wafCmp.attr("ctrlrole")=="grid"){
			//
			if(viewable==false){
				waf(wafCmp).wafGrid("hideCol",levelField[1]);
			}
			
			if(editable==false){
				var column = waf(wafCmp).wafGrid("optionColumn",levelField[1]);
				column.editable = false;
				waf(wafCmp).wafGrid("optionColumn",levelField[1],column);
			}
		}
		else if(wafCmp.attr("ctrlrole")=="datePicker"){
			/**/
			strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','readonly',!editable);";
			strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','disabled',!editable);";

			/* */
			if(viewable==false) {
				strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','hidden',!viewable);";
				var maskDisplay=document.createElement("span");
				maskDisplay.innerHTML="<a style='font-size:12px;color:red;' title='" + _self.localeStr.CANNOT_VIEW_FIELD + "'>##############</a>";
				ctrl[0].parentNode.parentNode.parentNode.parentNode.appendChild(maskDisplay);
			}

			/**/
			eval(strScript);
		}
		else if(wafCmp.attr("ctrlrole")=="promptBox"){
			/**/
			strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','readonly',!editable);";
			strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','disabled',!editable);";

			/* */
			if(viewable==false) {
				strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','hidden',!viewable);";
				var maskDisplay=document.createElement("span");
				maskDisplay.innerHTML="<a style='font-size:12px;color:red;' title='" + _self.localeStr.CANNOT_VIEW_FIELD + "'>##############</a>";
				ctrl[0].parentNode.parentNode.parentNode.parentNode.appendChild(maskDisplay);
			}

			/**/
			eval(strScript);
		}
		else {
			/**/
			strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','readonly',!editable);";
			strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','disabled',!editable);";

			/* */
			if(viewable==false) {
				strScript= strScript + "waf(wafCmp)." + waf.getCmpType(wafCmp.attr("ctrlrole")) + "('option','hidden',!viewable);";
				var maskDisplay=document.createElement("span");
				maskDisplay.innerHTML="<a style='font-size:12px;color:red;' title='" + _self.localeStr.CANNOT_VIEW_FIELD + "'>##############</a>";
				ctrl[0].parentNode.parentNode.appendChild(maskDisplay);
			}

			/**/
			eval(strScript);
		}
	}
});
/**
* WAFJS
* @author JASON LIU
* @class WAFJS
* @constructor
* @see superclass waf.framework.core
*/
waf.defineClass("waf.framework.Edit_LocaleStr_l1",waf.framework.WafCore_LocaleStr_l1,{
	btnSave_caption:"Save",
	btnDelete_caption:"Delete",
	btnEdit_caption:"Edit",
	btnRefresh_caption:"Refresh",
	btnExit_caption:"Exit",
	SAVE_SUCCESS:"Saved successfully.",
	CANNOT_VIEW_FIELD:"Can't not view the field.",
	EXIT_CONFIRM:"Are you sure you want to close?",
	ADDNEW_TITLE:"New",
	VIEW_TITLE:"View",
	EDIT_TITLE:"Edit"
});
waf.defineClass("waf.framework.Edit_LocaleStr_l2",waf.framework.WafCore_LocaleStr_l2,{
	btnSave_caption:"",
	btnDelete_caption:"",
	btnEdit_caption:"",
	btnRefresh_caption:"",
	btnExit_caption:"",
	SAVE_SUCCESS:"",
	CANNOT_VIEW_FIELD:".",
	EXIT_CONFIRM:"?",
	ADDNEW_TITLE:"",
	VIEW_TITLE:"",
	EDIT_TITLE:""
});
waf.defineClass("waf.framework.Edit_LocaleStr_l3",waf.framework.WafCore_LocaleStr_l3,{
	btnSave_caption:"",
	btnDelete_caption:"",
	btnEdit_caption:"",
	btnRefresh_caption:"",
	btnExit_caption:"",
	SAVE_SUCCESS:"",
	CANNOT_VIEW_FIELD:".",
	EXIT_CONFIRM:"?",
	ADDNEW_TITLE:"",
	VIEW_TITLE:"",
	EDIT_TITLE:""
});
/**
* WAFJS
* @author JASON LIU
* @class WAFJS
* @constructor
* @see superclass waf.framework.core
*/
waf.defineClass("waf.framework.BatchEdit",waf.framework.WafCore,{
	editWin:null,
	needConfirm:true, 
	/**
	 * :JS
	 */
	initalizeAction:function(){				
		waf("#grid").dataGrid("option","keyOptions",{lastCellAction:function(){
				_self.addNewAction();
			}});
			
		//
        waf("#grid").dataGrid("option","beforeReloadGrid",function() {
            if (_self.needConfirm) {
                var updateData=waf("#grid").dataGrid("getChangedRows");
                if((updateData.modifys!=null && updateData.modifys.length>0) 
                    || (updateData.deletes!=null && updateData.deletes.length>0)){ 
                    var result=confirm(_self.localeStr.VALUECHANGE);
                    if (result) {
                       return _self.saveBatchAction();
                    }
                }
            }
            return true;
        });
	},
	firstPageAction:function(){		/*  */
		if(waf("#grid").dataGrid("option","page")<=1){
			waf.msgBox.showInfo({
				summaryMsg:localStr.FIRSTPAGE_ALERT
			});
			
			return ;
		}
		waf.doPost(
			{
				action:'firstPage',
				param:"page=1",
				data:null,
				success:function(data){
					waf("#grid").dataGrid("option","page",1);
					waf("#grid").dataGrid("reloadGrid");
				}
			}
		);
	},
	previewPageAction:function(){	/*  */
		if(waf("#grid").dataGrid("option","page")<=1){
			waf.msgBox.showInfo({
				summaryMsg:localStr.FIRSTPAGE_ALERT
			});
			
			return ;
		}
		
		waf.doPost(
			{
				action:'previewPage',
				param:"page=" + (parseInt(waf("#grid").dataGrid("option","page")) -1 ),
				success:function(data){
					waf("#grid").dataGrid("option","page",parseInt(parseInt(waf("#grid").dataGrid("option","page")) - 1));
					waf("#grid").dataGrid("reloadGrid");
				}
			}
		);
	},
	nextPageAction:function(){		/*  */
		if(waf("#grid").dataGrid("option","page")>=waf("#grid").dataGrid("option","totalPages")){
			waf.msgBox.showInfo({
				summaryMsg:localStr.LASTTPAGE_ALERT
			});
			
			return ;
		}

		waf.doPost(
			{
				action:'nextPage',
				param:"page=" + (parseInt(waf("#grid").dataGrid("option","page")) + 1 ),
				success:function(data){
					waf("#grid").dataGrid("option","page",parseInt(parseInt(waf("#grid").dataGrid("option","page")) + 1));
					waf("#grid").dataGrid("reloadGrid");
				}
			}
		);
	},
	lastPageAction:function(){		/*  */
		if(waf("#grid").dataGrid("option","page")>=waf("#grid").dataGrid("option","totalPages")){
			waf.msgBox.showInfo({
				summaryMsg:localStr.LASTTPAGE_ALERT
			});
			
			return ;
		}

		waf.doPost(
			{
				action:'lastPage',
				param:"page=" + parseInt(waf("#grid").dataGrid("option","totalPages")),
				success:function(data){
					waf("#grid").dataGrid("option","page",parseInt(waf("#grid").dataGrid("option","totalPages")));
					waf("#grid").dataGrid("reloadGrid");
				}
			}
		);
	},
	advanceSearchAction:function(){		/* */
		waf("#commonQuery").commonQuery("showCommonQueryDialog",
			    {confirm:function(data){
			    	waf("#grid").dataGrid("option","filterItems",data);
		            waf("#grid").dataGrid("reloadGrid");
			    },
			    cancel:function(){
				    
				}
			}
		);
	},
	addNewAction:function(){		/*  */
		waf.doPost(
			{
				action:'addNew',
				success:function(rowData){
					waf("#grid").dataGrid("addRow",{data:rowData});
				}
			}
		);
	},
	editAction:function(){			/*  */
	   
	},
	saveBatchAction:function(){		/* */
	    //
		if(_self.shouldValidatorFormBeforeSave()) {
	        var result= waf("#form").wafFormValidator("validateForm",true);
	        var errorInput = waf("#grid").wafGrid('getErrorInput');
	        if(errorInput&&errorInput!=null&&errorInput.length>0){
	            waf("#msgArea1").wafMsgArea("show", {
                    type:"error",
                    summaryMsg:_self.localeStr.VERIFY_FAIL_MSG1+errorInput.length+_self.localeStr.VERIFY_FAIL_MSG2,
                    closeDetailTime:5     
                });
                return false;
            }else if(!result){
                waf("#msgArea1").wafMsgArea("show", {
                    type:"error",
                    summaryMsg:_self.localeStr.VERIFY_FAIL,
                    closeDetailTime:5     
                });
                return false;
            }else{
                return _self.saveChangedRows();
            }
        } else {
		    return _self.saveChangedRows(); 
		}
	},
	/**
	 * :,,true,false,()
	 */
	shouldValidatorFormBeforeSave:function(){
		return true;
	},
	saveChangedRows:function(){		/* */		
		var jsonData={};
		var updateData=waf("#grid").dataGrid("getChangedRows");
		if(updateData.modifys!=null){
			jsonData.modifiedSize=updateData.modifys.length;
			jsonData.modifiedRecord=updateData.modifys;
			for(var nIndex=0;nIndex<jsonData.modifiedRecord.length;nIndex++){
				var key=jsonData.modifiedRecord[nIndex].id;
				if(! isNaN(key)){
					jsonData.modifiedRecord[nIndex].id=null;
				}
			}
		}
		if(updateData.deletes!=null){
			jsonData.deleteSize=updateData.deletes.length;
			jsonData.deleteRecord=updateData.deletes;
		}
		var needReloadGrid = true;
		waf.doPost(
				{
					action:'saveBatch',
					data:jsonData,
					async:false,
					success:function(message){
					    _self.needConfirm=false;
						if(message.detailInfo!=null && message.detailInfo!="" && message.detailInfo!="<br>"){
							waf.msgBox.showInfo({
								summaryMsg:message.summaryMsg,
								buttonType:"ok",   					
					        	buttonCallBack:[
						        	function(dialog){
						        		waf.msgBox.close(dialog);
						        		_self.needConfirm=true;
						        	}
					        	],
					        	detailMsg:_self.localeStr.DETAILMSG + message.detailInfo
							});
							needReloadGrid = false;
						}
						else {
							waf.msgBox.showInfo({
								summaryMsg:message.summaryMsg,
								buttonType:"ok",   					
					        	buttonCallBack:[
						        	function(dialog){
						        		waf.msgBox.close(dialog);
										waf("#grid").dataGrid("reloadGrid");
										_self.needConfirm=true;
						        	}
					        	]
							});
						}
					}
				}
			);
	    return needReloadGrid;
	},
	deleteAction:function(){		/*  */
	    var selectedIds = waf("#grid").dataGrid("getGridParam", "selarrrow");
	    if(selectedIds && selectedIds.length>0) {
	        var rl = selectedIds.pop();
            while(rl){
                waf("#grid").dataGrid("delRow", rl);
                rl = selectedIds.pop();
            }
		}
 	},
	refreshAction:function(){		/*  */
		waf.doPost(
			{
						action:'refresh',
						success:function(data){
							//
							waf("#grid").dataGrid("reloadGrid");
						}
			}
		);
	},
	printAction:function(){			/*  */
		waf.doPost("print",null,null,
			function(data){
				document.location.reload();
			}
		);
	}
});
/**
* WAFJS_
* @author JASON LIU
* @class WAFJS_
* @constructor
* @see superclass waf.framework.core
*/
waf.defineClass("waf.framework.BatchEdit_LocaleStr_l1",waf.framework.WafCore_LocaleStr_l1,{
    VERIFY_FAIL:"Verify failed, there is unsuccessful verification items, please check.",
    VERIFY_FAIL_MSG1:"There is ",
    VERIFY_FAIL_MSG2:" unsuccessful verification items, please check.",
    DETAILMSG:"Details:",
    VALUECHANGE:"The data has been changed, you need to save?"
});
waf.defineClass("waf.framework.BatchEdit_LocaleStr_l2",waf.framework.WafCore_LocaleStr_l2,{
    VERIFY_FAIL:"",
    VERIFY_FAIL_MSG1:"",
    VERIFY_FAIL_MSG2:"",
    DETAILMSG:"",
    VALUECHANGE:","
});
waf.defineClass("waf.framework.BatchEdit_LocaleStr_l3",waf.framework.WafCore_LocaleStr_l3,{
    VERIFY_FAIL:"",
    VERIFY_FAIL_MSG1:"",
    VERIFY_FAIL_MSG2:"",
    DETAILMSG:"",
    VALUECHANGE:""
});
/**
* WAFJS
* @author JASON LIU
* @class WAFJS
* @constructor
* @see superclass waf.framework.core
*/
waf.defineClass("waf.framework.Edit_LocaleStr_l1",waf.framework.WafCore_LocaleStr_l1,{
	btnSave_caption:"Save",
	btnDelete_caption:"Delete",
	btnEdit_caption:"Edit",
	btnRefresh_caption:"Refresh",
	btnExit_caption:"Exit",
	SAVE_SUCCESS:"Saved successfully.",
	CANNOT_VIEW_FIELD:"Can't not view the field.",
	EXIT_CONFIRM:"Are you sure you want to close?",
	ADDNEW_TITLE:"New",
	VIEW_TITLE:"View",
	EDIT_TITLE:"Edit"
});
waf.defineClass("waf.framework.Edit_LocaleStr_l2",waf.framework.WafCore_LocaleStr_l2,{
	btnSave_caption:"",
	btnDelete_caption:"",
	btnEdit_caption:"",
	btnRefresh_caption:"",
	btnExit_caption:"",
	SAVE_SUCCESS:"",
	CANNOT_VIEW_FIELD:".",
	EXIT_CONFIRM:"?",
	ADDNEW_TITLE:"",
	VIEW_TITLE:"",
	EDIT_TITLE:""
});
waf.defineClass("waf.framework.Edit_LocaleStr_l3",waf.framework.WafCore_LocaleStr_l3,{
	btnSave_caption:"",
	btnDelete_caption:"",
	btnEdit_caption:"",
	btnRefresh_caption:"",
	btnExit_caption:"",
	SAVE_SUCCESS:"",
	CANNOT_VIEW_FIELD:".",
	EXIT_CONFIRM:"?",
	ADDNEW_TITLE:"",
	VIEW_TITLE:"",
	EDIT_TITLE:""
});
waf.defineClass("waf.template.bill.GeneralBillEditPage_LocaleStr_l1",waf.framework.Edit_LocaleStr_l1,{
	VIEW_PROGRESS_DIAGRAM_TITLE:"View Flowchart"
	,
	VIEW_OPIONION:"View Opinion"
	,
	MULTIAPPROVE:"Multi-Approval"
	,
	VIEW_ACTIVITY_LIST:"View Business Activity List"
	,
	SPECIFY_NEXT_PERSON:"Specify Next Participant"
	,
	TITLE_TRANS:"Doc Conversion"
	,
	TITLE_TRACEUP:"Doc Conversion_Source Doc"
	,
	TITLE_TRACEDOWN:"Doc Conversion_Target Doc"
	,
	TITLE_ATTACHMENT:"Attachment Management"
	,
	TITLE_REPORT:"Print",
	SUBMIT_SUCCESS:"Submited successfully."
});

waf.defineClass("waf.template.bill.GeneralBillEditPage_LocaleStr_l2",waf.framework.Edit_LocaleStr_l2,{
	VIEW_PROGRESS_DIAGRAM_TITLE:""
	,
	VIEW_OPIONION:""
	,
	MULTIAPPROVE:""
	,
	VIEW_ACTIVITY_LIST:""
	,
	SPECIFY_NEXT_PERSON:""
	,
	TITLE_TRANS:""
	,
	TITLE_TRACEUP:"_"
	,
	TITLE_TRACEDOWN:"_"
	,
	TITLE_ATTACHMENT:""
	,
	TITLE_REPORT:"",
	SUBMIT_SUCCESS:""
});

waf.defineClass("waf.template.bill.GeneralBillEditPage_LocaleStr_l3",waf.framework.Edit_LocaleStr_l3,{
	VIEW_PROGRESS_DIAGRAM_TITLE:"" 
	,
	VIEW_OPIONION:"" 
	,
	MULTIAPPROVE:"" 
	,
	VIEW_ACTIVITY_LIST:"" 
	,
	SPECIFY_NEXT_PERSON:"" 
	,
	TITLE_TRANS:"" 
	,
	TITLE_TRACEUP:"_" 
	,
	TITLE_TRACEDOWN:"_" 
	,
	TITLE_ATTACHMENT:"" 
	,
	TITLE_REPORT:"",
	SUBMIT_SUCCESS:""
});

waf.defineClass("waf.template.bill.GeneralBillListPage_LocaleStr_l1",waf.framework.List_LocaleStr_l1,{
	VIEW_PROGRESS_DIAGRAM_TITLE:"View Flowchart"
	,
	VIEW_OPIONION:"View Opinion"
	,
	MULTIAPPROVE:"Multi-Approval"
	,
	VIEW_ACTIVITY_LIST:"View Business Activity List"
	,
	SPECIFY_NEXT_PERSON:"Specify Next Participant"
	,
	TITLE_TRANS:"Doc Conversion"
	,
	TITLE_TRACEUP:"Doc Conversion_Source Doc"
	,
	TITLE_TRACEDOWN:"Doc Conversion_Target Doc"
	,
	TITLE_ATTACHMENT:"Attachment Management"
	,
	TITLE_REPORT:"Print"
});

waf.defineClass("waf.template.bill.GeneralBillListPage_LocaleStr_l2",waf.framework.List_LocaleStr_l2,{
	VIEW_PROGRESS_DIAGRAM_TITLE:""
	,
	VIEW_OPIONION:""
	,
	MULTIAPPROVE:""
	,
	VIEW_ACTIVITY_LIST:""
	,
	SPECIFY_NEXT_PERSON:""
	,
	TITLE_TRANS:""
	,
	TITLE_TRACEUP:"_"
	,
	TITLE_TRACEDOWN:"_"
	,
	TITLE_ATTACHMENT:""
	,
	TITLE_REPORT:""
});

waf.defineClass("waf.template.bill.GeneralBillListPage_LocaleStr_l3",waf.framework.List_LocaleStr_l3,{
	VIEW_PROGRESS_DIAGRAM_TITLE:"" 
	,
	VIEW_OPIONION:"" 
	,
	MULTIAPPROVE:"" 
	,
	VIEW_ACTIVITY_LIST:"" 
	,
	SPECIFY_NEXT_PERSON:"" 
	,
	TITLE_TRANS:"" 
	,
	TITLE_TRACEUP:"_" 
	,
	TITLE_TRACEDOWN:"_" 
	,
	TITLE_ATTACHMENT:"" 
	,
	TITLE_REPORT:"" 
});

waf.defineClass("waf.template.database.GeneralDataBaseBatchEditPage_LocaleStr_l1",waf.framework.BatchEdit_LocaleStr_l1,{
});

waf.defineClass("waf.template.database.GeneralDataBaseBatchEditPage_LocaleStr_l2",waf.framework.BatchEdit_LocaleStr_l2,{
});

waf.defineClass("waf.template.database.GeneralDataBaseBatchEditPage_LocaleStr_l3",waf.framework.BatchEdit_LocaleStr_l3,{
});

waf.defineClass("waf.template.database.GeneralDataBaseEditPage_LocaleStr_l1",waf.framework.Edit_LocaleStr_l1,{
});

waf.defineClass("waf.template.database.GeneralDataBaseEditPage_LocaleStr_l2",waf.framework.Edit_LocaleStr_l2,{
});

waf.defineClass("waf.template.database.GeneralDataBaseEditPage_LocaleStr_l3",waf.framework.Edit_LocaleStr_l3,{
});

waf.defineClass("waf.template.database.GeneralDataBaseListPage_LocaleStr_l1",waf.framework.List_LocaleStr_l1,{
});

waf.defineClass("waf.template.database.GeneralDataBaseListPage_LocaleStr_l2",waf.framework.List_LocaleStr_l2,{
});

waf.defineClass("waf.template.database.GeneralDataBaseListPage_LocaleStr_l3",waf.framework.List_LocaleStr_l3,{
});

waf.defineClass("waf.template.database.GroupDataBaseBatchEditPage_LocaleStr_l1",waf.framework.BatchEdit_LocaleStr_l1,{
	TITLE_ADDNEW:"New"
	,
	TITLE_EDIT:"Edit"
	,
	TITLE_VIEW:"View"
	,
	TITLE_SEARCH:"Search"
	,
	SELECT_NO_NODE:"Please select one node first."
	,
	SELECT_ONE_NODE:"Only one node can be selected."
	,
	NO_ROOTNODE:"Cannot operate on the root node."
	,
	SELECT_NO_GROUP:"Please select one group first."
	,
	SEARCH_BY_NAME:"Search by name:"
	,
	NO_NAME:"Name cannot be blank."
	,
	TITLE_VIEW:"View"
	,
	DETAIL:"Detail:"
	,
	DELETE_CONFIRM:"Are you sure you want to delete the selected record?"
	,
	DELETE_SUCCESS:"Deleted successfully."
	,
	ADDNEW_TITLE:"New"
	,
	VIEW_TITLE:"View"
	,
	EDIT_TITLE:"Edit"
});

waf.defineClass("waf.template.database.GroupDataBaseBatchEditPage_LocaleStr_l2",waf.framework.BatchEdit_LocaleStr_l2,{
	TITLE_ADDNEW:""
	,
	TITLE_EDIT:""
	,
	TITLE_VIEW:""
	,
	TITLE_SEARCH:""
	,
	SELECT_NO_NODE:""
	,
	SELECT_ONE_NODE:""
	,
	NO_ROOTNODE:""
	,
	SELECT_NO_GROUP:""
	,
	SEARCH_BY_NAME:""
	,
	NO_NAME:""
	,
	TITLE_VIEW:""
	,
	DETAIL:""
	,
	DELETE_CONFIRM:"?"
	,
	DELETE_SUCCESS:""
	,
	ADDNEW_TITLE:""
	,
	VIEW_TITLE:""
	,
	EDIT_TITLE:""
});

waf.defineClass("waf.template.database.GroupDataBaseBatchEditPage_LocaleStr_l3",waf.framework.BatchEdit_LocaleStr_l3,{
	TITLE_ADDNEW:"" 
	,
	TITLE_EDIT:"" 
	,
	TITLE_VIEW:"" 
	,
	TITLE_SEARCH:"" 
	,
	SELECT_NO_NODE:"" 
	,
	SELECT_ONE_NODE:"" 
	,
	NO_ROOTNODE:"" 
	,
	SELECT_NO_GROUP:"" 
	,
	SEARCH_BY_NAME:"" 
	,
	NO_NAME:"" 
	,
	TITLE_VIEW:"" 
	,
	DETAIL:"" 
	,
	DELETE_CONFIRM:"?"
	,
	DELETE_SUCCESS:""
	,
	ADDNEW_TITLE:""
	,
	VIEW_TITLE:""
	,
	EDIT_TITLE:""
});

waf.defineClass("waf.template.database.GroupDataBaseBatchTreeEditPage_LocaleStr_l1",waf.framework.Edit_LocaleStr_l1,{
});

waf.defineClass("waf.template.database.GroupDataBaseBatchTreeEditPage_LocaleStr_l2",waf.framework.Edit_LocaleStr_l2,{
});

waf.defineClass("waf.template.database.GroupDataBaseBatchTreeEditPage_LocaleStr_l3",waf.framework.Edit_LocaleStr_l3,{
});

waf.defineClass("waf.template.database.GroupDataBaseEditPage_LocaleStr_l1",waf.framework.Edit_LocaleStr_l1,{
});

waf.defineClass("waf.template.database.GroupDataBaseEditPage_LocaleStr_l2",waf.framework.Edit_LocaleStr_l2,{
});

waf.defineClass("waf.template.database.GroupDataBaseEditPage_LocaleStr_l3",waf.framework.Edit_LocaleStr_l3,{
});

waf.defineClass("waf.template.database.GroupDataBaseListPage_LocaleStr_l1",waf.framework.List_LocaleStr_l1,{
	TITLE_SEARCH:"Search"
	,
	SELECT_NO_NODE:"Please select one node first."
	,
	SELECT_ONE_NODE:"Only one node can be selected."
	,
	NO_ROOTNODE:"Cannot operate on the root node."
	,
	SELECT_NO_GROUP:"Please select one group first."
	,
	SEARCH_BY_NAME:"Search by name:"
	,
	NO_NAME:"Name cannot be blank."
});

waf.defineClass("waf.template.database.GroupDataBaseListPage_LocaleStr_l2",waf.framework.List_LocaleStr_l2,{
	TITLE_SEARCH:""
	,
	SELECT_NO_NODE:""
	,
	SELECT_ONE_NODE:""
	,
	NO_ROOTNODE:""
	,
	SELECT_NO_GROUP:""
	,
	SEARCH_BY_NAME:""
	,
	NO_NAME:""
});

waf.defineClass("waf.template.database.GroupDataBaseListPage_LocaleStr_l3",waf.framework.List_LocaleStr_l3,{
	TITLE_SEARCH:"" 
	,
	SELECT_NO_NODE:"" 
	,
	SELECT_ONE_NODE:"" 
	,
	NO_ROOTNODE:"" 
	,
	SELECT_NO_GROUP:"" 
	,
	SEARCH_BY_NAME:"" 
	,
	NO_NAME:"" 
});

waf.defineClass("waf.template.database.GroupDataBaseTreeEditPage_LocaleStr_l1",waf.framework.Edit_LocaleStr_l1,{
});

waf.defineClass("waf.template.database.GroupDataBaseTreeEditPage_LocaleStr_l2",waf.framework.Edit_LocaleStr_l2,{
});

waf.defineClass("waf.template.database.GroupDataBaseTreeEditPage_LocaleStr_l3",waf.framework.Edit_LocaleStr_l3,{
});

waf.defineClass("custom.TestTreeEditPage_LocaleStr_l1",waf.template.database.TreeDataBaseEditPage_LocaleStr_l1,{
});

waf.defineClass("custom.TestTreeEditPage_LocaleStr_l2",waf.template.database.TreeDataBaseEditPage_LocaleStr_l2,{
});

waf.defineClass("custom.TestTreeEditPage_LocaleStr_l3",waf.template.database.TreeDataBaseEditPage_LocaleStr_l3,{
});

waf.defineClass("waf.template.database.TreeDataBaseBatchEditPage_LocaleStr_l1",waf.framework.BatchEdit_LocaleStr_l1,{
	TITLE_SEARCH:"Locate"
	,
	SEARCH_BY_NAME:"Search by name:"
	,
	NO_NAME:"Name cannot be blank."
	,
	DETAIL:"Detail:"
});

waf.defineClass("waf.template.database.TreeDataBaseBatchEditPage_LocaleStr_l2",waf.framework.BatchEdit_LocaleStr_l2,{
	TITLE_SEARCH:""
	,
	SEARCH_BY_NAME:""
	,
	NO_NAME:""
	,
	DETAIL:""
});

waf.defineClass("waf.template.database.TreeDataBaseBatchEditPage_LocaleStr_l3",waf.framework.BatchEdit_LocaleStr_l3,{
	TITLE_SEARCH:"" 
	,
	SEARCH_BY_NAME:"" 
	,
	NO_NAME:"" 
	,
	DETAIL:"" 
});

waf.defineClass("waf.template.database.TreeDataBaseEditPage_LocaleStr_l1",waf.framework.Edit_LocaleStr_l1,{
});

waf.defineClass("waf.template.database.TreeDataBaseEditPage_LocaleStr_l2",waf.framework.Edit_LocaleStr_l2,{
});

waf.defineClass("waf.template.database.TreeDataBaseEditPage_LocaleStr_l3",waf.framework.Edit_LocaleStr_l3,{
});

waf.defineClass("waf.template.database.TreeDataBaseListPage_LocaleStr_l1",waf.framework.List_LocaleStr_l1,{
	TITLE_SEARCH:"Locate"
	,
	SELECT_NO_NODE:"Please select one node first."
	,
	SEARCH_BY_NAME:"Search by name:"
	,
	NO_NAME:"Name cannot be blank."
});

waf.defineClass("waf.template.database.TreeDataBaseListPage_LocaleStr_l2",waf.framework.List_LocaleStr_l2,{
	TITLE_SEARCH:""
	,
	SELECT_NO_NODE:""
	,
	SEARCH_BY_NAME:""
	,
	NO_NAME:""
});

waf.defineClass("waf.template.database.TreeDataBaseListPage_LocaleStr_l3",waf.framework.List_LocaleStr_l3,{
	TITLE_SEARCH:"" 
	,
	SELECT_NO_NODE:"" 
	,
	SEARCH_BY_NAME:"" 
	,
	NO_NAME:"" 
});


/**
 * web,widget
 */
$.widget("waf.WebComponent",{
	options:{
		id:null,
		ownerUI:null
	},
	setId:function(value) {
		this.option.id = value;
	},
	getId:function() {
		return this.option.id;
	},
	getLocaleResourceObject:function(localeClassName){
		return waf.createObject(eval(localeClassName + "_LocaleStr_" + waf.getContext().locale.toLowerCase()));
	},
	option: function( key, value ) {
		var options = key;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.extend( {}, this.options );
		}

		if  (typeof key === "string" ) {
			if ( value === undefined ) {
				if(this.options.hasOwnProperty(key)) {
					return this.options[ key ];
				}
				else {
					var method=key.charAt(0).toUpperCase() + key.substr(1);
					return eval("this._get" + method + "();");
				}
			}
			options = {};
			options[ key ] = value;
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var self = this;
		$.each( options, function( key, value ) {
			if(self.options.hasOwnProperty(key)) {
				self._setOption( key, value );
			}
			else {
				var method=key.charAt(0).toUpperCase() + key.substr(1);
				return eval("self._set" + method + "(value);");
			}
		});

		return this;
	},
	pingPostData:function(postData){
		var ajaxPostData = postData;
		ajaxPostData.componentID = this.getID();
		return ajaxPostData;
	}
});

/**
 * 
 */
$.widget("waf.attachment",$.waf.WebComponent,{
	options:{
		id:null,
		billID:null,
		url:null
	},
	
	display:false,
	rowNum:0,
    rowMap:new Map(),
    
	/*  */
	_create:function(){
		var self=this;
		//edit
		waf("#" + self.options.id).hide();
		
		if(self.options.billID!=null&&self.options.billID!="") {
		    self.getAttachments();
		}
	},
	
	/* billID */	
	getAttachments:function(){	
	    var self=this;
		//URLoperateState
		var operateState = "";
		var url = document.location.search.substring(1);
		var qs = url.split("&");
		for (var i=0;i<qs.length;i++) {   
            var pos = qs[i].indexOf('=');
            var argname = qs[i].substring(0,pos); 
            if (argname == "operateState") {
                operateState = qs[i].substring(pos+1,qs[i].length); 
                break;
            }
        }
        if (operateState!="addnew") {
		    waf.doPost(
    		   {url:self.options.url+"?method=initalize",
    			data:{billID:self.options.billID},
    			success:function(data) {
    			    if (data!=null) {
    			        self._showFiles(data);
    			        waf("#" + self.options.id).show();
    			    }
    			}}
    	    );
	    }
	},
	
	/*  */
	_showFiles:function(data){
	    var self = this;
	    var locale = waf.getContext().locale;
	    var fileMap = new Map();
	    for (var i=0;i<data.length;i++) {
	        var file = data[i];
	        if (file != null) {
	            self.rowNum += 1;
	            var fileName = file.name[locale],
	                fileSize = file.size,
	                fileImg = self._getFileImgBySn(file.simpleName);
	            var content = '<tr id="row'+self.options.id+self.rowNum+'"><td>';
	            content += fileImg;
	            content += '<a id="'+file.attachID+'" target="_blank" href="'+waf.getContextPath()+'/winlet/attachment/download.jsp?bosID='+file.attachID+'">'+fileName+'.'+file.simpleName+'</a>';
	            content += '&nbsp;&nbsp;'+fileSize;
	            content += '</td></tr>';
	            waf("#" + self.options.id + "_edit").append(content);
		        fileMap.put(self.options.id+self.rowNum.toString(),self.rowNum);
		    }
		}
		self.rowMap.put(self.options.id,fileMap);
	},
	
	/*  */
	_getFileImgBySn:function(simpleName){
	    var img = '<img style="cursor:pointer;" src="'+waf.getContextPath()+'/webviews/images/text.bmp"/>';
	    switch (simpleName) {
            case "doc":
	            img = '<img style="cursor:pointer;" src="'+waf.getContextPath()+'/webviews/images/word.bmp"/>';
	            break;
	        case "docx":
	            img = '<img style="cursor:pointer;" src="'+waf.getContextPath()+'/webviews/images/word.bmp"/>';
	            break;
	        case "xls":
	            img = '<img style="cursor:pointer;" src="'+waf.getContextPath()+'/webviews/images/excel.bmp"/>';
	            break;
	        case "xlsx":
	            img = '<img style="cursor:pointer;" src="'+waf.getContextPath()+'/webviews/images/excel.bmp"/>';
	            break;
	        case "ppt":
	        case "txt":
	        case "bmp":
	    }
	    return img;
	},
    
    /* */
    refresh:function(){
		var self=this;
		//edit
		waf("#" + self.options.id).hide();
		self._clear();
		waf.doPost(
    	    {url:self.options.url+"?method=initalize",
    		 data:{billID:self.options.billID},
    		 success:function(data) {
    			 if (data!=null) {
    			     self._showFiles(data);
    			     waf("#" + self.options.id).show();
    			 }
    	    }}
    	);
	},
	
	/* edit*/
	_clear:function(){
	    if (!this.rowMap.isEmpty()) {
	        var fmap = this.rowMap.get(this.options.id);
	        if (fmap!=null) {
	            for (var i=0;i<fmap.size();i++) {
	                var element = fmap.element(i);
	                this._delRow(element.key);
	            }
	        }
	        this.rowMap.remove(this.options.id);
	    }
	},
	
	_delRow:function(id){
	    waf("#row" + id).remove();
	}
});
/**
 * 
 */
//mod.defineModule("attachment",["waf","section","fileUpload","attachment_i18n"],function(){
	$.widget("waf.webAttachment",$.waf.WebComponent,{
		options:{
			id:null,
			billID:null,
			url:null,
			withoutSection:false,
			renderUpload:null,
			renderDownload:null,
			afterShowFiles:null
		},
	
		fileDatas:null,
		delDisable:false,
	
		/*  */
		_create:function(){
			var self=this;
			if(!self.element.data("domcreated")){
                $(self.element).attr("ctrlrole","waf.webAttachment").attr("data-domcreated","true");
            }
			self.localeStr = self.getLocaleResourceObject("waf.webcom.attachment.webAttachment");
		
			//renderUpload\renderDownload
			waf("#"+self.options.id+"_upload").wafFileUploadUI("option",
				{renderUpload:self.options.renderUpload==null?self.renderUpload:self.options.renderUpload,
				 renderDownload:self.options.renderDownload==null?self.renderDownload:self.options.renderDownload,
				 onComplete:function(event, data){
		             if (self.fileDatas == null) 
		                 self.fileDatas = new Map();
	                 var fDatas = waf.toJSONObject(data.jqXHR.responseText);
	                 var url = fDatas[0].delete_url;
	    	         var attachID = url.substring(url.indexOf("attachID=")+9,url.length);
	    			 self.fileDatas.put(attachID,{name:data.files[0].name,size:data.files[0].size});
	    	     },
	    	     onRemove:function(event, context){
	    	         var attachID = "";
	    	         var url = context.url;
	    	         var attachID = url.substring(url.indexOf("attachID=")+9,url.length);
	    		     self.fileDatas.remove(attachID);
	    		     if (self.fileDatas.size()==0) {
	    	             waf("#"+self.options.id+"_upload").children("div.ui-fileupload-files").append("<span class='nofiles'>"+self.localeStr.NOFILES+"</span>");
	    	         }
	    	     },
	    	     onAdd:function(event, data){
	    	         if (data!=null) {
	    	             var spanDom = waf("#"+self.options.id+"_upload").children("div.ui-fileupload-files").find(".nofiles");
	    	             if (spanDom.length>0) {
	    	                 spanDom.remove();
	    	             }
	    	         }
	    	     }
	        });
	        waf("#"+self.options.id+"_upload").find(".ui-fileupload-addFile a").html(self.localeStr.ADDFILE);
		    if(self.options.billID!=null&&self.options.billID!=""&&self.options.billID!="null") {
		        //urlbillID
		        var url = waf("#"+self.options.id+"_upload").wafFileUploadUI("option","url");
	    	    if (url.indexOf("billID")<0){
	    	        url += "&billID="+waf.encodeURIComponent(self.options.billID);
	    	        waf("#"+self.options.id+"_upload").wafFileUploadUI("option","url",url);
		        }
	            //
		    	self.showFiles();
		    }
		},
		
		/* billID */	
		showFiles:function(){	
		    var self=this;
		    waf.doPost(
	    	    {url:self.options.url+"?method=initalize",
	    		 data:{billID:self.options.billID},
	    		 async:true,
	    		 success:function(data) {
	    			 //
		             self.element.find(".ui-fileupload-list").html("");	             
			         if (data!=null) {
			         	 self.element.find(".ui-fileupload-files .nofiles").remove();
	    			     waf("#"+self.options.id+"_upload").wafFileUploadUI("downloads", data);
	    			     //
	    			     self.fileDatas = new Map();
	    			     for (var i=0;i<data.length;i++) {
	    			         var url = data[i].delete_url;
	    	                 var attachID = url.substring(url.indexOf("attachID=")+9,url.length);
	    			         self.fileDatas.put(attachID,{name:data[i].name,size:data[i].size});
	    			     }
	    			     if(self.options.afterShowFiles!=null) {
		        		     self.options.afterShowFiles(data);
		        	     };
		        	     self.deleteFileDisable(self.delDisable);
	    			 } else {
	//    			     var title = waf("#"+self.options.id).children("div.sheader").children("span.title");
	//                     title.trigger("click");
						if (self.element.find(".nofiles").length==0)
	                     	waf("#"+self.options.id+"_upload").children("div.ui-fileupload-files").append("<span class='nofiles'>"+self.localeStr.NOFILES+"</span>");
	    			 }
	    	    }}
	    	);
		},
		
		/*  */
		enable:function(){
		    var self=this;
		    waf("#"+self.options.id+"_upload").wafFileUploadUI("enable");
		},
		
		/*  */
		disable:function(){
		    var self=this;
		    waf("#"+self.options.id+"_upload").wafFileUploadUI("disable");
		},
		
		/*  */
		getFileUploadUI:function(){
		    var self=this;
		    return waf("#"+self.options.id+"_upload");
		},
		
		/* billID */
		setBillID:function(billID){
		    var self=this;
		    self.options.billID = billID;
		    //urlbillID
		    var url = waf("#"+self.options.id+"_upload").wafFileUploadUI("option","url");
		    if (url.indexOf("billID")<0){
		        url += "&billID="+waf.encodeURIComponent(self.options.billID);
		        waf("#"+self.options.id+"_upload").wafFileUploadUI("option","url",url);
		    }
		},
		
		renderUpload:function(options, files){
		    var file = $.isArray(files) ? files[0] : files,
	            filename = file.name,
	            filesize = $.wafFileUploadUI.formatFileSize(file.size),
	            fileerror = $.wafFileUploadUI.errors[file.error] || file.error,
	            li$ = $('<li class="ui-fileupload-upload-info"></li>')
	                    .append('<span class="f-icon-paper-clip"></span>')
	                    .append('<span class="uploadname">'+filename+'</span>')
	                    .append('<span class="size">'+filesize+'</span>')
	                    .append(function(){if(fileerror)return '<span class="errormsg">'+fileerror+'</span>';})
	                    .append(function(){if(!fileerror)return '<span class="progress"><div></div></span>';})
	                    .append(function(){if(!options.autoUpload && !fileerror)return '<span class="upload"><a>'+$.wafFileUploadUI.defaults.upload+'</a></span>';})
	                    .append('<span class="cancel"><a>'+$.wafFileUploadUI.defaults.cancel+'</a></span>');
	
	        file.progress = li$.find('.progress div');
	
	        return li$;
	    },
	    
	    renderDownload:function(options, files){
	        var isView = false;
	        if(waf.getUrlParams){
	            var params=  waf.getUrlParams("operateState");
	            isView = !!(params && params["operateState"] && "view" === params["operateState"]);
	        }
	        var file = $.isArray(files) ? files[0] : files,
	            filename = file.name,
	            filesize = $.wafFileUploadUI.formatFileSize(file.size),
	            fileerror = $.wafFileUploadUI.errors[file.error] || file.error,
	            fileurl = file.url,
	            filedeleteurl = file.delete_url,
	            filedeletetype = file.delete_type,
	            li$ = $('<li class="ui-fileupload-download-info"></li>')
	                .append('<span class="f-icon-paper-clip"></span>')
	                .append(function(){
	                    if(!fileerror && fileurl){
	                        if(!isView){
	                            return '<span class="downloadname"><a href="'+fileurl+'" title="'+filename+'" download="'+filename+'">'+filename+'</a></span>';
	                        } else {
	                            return '<span class="viewdownloadname"><a href="'+fileurl+'" title="'+filename+'" download="'+filename+'">'+filename+'</a></span>';
	                        }
	                    }
	                    return '<span class="uploadname">'+filename+'</span>';
	                })
	                .append('<span class="size">'+filesize+'</span>')
	                .append(function(){if(fileerror)return '<span class="errormsg">'+fileerror+'</span>';})
	                .append(function(){
	                    if(!isView){
	                        return '<span class="remove"><a data-type="'+filedeletetype+'" data-url="'+filedeleteurl+'">'+$.wafFileUploadUI.defaults.remove+'</a></span>';
	                    }
	                })
	                .find('a[download]').each($.wafFileUploadUI.enableDragToDesktop).end();
	
	        return li$;
	    },
	    
	    addFileDisable:function(isDisable){
	        var self=this;
	        if (isDisable)
	            self.getFileUploadUI().find(".ui-fileupload-buttonbar").hide();
	        else 
	            self.getFileUploadUI().find(".ui-fileupload-buttonbar").show();
	    },
	    
	    deleteFileDisable:function(isDisable){
	        var self=this;
	        self.element.find(".ui-fileupload-list").find("li").each(function (index, item) {
	            if (isDisable) {
	                waf(item.children[3]).hide();
	            } else {
	                waf(item.children[3]).show();
	            }
	        });
	        self.delDisable = isDisable;
	    },
	    
	    /*  */
		getFileDatas:function(){
		    var self=this;
		    return self.fileDatas;
		},
		
		_setOption:function (key, value) {
	        var self=this;
	        if (value === undefined) {
	            return;
	        }
	        if (key == "renderUpload" || "renderDownload") {
	            waf("#"+self.options.id+"_upload").wafFileUploadUI("option",key,value);
	        } 
	        self.options[ key ] = value;
	        return self;
	    }
	});
	
	//
	waf(function(){
		waf.registerComponent("waf.webAttachment",{
			createDOMFun:function(option){
				var obj = option && option.id && $("#"+option.id);
				if(!(obj&&obj.data("domcreated"))){
				    var sectionDom;
		    		if (!option.withoutSection) {
		    		    //section
		    		    sectionDom = waf.createDOM("section", option);
		    			option.title = "";
		    			option.hidden = (option.isPermission==null||option.isPermission)?false:true;
		    			waf.initComponent("section", option, sectionDom);
		    		} else {
		    		    sectionDom = waf("<div id='"+option.id+"'></div>");
		    		}
		    		//url
		    		option.url = waf.getContextPath()+"/component/WebAttachment.do";
					//fileUpload
					option.autoUpload = option.autoUpload==null?true:option.autoUpload;
					var flOps = {id:option.id+"_upload", name:option.id+"_upload", url:"/component/WebAttachment.do?method=upload",autoUpload:option.autoUpload};
		            var fileUploadDom = waf.createDOM("fileUpload", flOps);
		            if (!option.withoutSection) {
		                waf(sectionDom).wafSection("appendChildren",fileUploadDom);
		            } else {
		    		    waf.appendDOM(sectionDom, fileUploadDom);
		    		}
		            waf.initComponent("fileUpload", flOps, fileUploadDom);
					return sectionDom;
				}else{
                    return obj;
                }
			},
			initFun:function(option){
				waf("#" + option.id).webAttachment(option);
			}
		});
	});
//});

waf.defineClass("waf.webcom.attachment.webAttachment_LocaleStr_l1",waf.framework.WafCore,{
	ADDFILE:"+Add File",
	NOFILES:"No Files"
});

waf.defineClass("waf.webcom.attachment.webAttachment_LocaleStr_l2",waf.framework.WafCore,{
	ADDFILE:"+",
	NOFILES:""
});

waf.defineClass("waf.webcom.attachment.webAttachment_LocaleStr_l3",waf.framework.WafCore,{
	ADDFILE:"+",
	NOFILES:""
});

//mod.defineModule("bizCommonQuery",["waf","panel","column","tabPanel","tab","linkButton","promptBox","promptQuick","datePicker","numberField","select","text","label","dataGrid","bizCommonQuery_i18n"],function(){
	// Date Date String
	// (M)(d)(h)(m)(s)(q)  1-2 
	// (y) 1-4 (S) 1 ( 1-3 )
	// 
	// (new Date()).format("yyyy-MM-dd hh:mm:ss.S") ==> 2006-07-02 08:09:04.423
	// (new Date()).format("yyyy-M-d h:m:s.S")      ==> 2006-7-2 8:9:4.18
	Date.prototype.format = function(fmt) {
	    var o = {
	        "M+" : this.getMonth()+1,                 //
	        "d+" : this.getDate(),                    //
	        "h+" : this.getHours(),                   //
	        "m+" : this.getMinutes(),                 //
	        "s+" : this.getSeconds(),                 //
	        "q+" : Math.floor((this.getMonth()+3)/3), //
	        "S"  : this.getMilliseconds()             //
	    };
	    if(/(y+)/.test(fmt))
	        fmt=fmt.replace(RegExp.$1, (this.getFullYear()+"").substr(4 - RegExp.$1.length));
	    for(var k in o)
	        if(new RegExp("("+ k +")").test(fmt))
	            fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : (("00"+ o[k]).substr((""+ o[k]).length)));
	    return fmt;
	};
	
	(function( $, undefined ) {
		$.widget("waf.bizCommonQuery",$.waf.WebComponent,{
	        options:{
	            id:null,     //ID
	            orgId:null,  //ID
	            gridId:null, //ID
	
	            txtQuickSearchId:null, //
	            btnExpandId:null,  //
	            queryBarId:null,  //ID
				orgGroupNavId:null,    //ID
				dateGroupNavId:null,   //ID
				stateGroupNavId:null,  //ID
				commonSchemeNavId:null,//ID
				advanceQueryDefId:null,//ID
				advanceQueryNavId:null,//ID
	            btnOrgMultiSelectId:null, //
	            btnOrgMoreId:null,        //
	            btnDateMoreId:null,       //
	            datePickerFromId:null,    //
	            datePickerToId:null,      //
	            btnQuerySchSetId:null,      //
	            btnQuerySchMoreId:null,      //
	            btnAdvanceQueryId:null,      //
	            txtQueryNameId:null,         //
	            btnQuerySchSaveId:null,      //
	
				orgField:null,   //Query
				dateField:null,  //Query
				stateField:null, //Query
	            searchOptions:null, //[{name:"number",label:""}]
				dateFormat:null, //json,name
							     //valued1w1m133
	            stateFormat:null,  //name;value
	            orgRequired:false,   //
				dateRequired:false,  //
	            width:null,      //
	            height:null,     //
	            style:null,      //style
	            tagClass:null,   //cssclass
	            queryPK:null,    //Query
	            orgQueryPK:null, //Query            
	            orgDataUrl:null, //URL
	            orgGroupRows:5,  //
	            schemeRows:5,  //
	            
	            commonUseTabHide:false, //
	            schemeTabHide:false, //
	            
	            groupFilters:null, //
	            getCusFields:null, //query
	            
	            companyChanged:null,//
	            afterComFilterClick:null, //
	            afterComFilterRemove:null, //
	            beforeSearch:null  //filter
	        },
	        PRE_ORG_FILTER_LINK:"orgFilter",    //
	        PRE_DATE_FILTER_LINK:"dateFilter",   //
	        PRE_STATE_FILTER_LINK:"stateFilter",  //
	        PRE_SEARCHVIEW_FILTER_LINK:"searchViewFilter",  //
	        PRE_ORG_FILTER_LINK_QB:"orgFilterBar",    //
	        PRE_DATE_FILTER_LINK_QB:"dateFilterBar",   //
	        PRE_STATE_FILTER_LINK_QB:"stateFilterBar",  //
	        PRE_SEARCHVIEW_FILTER_LINK_QB:"searchViewFilterBar",  //
	
	        PRE_ORG_QUERY_BAR_HD:":",
	        PRE_DATE_QUERY_BAR_HD:":",
	        PRE_STATE_QUERY_BAR_HD:":",
	        PRE_SCH_QUERY_BAR_HD:":",
	
	        fields:null,        //Query
	    	fieldValues:null,   //Query
	        orgRowNum:0,    //
	        dateRowNum:0,   //
	        stateRowNum:0,  //
	        searchViewRowNum:0,//
	    	querySchRowNum:0,  //
	        PRE_SELECT_FIELD_ROW:"selectFieldRow",    //ID
	        PRE_SELECT_OPT_ROW:"selectFieldOpsRow",   //ID
	        PRE_DEL_ROW:"deleteRow",                  //ID
	        PRE_INPUT_ROW:"selectFieldValueRow",      //ID
	        PRE_INPUT_TYPE_HIDE_ROW:"selectFieldValueTypeRow",  //ID
	
	        isOrgMultiSelect:false,    //
	        cusMultiSelect:new Map(), 
	
	        firstOrgUnit:null,
	        defAdvanceFilterItems:"", //
	        currentFilterItems:{orgFilterItems:"",
						        dateFilterItems:"",
						        stateFilterItems:"",
						        quickFilterItems:"",
						        advanceFilterItems:"",
						        cusFilterItems:new Map()},
	        hideCusFilters:new Map(),
	        requiredFields:new Map(),
	        isQuerySelectDivHover:false,
	        
	        defaultSch:null,
	        defText:"()",
	        currentFilter:"",
	        uipk:"",
	        
	         /*  */
	        _create:function(){
	            var self = this;
	            
	            self.uipk = _self._uipk;
	
	            this.options.btnOrgMoreId = this.options.id + "_org_btnMore";
	            this.options.btnOrgMultiSelectId = this.options.id + "_org_btnMultiSelect";
	            this.options.btnDateMoreId = this.options.id + "_queryDate_btnMore";
	
	            this.options.btnAdvanceQueryId = this.options.id + "_advanceQueryQuery";
	            this.options.txtQueryNameId = this.options.id + "_saveQueryInput";
	            this.options.btnQuerySchSaveId = this.options.id + "_saveQuery_btnSet";
	
	            this.options.btnExpandId = this.options.id + "_collapseEx";
	
	            // placeholder 
	            if(!"placeholder" in document.createElement("input")){
	                this._placeholder(waf("#"+this.options.id+"_saveQueryInput").placeholder());
	            }
	
	            //
	            waf("#" + this.options.btnExpandId).live("click", function(e){
	                var displayStyle = waf("#" + self.options.id + "_tabPanelCol").css("display");
	                if (displayStyle == "none") {
	                    this.className="ui-commonquery-ex-icon";
	                    this.parentElement.className="ui-column border-sizing ui-commonquery-queryBar-foot-ex";
	                    waf("#"+self.options.id+"_tabPanelCol").show();
	                } else {
	                    this.className="ui-commonquery-notex-icon";
	                    this.parentElement.className="ui-column border-sizing ui-commonquery-queryBar-foot-notex";
	                    waf("#"+self.options.id+"_tabPanelCol").hide();
	                }
	            });
	            
	            if (!self.options.schemeTabHide) {
		            //
		            this._initQuickAdvanceSearch();
	            }
	            //,
		        if (self.options.orgField) {
			        waf.doGet({
			            url: this.options.orgDataUrl,
			            async: false,
			            showBlock: false,
			            data: {
			                "queryPK": this.options.orgQueryPK || ""
			            },
			            success: function (data) {
			                var orgObjRows = data.rows;
			                //
			                self.firstOrgUnit = orgObjRows[0];
			                if (self.defaultSch==null) {
			                    waf("#"+self.PRE_INPUT_ROW+"_org").wafPromptBox("setValue",self.firstOrgUnit);
			                    if (self.defAdvanceFilterItems.length>0)
			                        self.defAdvanceFilterItems += " and "+self.options.orgField+"='"+self.firstOrgUnit.id+"' ";
			                    else 
			                        self.defAdvanceFilterItems += self.options.orgField+"='"+self.firstOrgUnit.id+"' ";
		                        
			                    self.currentFilterItems.advanceFilterItems = self.defAdvanceFilterItems;
			                    self._reloadDataGrid();
			                }
		                    
		                    //
		                    if (!self.options.commonUseTabHide)
				                self._initOrgFilter(orgObjRows);
			            }
			        });
		        }
	            
	            if (!self.options.commonUseTabHide) {
		            //
		            waf("#" + this.options.btnOrgMultiSelectId).live("click", function(e){
		                self._orgMultiSelectOnClick();
		            });
	            
		            //
		            waf("#" + this.options.btnOrgMoreId).live("click", function(e){
		                self._orgMoreOnClick();
		            });
	
		            //
		            if (self.options.dateField) {
						self._initDateFilter();
						self._dateMoreOnClick(self.options.dateField,"",self.options.dateRequired);
		            }
	                    
		            //
		            if (self.defaultSch==null) {
		                 self._reloadDataGrid();
		            }
	
		        	//
		        	if (self.options.stateField) {
		        		var parentEl = waf("#" + this.options.stateGroupNavId);
						var data = eval("(" + this.options.stateFormat + ")");
	
		                var liEl = this._createFilterLink(parentEl, "", 0,
		                    this.PRE_STATE_FILTER_LINK, 0, this._stateFilterOnClick);
		                liEl.addClass("active");
						for (var i = 0; i < data.length; i++) {
		                    this.stateRowNum += 1;
							this._createFilterLink(parentEl, data[i].name, data[i].value,
		                        this.PRE_STATE_FILTER_LINK, this.stateRowNum, this._stateFilterOnClick);
						}
		        	}
	        	
		        	//
		            this.addCusFilter();
		        }
	            
	            //        
	            waf(".choosing").find(".chooseitem a").live("click",function(e){
	    		    var idstr = this.parentNode.id;
	    		    var fieldids = waf(this).parent().find("label").html().split(";");
	    		    for (var i = 0; i < fieldids.length; i++) {
	                    waf("#"+fieldids[i]).parent().removeClass("active");
					}
					var field;
	    		    switch (idstr) {
		 	    	    case self.PRE_ORG_FILTER_LINK_QB :
		 	    	        field = self.options.orgField;
		     		        self.currentFilterItems.orgFilterItems = "";
		     		        break;
		     		    case self.PRE_DATE_FILTER_LINK_QB :
		     		        field = self.options.dateField;
		     		        self.currentFilterItems.dateFilterItems = "";
		     		        break;
		     		    case self.PRE_STATE_FILTER_LINK_QB :
		     		        field = self.options.stateField;
		     		        self.currentFilterItems.stateFilterItems = "";
		 	    	        break;
		 	    	    case self.PRE_SEARCHVIEW_FILTER_LINK_QB :
		 	    	        field = "";
		     		        self._resetOptions();
		 	    	        break;
		 	    	    default:
		 	    	        field = idstr.substring(0,idstr.length-"FilterBar".length);
		 	    	        self.currentFilterItems.cusFilterItems.remove(field);
			        }
	    		    waf(this).parent().parent().remove();
	    		    
	                if (self.options.afterComFilterRemove!=null)
	                    self.options.afterComFilterRemove(e,field,self.currentFilterItems);
	
	    		    //
	                self._reloadDataGrid();
	     	    });	
	        },
	
	        _placeholder : function (el) {
	            el.val(el.attr("placeholder")).focus(function () {
	                if (el.val() === el.attr("placeholder")) {
	                    el.val("");
	                }
	            }).blur(function () {
	                if (el.val().length === 0) {
	                    el.val(el.attr("placeholder"));
	                }
	            });
	        },
	
	        _getSearchkeyNodes:function(event){
	            var self = this;
	            var key = waf("#" + self.options.id + "_searchTxt").val();
	            if (event.keyCode == 13){
	                //
	                //
	                if ("" != waf("#" + self.options.id + "_searchTxt").val()) {
	                    var activeEl = waf(".query-select-div").find(".query-select-fields > li[class='active']");
	                    var name = activeEl.attr("name");
	                    var category = activeEl.attr("text");
	
	                    //
	                    self._quickSearch(key, name, category);
	                }
	            } else if ((event.keyCode == 8 && $("#" + self.options.id + "_searchTxt").val() == "")
	                || (event.keyCode == 27)){
	                //  ESC
	                waf(".query-select-div").find(".query-select-fields > li[class='active']").removeClass("active");
	                waf(".query-select-div").find(".query-select-fields").hide();
	            } else if (event.keyCode == 38 || event.keyCode == 40) {
	                //
	                if( key!=null && key!=""){
	                    var activeEl = waf(".query-select-div").find(".query-select-fields > li[class='active']");
	                    if (waf(".query-select-div").find(".query-select-fields").css("display") == "none"
	                        || activeEl.length <= 0) {
	                        //
	                        waf(".query-select-div").find(".query-select-fields").show();
	
	                        //
	                        waf(".query-select-div .query-select-fields > li[class='active']").removeClass("active");
	                        waf(".query-select-div .query-select-fields > li:first").addClass("active");
	                    } else {
	                        //
	                        var firstLi = waf(".query-select-div .query-select-fields > li:first");
	                        var lastLi = waf(".query-select-div .query-select-fields > li:last");
	                        if (event.keyCode == 38) {
	                            //
	                            if (firstLi.attr("class") == "active") {
	                                waf(".query-select-div .query-select-fields > li:last").addClass("active");
	                            } else {
	                                activeEl.prev().addClass("active");
	                            }
	                        } else {
	                            //
	                            if (lastLi.attr("class") == "active") {
	                                waf(".query-select-div .query-select-fields > li:first").addClass("active");
	                            } else {
	                                activeEl.next().addClass("active");
	                            }
	                        }
	                        activeEl.removeClass("active");
	                    }
	                }
	            } else {
	                //
	                if( key!=null && key!=""){
	                    waf(".query-select-div .query-select-fields").find("li > a > span").empty();
	                    waf(".query-select-div .query-select-fields").find("li > a > span").append("<strong>"+key+"</strong>");
	
	                    if (waf(".query-select-div").find(".query-select-fields > li[class='active']").length <= 0) {
	                        waf(".query-select-div .query-select-fields > li:first").addClass("active");
	                    }
	                    waf(".query-select-div").find(".query-select-fields").show();
	                }
	            }
	            event.stopPropagation();
	            event.preventDefault();
	        },
	
	        _quickSearch:function(key, name, category) {
	            var activeEl = waf(".query-select-div .query-select-fields > li[class='active']");
	            if (activeEl.length > 0) {
	                this._createFacets(key, name, category);
	
	                this._setQuickFilterItems();
	
	                this._reloadDataGrid();
	
	                waf("#" + this.options.id + "_searchTxt").val("");
	                waf(".query-select-div .query-select-fields").find("li > a > span").empty();
	                waf(".query-select-div").find(".query-select-fields").hide();
	            }
	        },
	
	        _createFacets:function(key, name, category){
	            var facet = '<div class="query-search-facet">'
	                        + '<span class="query-search-category" name=""></span>'
	                        + '<span class="query-search-remove">x</span>'
	                        + '<span class="query-search-values">'
	                        +  '<span class="query-search-value"></span>'
	                        + '</span>'
	                        +'</div>';
	
	            var self = this;
	
	            var facetindex = 0;
	            var queryBarSearchId = this.options.id + "_queryBarSearchInput";
	            var inputWidth = waf("#" + self.options.id + "_searchTxt").innerWidth();
	            waf("#" + queryBarSearchId + " .query-search-facet").each(function(index){
	                if(waf(this).find(".query-search-category").attr("name") == name){
	                    facetindex++;
	                    waf(this).find(".query-search-values").append('<span class="query-search-value">'+key+'</span>');
	
	                    waf("#" + self.options.id + "_searchTxt").css("padding-left", waf(this).innerWidth() + 30);
	                    waf("#" + self.options.id + "_searchTxt").css("width", 285);
	                }
	            });
	            if(facetindex == 0){
	                waf("#" + queryBarSearchId).append(facet);
	                waf("#" + queryBarSearchId + " .query-search-facet:last").find(".query-search-category").html(category);
	                waf("#" + queryBarSearchId + " .query-search-facet:last").find(".query-search-value").html(key);
	                if(name!=null){
	                    waf("#" + queryBarSearchId + " .query-search-facet:last").find(".query-search-category").attr("name",name);
	
	                    var width = waf("#" + queryBarSearchId + " .query-search-facet").innerWidth();
	                    waf("#" + self.options.id + "_searchTxt").css("padding-left", width + 30);
	                    waf("#" + self.options.id + "_searchTxt").css("width", 285);
	                }
	            }
	
	            //
	            self.element.find(".query-search-remove").live("click",function(e){
	                waf(this).parent().remove();
	                waf("#" + self.options.id + "_searchTxt").css("padding-left", "");
	                waf("#" + self.options.id + "_searchTxt").css("width", "");
	
	                self._setQuickFilterItems();
	
	                self._reloadDataGrid();
	            });
	        },
	
	        _setQuickFilterItems:function() {
	            var searchEls = waf(".query-search-facet");
	            var filterItems = "";
	            for (var i=0; i<searchEls.length; i++) {
	                var name = waf(searchEls[i]).find(".query-search-category").attr("name");
	
	                var valueEls = waf(searchEls[i]).find(".query-search-value");
	                var filter = "";
	                for (var j=0; j<valueEls.length; j++) {
	                    if (filter.length > 0) {
	                        filter += " and ";
	                    }
	                    filter += name + " like '%" + waf(valueEls[j]).html() + "%' ";
	                }
	
	                if (filter.length > 0) {
	                    if (filterItems.length > 0) {
	                        filterItems += " or "
	                    }
	
	                    filterItems += "(" + filter + ")";
	                }
	            }
	
	            this.currentFilterItems.quickFilterItems = filterItems;
	        },
	
	        _getCompareOpSelectItem:function(val){
	    	    var self = this;
	    	    var searchview_op = null;
	    	    switch (val) {
		 		    case '=' :
		 		        searchview_op = {value:'=',alias:''};
		 		        break;
		 		    case '!=' :
		 		        searchview_op = {value:'!=',alias:''};
		 		        break;
		 		    case '>' :
		 		        searchview_op = {value:'>',alias:''};
		 		        break;
		 		    case '<' :
		 		        searchview_op = {value:'<',alias:''};
		 		        break;
		 		    case '>=' :
		 		        searchview_op = {value:'>=',alias:''};
		 		        break;
		 		    case '<=' :
		 		        searchview_op = {value:'<=',alias:''};
		 		        break;
		 		    case 'like' :
		 		        searchview_op = {value:'like',alias:''};
		 		        break;
		 		    case 'not like' :
		 		        searchview_op = {value:'not like',alias:''};
				    	break;
				}
				return searchview_op;
	    	},
	    	
	        /**
	         * 
	         * @param type 
	         * @returns {Array}
	         * @private
	         */
	        _getQueryFieldExPropOpts: function(type) {
	            var self = this;
	            var selectOpts = new Array();
	            switch (type) {
		 		    case 'String' :
		 		        selectOpts[0] = {value:'like',alias:''};
		 		        selectOpts[1] = {value:'not like',alias:''};
		 		        selectOpts[2] = {value:'=',alias:''};
		 		        selectOpts[3] = {value:'!=',alias:''};
				    	break;
		 		    case 'link' :
		 		        selectOpts[0] = {value:'=',alias:''};
		 		        selectOpts[1] = {value:'!=',alias:''};
				    	break;
				    case 'Number' :
				    case 'Int' :
				    case 'Short' :
				    case 'Double' :
				    case 'BigDecimal' :
				    case 'Integer' :
				    case 'Long' :
				    case 'Float' :
				    case 'Date' :
				    case 'Timestamp' :
	                    selectOpts[0] = {value:'=',alias:''};
		 		        selectOpts[1] = {value:'!=',alias:''};
		 		        selectOpts[2] = {value:'>',alias:''};
		 		        selectOpts[3] = {value:'<',alias:''};
		 		        selectOpts[4] = {value:'>=',alias:''};
		 		        selectOpts[5] = {value:'<=',alias:''};
	                    break;
				    case 'Boolean' :
				    case 'Enum' :
				    case 'EnumString' :
		 		        selectOpts[0] = {value:'=',alias:''};
		 		        selectOpts[1] = {value:'!=',alias:''};
				    	break;
				}
				return selectOpts;
	        },
	
	        _getSearchFiledValue:function(prefix, rowId, filterField) {
	            var self = this;
	            var value;
	
	            var curFieldVal = self.fieldValues.get(filterField);
	            var type = curFieldVal.type;
	
	            if (type != null) {
	                switch (type) {
	                    case 'Boolean' :
	                    case 'Enum' :
	                    case 'EnumString' :
	                        value = waf("#"+prefix+rowId).wafSelect("getValue");
	                        break;
	                    case "Date":
	                    case 'Timestamp' :
	                        value = waf.wafDatePicker.formatDate("yy-mm-dd",waf("#"+prefix+rowId).wafDatePicker("getDate"));
	                        break;
	                    case 'Number' :
	                    case 'Int' :
	                    case 'Short' :
	                    case 'Double' :
	                    case 'BigDecimal' :
	                    case 'Integer' :
	                    case 'Long' :
	                    case 'Float' :
	                        value = waf("#"+prefix+rowId).wafNumberField("getValue");
	                        break;
	                    case 'link' :
	                        value = waf("#"+prefix+rowId).wafPromptBox("getValue");
	                        break;
	                    default:
	                        value = waf("#"+prefix+rowId).wafText("getValue");
	                }
	            }
	            return value;
	        },
	
	        /**
	         * 
	         * @param type 
	         * @param parentEl DOMli
	         * @param curFieldVal 
	         * @param rowId
	         * @private
	         */
	        _getInputPropValueEl: function (type, parentEl, curFieldVal, rowId) {
	            var self = this;
	            var el = waf("#" + self.PRE_SELECT_OPT_ROW + rowId);
	            el.wafSelect("options", "enumSource", this._getQueryFieldExPropOpts(type));
	
	            var inputType;
	            var json = {
	                id: self.PRE_INPUT_ROW + rowId,
	                width:192,
	                style: "margin-right:10px;"
	            };
	            var dom;
	
	            //DOM
	            if (type == "link") {
	                inputType = "promptBox";
		            var dom = waf.createDOM("promptBox", json);
		            waf.appendDOM(parentEl, dom);
		            waf.initComponent(inputType, json, dom);
		            var f7Json = {
		                parentId:self.PRE_INPUT_ROW + rowId,
		                query:curFieldVal.promptQuery
		            };
		            var promptQuickDom = waf.createDOM("promptQuick", f7Json);
		            waf.initComponent("promptQuick", f7Json, promptQuickDom);
	            } else {
		            if (type == "Date") {
		                inputType = "datePicker";
		                json.type = "date";
		                dom = waf.createDOM(inputType, json);
		            }
		            if (type == "Timestamp") {
		                inputType = "datePicker";
		                json.type = "datetime";
		                dom = waf.createDOM(inputType, json);
		            }
		            if (type == 'Number' || type == 'Int' ||
		                type == "Short" || type == "Double" ||
		                type == "BigDecimal" || type == "Integer" ||
		                type == "Long" || type == "Float") {
		                inputType = "numberField";
		                dom = waf.createDOM(inputType, json);
		            }
		            if (type == "Enum" || type == "EnumString") {
		                inputType = "select";
		                json.enumSource = curFieldVal.enumSource;
		                dom = waf.createDOM(inputType, json);
		            }
		            if (type == "Boolean") {
		                inputType = "select";
		                json.enumSource = [
		                    {value: "1", alias: ""},
		                    {value: "0", alias: ""}
		                ];
		                dom = waf.createDOM(inputType, json);
		            }
		            if (type == "String") {
		                inputType = "text";
		                dom = waf.createDOM("text", json);
		            }
		            //
		            waf.appendDOM(parentEl, dom);
		            waf.initComponent(inputType, json, dom);
	            }
	            
	            //
	            var inputTypeJson = {
	                id: self.PRE_INPUT_TYPE_HIDE_ROW + rowId,
	                hidden: true,
	                value: inputType
	            };
	            var inputTypeDom = waf.createDOM("text", inputTypeJson);
	            waf.appendDOM(parentEl, inputTypeDom);
	            waf.initComponent("text", inputTypeJson, inputTypeDom);
	        },
	        
	        _setSelectInputValue:function(rowId,filterField,value) {
	            var self = this;
	            
		    	var curFieldVal = self.fieldValues.get(filterField);
	    		var type = curFieldVal.type;
	    		
	    		var inputType = "text";
			
	    		if (type != null) {
	         	    switch (type) {
	                    case 'Boolean' :
	                    	inputType = "select";
	                        if (value == 1) {
		                        waf("#"+self.PRE_INPUT_ROW+rowId).wafSelect("option",{value:{value:"1",alias:""}});
		                    } else if (value == 0 ) {
		                        waf("#"+self.PRE_INPUT_ROW+rowId).wafSelect("option",{value:{value:"0",alias:""}});      
		                    }
		                    break;
	    			    case 'Enum' :
	    			    case 'EnumString' :
	    			    	inputType = "select";
	                        if (curFieldVal.enumSource!=null) {
		                        for (var i=0;i<curFieldVal.enumSource.length;i++) {
		                            if (curFieldVal.enumSource[i].value == value) {
		                                waf("#"+self.PRE_INPUT_ROW+rowId).wafSelect("option",{value:curFieldVal.enumSource[i]});
		                                break;
		                            }
		                       }
		                    }
	                        break;
	                    case "Date":
	                    case 'Timestamp' :
	                    	inputType = "datePicker";
	                        waf("#"+self.PRE_INPUT_ROW+rowId).wafDatePicker("setDate",value);
	                        break;
	                    case 'Number' :
	                    case 'Int' :
	                    case 'Short' :
		    		    case 'Double' :
		    		    case 'BigDecimal' :
		    		    case 'Integer' :
	    			    case 'Long' :
	    			    case 'Float' :
	    			    	inputType = "numberField";
	                        waf("#"+self.PRE_INPUT_ROW+rowId).wafNumberField("setValue",value);
	                        break;
	                    case 'link' :
	    			    	inputType = "promptBox";
	                        waf("#"+self.PRE_INPUT_ROW+rowId).wafPromptBox("setValue",value);
	                        break;
	                    default:
	                    	waf("#"+self.PRE_INPUT_ROW + rowId).wafText("setValue",value);
	                }
	                
	                //
	                waf("#"+self.PRE_INPUT_TYPE_HIDE_ROW + rowId).wafText("setValue",inputType);
	            }
	        },
	
	        /**
	         * 
	         * @param parentEl DOMli
	         * @param rowId 
	         * @private
	         */
	        _insertSelectFields:function(parentEl, rowId, value){
	            //
	            var self = this;
	            var selectFieldJson = {
	                id:this.PRE_SELECT_FIELD_ROW+rowId,
	                enumSource:this.fields,
	                listHeight:"250px",
	                style:"margin-right:10px",
	                width:75,
	                value:value
	            };
	            selectFieldJson.onchange = function(e,ui) {
	                self._selectFieldOnChange(this.id);
	            };
	            var selectFieldsEl = waf.createDOM("select", selectFieldJson);
	            waf.appendDOM(parentEl, selectFieldsEl);
	            waf.initComponent("select", selectFieldJson, selectFieldsEl);
	        },
	
	        /**
	         * 
	         * @param rowId 
	         * @param parentEl
	         * @param curFieldVal 
	         * @private
	         */
	        _insertSelectOpts:function(rowId, parentEl, curFieldVal){
	            var fieldType = curFieldVal.type;
	            //
	            var selectFieldOpsJson = {
	                id:this.PRE_SELECT_OPT_ROW+rowId,
	                enumSource:this._getQueryFieldExPropOpts(fieldType),
	                listHeight:"150px",
	                style:"margin-right:10px",
	                width:75
	            };
	            var selectFieldOpsEl = waf.createDOM("select", selectFieldOpsJson);
	            waf.appendDOM(parentEl, selectFieldOpsEl);
	            waf.initComponent("select", selectFieldOpsJson, selectFieldOpsEl);
	        },
	
	        /**
	         * 
	         * @param rowId 
	         * @private
	         */
	        _removeSelectOpts:function(rowId){
	            //
	            var optJson = {
	                id:this.PRE_SELECT_OPT_ROW+rowId
	            };
	            waf.removeComponent("select", optJson);
	        },
	
	        /**
	         * 
	         * @param rowId 
	         * @param parentEl DOMli
	         * @param curFieldVal 
	         * @private
	         */
	        _insertSelectInput:function(rowId, parentEl, curFieldVal) {
	            //
	            var fieldType = curFieldVal.type;
	            this._getInputPropValueEl(fieldType,parentEl,curFieldVal,rowId);
	        },
	
	        /**
	         * 
	         * @param rowId 
	         * @private
	         */
	        _removeSelectInput:function(rowId) {
	            //,
	            var type = waf("#"+this.PRE_INPUT_TYPE_HIDE_ROW+rowId).wafText("getValue");
	            if (type != "" && type != null && type.length > 0) {
		            var optValueJson = {
		                id:this.PRE_INPUT_ROW+rowId
		            };
		            waf.removeComponent(type, optValueJson);
		            var optTypeJson = {
		                id:this.PRE_INPUT_TYPE_HIDE_ROW+rowId
		            };
		            waf.removeComponent("text", optTypeJson);
	            }
	        },
	
	        /**
	         * 
	         * @param id ID
	         * @private
	         */
	        _selectFieldOnChange:function(id) {
	            //ID
	            var rowId = id.substring(this.PRE_SELECT_FIELD_ROW.length,id.length);
	
	            //
	            this._removeSelectOpts(rowId);
	            //
	            this._removeSelectInput(rowId);
	
	            var selectFieldEl = waf("#"+this.PRE_SELECT_FIELD_ROW+rowId);
	            var parentEl = selectFieldEl.parent();
	            var curField = selectFieldEl.wafSelect("getValue");
	            var curFieldVal = this.fieldValues.get(curField);
	
	            //
	            this._insertSelectOpts(rowId, parentEl, curFieldVal);
	            this._insertSelectInput(rowId, parentEl, curFieldVal);
	        },
	
	        /**
	         *  :
	         * @private
	         */
	        _addOrgDefOptionRow:function(curField, curOpt, curValue){
	            var self = this;
	            //li
	        	var parentEl = waf("#"+this.options.advanceQueryDefId);
	        	//
	        	var liEl = waf("<li class='adqfilter'></li>");
	            liEl.appendTo(parentEl);
	            //div
	            var divEl = waf("<div id='adq_org'></div>");
	            divEl.appendTo(liEl);
	            divEl.css({display:"inline-block"});
	            //
	            var orgJson = {
	                id:this.PRE_SELECT_FIELD_ROW+"_org",
	                caption:"",
	                style:"margin-right:10px;display:inline-block;width:75px;"
	            };
	            var orgFieldsEl = waf.createDOM("label", orgJson);
	            waf.appendDOM(divEl, orgFieldsEl);
	            waf.initComponent("label", orgJson, orgFieldsEl);
	            //
	            var orgOpsJson = {
	                id:this.PRE_SELECT_OPT_ROW+"_org",
	                enumSource:[{value:'=',alias:''}],
	                listHeight:"150px",
	                style:"margin-right:10px;",
	                width:75
	            };
	            var orgOpsEl = waf.createDOM("select", orgOpsJson);
	            waf.appendDOM(divEl, orgOpsEl);
	            waf.initComponent("select", orgOpsJson, orgOpsEl);
	            //F7
	            var orgValJson = {
	                id:this.PRE_INPUT_ROW + "_org",
	                editable:!this.options.orgRequired,
	                width:192,
	                style: "margin-right:10px;"
	            };
	            var orgValEl = waf.createDOM("promptBox", orgValJson);
	            waf.appendDOM(divEl, orgValEl);
	            waf.initComponent("promptBox", orgValJson, orgValEl);
	            var orgF7Json = {
	                parentId:this.PRE_INPUT_ROW + "_org",
	                dataUrl: waf.getContextPath() + "/component/bizCommonQuery.do?method=getOrgDataForF7&queryPK=" + this.options.orgQueryPK +"&rows=12&page=0"
	            };
	            var promptQuickDom = waf.createDOM("promptQuick", orgF7Json);
	            waf.initComponent("promptQuick", orgF7Json, promptQuickDom);
	            if (self.options.companyChanged!=null) {
	                waf("#" + orgValJson.id).wafPromptBox("option", "onchange", function(e, value){
	    				self.options.companyChanged(e, value, self);
	    			});
				}
	            //
	            var spanHtml = "<span class='ui-lb-text' style='margin-right:10px;'></span>";
	            waf.appendDOM(liEl, waf(spanHtml));
	        },
	        
	        /**
	         *  :
	         * @private
	         */
	        _addDateDefOptionRow:function(curField, curOpt, curValue){
	            var self = this;
	            //li
	        	var parentEl = waf("#"+this.options.advanceQueryDefId);
	            //
	        	var liEl = waf("<li class='adqfilter'></li>");
	            liEl.appendTo(parentEl);
	            //div
	            var divDateEl = waf("<div id='adq_date'></div>");
	            divDateEl.appendTo(liEl);
	            divDateEl.css({display:"inline-block"});
	            divDateEl.css("margin-top","2px");
	            //
	            var dateJson = {
	                id:this.PRE_SELECT_FIELD_ROW+"_date",
	                caption:"",
	                style:"margin-right:10px;display:inline-block;width:75px;"
	            };
	            var dateFieldsEl = waf.createDOM("label", dateJson);
	            waf.appendDOM(divDateEl, dateFieldsEl);
	            waf.initComponent("label", dateJson, dateFieldsEl);
	            //
	            var dateOpsJson = {
	                id:this.PRE_SELECT_OPT_ROW+"_date",
	                enumSource:[{value:'=',alias:''},{value:'between',alias:''}],
	                onchange:function(e,ui){self._dateOpsChange(e,ui)},
	                listHeight:"150px",
	                width:75,
	                style:"margin-right:10px"
	            };
	            var dateOpsEl = waf.createDOM("select", dateOpsJson);
	            waf.appendDOM(divDateEl, dateOpsEl);
	            waf.initComponent("select", dateOpsJson, dateOpsEl);
	            //date
	            var divValEl = waf("<div id='adq_date_val'></div>");
	            waf.appendDOM(divDateEl, divValEl);
	            divValEl.css({display:"inline-block"});
	            var dateDatas = this._getDateEnumSource();
	            var dateValJson = {
	                id:this.PRE_INPUT_ROW + "_date",
	                enumSource:dateDatas.enumSource,
	                value:dateDatas.defValue,
	                listHeight:"150px",
	                width:192,
	                style: "margin-right:10px;"
	            };
	            var dateValEl = waf.createDOM("select", dateValJson);
	            waf.appendDOM(divValEl, dateValEl);
	            waf.initComponent("select", dateValJson, dateValEl);
	            //
	            var spanHtml = "<span class='ui-lb-text' style='margin-right:10px;'></span>";
	            waf.appendDOM(liEl, waf(spanHtml));
	        },
	        
	        /**
	         * 
	         * @private
	         */
	        _addNewOptionRow:function(curField, curOpt, curValue){
	            this.querySchRowNum += 1;
	            var rowId = this.querySchRowNum;
	
	            //li
	        	var parentEl = waf("#"+this.options.advanceQueryNavId);
	        	var liEl = waf("<li></li>");
	            liEl.appendTo(parentEl);
	
	            //div
	            var divEl = waf("<div id='"+ rowId +"'></div>");
	            divEl.appendTo(liEl);
	            divEl.css({display:"inline-block"});
	
	            //
	            var fieldValue = null;
	            if (curField != null && curField != "") {
	            	fieldValue = this._getFilterFieldSelectItem(curField);
	            }
	            this._insertSelectFields(divEl, rowId, fieldValue);
	            var selectFieldEl = waf("#"+this.PRE_SELECT_FIELD_ROW+rowId);
	
	            //
	            var curFieldDefault = selectFieldEl.wafSelect("getValue");
	            var curFieldVal = this.fieldValues.get(curFieldDefault);
		            
	            //
	            this._insertSelectOpts(rowId, divEl, curFieldVal);
	            
	            if(curOpt != null && curOpt != "") {
	            	var optValue = this._getCompareOpSelectItem(curOpt);
	            	waf("#"+ this.PRE_SELECT_OPT_ROW+rowId).wafSelect("option",{value:optValue});
	            }
	
	            //
	            this._insertSelectInput(rowId, divEl, curFieldVal);
	            if(curValue != null && curValue != "") {
	            	this._setSelectInputValue(rowId, curField, curValue);
	            }
	        	
	        	//
	            var spanHtml = "<span class='ui-lb-text' style='margin-right:10px;'></span>";
	            waf.appendDOM(liEl, waf(spanHtml));
	
	            //
	            var btnOpts = {
	                id:this.PRE_DEL_ROW+rowId,
	                caption:"",
	                tagClass:"adqdel"
	            };
	            var linkBtnDom = waf.createDOM("linkButton", btnOpts);
	            waf.appendDOM(liEl, linkBtnDom);
	            waf.initComponent("linkButton", btnOpts, linkBtnDom);
	            //
	            waf("#"+this.PRE_DEL_ROW+rowId).live("click",function(e){
	            	waf(this).parent().remove();
	            });
	        },
	        
	        _reloadDataGrid:function() {
	            var filter = "";
	
	            if (this.currentFilterItems.orgFilterItems.length > 0) {
	                filter = filter + this.currentFilterItems.orgFilterItems;
	            }
	
	            if (this.currentFilterItems.dateFilterItems.length > 0) {
	                if (filter.length > 0) {
	                    filter = filter + " and "
	                }
	                filter = filter + this.currentFilterItems.dateFilterItems;
	            }
	
	            if (this.currentFilterItems.stateFilterItems.length > 0) {
	                if (filter.length > 0) {
	                    filter = filter + " and "
	                }
	                filter = filter + this.currentFilterItems.stateFilterItems;
	            }
	
	            if (this.currentFilterItems.quickFilterItems.length > 0) {
	                if (filter.length > 0) {
	                    filter = filter + " and "
	                }
	                filter = filter + this.currentFilterItems.quickFilterItems;
	            }
	            
	            if (this.currentFilterItems.advanceFilterItems.length > 0) {
	                if (filter.length > 0) {
	                    filter = filter + " and "
	                }
	                filter = filter + this.currentFilterItems.advanceFilterItems;
	            }
	            
	            if (this.currentFilterItems.cusFilterItems.values().length > 0) {
	                if (filter.length > 0) {
	                    filter = filter + " and "
	                }
	                for (var i=0;i<this.currentFilterItems.cusFilterItems.values().length;i++) {
	                    filter += this.currentFilterItems.cusFilterItems.values()[i];
	                    if (i<this.currentFilterItems.cusFilterItems.values().length-1)
	                        filter += " and ";
	                }
	            }
	            
	            if (this.options.beforeSearch!=null) {
			        filter = this.options.beforeSearch(filter);
			    }
	            this.currentFilter=filter;
	            
	            waf("#"+this.options.gridId).dataGrid("option","page",1);
	            waf("#"+this.options.gridId).dataGrid("option","filterItems",filter);
	            waf("#"+this.options.gridId).dataGrid("reloadGrid");
	        },
	        
	        /* sql */
	        _getDateSql:function (filterField, compareOp, filterValue) {
	            var dataFilter = filterField+compareOp+"'"+filterValue+"'";
	            
	            if (dataFilter.length>0)
	                dataFilter = "(" + dataFilter + ")";
	            return dataFilter;
	        },
	
	        _setOrgFilterItemByMultiSelect:function(filterField, filterValue) {
	            var filterItems = filterField + "='" + filterValue + "' ";
	
	            this.currentFilterItems.orgFilterItems = filterItems;
	        },
	
	        _setOrgFilterItem:function(filterField, filterValue) {
	            var filterItems = filterField + "='" + filterValue + "' ";
	
	            this.currentFilterItems.orgFilterItems = filterItems;
	        },
	
	        _setDateFilterItemByRange:function(filterField, dateFrom, dateTo) {
	            var filterItems = "(";
	            filterItems += this._getDateSql(filterField, ">=", dateFrom.format("yyyy-MM-dd"));
	            filterItems += "and" + this._getDateSql(filterField, "<=", dateTo.format("yyyy-MM-dd"));
	            filterItems += ")";
	            if (filterField==this.options.dateField)
	                this.currentFilterItems.dateFilterItems = filterItems;
	            else
	                this.currentFilterItems.cusFilterItems.put(filterField,filterItems);
	        },
	
	        _getDateFilter:function(filterField, filterValue) {
	            var self = this;
	            var dateFlag = filterValue.substring(0,1);
	            var dateNum = filterValue.substring(1,2);
	
	            var today = new Date();
	            var day  = today.getDay();
	            var month = today.getMonth();
	            var year = today.getFullYear();
	
	            var filterItems;
	            var beginTime = null;
	            var endTime = null;
	            var beginCompare;
	            var endCompare;
	            switch(dateFlag) {
	                case "d":
	                    //
	                    beginTime = today;
	                    beginCompare = ">=";
	                    endTime =  new Date(year, month, today.getDate()+ 1);
	                    endCompare = "<";
	                    break;
	                case "w":
	                    //
	                    var weekFirstDay = today.getDate() - (day -1);
	                    beginTime = new Date(year, month, weekFirstDay);
	                    beginCompare = ">=";
	                    endTime =  new Date(year, month, weekFirstDay + 7);
	                    endCompare = "<";
	                    break;
	                case "m":
	                    //
	                    if (dateNum == 3) {
	                        beginTime = new Date(year, month - 2, 1);
	                        endTime = new Date(year, month + 1, 1);
	                    } else {
	                        beginTime = new Date(year, month, 1);
	                        endTime = new Date(year, month + 1, 1);
	                    }
	                    beginCompare = ">=";
	                    endCompare = "<";
	                    break;
	                default:
	                    //
	                    var weekFirstDay = today.getDate() - (day -1);
	                    beginTime = new Date(year, month, weekFirstDay);
	                    beginCompare = ">=";
	                    endTime =  new Date(year, month, weekFirstDay + 7);
	                    endCompare = "<";
	            }
	
	            filterItems = "(";
	            filterItems += self._getDateSql(filterField, beginCompare, beginTime.format("yyyy-MM-dd"));
	            if (endTime != null) {
	                filterItems += " and " + this._getDateSql(filterField, endCompare, endTime.format("yyyy-MM-dd"));
	            }
	            filterItems += ")";
	
	            return filterItems;
	        },
	        
	        _setDateFilterItem:function(filterField, filterValue) {
	            var self = this;
	            var filterItems = self._getDateFilter(filterField, filterValue);
	            self.currentFilterItems.dateFilterItems = filterItems;
	        },
	
	        _orgFilterOnClick:function(self, e, elId, idPre, options) {
	            var rowCount = self.orgRowNum;;
	            var filterField = self.options.orgField;
	            if (self.isOrgMultiSelect) {
	                //,
	                if (self._hasSomeClass(waf("#"+elId).parent().attr("class"),"active")) {
	                    waf("#"+elId).parent().removeClass("active");
	                } else {
	                    waf("#"+elId).parent().addClass("active");
	                }
	            } else {
	                var caption = "";
	
	                if (self._hasSomeClass(waf("#"+elId).parent().attr("class"),"active")) {
	                    //
	                    return;
	                }
	
	                //
	                for (var i=1; i<=rowCount; i++) {
	                    var currId = idPre + i;
	                    if (currId == elId) {
	                        waf("#"+currId).parent().addClass("active");
	                        caption = waf("#"+currId).wafLinkButton("option", "caption");
	                    } else {
	                        waf("#"+currId).parent().removeClass("active");
	                    }
	                }
	
	                var filterValue = waf("#" + elId + "_v").wafText('getValue');
	                self._setOrgFilterItem(filterField, filterValue);
	
	                //
	                self._updateChooseBar(self.PRE_ORG_FILTER_LINK_QB,
	                    self.PRE_ORG_QUERY_BAR_HD, caption, elId, options);
	                if (self.options.orgRequired) {
				        self.requiredFields.put(self.options.orgField,{filterLinkQBId:self.PRE_ORG_FILTER_LINK_QB,
				                                                       caption:self.PRE_ORG_QUERY_BAR_HD+caption,
				                                                       value:elId,
				                                                       filter:filterField+"='"+filterValue+"' "});
		            }
	                if (self.options.afterComFilterClick!=null)
	                    self.options.afterComFilterClick(e,filterField,filterValue,self.currentFilterItems);
	
	                //
	                self._reloadDataGrid();
	            }
	        },
	
	        _dateFilterOnClick:function(self, e, elId, idPre, options) {
	            var rowCount = self.dateRowNum;
	            var filterField = self.options.dateField;
	
	            var caption = "";
	
	            if (waf("#"+elId).parent().attr("class") == "active") {
	                //
	                return;
	            }
	
	            for (var i=1; i<=rowCount; i++) {
	                var currId = idPre + i;
	                if (currId == elId) {
	                    waf("#"+currId).parent().addClass("active");
	                    caption = waf("#"+currId).wafLinkButton("option", "caption");
	                } else {
	                    waf("#"+currId).parent().removeClass("active");
	                }
	            }
	
	            //
	            var filterValue = waf("#" + elId + "_v").wafText('getValue');
	            self._setDateFilterItem(filterField, filterValue);
	
	            //
	            self._updateChooseBar(self.PRE_DATE_FILTER_LINK_QB,
	                self.PRE_DATE_QUERY_BAR_HD, caption, elId, options);
	            if (self.options.dateRequired) {
				    self.requiredFields.put(self.options.dateField,{filterLinkQBId:self.PRE_DATE_FILTER_LINK_QB,
				                                                    caption:self.PRE_DATE_QUERY_BAR_HD+caption,
				                                                    value:elId,
				                                                    filter:self._getDateFilter(filterField, filterValue)});
		        }
	            if (self.options.afterComFilterClick!=null)
	                self.options.afterComFilterClick(e,filterField,filterValue,self.currentFilterItems);
	
	            //
	            self._reloadDataGrid();
	        },
	
	        _stateFilterOnClick:function(self, e, elId, idPre) {
	            var rowCount = self.stateRowNum;
	            var filterField = self.options.stateField;
	            var filterItems;
	
	            var caption = "";
	
	            if (waf("#"+elId).parent().attr("class") == "active") {
	                //
	                return;
	            }
	
	            //00
	            for (var i=0; i<=rowCount; i++) {
	                var currId = idPre + i;
	                if (currId == elId) {
	                    waf("#"+currId).parent().addClass("active");
	                    caption = waf("#"+currId).wafLinkButton("option", "caption");
	                } else {
	                    waf("#"+currId).parent().removeClass("active");
	                }
	            }
	
	            var filterValue = "";
	            if (elId != idPre+"0") {
	                filterValue = waf("#" + elId + "_v").wafText('getValue');
	                filterItems = filterField + "=" + filterValue;
	                
	                //
	                self._updateChooseBar(self.PRE_STATE_FILTER_LINK_QB,
	                self.PRE_STATE_QUERY_BAR_HD, caption, elId);
	            } else {
	            	waf("#" + self.PRE_STATE_FILTER_LINK_QB).parent().remove();
	                filterItems = "";
	            }
	
	            self.currentFilterItems.stateFilterItems = filterItems;
	
	            if (self.options.afterComFilterClick!=null)
	                self.options.afterComFilterClick(e,filterField,filterValue,self.currentFilterItems);
	
	            //
	            self._reloadDataGrid();
	        },
	
	        _getSearchViewFilterArr:function() {
	        	var self = this;
	        	var searchResult = [],
	        	    i=0;
	
	            //:
	            var orgFilterField = self.options.orgField;
	            if (orgFilterField) {
		            var orgFilterOps = waf("#" + self.PRE_SELECT_OPT_ROW+"_org").wafSelect("getValue");
		            var orgFilterValue = waf("#" + self.PRE_INPUT_ROW + "_org").wafPromptBox("getValue");
	
		            if (orgFilterValue != null && orgFilterValue != "") {
		                searchResult[i] = {
		                    prop_field : "aqdef."+orgFilterField,
		                    prop_op : orgFilterOps,
		                    prop_value : orgFilterValue
		                }
		                i++;
		            }
	            }
	            
	            //:
	            var dateFilterField = self.options.dateField;
	            if (dateFilterField) {
		            var dateFilterOps = waf("#" + self.PRE_SELECT_OPT_ROW+"_date").wafSelect("getValue");
		            if (dateFilterOps == "=") {
		                var dateFilterValue = waf("#" + self.PRE_INPUT_ROW + "_date").wafSelect("getValue");
		                if (dateFilterValue != null && dateFilterValue != "") {
		                    searchResult[i] = {
		                        prop_field : "aqdef."+dateFilterField,
		                        prop_op : dateFilterOps,
		                        prop_value : dateFilterValue
		                    }
		                    i++;
		                }
		            }
		            if (dateFilterOps == "between") {
		                var dateFromValue = waf("#adqDateFrom").wafDatePicker("getValue");
		                if (dateFromValue != null && dateFromValue != "") {
		                    searchResult[i] = {
		                        prop_field : "aqdef."+dateFilterField,
		                        prop_op : ">=",
		                        prop_value : waf.wafDatePicker.formatDate("yy-mm-dd",dateFromValue)
		                    }
		                    i++;
		                }
		                var dateToValue = waf("#adqDateTo").wafDatePicker("getValue");
		                if (dateToValue != null && dateToValue != "") {
		                    searchResult[i] = {
		                        prop_field : "aqdef."+dateFilterField,
		                        prop_op : "<=",
		                        prop_value : waf.wafDatePicker.formatDate("yy-mm-dd",dateToValue)
		                    }
		                    i++;
		                }
		            }
	            }
	            
	            //
	            waf("#" + self.options.advanceQueryNavId + " > li").each(function(index){
	                var rowId = waf(this).find("div").attr("id");
	
	                var filterField = waf("#" + self.PRE_SELECT_FIELD_ROW + rowId).wafSelect("getValue");
	                var filterOps = waf("#" + self.PRE_SELECT_OPT_ROW + rowId).wafSelect("getValue");
	                var filterValue = self._getSearchFiledValue(self.PRE_INPUT_ROW, rowId, filterField);
	
	                if (filterValue == null || filterValue == "") {
	                    return;
	                }
	                searchResult[i] = {
	                    prop_field : filterField,
	                    prop_op : filterOps,
	                    prop_value : filterValue
	                }
	                i++;
	            });
	            
	            return searchResult;
	        },
	        
	        _getFilterFieldSelectItem:function(val){
	    	    if (this.fields!=null) {
	    	        for (var i=0;i<this.fields.length;i++) {
	    	            if (this.fields[i].value == val) {
	    	                return this.fields[i];
	    	            }
	    	        }
	    	    }
	    	    return null;
	    	},
	    	
	        _advanceSearch:function(searchResult) {
	        	var self = this;
	        	
	        	var filterItems = "";
	        	for (var index=0; index < searchResult.length; index++) {
	        		var filterField = searchResult[index].prop_field;
	        		var prop_op = searchResult[index].prop_op;
	        		var prop_value = searchResult[index].prop_value;
		        	
		        	//:
		        	if(filterField=="aqdef."+self.options.orgField) {
		        	    filterItems += self.options.orgField +" "+ prop_op+" '"+prop_value.id+"' ";
		        	} else if(filterField=="aqdef."+self.options.dateField) {
		        	    //
		        	    var dateFilter = "";
					    if(prop_op == "=" && (prop_value.indexOf("d")==0||prop_value.indexOf("w")==0||prop_value.indexOf("m")==0)){
					        dateFilter = self._getDateFilter(self.options.dateField, prop_value);
						}else{
						    dateFilter = self._getDateSql(self.options.dateField,prop_op,prop_value);
						}	
						if(index == 0){
						    filterItems += dateFilter;
						}else{
							filterItems += " and " + dateFilter;
						}
		        	} else {
		        	    var curFieldVal = self.fieldValues.get(filterField);
	    			    var type = curFieldVal.type;
	    			    if(type == "link")
	    			        prop_value = prop_value.id;
	    				if(type == "String" || type == "link" || type == "EnumString"){
	    					if(index == 0){
	    						if(prop_op == "like" || prop_op == "not like"){
	    							filterItems += filterField +" "+ prop_op+" '%"+prop_value+"%' ";
	    						}else{
	    							filterItems += filterField + prop_op+" '"+prop_value+"' ";
	    						}
	    					}else{
	    						if(prop_op == "like" || prop_op == "not like"){
	    							filterItems += " and "+filterField +" "+ prop_op+" '%"+prop_value+"%'";
	    						}else{
	    							filterItems += " and "+filterField + prop_op+" '"+prop_value+"'";
	         					}
	    					}
	    				}else if(type == "Date" || type == "Timestamp" ){
	    					if(index == 0){
	    					    filterItems += self._getDateSql(filterField,prop_op,prop_value);
	    					}else{
	    						filterItems += " and " + self._getDateSql(filterField,prop_op,prop_value);
	    					}
	    				}else{
	    					if(index == 0){
	    						filterItems += filterField + prop_op + prop_value;
	    					}else{
		    					filterItems += " and " + filterField + prop_op + prop_value;
		    				}
		    			}
					}
	        	}
	        	self.currentFilterItems.advanceFilterItems = "(" + filterItems + ")";
	        	//
	            self._reloadDataGrid();
	            //
	            self.currentFilterItems.advanceFilterItems = "";
	        },
	        
	        _searchViewFilterOnClick:function(self, e, elId, idPre) {
	        	var rowCount = self.searchViewRowNum;            
	            var caption = "";
	            if (waf("#"+elId).parent().attr("class") == "active") {
	                //
	                return;
	            }
	            for (var i=0; i<=rowCount; i++) {
	                var currId = idPre + i;
	                if (currId == elId) {
	                    waf("#"+currId).parent().addClass("active");
	                    caption = waf("#"+currId).wafLinkButton("option", "caption");
	                } else {
	                    waf("#"+currId).parent().removeClass("active");
	                }
	            }
	            //
	            self._updateChooseBar(self.PRE_SEARCHVIEW_FILTER_LINK_QB,self.PRE_SCH_QUERY_BAR_HD, caption, elId);
	            
	            if (elId == idPre + "0") {
	            	//
					waf("#"+self.options.advanceQueryNavId + " > li").remove();
	            	self._addNewOptionRow(null, null, null);
	            } else {
		            //ID
		            var searchViewId = waf("#" + elId + "_v").wafText('getValue');;
		            
		            //Ajax
		            waf.doGet({
						url: waf.getContextPath() + "/component/bizCommonQuery.do?method=findSearchView",
						data: {
						    query: self.options.queryPK,
							viewId : searchViewId
						},
						success: function(data) {
							var searchFilter = data.searchFilter;
							var defaultView = data.defaultView;
							
							if (searchFilter.length > 0) {
							    //
								waf("#"+self.options.advanceQueryDefId + " > li").remove();
								waf("#"+self.options.advanceQueryNavId + " > li").remove();
								if (caption.indexOf(self.defText)>=0) {
								    waf("#" + self.options.txtQueryNameId).val(caption.substring(0,caption.length-self.defText.length));
								} else {
								    waf("#" + self.options.txtQueryNameId).val(caption);
								}
								//
								if (self.options.orgField)
		                            self._addOrgDefOptionRow();
	                            if (self.options.dateField)
	                                self._addDateDefOptionRow();
								//
								for (var j = 0; j < searchFilter.length; j++) {
									var curField = searchFilter[j].prop_field;
						            var curOp = searchFilter[j].prop_op;		     	        
					    	        var curValue = searchFilter[j].prop_value;
					    	        if (curField == "aqdef."+self.options.orgField) {
					    	            //
					    	            waf("#"+self.PRE_INPUT_ROW + "_org").wafPromptBox("setValue",curValue);
					    	        } else if (curField == "aqdef."+self.options.dateField) {
					    	            //
					    	            if (curOp == "=") {
					    	                var dateObj = self._getDateObjByValue(curValue);
					    	                waf("#"+self.PRE_INPUT_ROW + "_date").wafSelect("option","value",dateObj);
					    	            } else if (curOp == ">=" || curOp == "<=") {
					    	                waf("#"+self.PRE_SELECT_OPT_ROW + "_date").wafSelect("option","value",{value:'between',alias:''});
					    	                if (curOp == ">=")
					    	                    waf("#adqDateFrom").wafDatePicker("setValue",curValue);
					    	                if (curOp == "<=")
					    	                    waf("#adqDateTo").wafDatePicker("setValue",curValue);
					    	            }
					    	        } else {
	    				    	        //
	    					            self._addNewOptionRow(curField, curOp, curValue);
						            }
								}
								
								//,
								var searchResult = self._getSearchViewFilterArr();
								self._advanceSearch(searchResult);
							}
						}
					});
	            }
	        },
	
	        _updateQueryBarFilter:function(filterLinkQBId,filterLinkQBHdPre,caption,filterIds) {
	            var self = this;
	
	            //
	            var queryBarEl = waf("#" + self.options.queryBarId);
	            var QBEl = waf("#" + filterLinkQBId);
	            if (QBEl == null || QBEl.length <= 0) {
	                self._createFilterLink(queryBarEl, filterLinkQBHdPre+caption, filterIds,
	                    filterLinkQBId, "", null);
	            } else {
	                QBEl.wafLinkButton("option", "caption", filterLinkQBHdPre+caption);
	                waf("#" + filterLinkQBId + "_v").wafText('setValue', filterIds);
	                QBEl.attr("title", filterLinkQBHdPre+caption);
	            }
	        },
	
	        /**
	         * 
	         * @private
	         */
	        _dateMoreOnClick:function(field,title,required) {
	            var parentEl = waf("#"+this.options.id+"_query"+field+"GroupNav");
	            var preFilter = field+"Filter",
	                preQB = field+"FilterBar",
	                preHD = title+":";
	            if (field==this.options.dateField) {
		            parentEl = waf("#"+this.options.dateGroupNavId);
		            preFilter = this.PRE_DATE_FILTER_LINK;
		            preQB = this.PRE_DATE_FILTER_LINK_QB;
		            preHD = this.PRE_DATE_QUERY_BAR_HD;
		        }
	            var liEl = waf("<li id='"+field+"dateFilterCust'></li>");
	            liEl.css("height","28px");
	            liEl.appendTo(parentEl);
	            
	            waf('<span class="ui-lb-text ui-commonquery-group-dateCus">:</span>').appendTo(liEl);
	
	            //
	            var datePickerJson;
	            datePickerJson = {
	                id:field+"dateFrom",
	                name:field+"dateFrom",
	                width:"100px",
	                dateFormat:"yy-mm-dd"
	            };
	            var datePickerFromDom = waf.createDOM("datePicker", datePickerJson);
	            waf.appendDOM(liEl, datePickerFromDom);
	            waf.initComponent("datePicker", datePickerJson, datePickerFromDom);
	
	            //
	            var divEl = waf("<div><span class='ui-lb-text'>-</span></div>");
	            divEl.css("display","inline-block");
	            divEl.css("vertical-align","top");
	            divEl.css("padding-top","5px");
	            divEl.css("margin-left","2px");
	            divEl.css("margin-right","2px");
	            divEl.appendTo(liEl);
	
	            //
	            datePickerJson = {
	                id:field+"dateTo",
	                name:field+"dateTo",
	                dateFormat:"yy-mm-dd",
	                width:"100px",
	                style:"margin-right: 8px;"
	            };
	            var datePickerFromTo = waf.createDOM("datePicker", datePickerJson);
	            waf.appendDOM(liEl, datePickerFromTo);
	            waf.initComponent("datePicker", datePickerJson, datePickerFromTo);
	
	            //
	            var self = this;
	            var divBtnEl = waf("<div class='ui-commonquery-group-confirm'></div>");
	            divBtnEl.appendTo(liEl);
	            var btnJson = {
	                tagClass:"btn",
	                caption:"",
	                id:"dateRangOK",
	                onclick:(function(){
	                    var dateFrom = waf("#"+field+"dateFrom").wafDatePicker("getValue");
	                    var dateTo = waf("#"+field+"dateTo").wafDatePicker("getValue");
	
	                    //
	                    if (dateFrom == null || dateTo==null) {
	                        _self.showMessage("!");
	                    } else {
	                        if (dateFrom > dateTo) {
	                            _self.showMessage("!");
	                        } else {
	                            for (var i=1; i<=self.dateRowNum; i++) {
	                                waf("#"+preFilter+i).parent().removeClass("active");
	                            }
	                            //waf("#dateFilterCust").addClass("active");
	
	                            //
	                            self._setDateFilterItemByRange(field, dateFrom, dateTo);
	
	                            //
	                            var caption = dateFrom.format("yyyy-MM-dd") + "~" + dateTo.format("yyyy-MM-dd");
	                            var filterValue = dateFrom.format("yyyy-MM-dd") + "~" + dateTo.format("yyyy-MM-dd");
	                            self._updateChooseBar(preQB,preHD, caption, field+"dateFilterCust",{required:self.options.dateRequired});
	                            if (required) {
	                                var filterItems = "(";
						            filterItems += self._getDateSql(field, ">=", dateFrom.format("yyyy-MM-dd"));
						            filterItems += "and" + self._getDateSql(field, "<=", dateTo.format("yyyy-MM-dd"));
						            filterItems += ")";
							        self.requiredFields.put(field,{filterLinkQBId:preQB,
					                                               caption:preHD+caption,
					                                               value:field+"dateFilterCust",
					                                               filter:filterItems});
			                    }
	                            if (self.options.afterComFilterClick!=null)
	                                 self.options.afterComFilterClick(null,self.options.dateField,self.currentFilterItems.dateFilterItems,self.currentFilterItems);
	                            }
	
	                            //
	                            self._reloadDataGrid();
	                    }
	                })
	            };
	            var btnOK = waf.createDOM("linkButton", btnJson);
	            waf.appendDOM(divBtnEl, btnOK);
	            waf.initComponent("linkButton", btnJson, btnOK);
	//            btnJson = {
	//                tagClass:"btn",
	//                caption:"",
	//                id:"dateRangCancel",
	//                onclick:(function(){
	//                    waf("#" + self.options.btnDateMoreId).wafLinkButton("option","style","");
	//                    waf("#dateFilterCust").remove();
	//
	//                    //
	//                    var dateFilterValue = waf("#" + self.PRE_DATE_FILTER_LINK_QB + "_v").wafText("getValue");
	//                    if (dateFilterValue == "dateFilterCust") {
	//                        //
	//                        waf("#" + self.PRE_DATE_FILTER_LINK + "2").click();
	//                    }
	//                })
	//            };
	//            var btnCancel = waf.createDOM("linkButton", btnJson);
	//            waf.appendDOM(divBtnEl, btnCancel);
	//            waf.initComponent("linkButton", btnJson, btnCancel);
	
	            //
	            waf("#" + this.options.btnDateMoreId).wafLinkButton("option","style","display:none");
	        },
	
	        /**
	         * 
	         * @private
	         */
	        _orgMultiSelectOnClick:function(){
	            var self = this;
	            self.isOrgMultiSelect = true;
	            
	            var orgMoreli = waf("#" + self.options.id+"_queryOrgContent").find(".ui-commonquery-group-nav .more");
	            if (orgMoreli.css("display")=="none") {
	                orgMoreli.show();
	                waf("#" + this.options.btnOrgMoreId).wafLinkButton("option","caption","");
	            } 
	
	            waf("#" + self.options.id+"_queryOrgMore").css("display", "none");
	            var parentEl = waf("#" + self.options.id+"_queryOrgContent");
	            var divEl = waf("<div id='orgMultiSelectCol'></div>");
	            divEl.css("margin-right","150px");
	            divEl.css("text-align", "center");
	            divEl.appendTo(parentEl);
	
	            var btnJson = {
	                tagClass:"btn",
	                caption:"",
	                id:"orgMultiOK",
	                onclick:(function(){
	                    //
	                    var activeEls = waf("#" + self.options.orgGroupNavId + " .active");
	                    if (activeEls.length <= 0) {
	                        return;
	                    }
	
	                    var filterItems = "";
	                    var filterField = self.options.orgField;
	                    var captions = "";
	                    var values = "";
	                    for (var i=1; i<=self.orgRowNum; i++) {
	                        var orgElId = self.PRE_ORG_FILTER_LINK + i;
	                        if (self._hasSomeClass(waf("#"+orgElId).parent().attr("class"),"active")) {
	                            if (filterItems.length > 0) {
	                                filterItems += " or ";
	                            }
	                            var value = waf("#" + orgElId + "_v").wafText('getValue');
	                            filterItems += filterField + "='" + value + "'";
	
	                            if (captions.length > 0) {
	                                captions += ",";
	                            }
	                            captions += waf("#" + orgElId).wafLinkButton("option", "caption");
	                            if (values.length > 0) {
	                                values += ";";
	                            }
	                            values += orgElId;
	                        }
	                    }
	                    filterItems = "(" + filterItems + ")";
	                    self.currentFilterItems.orgFilterItems = filterItems;
	
	                    //
	                    self._updateChooseBar(self.PRE_ORG_FILTER_LINK_QB, self.PRE_ORG_QUERY_BAR_HD, captions, values, {required:self.options.orgRequired})
	                    if (self.options.orgRequired) {
					        self.requiredFields.put(self.options.orgField,{filterLinkQBId:self.PRE_ORG_FILTER_LINK_QB,
					                                                       caption:self.PRE_ORG_QUERY_BAR_HD+captions,
					                                                       value:values,
					                                                       filter:filterItems});
			            }
	                    if (self.options.afterComFilterClick!=null)
	                        self.options.afterComFilterClick(null,filterField,filterItems,self.currentFilterItems);
	
	                    //
	                    self._reloadDataGrid();
	
	                    //
	                    waf("#" + self.options.id+"_queryOrgMore").css("display", "");
	
	                    //
	                    waf("#orgMultiSelectCol").remove();
	                    
	                    //
	                    var orgMoreli = waf("#" + self.options.id+"_queryOrgContent").find(".ui-commonquery-group-nav .more");
	                    orgMoreli.hide();
	                    waf("#" + self.options.btnOrgMoreId).wafLinkButton("option","caption","");
	
	                    //
	                    self.isOrgMultiSelect = false;
	                })
	            };
	            var btnCancel = waf.createDOM("linkButton", btnJson);
	            waf.appendDOM(divEl, btnCancel);
	            waf.initComponent("linkButton", btnJson, btnCancel);
	
	            btnJson = {
	                tagClass:"btn",
	                caption:"",
	                id:"orgMultiCancel",
	                onclick:(function(){
	                    //
	                    waf("#" + self.options.orgGroupNavId + " .active").removeClass("active");
	
	                    var orgFilterValue = waf("#" + self.PRE_ORG_FILTER_LINK_QB).find("label").html();
	                    if (orgFilterValue!=null) {
	                        var orgFilterIdArr = orgFilterValue.split(";");
	                        for (var i=0;i<orgFilterIdArr.length; i++) {
	                            waf("#"+orgFilterIdArr[i]).parent().addClass("active");
	                        }
	                    }
	                    //
	                    waf("#" + self.options.id+"_queryOrgMore").css("display", "");
	                    //
	                    waf("#orgMultiSelectCol").remove();
	                    //
	                    var orgMoreli = waf("#" + self.options.id+"_queryOrgContent").find(".ui-commonquery-group-nav .more");
	                    orgMoreli.hide();
	                    waf("#" + self.options.btnOrgMoreId).wafLinkButton("option","caption","");
	
	                    self.isOrgMultiSelect = false;
	                })
	            };
	            var btnCancel = waf.createDOM("linkButton", btnJson);
	            waf.appendDOM(divEl, btnCancel);
	            waf.initComponent("linkButton", btnJson, btnCancel);
	
	        },
	        
	        /**
	         * 
	         */
	        _orgMoreOnClick:function() {
	            var orgMoreli = waf("#" + this.options.id+"_queryOrgContent").find(".ui-commonquery-group-nav .more");
	            if (orgMoreli.css("display")=="none") {
	                orgMoreli.show();
	                waf("#" + this.options.btnOrgMoreId).wafLinkButton("option","caption","");
	            } else {
	                orgMoreli.hide();
	                waf("#" + this.options.btnOrgMoreId).wafLinkButton("option","caption","");
	            }
	        },
	        
	        /**
	         * 
	         * @private
	         */
	        _querySchSetOnClick:function(){
	            var self = this;
	            var schMoreli = waf(".ui-commonquery-scheme .ui-commonquery-group-content .ui-commonquery-group-nav .more");
	            if (schMoreli.css("display")=="none") {
	                schMoreli.show();
	                waf("#" + this.options.btnQuerySchMoreId).wafLinkButton("option","caption","");
	            } 
	
	            waf("#" + self.options.id+"_commonSchemeMore").css("display", "none");
	            var parentEl = waf("#" + self.options.id+"_commonSchemeContent");
	            var divEl = waf("<div id='schemeSetCol'></div>");
	            divEl.css("margin-right","150px");
	            divEl.css("text-align", "center");
	            divEl.appendTo(parentEl);
	
	            var btnJson = {
	                tagClass:"btn",
	                caption:"",
	                id:"schemeDef",
	                onclick:(function(){
	                    var parentEl = waf("#"+self.options.commonSchemeNavId);
	                    var liEl = parentEl.find(".active");
	                    var elId = liEl.find("a").attr("id");
	                    var viewId = waf("#"+elId+"_v").wafText("getValue");
	                    waf.doPost(
			                {url:waf.getContextPath() + "/component/bizCommonQuery.do?method=setDefaultSolution", 
			                data:{queryPK:self.options.queryPK,
		        		    oldSoluId:self.defaultSch==null?"":self.defaultSch.viewId,
		    	   	        solutionId:viewId},
		            		success:function(data) {
		    	        	    if (self.defaultSch!=null) {
			    	                var oldAlias = waf("#"+self.defaultSch.elId).wafLinkButton("option","caption");
			    	                waf("#"+self.defaultSch.elId).wafLinkButton("option","caption",oldAlias.substring(0,oldAlias.length-self.defText.length));
			             	    }
				                var newDefText = waf("#"+elId).wafLinkButton("option","caption");
	            	            var newAlias = newDefText+self.defText;
	            	            waf("#"+elId).wafLinkButton("option","caption",newAlias);
	            	            self.defaultSch = {elId:elId,viewId:viewId,viewName:newDefText};
	           	    		}}
	        	        );
	                })
	            };
	            var btnDef = waf.createDOM("linkButton", btnJson);
	            waf.appendDOM(divEl, btnDef);
	            waf.initComponent("linkButton", btnJson, btnDef);
	
	            btnJson = {
	                tagClass:"btn",
	                caption:"",
	                id:"schemeDel",
	                onclick:(function(e){
	                    var parentEl = waf("#"+self.options.commonSchemeNavId);
	                    var liEl = parentEl.find(".active");
	                    var elId = liEl.find("a").attr("id");
	                    var viewId = waf("#"+elId+"_v").wafText("getValue");
	                    waf.doPost({
	                        url: waf.getContextPath() + "/component/bizCommonQuery.do?method=delSearchView",
	                        async:false,
						    data: {
	                            viewId : viewId
	                        },
	                        success: function(data) {
	                            if (liEl.attr("class").indexOf("more")<0) {
	                                var ms = parentEl.find(".more");
	                                if (ms.length>0)
	                                    waf(ms[0]).removeClass("more");
	                            }
	                            liEl.remove();
	                            self._resetOptions();
	                            //
	                            waf("#" + self.options.queryBarId).empty();
	                            self.currentFilterItems.advanceFilterItems = self.defAdvanceFilterItems;
	                            self._reloadDataGrid();
	                        }
	                    });
	                    e.stopPropagation();
	                })
	            };
	            var btnDel = waf.createDOM("linkButton", btnJson);
	            waf.appendDOM(divEl, btnDel);
	            waf.initComponent("linkButton", btnJson, btnDel);
	            
	            btnJson = {
	                tagClass:"btn",
	                caption:"",
	                id:"schemeFini",
	                onclick:(function(){
	                    //
	                    waf("#" + self.options.id+"_commonSchemeMore").show();
	
	                    //
	                    waf("#schemeSetCol").remove();
	                    
	                    //
	                    var schMoreli = waf(".ui-commonquery-scheme .ui-commonquery-group-content .ui-commonquery-group-nav .more");
	                    schMoreli.hide();
	                    waf("#" + self.options.btnQuerySchMoreId).wafLinkButton("option","caption","");
	                })
	            };
	            var btnFini = waf.createDOM("linkButton", btnJson);
	            waf.appendDOM(divEl, btnFini);
	            waf.initComponent("linkButton", btnJson, btnFini);
	
	        },
	
	        /**
	         * DOM
	         * @param parentEl 
	         * @param name 
	         * @param value SQL
	         * @param idPre ID
	         * @param rowId ID
	         * @param onclick 
	         * @returns {*}
	         * @private
	         */
	        _createFilterLink:function(parentEl, name, value, idPre, rowId, onclick, options) {
	            //lilinkbuttonul
	            var liEl = waf("<li></li>");
	            liEl.appendTo(parentEl);
	            if (options!=null&&options.isMore)
	                liEl.addClass("more");
	
	            var elId = idPre+rowId;
	            var linkOpts = {
	                id: elId || "",
	                name: elId || "",
	                caption:name
	            };
	            var linkBtnDom = waf.createDOM("linkButton", linkOpts);
	            linkBtnDom.attr("title", name);
	            waf.appendDOM(liEl, linkBtnDom);
	            waf.initComponent("linkButton", linkOpts, linkBtnDom);
	
	            if (onclick != null) {
	                var self = this;
	                linkBtnDom.bind("click.wafLinkButton", function (event) {
	                    onclick(self,event,this.id,idPre,options);
	                });
	            }
	
	            //value
	            var inputTypeJson = {
	                id: elId + "_v",
	                name: elId + "_v",
	                hidden: true,
	                value: value
	            };
	            var inputTypeDom = waf.createDOM("text", inputTypeJson);
	            waf.appendDOM(liEl, inputTypeDom);
	            waf.initComponent("text", inputTypeJson, inputTypeDom);
	
	            return liEl;
	        },
	
	        /**
	         * 
	         */
	        _initOrgFilter:function(orgObjRows) {
	            var self = this;
	            var len = orgObjRows.length;
	            if (len<=this.options.orgGroupRows)
	                waf("#" + self.options.btnOrgMoreId).hide();
	            if (len > 0) {
	                var parentEl = waf("#" + this.options.orgGroupNavId);
		            var queryBarEl = waf("#"+this.options.queryBarId);
		            for (var i=0; i<len; i++) {
		                var isActive = false;
		                this.orgRowNum += 1;
		
		                //
		                if (i == 0) {
			                if (self.defaultSch==null) {
			                    isActive=true;
		                        //
			                    this._addChoose(queryBarEl, this.PRE_ORG_QUERY_BAR_HD+orgObjRows[i].name,
		                            this.PRE_ORG_FILTER_LINK + this.orgRowNum, this.PRE_ORG_FILTER_LINK_QB, null, {required:self.options.orgRequired});
			                    //
		                        this._setOrgFilterItem(this.options.orgField, orgObjRows[i].id);
		                    } else {
		                    	if (self.options.orgRequired) {
				                    isActive=true;
		                    	}
		                    }
		                    if (self.options.orgRequired) {
				                self.requiredFields.put(self.options.orgField,{filterLinkQBId:this.PRE_ORG_FILTER_LINK_QB,
				                                                               caption:this.PRE_ORG_QUERY_BAR_HD+orgObjRows[i].name,
				                                                               value:this.PRE_ORG_FILTER_LINK + this.orgRowNum,
				                                                               filter:this.options.orgField+"='"+orgObjRows[i].id+"' "});
		                    }
		                }
			            var isOrgMore = i>=this.options.orgGroupRows?true:false;
			            var liEl = this._createFilterLink(parentEl, orgObjRows[i].name, orgObjRows[i].id,
			                this.PRE_ORG_FILTER_LINK, this.orgRowNum, this._orgFilterOnClick, {isMore:isOrgMore,required:self.options.orgRequired});
	                    if (isActive)
				            liEl.addClass("active");
		            }
	            }
	            waf("#" + self.options.id+"_queryOrgContent").find(".ui-commonquery-group-nav .more").hide();
	        },
	        
	        /**
	         * 
	         */
	        _initDateFilter:function() {
	        	var self = this;
	            if (this.options.dateFormat) {
	                var dates = eval("(" + this.options.dateFormat + ")");
	                var parentEl = waf("#"+this.options.dateGroupNavId);
	                var queryBarEl = waf("#"+this.options.queryBarId);
	                for (var i = 0; i < dates.length; i++) {
	                    this.dateRowNum += 1;
	                    var isActive=false;
	                    if (dates[i].isDefault) {
		                    if (this.defaultSch==null) {
		                        isActive=true;
		                        //
		                        this._addChoose(queryBarEl, this.PRE_DATE_QUERY_BAR_HD+dates[i].name,
		                            this.PRE_DATE_FILTER_LINK+this.dateRowNum, this.PRE_DATE_FILTER_LINK_QB, null, {required:this.options.dateRequired});
		                        //
		                        this._setDateFilterItem(this.options.dateField, dates[i].value);
		                        if (this.defAdvanceFilterItems.length>0)
		                            this.defAdvanceFilterItems += " and "+this.currentFilterItems.dateFilterItems;
		                        else 
		                            this.defAdvanceFilterItems += this.currentFilterItems.dateFilterItems;
		                    } else {
		                    	if (self.options.dateRequired) {
				                    isActive=true;
		                    	}
		                    }
		                    if (self.options.orgRequired) {
				                self.requiredFields.put(self.options.dateField,{filterLinkQBId:this.PRE_DATE_FILTER_LINK_QB,
				                                                                caption:this.PRE_DATE_QUERY_BAR_HD+dates[i].name,
				                                                                value:this.PRE_DATE_FILTER_LINK+this.dateRowNum,
				                                                                filter:self._getDateFilter(this.options.dateField, dates[i].value)});
		                    }
	                    }
	                    var el = this._createFilterLink(parentEl, dates[i].name, dates[i].value,
	                        this.PRE_DATE_FILTER_LINK, this.dateRowNum, this._dateFilterOnClick, {required:this.options.dateRequired});
	                    if (isActive)
	                    	el.addClass("active");
	                }
	            }
	        },
	        
	        /**
	         * 
	         * @private
	         */
	        _initQuickAdvanceSearch:function() {
	            var self = this;
	            
	            self.options.btnQuerySchMoreId = self.options.id + "_commonSch_btnMore";
	            self.options.btnQuerySchSetId = self.options.id + "_commonSch_btnSet";
	            
	            //
	            var selectFieldsDiv = waf('<div class="query-select-div"><ul class="query-select-fields"></ul></div>');
	            selectFieldsDiv.appendTo(waf("body"));
	
	            var position = waf("#" + self.options.id + "_searchTxt").offset();
	            var width = waf("#" + self.options.id + "_searchTxt").innerWidth();
	            var height = waf("#" + self.options.id + "_searchTxt").innerHeight();
	            waf(".query-select-div").width(width);
	            waf(".query-select-div").css("left", position.left);
	            waf(".query-select-div").css("top", position.top + height);
	
	            //
	            $("#" + self.options.id + "_searchTxt").bind("keyup.wafPromptGrid", function( event ) {
	                self._getSearchkeyNodes(event);
	            });
	
	            //
	            $("#" + self.options.id + "_searchTxt").blur(function() {
	                if (!self.isQuerySelectDivHover) {
	                    waf("#" + self.options.id + "_searchTxt").val("");
	
	                    $(".query-select-div .query-select-fields").find("li > a > span").empty();
	                    waf(".query-select-div").find(".query-select-fields > li[class='active']").removeClass("active");
	                    $(".query-select-div").find(".query-select-fields").hide();
	                }
	            });
	
	            //Query
	            waf.doGet({
	                url: waf.getContextPath() + "/component/bizCommonQuery.do?method=getProperties",
	                async: false,
	                showBlock: false,
	                data: {
	                    query : this.options.queryPK
	                },
	                success: function(data) {
	                    if (self.options.getCusFields!=null) 
	                        data.fields = self.options.getCusFields(data.fields);
	                    //
	                    self.fields = data.fields;
	                    self.fieldValues = new Map();
	                    for (var i=0;i<self.fields.length;i++) {
	                        self.fieldValues.put(data.fields[i].value,data.fields[i]);
	                    }
	
	                    //
	                    if (self.options.searchOptions == null) {
	                        self.options.searchOptions = data.searchOptions;
	                    }
	                    if (self.options.searchOptions == null || self.options.searchOptions.length<=0) {
	                        self.options.searchOptions = [{name:"number",label:""}];
	                    }
	
	                    //
	                    var searchOptions = self.options.searchOptions;
	                    var allSearchOpts = "";
	                    for (var i=0;i<searchOptions.length;i++) {
	                        var dom = "<li name='"+searchOptions[i].name+"' text='"+searchOptions[i].label+"'>"
	                            +"<a href='#'> "+searchOptions[i].label+" : <span></span></a>"
	                            +"</li>";
	                        $(".query-select-div").find(".query-select-fields").append(dom);
	
	                        if (allSearchOpts.length > 0) {
	                            allSearchOpts += ";";
	                        }
	                        allSearchOpts += searchOptions[i].label;
	                    }
	                    //
	                    if (searchOptions.length>1) {
	                        var domAll = "<li class name='all' text='"+allSearchOpts+"'>"
	                            + "<a href='#'> "+allSearchOpts+" : <span></span></a>";
	                        $(".query-select-div").find(".query-select-fields").append(domAll);
	                    }
	                    $(".query-select-div").find(".query-select-fields").hide();
	                    $(".query-select-div .query-select-fields > li").hover(
	                        function () {
	                            waf(".query-select-div .query-select-fields > li[class='active']").removeClass("active");
	                            $(this).addClass("active");
	                            self.isQuerySelectDivHover = true;
	                        },
	                        function () {
	                            waf(".query-select-div .query-select-fields > li[class='active']").removeClass("active");
	                            $(this).removeClass("active");
	                            self.isQuerySelectDivHover = false;
	                        }
	                    );
	                    $(".query-select-div .query-select-fields > li").live('click',function(){
	                        var key = $(this).find("strong").html();
	                        var name = $(this).attr("name");
	                        var category = $(this).attr("text");
	
	                        //
	                        self._quickSearch(key, name, category);
	                    });
	
	                    //
	                    //self._addNewOptionRow();
	                }
	            });
	            
	            //
	            waf.doGet({
	                url: waf.getContextPath() + "/component/bizCommonQuery.do?method=findSearchViewList",
	                async: false,
	                showBlock: false,
	                data: {
	                    query : self.options.queryPK,
	                    uipk : self.uipk
	                },
	                success: function(data) {
	                    var parentEl = waf("#"+self.options.commonSchemeNavId);
	                    
	                    //
	                    if (data==null || data.length<=0) {
	                        var liEl = self._createFilterLink(parentEl, "", 0,
	                            self.PRE_SEARCHVIEW_FILTER_LINK, 0, self._searchViewFilterOnClick);
	//                        liEl.addClass("active");
	                    }
	                    //
	                    for(var i=0;i<data.length;i++){
	                        self.searchViewRowNum += 1;
	                        var isSchemeMore = i>=self.options.schemeRows?true:false;
	                        var title = data[i].name;
	                        if (data[i].defaultView) {
	                            title = data[i].name+self.defText;
	                            self.defaultSch = {elId:self.PRE_SEARCHVIEW_FILTER_LINK+self.searchViewRowNum,viewId:data[i].id,viewName:data[i].name};
	                        }
	                        self._createFilterLink(parentEl, title, data[i].id,
	                            self.PRE_SEARCHVIEW_FILTER_LINK, self.searchViewRowNum, self._searchViewFilterOnClick, {isMore:isSchemeMore});
	                    }
	                    waf(".ui-commonquery-scheme .ui-commonquery-group-content .ui-commonquery-group-nav .more").hide();
	                    if (data.length<=self.options.schemeRows)
	                        waf("#" + self.options.btnQuerySchMoreId).hide();
	                    
	                    //
	                    if (self.defaultSch) {
	                        waf("#"+self.options.id+"_tabPanel").wafTabs("select","#"+self.options.id+"_scheme");
	                        self._searchViewFilterOnClick(self, null, self.defaultSch.elId, self.PRE_SEARCHVIEW_FILTER_LINK)
	                    }
	                }
	            });
	            
	            //
	            waf("#" + self.options.btnQuerySchSetId).live("click",function(e){
	            	self._querySchSetOnClick();
	            });
	            
	            //
	            waf("#" + self.options.btnQuerySchMoreId).live("click",function(e){
	            	var schMoreli = waf(".ui-commonquery-scheme .ui-commonquery-group-content .ui-commonquery-group-nav .more");
	                if (schMoreli.css("display")=="none") {
	                    schMoreli.show();
	                    waf("#" + self.options.btnQuerySchMoreId).wafLinkButton("option","caption","");
	                } else {
	                    schMoreli.hide();
	                    waf("#" + self.options.btnQuerySchMoreId).wafLinkButton("option","caption","");
	                }
	            });
	            
	            //
	            waf("#"+this.options.id+"_advanceQuery_btnSet").live("click",function(e){
	                self._resetOptions();
	            });
	
	            //
	            waf("#"+this.options.id+"_advanceQueryBtnAdd").live("click",function(e){
	                self._addNewOptionRow(null, null, null);
	            });
	
	            //
	            waf("#"+this.options.btnAdvanceQueryId).live("click",function(e){
					//
	                var QBEl = waf("#" + self.PRE_SEARCHVIEW_FILTER_LINK_QB);
	                if (QBEl == null || QBEl.length <= 0) {
	                    self._clearChoose();
	                }
	                
	            	//,
					var searchResult = self._getSearchViewFilterArr();
					self._advanceSearch(searchResult);
	            });
	
	            //
	            waf("#"+this.options.btnQuerySchSaveId).live("click",function(e){
	                var viewName = waf("#" + self.options.txtQueryNameId).val();
	                if (viewName == null || viewName == "") {
	                    _self.showMessage("!");
	                    return;
	                }
	                if (viewName.indexOf(self.defText)>=0)
	                    viewName = viewName.substring(0,viewName.length-self.defText.length);
	
	                var isDefaultView = null;
	                if (self.defaultSch!=null && viewName == self.defaultSch.viewName) {
	                    isDefaultView = "checked";
	                }
	
	                //
	                var searchResult = self._getSearchViewFilterArr();
	                if (searchResult.length<=0) {
	                    return;
	                }
	
	                var searchFilter = JSON.stringify(searchResult);
	                waf.doPost({
	                    url: waf.getContextPath() + "/component/bizCommonQuery.do?method=saveSearchView",
	                    data: {
	                        query : self.options.queryPK,
	                        viewName : viewName,
	                        searchFilter : searchFilter,
	                        defaultView : isDefaultView,
	                        uipk:self.uipk
	                    },
	                    success: function(data) {
	                        _self.showMessage("!");
	                        if(data!=null && data.viewId!=null){
	                            if (data.oprSta == "addnew") {
	                               //
	                                var parentEl = waf("#"+self.options.commonSchemeNavId);
	                                self.searchViewRowNum += 1;
	                                var liEl = self._createFilterLink(parentEl, viewName, data.viewId,
	                                    self.PRE_SEARCHVIEW_FILTER_LINK, self.searchViewRowNum, self._searchViewFilterOnClick);
	                               	parentEl.find(" .active").removeClass("active");
	                               	liEl.addClass("active");
	                               	//
	                                self._updateChooseBar(self.PRE_SEARCHVIEW_FILTER_LINK_QB,self.PRE_SCH_QUERY_BAR_HD, viewName, self.PRE_SEARCHVIEW_FILTER_LINK+self.searchViewRowNum);
	                               	
	                               	//,
						    		self._advanceSearch(searchResult);
	                            }
	                        }
	                    }
	                });
	            });
	
	            //
	            if (waf("#"+self.options.advanceQueryDefId + " > li").length<=0) {
	            	if (self.options.orgField)
		                self._addOrgDefOptionRow();
	                if (self.options.dateField)
	                    self._addDateDefOptionRow();
	            }
	        },
	        
	        _hasSomeClass:function(classAttr,someClass){
	            if (classAttr!=null) {
	                var array = classAttr.split(" ");
	                return waf.inArray(someClass,array)>=0?true:false;
	            }
	            return false;
	        },
	        
	        _updateChooseBar:function(filterLinkQBId,filterLinkQBHdPre,caption,filterIds,options) {
	            var self = this;
	            
	            //
	            var queryBarEl = waf("#" + self.options.queryBarId);
	            var QBEl = waf("#" + filterLinkQBId);
	            if (QBEl == null || QBEl.length <= 0) {
	                if (filterLinkQBId == self.PRE_SEARCHVIEW_FILTER_LINK_QB) {
	                    self._clearChoose();
	                } else {
	                    if (waf("#"+self.PRE_SEARCHVIEW_FILTER_LINK_QB).length>0) {
	                        var fieldids = waf("#"+self.PRE_SEARCHVIEW_FILTER_LINK_QB).find("label").html().split(";");
	        		        for (var i = 0; i < fieldids.length; i++) {
	                            waf("#"+fieldids[i]).parent().removeClass("active");
	    				    }
	    				    waf("#"+self.PRE_SEARCHVIEW_FILTER_LINK_QB).parent().remove();
	    				    self._resetOptions();
	    				    //
				            self._addRequiredChoose(queryBarEl);
					    }
	                }
	                self.currentFilterItems.advanceFilterItems = "";
	                if (waf("#" + filterLinkQBId).length <= 0) {
		                self._addChoose(queryBarEl, filterLinkQBHdPre+caption, filterIds, filterLinkQBId, null,options);
		            } else {
		                var chooseDom = filterLinkQBHdPre+caption+'<label>'+filterIds+'</label><a>X</a>';
		                if (options!=null&&options.required)
		                    chooseDom = filterLinkQBHdPre+caption+'<label>'+filterIds+'</label>';
		                waf("#" + filterLinkQBId).html(chooseDom);
		                waf("#" + filterLinkQBId).attr("title", filterLinkQBHdPre+caption);
		            }
	            } else {
	                var chooseDom = filterLinkQBHdPre+caption+'<label>'+filterIds+'</label><a>X</a>';
	                if (options!=null&&options.required)
	                    chooseDom = filterLinkQBHdPre+caption+'<label>'+filterIds+'</label>';
	                QBEl.html(chooseDom);
	                QBEl.attr("title", filterLinkQBHdPre+caption);
	            }
	        },
	        
	        _addChoose:function(parentEl,caption,value,filterLinkQBId,field,options){
	           var self = this;
	           var liEl = waf("<li class='choosing'></li>");
	           liEl.appendTo(parentEl);
	           var choose = '<span id="'+filterLinkQBId+'" class="chooseitem nomal">'+caption+'<label>'+value+'</label><a>X</a></span>';
	           if (options!=null&&options.required)
	               choose = '<span id="'+filterLinkQBId+'" class="chooseitem required">'+caption+'<label>'+value+'</label></span>';
	           waf.appendDOM(liEl, choose);
	       },
	       
	       _addRequiredChoose:function(parentEl){
	           var self = this;
	               fields = self.requiredFields.keys();
	           for (var i=0;i<fields.length;i++) {
	               var need = false,
	                   values = self.requiredFields.get(fields[i]);
		           if (fields[i]==self.options.orgField) {
		               if (waf("#"+self.PRE_ORG_FILTER_LINK_QB).length<=0) {
		                   need = true;
		                   if (self.currentFilterItems.orgFilterItems == "") 
		                       self.currentFilterItems.orgFilterItems = values.filter;
		               }
		           } else if (fields[i]==self.options.dateField) {
		               if (waf("#"+self.PRE_DATE_FILTER_LINK_QB).length<=0) {
		                   need = true;
		                   if (self.currentFilterItems.dateFilterItems == "") 
		                       self.currentFilterItems.dateFilterItems = values.filter;    
		               }
		           } else {
		               if (waf("#"+fields[i]+"FilterBar").length<=0) {
		                   need = true;
		                   if (self.currentFilterItems.cusFilterItems.get(fields[i])==null
		                           ||self.currentFilterItems.cusFilterItems.get(fields[i])=="")
		   		               self.currentFilterItems.cusFilterItems.put(fields[i],values.filter);
		               }
		           }
		           if (need) {
			           var liEl = waf("<li class='choosing'></li>");
				       liEl.appendTo(parentEl);
				       var choose = '<span id="'+values.filterLinkQBId+'" class="chooseitem required">'+values.caption+'<label>'+values.value+'</label></span>';
				       waf.appendDOM(liEl, choose);
		           }
	           }
	       },
	       
	       _clearChoose:function(){
	           var self = this;
	           waf(".choosing .chooseitem").each(function(index){
	    		    var idstr = this.id;
	    		    var fieldids = waf(this).find("label").html().split(";");
			        var field;
	    		    switch (idstr) {
		 	    	    case self.PRE_ORG_FILTER_LINK_QB :
		 	    	        field = self.options.orgField;
		     		        self.currentFilterItems.orgFilterItems = "";
		     		        break;
		     		    case self.PRE_DATE_FILTER_LINK_QB :
		     		        field = self.options.dateField;
		     		        self.currentFilterItems.dateFilterItems = "";
		     		        break;
		     		    case self.PRE_STATE_FILTER_LINK_QB :
		     		        field = self.options.stateField;
		     		        self.currentFilterItems.stateFilterItems = "";
		 	    	        break;
		 	    	    case self.PRE_SEARCHVIEW_FILTER_LINK_QB :
		 	    	        field = "";
		     		        self.currentFilterItems.advanceFilterItems = "";
		 	    	        break;
		 	    	    default:
		 	    	        field = idstr.substring(0,idstr.length-"FilterBar".length);
		 	    	        self.currentFilterItems.cusFilterItems.remove(field);
			        }
	    		    waf(this).parent().remove();
	    		    if (!self.requiredFields.containsKey(field)) {
		    		    for (var i = 0; i < fieldids.length; i++) {
		                    waf("#"+fieldids[i]).parent().removeClass("active");
						}
	    		    } 
	            });
	       },
	       
	       _getDateEnumSource:function() {
	            var source = {},
	                enumSource = new Array();
	            if (this.options.dateFormat == null) 
	                return source;
	            var dates = eval("(" + this.options.dateFormat + ")");
	            for (var i = 0; i < dates.length; i++) {
	                var enumItem = {};
	                enumItem.alias=dates[i].name,
	                enumItem.value=dates[i].value;
	                enumSource[i]=enumItem;
	                if (dates[i].isDefault == 1) 
	                    source.defValue = enumSource[i];
	            }
	            source.enumSource = enumSource;
	            return source;
	       },
	       
	       _getDateObjByValue:function(value) {
	            var obj = {};
	            if (this.options.dateFormat == null) 
	                return null;
	            var dates = eval("(" + this.options.dateFormat + ")");
	            for (var i = 0; i < dates.length; i++) {
	                if (dates[i].value == value) {
	                    obj.alias=dates[i].name,
	                    obj.value=dates[i].value;
	                    break;
	                }
	            }
	            return obj;
	       },
	       
	       _dateOpsChange:function(e,ui) {
	           waf("#adq_date_val").html("");
	           if (ui.current == "=") {
	               var dateDatas = this._getDateEnumSource();
	               var dateValJson = {
	                   id:this.PRE_INPUT_ROW + "_date",
	                   enumSource:dateDatas.enumSource,
	                   value:dateDatas.defValue,
	                   listHeight:"150px",
	                   width:192,
	                   style: "margin-right:10px;"
	               };
	               var dateValEl = waf.createDOM("select", dateValJson);
	               waf.appendDOM(waf("#adq_date_val"), dateValEl);
	               waf.initComponent("select", dateValJson, dateValEl);
	           } 
	           if (ui.current == "between") {
	               //
	                var datePickerJson;
	                datePickerJson = {
	                    id:"adqDateFrom",
	                    name:"adqDateFrom",
	                    width:"90px",
	                    dateFormat:"yy-mm-dd"
	                };
	                var datePickerFromDom = waf.createDOM("datePicker", datePickerJson);
	                waf.appendDOM(waf("#adq_date_val"), datePickerFromDom);
	                waf.initComponent("datePicker", datePickerJson, datePickerFromDom);
	                //
	                var divEl = waf("<div><span class='ui-lb-text'>-</span></div>");
	                divEl.css("display","inline-block");
	                divEl.css("vertical-align","top");
	                divEl.css("padding-top","5px");
	                divEl.css("margin-left","2px");
	                divEl.css("margin-right","2px");
	                divEl.css("width","8px");
	                divEl.appendTo(waf("#adq_date_val"));
	
	                //
	                datePickerJson = {
	                    id:"adqDateTo",
	                    name:"adqDateTo",
	                    dateFormat:"yy-mm-dd",
	                    width:"90px",
	                    style:"margin-right: 10px;"
	                };
	                var datePickerFromTo = waf.createDOM("datePicker", datePickerJson);
	                waf.appendDOM(waf("#adq_date_val"), datePickerFromTo);
	                waf.initComponent("datePicker", datePickerJson, datePickerFromTo);
	            }
	       },
	       
	       _resetOptions:function() {
	           //
	           waf("#"+this.PRE_INPUT_ROW + "_org").wafPromptBox("setValue",this.firstOrgUnit);
	           waf("#"+this.PRE_SELECT_OPT_ROW+"_date").wafSelect("option","value",{value:'=',alias:''});
	           var dateDatas = this._getDateEnumSource();
	           waf("#"+this.PRE_INPUT_ROW + "_date").wafSelect("option","value",dateDatas.defValue);
	           //
	           waf("#"+this.options.advanceQueryNavId).html("");
	           waf("#" + this.options.txtQueryNameId).val("");
	           //
	           this.currentFilterItems.advanceFilterItems = this.defAdvanceFilterItems;
	       },
	       
	       //
	       addCusFilter:function() {
	           if(this.options.groupFilters && this.options.groupFilters.length>0) {
	               for (var i=0;i<this.options.groupFilters.length;i++) {
	                   var group = this.options.groupFilters[i];
	                   this._addCusFilterDOM(group.field,group.title,group.dataType);
	                   this._initCusFilter(group.field,group.title,group.filterItems,group.displayCount,group.miltiSelect,group.dataType,group.required,group.unlimited);
	                   if ((group.dataType=="Date"||group.dataType=="Timestamp")&&group.needScope)
	                   		this._dateMoreOnClick(group.field,group.title,group.required);
	               }
	           }
	       },
	       
	       _addCusFilterDOM:function(field,title,dataType,required) {
	            var self = this;
	            var id = self.options.id;
	            var optsJson = {
	                id:id + "_query"+field+"Col",
	                colWidth:"100%"
	            };
	            var queryColDom = waf.createDOM("column", optsJson);
	            waf.appendDOM(waf("#"+id+"_commUsePanel"), queryColDom);
	            waf.initComponent("column", optsJson, queryColDom);
	
	            optsJson = {
	                id:id + "_query"+field,
	                layout:"column",
	                tagClass:"ui-commonquery-group"
	            };
	            var queryPanelDom = waf.createDOM("panel", optsJson);
	            waf.appendDOM(queryColDom, queryPanelDom);
	            waf.initComponent("panel", optsJson, queryPanelDom);
	
	            optsJson = {
	                id:id + "_query"+field+"Hd",
	                colWidth:"10%",
	                tagClass:"ui-commonquery-group-hd"
	            };
	            var queryHdDom = waf.createDOM("column", optsJson);
	            waf.appendDOM(queryPanelDom, queryHdDom);
	            waf.initComponent("column", optsJson, queryHdDom);
	
	            waf("<span class='ui-lb-text'>"+title+":</span>").appendTo(queryHdDom);
	
	            optsJson = {
	                id:id + "_query"+field+"Content",
	                colWidth:"90%",
	                tagClass:"ui-commonquery-group-content"
	            };
	            var queryContentDom = waf.createDOM("column", optsJson);
	            waf.appendDOM(queryPanelDom, queryContentDom);
	            waf.initComponent("column", optsJson, queryContentDom);
	            waf("<ul id='"+id+"_query"+field+"GroupNav' class='ui-commonquery-group-nav'>").appendTo(queryContentDom);
	
	            optsJson = {
	                id:id + "_query"+field+"More",
	                colWidth:"",
	                tagClass:"ui-commonquery-group-more"
	            };
	            var queryMoreDom = waf.createDOM("column", optsJson);
	            waf.appendDOM(queryContentDom, queryMoreDom);
	            waf.initComponent("column", optsJson, queryMoreDom);
	            optsJson = {
	                tagClass:"btn",
	                caption:"",
	                id:id+"_"+field+"_btnMultiSelect"
	            };
	            var btnMultiSelectDom = waf.createDOM("linkButton", optsJson);
	            waf.appendDOM(queryMoreDom, btnMultiSelectDom);
	            waf.initComponent("linkButton", optsJson, btnMultiSelectDom);
	
	            optsJson = {
	                tagClass:"btn",
	                caption:"",
	                id:id+"_"+field+"_btnMore"
	            };
	            var btnMoreDom = waf.createDOM("linkButton", optsJson);
	            waf.appendDOM(queryMoreDom, btnMoreDom);
	            waf.initComponent("linkButton", optsJson, btnMoreDom);
	
	            waf("#" + id + "_query"+field).wafColumnLayout();
	            
	            //
	            waf("#"+id+"_"+field+"_btnMultiSelect").wafLinkButton("option","onclick", function(e){
	                self._cusMultiSelectOnClick(field,title,dataType,required);
	            });
	            
	            //
	            waf("#"+id+"_"+field+"_btnMore").wafLinkButton("option","onclick", function(e){
	                self._cusMoreOnClick(field);
	            });
	        },
	        
	        /**
	         * 
	         */
	        _initCusFilter:function(field,title,filterItems,displayCount,miltiSelect,dataType,required,unlimited) {
	            var self = this;
	            if (dataType=="Date"||dataType=="Timestamp")
	                displayCount = 20;
	            if (!miltiSelect)
	                waf("#"+self.options.id+"_"+field+"_btnMultiSelect").hide();
	            var len = filterItems==null?0:filterItems.length;
	            if (len<=displayCount)
	                waf("#"+self.options.id+"_"+field+"_btnMore").hide();
	            if (len > 0) {
	                var parentEl = waf("#"+self.options.id+"_query"+field+"GroupNav");
		            var queryBarEl = waf("#"+self.options.queryBarId);
		            var options = {isMore:isMore, title:title, dataType:dataType, required:required, unlimited:unlimited};
		            var rowNum = 0;
		            var unlimitedLiEl = null;
		            if (unlimited)
			            unlimitedLiEl = self._createFilterLink(parentEl, "", "unlimited", field+"Filter", 0, self._cusFilterOnClick, options);
	                var hasActive = false;
		            for (var i=0; i<len; i++) {
		                var isDefault = filterItems[i].isDefault;
		                var isActive = false;
		                rowNum += 1;
		     
		                if (isDefault) {
			                if (self.defaultSch==null) {
			                    isActive=true;
			                    //
		                        self._updateChooseBar(field+"FilterBar",title+":", filterItems[i].alias, field+"Filter"+rowNum, {required:required});
		                        //
		                        self._setCusFilterItem(field, filterItems[i].value, dataType);
		                        self._reloadDataGrid();
		                    } else {
		                        if (required) 
		                            isActive=true;
		                    }
		                    if (required) {
				                self.requiredFields.put(field,{filterLinkQBId:field+"FilterBar",
				                                               caption:title+":"+filterItems[i].alias,
				                                               value:field+"Filter"+rowNum,
				                                               filter:self._getCusFilter(field, filterItems[i].value, dataType)});
		                    }
		                }
		                var isMore = i>=displayCount?true:false;
		                options.isMore=isMore;
		                var liEl = self._createFilterLink(parentEl, filterItems[i].alias, filterItems[i].value,
		                    field+"Filter", rowNum, self._cusFilterOnClick, options);
		                if (isActive) {
		                    liEl.addClass("active");
		                    hasActive = true;
		                }
		            }
		            if (unlimitedLiEl!=null&&!hasActive) 
		                unlimitedLiEl.addClass("active");
	            }
	            waf("#" + self.options.id+"_query"+field+"Content").find(".ui-commonquery-group-nav .more").hide();
	        },
	        
	        _cusFilterOnClick:function(self, e, elId, idPre, options) {
	            var title=options.title, 
	                dataType=options.dataType, 
	                required=options.required;
	            var field = idPre.substring(0,idPre.length-"Filter".length);
	            var rowCount = waf("#" + self.options.id+"_query"+field+"GroupNav").find("li").length;
	            if (self.cusMultiSelect.get(field)) {
	                //,
	                if (self._hasSomeClass(waf("#"+elId).parent().attr("class"),"active")) {
	                    waf("#"+elId).parent().removeClass("active");
	                } else {
	                    waf("#"+elId).parent().addClass("active");
	                }
	            } else {
	                var caption = "";
	
	                if (self._hasSomeClass(waf("#"+elId).parent().attr("class"),"active")) {
	                    //
	                    return;
	                }
	
	                //
	                for (var i=0; i<=rowCount; i++) {
	                    var currId = idPre + i;
	                    if (currId == elId) {
	                        waf("#"+currId).parent().addClass("active");
	                        caption = waf("#"+currId).wafLinkButton("option", "caption");
	                    } else {
	                        waf("#"+currId).parent().removeClass("active");
	                    }
	                }
	                
	                var filterValue = "";
		            if (elId != idPre+"0") {
		                var filterValue = waf("#" + elId + "_v").wafText('getValue');
		                self._setCusFilterItem(field, filterValue, dataType);
	                
	                    //
		                self._updateChooseBar(field+"FilterBar",title+":", caption, elId, options);
		                if (required) {
					        self.requiredFields.put(field,{filterLinkQBId:field+"FilterBar",
					                                       caption:title+":"+caption,
					                                       value:elId,
					                                       filter:self._getCusFilter(field, filterValue, dataType)});
			            }
		            } else {
		            	waf("#"+field+"FilterBar").parent().remove();
		                self._setCusFilterItem(field, null, dataType);
		            }
	
	                if (self.options.afterComFilterClick!=null)
	                    self.options.afterComFilterClick(e,field,filterValue,self.currentFilterItems);
	
	                //
	                self._reloadDataGrid();
	            }
	        },
	        
	        _getCusFilter:function(filterField, filterValue, dataType) {
	            var self = this;
	            var filterItems = "";
	            switch (dataType) {
	                case 'String' :
	                     filterItems = filterField + "='" + filterValue + "' ";
	                     break;
	                case 'ObjectValue' :
	                     filterItems = filterField + ".id='" + filterValue + "' ";
	                     break;
	                case "Date":
	                case 'Timestamp' :
	                    filterItems = self._getDateFilter(filterField, filterValue);
	                    break;
	                case 'Enum' :
	                     filterItems = filterField + "=" + filterValue + " ";
	                     break;
	                case 'EnumString' :
	                     filterItems = filterField + "='" + filterValue + "' ";
	                     break;
	                case 'Number' :
	                case 'Int' :
	                case 'Short' :
	 			    case 'Double' :
		   		    case 'BigDecimal' :
		   		    case 'Integer' :
		   		    case 'Long' :
		   		    case 'Float' :
	                    filterItems = filterField + "=" + filterValue + " ";
	                    break;
	            }
	            return filterItems;
	        },
	        
	        _setCusFilterItem:function(filterField, filterValue, dataType) {
	            if (filterValue==null) {
	                this.currentFilterItems.cusFilterItems.remove(filterField);
	                return;
	            }
	            var filterItems = this._getCusFilter(filterField, filterValue, dataType);
	
	            if (this.currentFilterItems.cusFilterItems.containsKey(filterField)){
	                this.currentFilterItems.cusFilterItems.remove(filterField);
	            } 
	            this.currentFilterItems.cusFilterItems.put(filterField,filterItems);
	           
	        },
	        
	        /**
	         * 
	         * @private
	         */
	        _cusMultiSelectOnClick:function(field,title,dataType,required){
	            var self = this;
	            self.cusMultiSelect.put(field,true);
	            
	            var cusMoreli = waf("#" + self.options.id+"_query"+field+"Content").find(".ui-commonquery-group-nav .more");
	            if (cusMoreli.css("display")=="none") {
	                cusMoreli.show();
	                waf("#"+self.options.id+"_"+field+"_btnMore").wafLinkButton("option","caption","");
	            } 
	
	            waf("#" + self.options.id+"_query"+field+"More").css("display", "none");
	            var parentEl = waf("#" + self.options.id+"_query"+field+"Content");
	            var divEl = waf("<div id='"+field+"MultiSelectCol'></div>");
	            divEl.css("margin-right","150px");
	            divEl.css("text-align", "center");
	            divEl.appendTo(parentEl);
	
	            var btnJson = {
	                tagClass:"btn",
	                caption:"",
	                id:field+"MultiOK",
	                onclick:(function(){
	                    //
	                    var activeEls = waf("#"+self.options.id+"_query"+field+"GroupNav" + " .active");
	                    if (activeEls.length <= 0) {
	                        return;
	                    }
	
	                    var filterItems = "";
	                    var captions = "";
	                    var values = "";
	                    var rowCount = waf("#" + self.options.id+"_query"+field+"GroupNav").find("li").length;
	                    for (var i=1; i<=rowCount; i++) {
	                        var cusElId = field+"Filter" + i;
	                        if (self._hasSomeClass(waf("#"+cusElId).parent().attr("class"),"active")) {
	                            if (filterItems.length > 0) {
	                                filterItems += " or ";
	                            }
	                            var value = waf("#" + cusElId + "_v").wafText('getValue');
	                            var cusFilter = self._getCusFilter(field, value, dataType);
	                            filterItems += cusFilter;
	
	                            if (captions.length > 0) {
	                                captions += ",";
	                            }
	                            captions += waf("#" + cusElId).wafLinkButton("option", "caption");
	                            if (values.length > 0) {
	                                values += ";";
	                            }
	                            values += cusElId;
	                        }
	                    }
	                    filterItems = "(" + filterItems + ")";
	                    self.currentFilterItems.cusFilterItems.put(field,filterItems);
	
	                    //
	                    self._updateChooseBar(field+"FilterBar",title, captions, values, {required:required})
	                    if (required) {
					        self.requiredFields.put(field,{filterLinkQBId:field+"FilterBar",
					                                       caption:title+":"+caption,
					                                       value:values,
					                                       filter:filterItems});
			            }
	                    if (self.options.afterComFilterClick!=null)
	                        self.options.afterComFilterClick(null,field,filterItems,self.currentFilterItems);
	
	                    //
	                    self._reloadDataGrid();
	                    
	                    //
	                    waf("#" + self.options.id+"_query"+field+"More").css("display", "");
	
	                    //
	                    waf("#"+field+"MultiSelectCol").remove();
	                    
	                    //
	                    var cusMoreli = waf("#" + self.options.id+"_query"+field+"Content").find(".ui-commonquery-group-nav .more");
	                    cusMoreli.hide();
	                    waf("#"+self.options.id+"_"+field+"_btnMore").wafLinkButton("option","caption","");
	
	                    //
	                    self.cusMultiSelect.remove(field);
	                })
	            };
	            var btnCancel = waf.createDOM("linkButton", btnJson);
	            waf.appendDOM(divEl, btnCancel);
	            waf.initComponent("linkButton", btnJson, btnCancel);
	
	            btnJson = {
	                tagClass:"btn",
	                caption:"",
	                id:"orgMultiCancel",
	                onclick:(function(){
	                    //
	                    waf("#"+self.options.id+"_query"+field+"GroupNav" + " .active").removeClass("active");
	
	                    var cusFilterValue = waf("#" + field+"FilterBar").find("label").html();
	                    if (cusFilterValue!=null) {
	                        var cusFilterIdArr = cusFilterValue.split(";");
	                        for (var i=0;i<cusFilterIdArr.length; i++) {
	                            waf("#"+cusFilterIdArr[i]).parent().addClass("active");
	                        }
	                    }
	                    //
	                    waf("#" + self.options.id+"_query"+field+"More").css("display", "");
	                    //
	                    waf("#"+field+"MultiSelectCol").remove();
	                    //
	                    var cusMoreli = waf("#" + self.options.id+"_query"+field+"Content").find(".ui-commonquery-group-nav .more");
	                    cusMoreli.hide();
	                    waf("#"+self.options.id+"_"+field+"_btnMore").wafLinkButton("option","caption","");
	
	                    //
	                    self.cusMultiSelect.remove(field);
	                })
	            };
	            var btnCancel = waf.createDOM("linkButton", btnJson);
	            waf.appendDOM(divEl, btnCancel);
	            waf.initComponent("linkButton", btnJson, btnCancel);
	
	        },
	        
	        /**
	         * 
	         */
	        _cusMoreOnClick:function(field) {
	            var cusMoreli = waf("#" + this.options.id+"_query"+field+"Content").find(".ui-commonquery-group-nav .more");
	            if (cusMoreli.css("display")=="none") {
	                cusMoreli.show();
	                waf("#"+this.options.id+"_"+field+"_btnMore").wafLinkButton("option","caption","");
	            } else {
	                cusMoreli.hide();
	                waf("#"+this.options.id+"_"+field+"_btnMore").wafLinkButton("option","caption","");
	            }
	        },
	        
	        getCurrentFilter:function() {
	            return this.currentFilter;
	        },
	        
	        showCusFilterByField:function(field) {
	            waf("#"+this.options.id+"_query"+field+"Col").show();
	            waf("#"+field+"FilterBar").parent().show();
	            var filter = this.hideCusFilters.get(field);
	            this.currentFilterItems.cusFilterItems.put(field,filter);
	        },
	        
	        hideCusFilterByField:function(field) {
	            waf("#"+this.options.id+"_query"+field+"Col").hide();
	            waf("#"+field+"FilterBar").parent().hide();
	            var filter = this.currentFilterItems.cusFilterItems.get(field);
	            this.hideCusFilters.put(field,filter);
	            this.currentFilterItems.cusFilterItems.remove(field);
	        },
	        
	        addCusFilterByGroup:function(group) {
	             //
	             if (waf("#"+this.options.id+"_query"+group.field+"Col").length>0) {
	                 this.removeCusFilterByField(group.field);
	             }
	             this._addCusFilterDOM(group.field,group.title,group.dataType,group.required);
	             this._initCusFilter(group.field,group.title,group.filterItems,group.displayCount,group.miltiSelect,group.dataType,group.required,group.unlimited);
	             if ((group.dataType=="Date"||group.dataType=="Timestamp")&&group.needScope)
	                 this._dateMoreOnClick(group.field,group.title,group.required);
	        },
	        
	        removeCusFilterByField:function(field) {
	            waf("#"+this.options.id+"_query"+field+"Col").remove();
	            waf("#"+field+"FilterBar").parent().remove();
	            this.currentFilterItems.cusFilterItems.remove(field);
	        }
	       
		});
	
	    //
	    waf(function(){
	        waf.registerComponent("waf.bizCommonQuery",{
	            createDOMFun:function(option){
	                var id = option.id;
	
	                //
	                var optsJson = {
	                    id:id,
	                    layout:"column",
	                    tagClass:"ui-commonquery"
	                };
	                var mainPanel = waf.createDOM("panel", optsJson);
	                waf.initComponent("panel", optsJson, mainPanel);
	
	                //
	                optsJson = {
	                    id:id + "_queryHdCol",
	                    colWidth:"100%",
	                    style:"padding-right:40px;"
	                };
	                var queryHdColDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(mainPanel, queryHdColDom);
	                waf.initComponent("column", optsJson, queryHdColDom);
	
	                optsJson = {
	                    id:id + "_queryBarPanel",
	                    layout:"column",
	                    tagClass:"ui-commonquery-queryBar"
	                };
	                var queryBarDom = waf.createDOM("panel", optsJson);
	                waf.appendDOM(queryHdColDom, queryBarDom);
	                waf.initComponent("panel", optsJson, queryBarDom);
	
	                //
	                optsJson = {
	                    id:id + "_queryBarHd",
	                    colWidth:"10%",
	                    tagClass:"ui-commonquery-queryBar-hd"
	                };
	                var queryHdColDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(queryBarDom, queryHdColDom);
	                waf.initComponent("column", optsJson, queryHdColDom);
	
	                waf('<span class="ui-lb-text">:</span>').appendTo(queryHdColDom);
	
	                optsJson = {
	                    id:id + "_queryBarItem",
	                    colWidth:"90%",
	                    tagClass:"ui-commonquery-queryBar-item"
	                };
	                var queryBarItemDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(queryBarDom, queryBarItemDom);
	                waf.initComponent("column", optsJson, queryBarItemDom);
	                waf("<ul id='"+id+"_queryBarGroupNav' class='ui-commonquery-queryBar-nav'></ul>").appendTo(queryBarItemDom);
	
	                //
	                optsJson = {
	                    id:id + "_queryBarSearch",
	                    colWidth:"",
	                    tagClass:"ui-commonquery-queryBar-quickSearch"
	                };
	                var queryBarSearchDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(queryBarItemDom, queryBarSearchDom);
	                waf.initComponent("column", optsJson, queryBarSearchDom);
	                optsJson = {
	                    id:id + "_queryBarSearchInput",
	                    colWidth:""
	                };
	                var queryBarSearchInputDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(queryBarSearchDom, queryBarSearchInputDom);
	                waf.initComponent("column", optsJson, queryBarSearchInputDom);
	
	                waf("<input id='"+id+"_searchTxt' type='text' class='query-search' autocomplete='off' placeholder=''>").appendTo(queryBarSearchInputDom);
	                waf("<span id='"+id+"_searchImg' class='query-search-icon ui-commonquery-b-icon b-icon-search'></span>").appendTo(queryBarSearchInputDom);
	
	                //
	                optsJson = {
	                    id:id + "_queryFootCol",
	                    colWidth:"",
	                    tagClass:"ui-commonquery-queryBar-foot-notex"
	                };
	                var queryFootColDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(mainPanel, queryFootColDom);
	                waf.initComponent("column", optsJson, queryFootColDom);
	
	                waf("<span id='"+id+"_collapseEx' class='ui-commonquery-notex-icon'></span>").appendTo(queryFootColDom);
	                waf("#" + id + "_queryBarPanel").wafColumnLayout();
	
	                //
	                optsJson = {
	                    id:id + "_tabPanelCol",
	                    style:"display:none;",
	                    colWidth:"100%",
	                    tagClass:"ui-commonquery-tabPanelCol"
	                };
	                var tabPanelColDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(mainPanel, tabPanelColDom);
	                waf.initComponent("column", optsJson, tabPanelColDom);
	                
	                var commonUseTabDom = null;
	                var schemeTabDom = null;
	                var comOptsJson = {
		                title:"",
		                id:id + "_commonUse",
		                parentId:id + "_tabPanel"
		            };
	                var schOptsJson = {
		                title:"",
		                id:id + "_scheme",
		                parentId:id + "_tabPanel"
		            };
	                //
	                if (option.commonUseTabHide || option.schemeTabHide) {
	                	if (option.schemeTabHide) {
	                		comOptsJson.tagClass = "ui-commonquery-onetab";
			                commonUseTabDom = waf.createDOM("panel", comOptsJson);
	                		waf.appendDOM(tabPanelColDom, commonUseTabDom);
			                waf.initComponent("panel", comOptsJson, commonUseTabDom);
	                	}
	                	if (option.commonUseTabHide) {
	                		schOptsJson.tagClass = "ui-commonquery-onetab";
			                schemeTabDom = waf.createDOM("panel", schOptsJson);
	                		waf.appendDOM(tabPanelColDom, schemeTabDom);
			                waf.initComponent("panel", schOptsJson, schemeTabDom);
	                	}
	                	
	                } else {
		                optsJson = {
		                    id:id + "_tabPanel",
		                    tagClass:"ui-commonquery-tabPanel"
		                };
		                var tabPanelDom = waf.createDOM("tabPanel", optsJson);
		                waf.appendDOM(tabPanelColDom, tabPanelDom);
		                waf.initComponent("tabPanel", optsJson, tabPanelDom);
	
		                commonUseTabDom = waf.createDOM("tab", comOptsJson);
		                tabPanelDom.wafTabs('appendChildren', commonUseTabDom);
		                waf.initComponent("tab", comOptsJson, commonUseTabDom);
	
		                schemeTabDom = waf.createDOM("tab", schOptsJson);
		                tabPanelDom.wafTabs('appendChildren', schemeTabDom);
		                waf.initComponent("tab", schOptsJson, schemeTabDom);
	                }
	
	                //
	                if (!option.commonUseTabHide) {
	                optsJson = {
	                    id:id + "_commUsePanel",
	                    layout:"column"
	                };
	                var commUsePanelDom = waf.createDOM("panel", optsJson);
	                waf.appendDOM(commonUseTabDom, commUsePanelDom);
	                waf.initComponent("panel", optsJson, commUsePanelDom);
	
	                //
	                if (option.orgField != null) {
	                optsJson = {
	                    id:id + "_queryOrgCol",
	                    colWidth:"100%"
	                };
	                var queryOrgColDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(commUsePanelDom, queryOrgColDom);
	                waf.initComponent("column", optsJson, queryOrgColDom);
	
	                optsJson = {
	                    id:id + "_queryOrg",
	                    layout:"column",
	                    tagClass:"ui-commonquery-group"
	                };
	                var queryOrgPanelDom = waf.createDOM("panel", optsJson);
	                waf.appendDOM(queryOrgColDom, queryOrgPanelDom);
	                waf.initComponent("panel", optsJson, queryOrgPanelDom);
	
	                optsJson = {
	                    id:id + "_queryOrgHd",
	                    colWidth:"10%",
	                    tagClass:"ui-commonquery-group-hd"
	                };
	                var queryOrgHdDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(queryOrgPanelDom, queryOrgHdDom);
	                waf.initComponent("column", optsJson, queryOrgHdDom);
	
	                waf("<span class='ui-lb-text'>:</span>").appendTo(queryOrgHdDom);
	
	                optsJson = {
	                    id:id + "_queryOrgContent",
	                    colWidth:"90%",
	                    tagClass:"ui-commonquery-group-content"
	                };
	                var queryOrgContentDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(queryOrgPanelDom, queryOrgContentDom);
	                waf.initComponent("column", optsJson, queryOrgContentDom);
	                waf("<ul id='"+id+"_queryOrgGroupNav' class='ui-commonquery-group-nav'>").appendTo(queryOrgContentDom);
	
	                optsJson = {
	                    id:id + "_queryOrgMore",
	                    colWidth:"",
	                    tagClass:"ui-commonquery-group-more"
	                };
	                var queryOrgMoreDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(queryOrgContentDom, queryOrgMoreDom);
	                waf.initComponent("column", optsJson, queryOrgMoreDom);
	                optsJson = {
	                    tagClass:"btn",
	                    caption:"",
	                    id:id+"_org_btnMultiSelect"
	                };
	                var btnOrgMultiSelectDom = waf.createDOM("linkButton", optsJson);
	                waf.appendDOM(queryOrgMoreDom, btnOrgMultiSelectDom);
	                waf.initComponent("linkButton", optsJson, btnOrgMultiSelectDom);
	
	                optsJson = {
	                    tagClass:"btn",
	                    caption:"",
	                    id:id+"_org_btnMore"
	                };
	                var btnOrgMoreDom = waf.createDOM("linkButton", optsJson);
	                waf.appendDOM(queryOrgMoreDom, btnOrgMoreDom);
	                waf.initComponent("linkButton", optsJson, btnOrgMoreDom);
	
	                waf("#" + id + "_queryOrg").wafColumnLayout();
	                }
	                //
	                if (option.dateField != null) {
	                optsJson = {
	                    id:id + "_queryDateCol",
	                    colWidth:"100%"
	                };
	                var queryDateColDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(commUsePanelDom, queryDateColDom);
	                waf.initComponent("column", optsJson, queryDateColDom);
	
	                optsJson = {
	                    id:id + "_queryDatePanel",
	                    layout:"column",
	                    tagClass:"ui-commonquery-group"
	                };
	                var queryDatePanelDom = waf.createDOM("panel", optsJson);
	                waf.appendDOM(queryDateColDom, queryDatePanelDom);
	                waf.initComponent("panel", optsJson, queryDatePanelDom);
	
	                optsJson = {
	                    id:id + "_queryDateHd",
	                    colWidth:"10%",
	                    tagClass:"ui-commonquery-group-hd"
	                };
	                var queryDateHdDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(queryDatePanelDom, queryDateHdDom);
	                waf.initComponent("column", optsJson, queryDateHdDom);
	                waf('<span class="ui-lb-text">:</span>').appendTo(queryDateHdDom);
	
	                optsJson = {
	                    id:id + "_queryDateContent",
	                    colWidth:"90%",
	                    tagClass:"ui-commonquery-group-content"
	                };
	                var queryDateContentDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(queryDatePanelDom, queryDateContentDom);
	                waf.initComponent("column", optsJson, queryDateContentDom);
	                waf("<ul id='"+id+"_queryDateGroupNav' class='ui-commonquery-group-nav'>").appendTo(queryDateContentDom);
	
	                optsJson = {
	                    id:id + "_queryDateMore",
	                    colWidth:"",
	                    tagClass:"ui-commonquery-group-more"
	                };
	                var queryDateMoreDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(queryDateContentDom, queryDateMoreDom);
	                waf.initComponent("column", optsJson, queryDateMoreDom);
	
	                optsJson = {
	                    tagClass:"btn",
	                    caption:"",
	                    id:id+"_queryDate_btnMore"
	                };
	                var btnDateMoreDom = waf.createDOM("linkButton", optsJson);
	                waf.appendDOM(queryDateMoreDom, btnDateMoreDom);
	                waf.initComponent("linkButton", optsJson, btnDateMoreDom);
	
	                waf("#" + id + "_queryDatePanel").wafColumnLayout();
	                }
	                
	                //
	                if (option.stateField != null) {
	                optsJson = {
	                    id:id + "_queryStateCol",
	                    colWidth:"100%"
	                };
	                var queryStateColDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(commUsePanelDom, queryStateColDom);
	                waf.initComponent("column", optsJson, queryStateColDom);
	
	                optsJson = {
	                    id:id + "_queryStatePanel",
	                    layout:"column",
	                    tagClass:"ui-commonquery-group"
	                };
	                var queryStatePanelDom = waf.createDOM("panel", optsJson);
	                waf.appendDOM(queryStateColDom, queryStatePanelDom);
	                waf.initComponent("panel", optsJson, queryStatePanelDom);
	
	                optsJson = {
	                    id:id + "_queryStateHd",
	                    colWidth:"10%",
	                    tagClass:"ui-commonquery-group-hd"
	                };
	                var queryStateHdDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(queryStatePanelDom, queryStateHdDom);
	                waf.initComponent("column", optsJson, queryStateHdDom);
	                waf('<span class="ui-lb-text">:</span>').appendTo(queryStateHdDom);
	
	                optsJson = {
	                    id:id + "_queryStateContent",
	                    colWidth:"90%",
	                    tagClass:"ui-commonquery-group-content"
	                };
	                var queryStateContentDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(queryStatePanelDom, queryStateContentDom);
	                waf.initComponent("column", optsJson, queryStateContentDom);
	                waf('<ul id="'+id+'_queryStateGroupNav" class="ui-commonquery-group-nav">').appendTo(queryStateContentDom);
	                waf("#" + id + "_queryStatePanel").wafColumnLayout();
	                }
	
	                waf("#" + id + "_commUsePanel").wafColumnLayout();
	                }
	
	                //
	                if (!option.schemeTabHide) {
	                optsJson = {
	                    id:id + "_schemePanel",
	                    layout:"column"
	                };
	                var schemePanelDom = waf.createDOM("panel", optsJson);
	                waf.appendDOM(schemeTabDom, schemePanelDom);
	                waf.initComponent("panel", optsJson, schemePanelDom);
	
	                //
	                optsJson = {
	                    id:id + "_commonSchemeCol",
	                    colWidth:"100%"
	                };
	                var commonSchemeColDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(schemePanelDom, commonSchemeColDom);
	                waf.initComponent("column", optsJson, commonSchemeColDom);
	
	                optsJson = {
	                    id:id + "_commonSchemePanel",
	                    layout:"column",
	                    tagClass:"ui-commonquery-scheme"
	                };
	                var commonSchemePanelDom = waf.createDOM("panel", optsJson);
	                waf.appendDOM(commonSchemeColDom, commonSchemePanelDom);
	                waf.initComponent("panel", optsJson, commonSchemePanelDom);
	                
	                optsJson = {
	                    id:id + "_commonSchemeHd",
	                    colWidth:"10%",
	                    tagClass:"ui-commonquery-group-hd"
	                };
	                var commonSchemeHdDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(commonSchemePanelDom, commonSchemeHdDom);
	                waf.initComponent("column", optsJson, commonSchemeHdDom);
	                waf('<span class="ui-lb-text">:</span>').appendTo(commonSchemeHdDom);
	
	                optsJson = {
	                    id:id + "_commonSchemeContent",
	                    colWidth:"90%",
	                    tagClass:"ui-commonquery-group-content"
	                };
	                var commonSchemeContentDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(commonSchemePanelDom, commonSchemeContentDom);
	                waf.initComponent("column", optsJson, commonSchemeContentDom);
	                waf('<ul id="'+id+'_commonSchemeNav" class="ui-commonquery-group-nav">').appendTo(commonSchemeContentDom);
	                
	                optsJson = {
	                    id:id + "_commonSchemeMore",
	                    colWidth:"",
	                    tagClass:"ui-commonquery-group-more"
	                };
	                var commonSchemeMoreDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(commonSchemePanelDom, commonSchemeMoreDom);
	                waf.initComponent("column", optsJson, commonSchemeMoreDom);
	                optsJson = {
	                    tagClass:"btn",
	                    caption:"",
	                    id:id+"_commonSch_btnSet"
	                };
	                var btnCommonSchSetDom = waf.createDOM("linkButton", optsJson);
	                waf.appendDOM(commonSchemeMoreDom, btnCommonSchSetDom);
	                waf.initComponent("linkButton", optsJson, btnCommonSchSetDom);
	
	                optsJson = {
	                    tagClass:"btn",
	                    caption:"",
	                    id:id+"_commonSch_btnMore"
	                };
	                var btnCommonSchMoreDom = waf.createDOM("linkButton", optsJson);
	                waf.appendDOM(commonSchemeMoreDom, btnCommonSchMoreDom);
	                waf.initComponent("linkButton", optsJson, btnCommonSchMoreDom);
	                
	                waf("#" + id + "_commonSchemePanel").wafColumnLayout();
	
	                //
	                optsJson = {
	                    id:id + "_advanceQueryCol",
	                    colWidth:"100%"
	                };
	                var advanceQueryColDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(schemePanelDom, advanceQueryColDom);
	                waf.initComponent("column", optsJson, advanceQueryColDom);
	
	                optsJson = {
	                    id:id + "_advanceQueryPanel",
	                    layout:"column",
	                    tagClass:"ui-commonquery-group"
	                };
	                var advanceQueryPanelDom = waf.createDOM("panel", optsJson);
	                waf.appendDOM(advanceQueryColDom, advanceQueryPanelDom);
	                waf.initComponent("panel", optsJson, advanceQueryPanelDom);
	
	                optsJson = {
	                    id:id + "_advanceQueryHd",
	                    colWidth:"10%",
	                    tagClass:"ui-commonquery-group-hd"
	                };
	                var advanceQueryHdDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(advanceQueryPanelDom, advanceQueryHdDom);
	                waf.initComponent("column", optsJson, advanceQueryHdDom);
	                waf('<span class="ui-lb-text">:</span>').appendTo(advanceQueryHdDom);
	
	                optsJson = {
	                    id:id + "_advanceQueryContent",
	                    style:"margin-top:2px",
	                    colWidth:"90%",
	                    tagClass:"ui-commonquery-group-content"
	                };
	                var advanceQueryContentDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(advanceQueryPanelDom, advanceQueryContentDom);
	                waf.initComponent("column", optsJson, advanceQueryContentDom);
	                waf('<ul id="'+id+'_advanceQueryDef" class="ui-commonquery-group-nav">').appendTo(advanceQueryContentDom);
	                waf('<ul id="'+id+'_advanceQueryNav" class="ui-commonquery-group-nav">').appendTo(advanceQueryContentDom);
	                
	                optsJson = {
	                    id:id + "_advanceQueryReset",
	                    colWidth:"",
	                    tagClass:"ui-commonquery-group-reset"
	                };
	                var advanceQueryResetDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(advanceQueryPanelDom, advanceQueryResetDom);
	                waf.initComponent("column", optsJson, advanceQueryResetDom);
	                
	                optsJson = {
	                    caption:"",
	                    id:id+"_advanceQuery_btnSet",
	                };
	                var btnAdvanceQuerySetDom = waf.createDOM("linkButton", optsJson);
	                waf.appendDOM(advanceQueryResetDom, btnAdvanceQuerySetDom);
	                waf.initComponent("linkButton", optsJson, btnAdvanceQuerySetDom);
	
	                optsJson = {
	                    caption:"+ ",
	                    id:id + "_advanceQueryBtnAdd",
	                    tagClass:"adqadd"
	                };
	                var btnAdvanceQueryAdd = waf.createDOM("linkButton", optsJson);
	                waf.appendDOM(advanceQueryContentDom, btnAdvanceQueryAdd);
	                waf.initComponent("linkButton", optsJson, btnAdvanceQueryAdd);
	                waf('<br>').appendTo(advanceQueryContentDom);
	                
	                waf("#" + id + "_advanceQueryPanel").wafColumnLayout();
	
	                //
	                optsJson = {
	                    id:id + "_saveQueryCol",
	                    colWidth:"100%"
	                };
	                var saveQueryColDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(schemePanelDom, saveQueryColDom);
	                waf.initComponent("column", optsJson, saveQueryColDom);
	
	                optsJson = {
	                    id:id + "_saveQueryPanel",
	                    layout:"column",
	                    tagClass:"ui-commonquery-savegroup"
	                };
	                var saveQueryPanelDom = waf.createDOM("panel", optsJson);
	                waf.appendDOM(saveQueryColDom, saveQueryPanelDom);
	                waf.initComponent("panel", optsJson, saveQueryPanelDom);
	
	                optsJson = {
	                    id:id + "_saveQueryHd",
	                    tagClass:"ui-commonquery-group-hd",
	                    colWidth:"10%",
	                };
	                var saveQueryHdDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(saveQueryPanelDom, saveQueryHdDom);
	                waf.initComponent("column", optsJson, saveQueryHdDom);
	                waf('<span class="ui-lb-text">:</span>').appendTo(saveQueryHdDom);
	
	                optsJson = {
	                    id:id + "_saveQueryContent",
	                    tagClass:"ui-commonquery-group-content",
	                    colWidth:"90%",
	                };
	                var saveQueryContentDom = waf.createDOM("column", optsJson);
	                waf.appendDOM(saveQueryPanelDom, saveQueryContentDom);
	                waf.initComponent("column", optsJson, saveQueryContentDom);
	                waf('<input id="'+id+'_saveQueryInput" type="text" class="savequeryinput" placeholder="">').appendTo(saveQueryContentDom);
	
	                optsJson = {
	                    tagClass:"btn",
	                    caption:"",
	                    id:id + "_saveQuery_btnSet"
	                };
	                var btnSaveQuerySet = waf.createDOM("linkButton", optsJson);
	                waf.appendDOM(saveQueryContentDom, btnSaveQuerySet);
	                waf.initComponent("linkButton", optsJson, btnSaveQuerySet);
	                
	                var searchBtnDivDom = waf('<div id="'+id+'_searchBtnDiv" class="savebtndiv"></div>');
	                searchBtnDivDom.appendTo(saveQueryContentDom);
	                optsJson = {
	                    tagClass:"btn blue savebtn",
	                    caption:"",
	                    id:id + "_advanceQueryQuery"
	                };
	                var btnAdvanceQuery = waf.createDOM("linkButton", optsJson);
	                waf.appendDOM(searchBtnDivDom, btnAdvanceQuery);
	                waf.initComponent("linkButton", optsJson, btnAdvanceQuery);
	
	                waf("#" + id + "_saveQueryPanel").wafColumnLayout();
	
	                waf("#" + id + "_schemePanel").wafColumnLayout();
	                }
	
	                waf("#" + id).wafColumnLayout();
	
	                return mainPanel;
	            },
	            initFun:function(option){
	                if (option.queryPK == null) {
	                    waf.msgBox.showError("Query");
	                    return;
	                }
	                if (option.gridId == null) {
	                    waf.msgBox.showError("ID");
	                    return;
	                }
	                if (option.orgField!=null&&option.orgField!="") {
		                if (option.orgQueryPK == null) {
		                    waf.msgBox.showError("Query");
		                    return;
		                }
		                if (option.orgDataUrl == null || option.orgDataUrl == "") {
		                    option.orgDataUrl = waf.getContextPath() + "/component/bizCommonQuery.do?method=getOrgData";
		                } else {
		                    option.orgDataUrl = waf.getContextPath() + option.orgDataUrl;
		                }
	                }
	                if (option.dateField!=null&&(option.dateFormat==null||option.dateFormat=="")) {
	                    option.dateFormat = "[{name:'',value:'d1',isDefault:false},	{name:'',value:'w1',isDefault:true},{name:'',value:'m1',isDefault:false},{name:'',value:'m3',isDefault:false}]";
	                }
	                if (option.stateField!=null&&(option.stateFormat==null||option.stateFormat=="")) {
	                    waf.msgBox.showError("");
	                    return;
	                }
	                if (option.orgGroupRows == null || option.orgGroupRows == "") {
	                    option.orgGroupRows = "5";
	                }
	                option.orgId = option.id + "_queryOrg";
	                option.queryBarId = option.id + "_queryBarGroupNav";
	                option.orgGroupNavId = option.id + "_queryOrgGroupNav";
	                option.dateGroupNavId = option.id + "_queryDateGroupNav";
	                option.stateGroupNavId = option.id + "_queryStateGroupNav";
	                option.commonSchemeNavId = option.id + "_commonSchemeNav";
	                option.advanceQueryNavId = option.id + "_advanceQueryNav";
	                option.advanceQueryDefId = option.id + "_advanceQueryDef";
	
	                waf("#" + option.id).bizCommonQuery(option);
	            }
	        });
	    });
	}(jQuery));
//});

waf.defineClass("waf.webcom.bizCommonQuery.bizCommonQuery_LocaleStr_l1",waf.framework.WafCore,{
	MYORG:"Organization:",
	MORE:"More...",
	ALL: "All",
    DEL:"Delete"
});

waf.defineClass("waf.webcom.bizCommonQuery.bizCommonQuery_LocaleStr_l2",waf.framework.WafCore,{
	MYORG:":",
	MORE:"...",
	ALL: "",
    DEL:""
});

waf.defineClass("waf.webcom.bizCommonQuery.bizCommonQuery_LocaleStr_l3",waf.framework.WafCore,{
	MYORG:":",
	MORE:"...",
	ALL: "",
    DEL:""
});
/**
 * BOTP
 */
//mod.defineModule("botp",["waf","window"],function(){
	$.widget("waf.botp",$.waf.WebComponent,{
		/*
		 * 
		 */
		options:{
		    billUserDefinedAdapter:null,
		},
		_create:function () {
            var self = this;
            if(!self.element.data("domcreated")){
                $(self.element).attr("ctrlrole","waf.botp").attr("data-domcreated","true");
            }
        },
		/*
		 * 
		 */
		openCreateToAssBillDialog:function(option){
			if(option.billIds==undefined || option.billIds==null){
				alert("bill id can't be null");
				return ;
			}
			var url=waf.getContextPath() + "/component/botp.do?method=createToAssBill&billIDs=" + waf.encodeURIComponent(option.billIds);
			
			if(this.options.billUserDefinedAdapter){
				url = url + "&billUserDefinedAdapter=" + waf.encodeURIComponent(this.options.billUserDefinedAdapter);
			}
	
			waf.window.open({
					    url:url,
					    OpenType:"iframe",
					    method:'POST',
					    data:{billIDs : option.billIds.toString(),billUserDefinedAdapter:this.options.billUserDefinedAdapter},
					    modal:true,
					    openFromParent:false,
					    title:"",
					    showTitleBar : true,
					    position: 'center',
					    width: 500,
					    height: 400,
					    minHeight:500,
					    minWidth:640,
					    iconCls:"ui-icon-winIcon",
					    draggable: true,
					    resizable: false,
					    hideEffect: "slide",
					    close:function(event, ui){
					       if(option.close!=undefined && option.close!=null){
					       	  option.close(event,ui);
					       }
					    },
					    openCompleted:function(event, ui){
					        
					    }
			});
		},
		/*
		 * 
		 */
		 openTraceUpDialog:function(option){
		 	if(option.billIds==undefined || option.billIds==null){
				alert("bill id can't be null");
				return ;
			}
			var url = waf.getContextPath() + "/component/botp.do?method=traceUp&billInfoID=" + waf.encodeURIComponent(option.billIds);
			if(this.options.billUserDefinedAdapter){
				url = url + "&billUserDefinedAdapter=" + waf.encodeURIComponent(this.options.billUserDefinedAdapter);
			}
		 	waf.window.open({
					    url:url,
					    OpenType:"iframe",
					    //bgiframe: false,
					    method:'GET',
					    data:{OpenType : "iframe",modal : "true",position : "center",
					        width : "420",height : "360",draggable : "true",resizable : "true"},
					    modal:true,
					    openFromParent:true,
					    title:"",
					    position: 'center',
					    showTitleBar : true,
					    width: 750,
	                    autoMax:true,
					    minHeight:480,
					    minWidth:620,
					    iconCls:"ui-icon-winIcon",
					    draggable: true,
					    resizable: true,
					    //showEffect:"slide",
					    hideEffect: "none",
					    //autoMax:true,
					    close:function(event, ui){
					    	if(option.close!=undefined && option.close!=null){
					       	  option.close(event,ui);
					       	}
					    }
			});
		 },
		 /*
		  * 
		  */
		 openTraceDownDialog:function(option){
		 	if(option.billIds==undefined || option.billIds==null){
				alert("bill id can't be null");
				return ;
			}
			
			var url = waf.getContextPath() + "/component/botp.do?method=traceDown&billInfoID=" + waf.encodeURIComponent(option.billIds);
			if(this.options.billUserDefinedAdapter){
				url = url + "&billUserDefinedAdapter=" + waf.encodeURIComponent(this.options.billUserDefinedAdapter);
			}
		 	waf.window.open({
					    url:url,
					    OpenType:"iframe",
					    //bgiframe: false,
					    method:'GET',
					    data:{},
					    modal:true,
					    openFromParent:true,
					    title:"",
					    position: 'center',
					    showTitleBar : true,
	                    width: 750,
	                    autoMax:true,
					    minHeight:480,
					    minWidth:620,
					    iconCls:"ui-icon-winIcon",
					    draggable: true,
					    resizable: true,
					    //showEffect:"slide",
					    hideEffect: "none",
					    //autoMax:true,
					    close:function(event, ui){
					    	if(option.close!=undefined && option.close!=null){
					       	  option.close(event,ui);
					       	}
					    }
			});
		 }
	});
	
	//
	waf(function(){
		waf.registerComponent("waf.botp",{
			createDOMFun:function(option){
				var obj = option && option.id && $("#"+option.id);
				if(!(obj&&obj.data("domcreated"))){
					return waf("<span id='" + option.id + "'></span>");
				}else{
                    return obj;
                }
			},
			initFun:function(option){
				waf("#" + option.id).botp(option);
			}
		});
	});
//});
/****************************************************************************/
/****************JS************************************/

waf.defineClass("waf.botp.listPull",waf.framework.WafCore,{
	/*  */
	initalizeAction:function(){
		_self.cmbSourceType_onChange();
	},
	/* */
	cmbSourceType_onChange:function(){
		var params={};
		params.sourceType=waf("#cmbSourceType").wafSelect("getValue");
		params.destBillBosType=document.getElementById("destBillBosType").value;
		
		var options=waf("#cmbTransRule").wafSelect("getAllOptions");
		if(options!=null){
			waf("#cmbTransRule").wafSelect("removeOption");
		}

		//
		waf.doPost({
					url:waf.getContextPath() + '/component/botp.do?method=getPullTransRuleAndQuery',
					data:params,
					success:function(data){
						waf("#cmbTransRule").wafSelect("addOption",data.transRuleList);
						//F7
		                waf("#source_f7").wafPromptGrid("option","query",data.queryPK);
					}
				});
	},
	/*  */
	btnTransform_onClick:function(){
		var sourceBills = waf("#source_f7").wafPromptBox("getValue");
		if (sourceBills == null) {
		    waf.msgBox.showWarning({
                summaryMsg:_self.localeStr.NO_SOURCE_SELECTED
            });
            return;
        }
        var srcBillIDs = "";
        for (var i=0;i<sourceBills.length;i++) {
            srcBillIDs += sourceBills[i].id+",";
        }
        srcBillIDs = srcBillIDs.substring(0,srcBillIDs.length-1);
		var params={};
		params.billIDs=srcBillIDs;
		params.transformRule=waf("#cmbTransRule").wafSelect("getValue");
		params.destBillBosType=document.getElementById("destBillBosType").value;
		//
		waf.doPost({
					url:waf.getContextPath() + '/component/botp.do?method=transform',
					data:params,
					success:function(data){
					    if (data.showType==1) {
					        waf.window.open({
				                url:waf.getContextPath()+data.url,
				                OpenType:"iframe",
             				    method:'GET',
             				    openFromParent:true,
             				    title:_self.localeStr.TITLE_EDIT,
            				    position: 'center',
            				    showTitleBar : true,
            				    width: 900,
				                height: 600,
				                minHeight:600,
				                minWidth:900,
				                autoMax:true,
            				    iconCls:"ui-icon-winIcon",
            				    draggable: true,
             				    resizable: true,
             				    close:function(event, ui){
             				        waf.window.close();
				                }
                		    });
					    } else {
						    parent.waf.msgBox.showInfo({
								summaryMsg:_self.localeStr.SUCCESS,
								buttons:[{
									text :_self.localeStr.CONFIRM,
									click:function(){
										waf.window.close();
									}
								}]
						    });
						}
					}
				});
	},
	/* */
	btnCancel_onClick:function(){
		 waf.window.close();
	}
});

/****************-JS*******************************/
waf.defineClass("waf.botp.listPull_LocaleStr_l1",waf.framework.WafCore,{
	SUCCESS:"The target document is generated successfully.",
	CONFIRM:"OK",
	NO_SOURCE_SELECTED:"Have not choose source documents.",
	TITLE_EDIT:"Edit"
});

waf.defineClass("waf.botp.listPull_LocaleStr_l2",waf.framework.WafCore,{
	SUCCESS:".",
	CONFIRM:"",
	NO_SOURCE_SELECTED:"",
	TITLE_EDIT:""
});

waf.defineClass("waf.botp.listPull_LocaleStr_l3",waf.framework.WafCore,{
	SUCCESS:".",
	CONFIRM:"",
	NO_SOURCE_SELECTED:"",
	TITLE_EDIT:""
});

/****************************************************************************/
/****************-JS************************************/

waf.defineClass("waf.botp.listPush",waf.framework.WafCore,{
	/*  */
	initalizeAction:function(){
		_self.cmbDestType_onChange();
	},
	/* */
	cmbDestType_onChange:function(){
		var params={};
		params.billIDs=document.getElementById("srcBillIDs").value;
		params.destType=waf("#cmbDestType").wafSelect("getValue");
		
		var options=waf("#cmbTransRule").wafSelect("getAllOptions");
		if(options!=null){
			waf("#cmbTransRule").wafSelect("removeOption");
		}

		//
		waf.doPost({
					url:waf.getContextPath() + '/component/botp.do?method=getTransRule',
					data:params,
					success:function(data){
						waf("#cmbTransRule").wafSelect("addOption",data);
					}
		});		
	},
	/*  */
	btnTransform_onClick:function(){
		var params={};
		params.billIDs=document.getElementById("srcBillIDs").value;
		if (document.getElementById("billUserDefinedAdapter")!=null)
			params.billUserDefinedAdapter=document.getElementById("billUserDefinedAdapter").value;
		params.transformRule=waf("#cmbTransRule").wafSelect("getValue");
		params.destBillType=waf("#cmbDestType").wafSelect("getValue");
		//
		waf.doPost({
					url:waf.getContextPath() + '/component/botp.do?method=transform',
					data:params,
					success:function(data){
					    if (data.url!=null && data.url!="") {
					        //waf.redirect(waf.getContextPath()+url);
					        //var target = waf.windowMgr.getTargetObj();
					        //waf.window.max(target);
					        waf.window.open({
				                url:waf.getContextPath()+data.url,
				                OpenType:"iframe",
             				    method:'GET',
             				    openFromParent:true,
             				    title:waf("#cmbDestType").wafSelect("getSelectedAlias"),
            				    position: 'center',
            				    showTitleBar : true,
            				    width: 800,
				                height: 600,
				                minHeight:600,
				                minWidth:700,
            				    iconCls:"ui-icon-winIcon",
            				    autoMax:true,
            				    draggable: true,
             				    resizable: true
                		    });
                		    waf.window.close();
					    } else {
						    parent.waf.msgBox.showInfo({
								summaryMsg:_self.localeStr.SUCCESS,
								buttons:[{
									text :_self.localeStr.CONFIRM,
									click:function(){
										waf.window.close();
									}
								}]
						    });
						}
					}
				});
	},
	/* */
	btnCancel_onClick:function(){
		 waf.window.close();
	}
});

/****************-JS*******************************/
waf.defineClass("waf.botp.listPush_LocaleStr_l1",waf.framework.WafCore,{
	SUCCESS:"The target document is generated successfully.",
	CONFIRM:"OK"	
});

waf.defineClass("waf.botp.listPush_LocaleStr_l2",waf.framework.WafCore,{
	SUCCESS:".",
	CONFIRM:""
});

waf.defineClass("waf.botp.listPush_LocaleStr_l3",waf.framework.WafCore,{
	SUCCESS:".",
	CONFIRM:""
});

/****************************************************************************/
/****************-JS************************************/

waf.defineClass("waf.botp.navigation",waf.framework.WafCore,{
	exitWindow:function(){
		waf.window.close();
	}
});

/****************-JS*******************************/
//mod.defineModule("breadCrumbs",["waf"],function(){
	(function($, undefined) {
		$.widget("waf.breadCrumbs", $.waf.WebComponent, {
			options : {
				id : null, //ID
				width : null, //
				height : null, //
				style : null, //style
				tagClass : null, //cssclass
				maxCrumbs : 10,   //
				maxMemory : 20,
				seperator : "&gt;",
				onclick : null
			},
			crumbs:new Array(),
			/**
			 * 
			 * @private
			 */
			_enter2tab : function() {
				if ($.fn.enter2tab) {
					this.element.enter2tab();
				}
			},
			_create:function(){
	            var hdEl = waf("<span>:</span>");
	            hdEl.addClass("ui-lb-text ui-breadcrumbs-hd");
	            hdEl.appendTo(waf(this.element));
			},
			
			createCrumbs:function(title,tabpk){	
			    var crumbs = this.getCrumbs(),
					crumbList = $(document.createElement('ul')).addClass("ui-breadcrumbs").appendTo($(this.element)),
					crumbListItem;
				if(crumbs){
	                //
					var startIndex = 0;
					
					if(crumbs.length > this.options.maxCrumbs) {
						startIndex = crumbs.length - this.options.maxCrumbs;
					}
					
					var self = this;
					for(var i = startIndex; i < crumbs.length-1;i++){
	                    //
						crumbListItem = $(document.createElement('li'));
						var crumbLink = $(document.createElement('a'));
						crumbLink.attr({'id' : crumbs[i].tabpk}).text(crumbs[i].title).appendTo(crumbListItem.appendTo(crumbList));
						
						//
						crumbLink.click(this.options.onclick);
						crumbLink.data("index", i);
	
	                    //
						if(this.options.seperator){
							$(document.createElement('span')).addClass("divider").html(this.options.seperator).appendTo(crumbListItem);
						}
					}
	
	                //
					crumbListItem = $(document.createElement('li'));
					$(document.createElement('span')).text(title).appendTo($(crumbListItem).appendTo($(crumbList)));				
				}
			},
			getCrumbs : function() {
				return this.crumbs;
			},
			setCrumb : function(crumb) {
				var crumbs = this.getCrumbs();
				if (crumbs.length==0) {
					crumbs.push(crumb);
				} else if (crumbs[crumbs.length - 1].tabpk != crumb.tabpk){
				    crumbs.push(crumb);
				}
			},
			removeCrumb : function(index) {
				var crumbs = this.getCrumbs();
				crumbs.splice(index, (crumbs.length - index));
			},
			cleanCrumbs:function(){	
			    this.element.find(".ui-breadcrumbs").remove();
			}
		});
	
	    //
	    waf(function(){
	        waf.registerComponent("waf.breadCrumbs",{
	            createDOMFun:function(option){
	                //div
	                var div = waf("<div id='" + option.id + "'  class='border-sizing'></div>");
	                return div;
	            },
	            initFun:function(option){
	                if (option.maxCrumbs == null || option.maxCrumbs == "") {
	                    option.maxCrumbs = 10;   //
	                }
	                if (option.maxMemory == null || option.maxMemory == "") {
	                    option.maxMemory = 20;
	                }
	                if (option.seperator == null || option.seperator == "") {
	                    option.seperator = "&gt;";
	                }
	
	                waf("#" + option.id).breadCrumbs(option);
	            }
	        });
	    });
	}(jQuery));
//});
/**
 * 
 */
//mod.defineModule("commonQuery",["waf","window","commonQuery_i18n"],function(){
	$.widget("waf.commonQuery",$.waf.WebComponent,{
		options:{
			id:null,
			url:null,
			queryPK:null,
			grid:null,
			getMyFilterField:null,
			getMyFilterValueList:null,
			width:900,
			height:450
		},
		localeStr:null,
		queryWin:null,
		/*  */
		_create:function(){
		    this.localeStr = this.getLocaleResourceObject("waf.webcom.commonquery.commonQuery");
		},
	
	    /*  */
	    showCommonQueryDialog : function(option) {
	    	var self = this;
	    	if (self.options.queryPK == null || self.options.queryPK == "" || self.options.queryPK == "null") {
	            waf.msgBox.showError(self.localeStr.PARAM_ERROR);
	            return;
	        } 
	    	if (self.queryWin==null) {
	    	    self.queryWin = waf.window.open({
		    		url:waf.getContextPath()+"/component/CommonQuery.do?method=initalize",
			        openType:"iframe",
		    	    method:'POST',
		    	    data:{url : self.options.url,
		    	          queryPK : self.options.queryPK,
		    	          getMyFilterField:self.options.getMyFilterField,
		    	          getMyFilterValueList:self.options.getMyFilterValueList}, 
		        	modal:true,
		        	title:self.localeStr.TITLE,
		         	position: 'center', 
		     	    width: self.options.width,
		    	    height: self.options.height,
		    	    minHeight:0,
		    	    minWidth:200,
		    	    iconCls:"waf-ui-icon",
		    	    draggable: true,
		    	    minMixBtn: false,
		    	    hideCloseBtn:true,
		        	resizable: false,
		        	hideEffect: "slide",
		        	beforeHide:function(event,ui,value){
		        		if(option.confirm!=null) {
		    		        option.confirm(value);
		    	        }
		    	        event.preventDefault();
	                },
	                retValCallBack:function(comp){
		        		if(option.modifyOption!=null) {
		    		        option.modifyOption(comp);
		    	        }
	                }
		        });
		    } else {
		        waf.window.resume(self.queryWin);  //
		    }
	    }
	    
	});
	
	//
	waf(function(){
		waf.registerComponent("waf.commonQuery",{
			createDOMFun:function(option){
				return waf("<div id='" + option.id + "'></div>");
			},
			initFun:function(option){
			    if (option.queryPK == null) {
			        var localeStr = waf.createObject(eval("waf.webcom.commonquery.commonQuery" + "_LocaleStr_" + waf.getContext().locale.toLowerCase()));
	                waf.msgBox.showError(localeStr.PARAM_ERROR);
	                return;
	            }
	            option.url = waf.getContextPath()+"/component/CommonQuery.do"; 
			    if(option.width == null) option.width = "900";
		        if(option.height == null) option.height = "450";
		        
				waf("#" + option.id).commonQuery(option);
			}
		});
	});
//});













/**
 * 
 */
$.widget("waf.commonQueryDialog",$.waf.WebComponent,{
	options:{
		id:null,
		url:null,
		queryPK:null,
		getMyFilterField:null,
		getMyFilterValueList:null
	},
	TYPE_TEXT:"0",
	TYPE_ENUM:"1",
	TYPE_DATE:"2",
	TYPE_F7:"3",
	TYPE_NUMBER:"4",
	
	solutionList:null,
	filterField:null,
    filterValueList:null,
	compareOp:null,
    selectSolution:null,
    defaultSolu:null,
    fEditRowIndex:1,
    fEditColIndex:0,
    sEditRowIndex:1,
    sEditColIndex:0,
    defText:"",
    localeStr:null,
    
    /*  */
	_create:function(){
		var self=this;
		self.localeStr = self.getLocaleResourceObject("waf.webcom.commonquery.commonQuery");
		self.defText = self.localeStr.DEFAULT;
		
		waf.doPost(
		   {url:self.options.url+"?method=getInitalData&queryPK=" + this.options.queryPK,
			data:null,
			success:function(data) {
				    self.solutionList = data.solutionList;
				    if(self.options.getMyFilterField!=null&&self.options.getMyFilterField!="null") {
	    		        self.filterField = eval("parent.jsBinder."+self.options.getMyFilterField+"(data.filterField)");
	    	        } else {
				        self.filterField = data.filterField;
				    }
				    if(self.options.getMyFilterValueList!=null&&self.options.getMyFilterValueList!="null") {
	    		        self.filterValueList = eval("parent.jsBinder."+self.options.getMyFilterValueList+"(data.filterValueList)");
	    	        } else {
				        self.filterValueList = data.filterValueList;
				    }
				    self.compareOp = data.compareOp;
				    self.defaultSolu = data.defaultSolu.id;
				    self.selectSolution = data.defaultSolu.id;

				    self._initFilter(data);
				    self._initSorter(data);
				    self._loadSoutionList(self.solutionList);
			}}
	    );

	    waf("#query_btnSave").click(function(e) {
				self._save(e);
			});
	    waf("#query_btnSaveAs").click(function(e) {
				self._saveAs(e);
			});
	    waf("#query_btnDelete").click(function(e) {
				self._delete(e);
			});
	    waf("#query_btnSetDefault").click(function(e) {
				self._setDefault(e);
			});
			
        waf("#query_btnAddRow").click(function() {
				self._addRow();
			});
	    waf("#query_btnDelRow").click(function() {
				self._delRow();
			});
	    waf("#query_btnClear").click(function() {
				self._clearAll();
			});
			
	    waf("#query_btnMoveToFirst").click(function() {
				self._moveToFirst();
			});
     	waf("#query_btnMoveUp").click(function() {
				self._moveUp();
			});
    	waf("#query_btnMoveDown").click(function() {
				self._moveDown();
			});
        waf("#query_btnMoveToLast").click(function() {
				self._moveToLast();
			});
    	waf("#query_btnToDefault").click(function() {
				self._toDefault();
			});
			
		waf("#query_ok").click(function() {
				self._queryOk();
			});
	    waf("#query_cancal").click(function() {
				self._queryCancel();
			});
	},

	/*  */
	_loadSoutionList:function(data) {
		var self = this;
	    for (var i in data) {
	        if (data[i].id == this.defaultSolu) {
	            waf("#query_solutions").append('<li id="'+ data[i].id
				    +'"><a href="#" id="'+ data[i].id+'">'
	                + data[i].name+ this.defText + '</a></li>');
	        } else {
	            waf("#query_solutions").append('<li id="'+ data[i].id 
				    +'"><a href="#" id="'+ data[i].id+'">'
	                + data[i].name + '</a></li>');
	        }
	        waf("#query_solutions li[id='"+ data[i].id +"']").click(function(e) {
	                waf("#query_filter").dataGrid("editStop");
	                waf("#query_sorter").dataGrid("editStop");
				    self._loadCurrentSolution(this.id,e);
			});
	    }
	    waf("#query_solutions li").css("color","#FFFFFF");
	    waf("#query_solutions li[id='"+ self.defaultSolu.id +"']").css("color","#FFA500");
	    waf("#query_solutions a[id='"+ self.selectSolution.id +"']").css("color","#FFA500");
	    
	    self._loadCurrentSolution(self.defaultSolu);
    },
        
    /*  */
    _loadCurrentSolution : function(id,e) {
        var filterurl = this.options.url + "?method=getCurrentFilter&queryPK=" + this.options.queryPK + "&solutionId=" + waf.encodeURIComponent(id);
	    waf("#query_filter").dataGrid("setGridParam", {url : filterurl});
	    
	    var sorterurl = this.options.url + "?method=getCurrentSorter&queryPK=" + this.options.queryPK + "&solutionId=" + waf.encodeURIComponent(id);		
        waf("#query_sorter").dataGrid("setGridParam", {url : sorterurl});
		
	    this.selectSolution = id;
	    waf("#query_solutions a").css("color","#0000A0");
	    waf("#query_solutions a[id='"+ this.selectSolution +"']").css("color","#FFA500");
	    
	    window.setTimeout(function() {
	        waf("#query_filter").dataGrid("reloadGrid");
	        waf("#query_sorter").dataGrid("reloadGrid");
	    },80);
	    
	    if (e!=null)
	        e.preventDefault();
    },
    
    /*  */
    _initFilter:function(data) {
    	var self=this;
    	var filter_option = {rownumbers:true};
        filter_option.beforeEditCell = function(rowid, cellname, value, iRow, iCol,rowdata) {
            if(cellname == "filterValue"){
                var compareOp = waf("#query_filter").wafGrid("getCell", rowid, "compareOp");
                if (compareOp!=null 
                   && (compareOp.indexOf("2")>0 || compareOp=="is" || compareOp=="is not")){
                    return false;
                }
            }
        };
        filter_option.afterSaveCell = function(rowid, name, val, iRow, iCol) {
			if (name == "filterField") {
				waf("#query_filter").jqGrid("setCell", rowid, "filterValue", null);
				waf("#query_filter").jqGrid("setCell", rowid, "compareOp", null);
			}
			if (name == "compareOp"&&(val.indexOf("2")>0||val=="is"||val=="is not")) {
				waf("#query_filter").jqGrid("setCell", rowid, "filterValue", null);
			}
		};
		filter_option.formatCell = function(rowid, name, val, iRow, iCol) {
		    //
		    if (name == "compareOp") {
			    var isNeedFormat = 0,
				    filterField = waf("#query_filter").wafGrid("getCell", rowid, "filterField");
				for (var i in self.filterValueList) {
					var key = self.filterValueList[i].key;
					if (filterField == key) {
						var formatter = self.filterValueList[i].value;
						self._setCompareOp(formatter,self.compareOp,rowid);
						isNeedFormat = 1;
						break;
					}
				}
				if (isNeedFormat == 0)
					self._setCompareOp(null,self.compareOp,rowid);
			}
			self.fEditRowIndex = iRow;
			self.fEditColIndex = iCol;
		};
		filter_option.formatCellEditor = function(rowid, name, val, iCol,rowdata) {
			if (name == "filterValue") {
			    var editor = {},
				    isNeedFormat = 0,
				    filterField = waf("#query_filter").wafGrid("getCell", rowid, "filterField");
				if (!filterField) filterField = rowdata.filterField;
				for (var i in self.filterValueList) {
					var key = self.filterValueList[i].key;
					if (filterField == key) {
						var formatter = self.filterValueList[i].value;
						editor = self._setCellProp(formatter);
						isNeedFormat = 1;
						break;
					}
				}
				if (isNeedFormat == 0)
					editor = self._setCellProp(null);
				
				//
				waf.windowMgr.triggerRetValCallBack({filterField:filterField,editor:editor});
				waf("#query_filter").wafGrid("changeCellEditor",rowid,name,editor);
			}
		};
        waf("#query_filter").wafGrid("option",filter_option);
        
        var filterField_column_option = {edittype:"wafselect",editoptions:{selectJson:{listHeight:150},enumSource:self.filterField}};
        waf("#query_filter").wafGrid("optionColumn","filterField",filterField_column_option);
        var compareOp_column_option = {edittype:"wafselect",editoptions:{selectJson:{listHeight:150},enumSource:data.compareOp},filterSpecialChar:false};
        waf("#query_filter").wafGrid("optionColumn","compareOp",compareOp_column_option);
        var leftBracket_column_option = {edittype:"wafselect",editoptions:{selectJson:{listHeight:150},enumSource:data.leftBracket}};
        waf("#query_filter").wafGrid("optionColumn","leftBracket",leftBracket_column_option);
        var rightBracket_column_option = {edittype:"wafselect",editoptions:{selectJson:{listHeight:150},enumSource:data.rightBracket}};
        waf("#query_filter").wafGrid("optionColumn","rightBracket",rightBracket_column_option);
        var logicalOp_column_option = {edittype:"wafselect",editoptions:{selectJson:{},enumSource:data.logicalOp}};
        waf("#query_filter").wafGrid("optionColumn","logicalOp",logicalOp_column_option);
     },
    
    /*  */
    _initSorter:function(data) {
    	var self=this;
    	var sorter_option = {rownumbers:true};
        sorter_option.formatCell = function(rowid, name, val, iRow, iCol) {
			self.sEditRowIndex = iRow;
			self.sEditColIndex = iCol;
		};
        waf("#query_sorter").wafGrid("option",sorter_option);
        
        var sorterField_column_option = {edittype:"wafselect",editoptions:{selectJson:{},enumSource:data.sorterField}};
        waf("#query_sorter").wafGrid("optionColumn","sorterField",sorterField_column_option);
        var sorterOp_column_option = {edittype:"wafselect",editoptions:{selectJson:{},enumSource:data.sorterOp}};
        waf("#query_sorter").wafGrid("optionColumn","sorterOp",sorterOp_column_option);
        var sorterType_column_option = {edittype:"wafselect",editoptions:{selectJson:{},enumSource:data.sorterType}};
        waf("#query_sorter").wafGrid("optionColumn","sorterValue",sorterType_column_option);
    },
    
    /* */
    _setCellProp:function(formatter) {
        var self = this;
        var editor = {};
     	if (formatter == null) {
     	    editor = {edittype:"waftext",formatter:"waftext",editoptions:{inputJson:{}}};
 	    } else {
	        	switch (formatter[0]) {
	 		    case self.TYPE_ENUM :
                    editor = {edittype:"wafselect",formatter:"wafselect",editoptions:{selectJson:{listHeight:150},enumSource:formatter[1]}};
			    	break;
			    case self.TYPE_DATE :
                    editor = {edittype:"datepicker",formatter:"datepicker",editoptions:{datepickerjson:{dateFormat:'yy-mm-dd'}}};
			    	break;
			    case self.TYPE_F7 :
                    editor = {edittype:"f7",formatter:"f7",
                              editoptions:{f7Json:{},displayFormat:null,subWidgetName:"wafPromptQuick",
                                           subTagJson:{query:formatter[1],minLength:0,autoCompleteItem:"name",dataUrl:waf.getContextPath()+"/component/F7Quick.do?method=initalize"}}};
			    	break;
			    case self.TYPE_NUMBER :
                    editor = {edittype:"numberfield",formatter:"numberfield",editoptions:{inputJson:{}}};
			    	break;
			    
	    	    }
	        }
	    return editor;
    },
    
    /* */
    _setCompareOp:function(formatter,compareOp,rowid) {
        var self = this;
        var newEnum = [];
	    if (formatter == null) {//text
     	    for (var i=0;i<compareOp.length;i++) {
			    if (compareOp[i].value!=">"&&compareOp[i].value!=">="&&compareOp[i].value!="<"&&compareOp[i].value!="<="&&compareOp[i].value!="is"&&compareOp[i].value!="is not"&&compareOp[i].value.indexOf("2")<0)
			        newEnum[i]=compareOp[i];
			}
 	    } else {
 	        switch (formatter[0]) {
	 		    case self.TYPE_ENUM ://select
                    for (var i=0;i<compareOp.length;i++) {
			            if (compareOp[i].value!="like"&&compareOp[i].value!="not like"&&compareOp[i].value!="is"&&compareOp[i].value!="is not"&&compareOp[i].value!=">"&&compareOp[i].value!=">="&&compareOp[i].value!="<"&&compareOp[i].value!="<="&&compareOp[i].value.indexOf("2")<0)
			                newEnum[i]=compareOp[i];
			        }
			    	break;
			    case self.TYPE_DATE ://date
                    for (var i=0;i<compareOp.length;i++) {
			            if (compareOp[i].value!="!="&&compareOp[i].value!="like"&&compareOp[i].value!="not like")
			                newEnum[i]=compareOp[i];
			        }
			    	break;
			    case self.TYPE_F7 ://F7
                    for (var i=0;i<compareOp.length;i++) {
			            if (compareOp[i].value!="like"&&compareOp[i].value!="not like"&&compareOp[i].value!=">"&&compareOp[i].value!=">="&&compareOp[i].value!="<"&&compareOp[i].value!="<="&&compareOp[i].value.indexOf("2")<0)
			                newEnum[i]=compareOp[i];
			        }
                    break;
                case self.TYPE_NUMBER ://numberField
                    for (var i=0;i<compareOp.length;i++) {
			            if (compareOp[i].value!="like"&&compareOp[i].value!="not like"&&compareOp[i].value.indexOf("2")<0)
			                newEnum[i]=compareOp[i];
			        }
			    	break;
	    	}
	    }
        waf("#query_filter").wafGrid("setCellEditorConfig","compareOp","enumSource",newEnum,rowid);
    },

    /*  */
    _addRow : function() {
    	waf("#query_filter").wafGrid('addRow',{useFormatter:true});
    },

    /*  */
    _delRow : function() {
        var self = this;
    	self._saveEditCell();
    	var id = waf("#query_filter").jqGrid('getGridParam', 'selrow');
    	if (id) {
       		var content = self.localeStr.DELETE_LINE;
	    	waf.msgBox.showConfirm({
    		    summaryMsg:content,
    		    buttonCallBack:[function(dialog) {
    			    waf("#query_filter").jqGrid("delRow", id);
    			    waf.msgBox.close(dialog);
    		    }]
    	    }); 
    	} else {
    		waf.msgBox.showInfo({
				summaryMsg:self.localeStr.SELECT_ONE_LINE
			});   
    	}
    },

    /*  */
    _clearAll : function() {
        var self = this;
        if(waf("#query_filter").find("tr.norecord").length==0) {
        	waf.msgBox.showConfirm({
        		summaryMsg:self.localeStr.CLEAR_ALL,
        		buttonCallBack:[function(dialog) {
        		    waf("#query_filter").dataGrid("editStop");
	                waf("#query_filter").jqGrid("clearGridData", true);
    	    		waf.msgBox.close(dialog);
    	    	}]
    	    }); 
    	}
    },

    /*  */
    _moveToFirst : function() {
        var self = this;
    	var rowid = waf("#query_sorter").jqGrid("getGridParam", "selrow");
    	if (rowid) {
	        var rowData = waf("#query_sorter").jqGrid("getRowData", rowid);
	        waf("#query_sorter").jqGrid("delRowData", rowid);
	        waf("#query_sorter").jqGrid('addRowData',rowid,rowData,"first");
	        
	        waf("#query_sorter").wafGrid("setSelection",rowid);
    	} else {
    		waf.msgBox.showInfo({
				summaryMsg:self.localeStr.SELECT_ONE_LINE  
			});  
	    }
    },

    /*  */
    _moveToLast : function() {
        var self = this;
    	var rowid = waf("#query_sorter").jqGrid('getGridParam', 'selrow');
    	if (rowid) {
    	    var rowData = waf("#query_sorter").jqGrid("getRowData", rowid);
    	    waf("#query_sorter").jqGrid("delRowData", rowid);
	        waf("#query_sorter").jqGrid('addRowData',rowid,rowData,"last");
	        
	        waf("#query_sorter").wafGrid("setSelection",rowid);
    	} else {
    		waf.msgBox.showInfo({
				summaryMsg:self.localeStr.SELECT_ONE_LINE 
			});  
    	}
    },

    /*  */
    _moveUp : function() {
        var self = this;
    	var rowid = waf("#query_sorter").jqGrid('getGridParam', 'selrow');
    	if (rowid) {
    	    var rowData = waf("#query_sorter").jqGrid("getRowData", rowid);

    	    var srcrowid;
    	    var ids = waf("#query_sorter").jqGrid("getDataIDs");
    	    for (var i in ids) {
    		    if (ids[i]!=rowid) {
    		       srcrowid = ids[i];
    		    } else {
    		        break;
    		    }
    	    }
    	    if (srcrowid == null) return;
	    
    	    waf("#query_sorter").jqGrid("delRowData", rowid);
    	    waf("#query_sorter").jqGrid('addRowData',rowid,rowData,"before",srcrowid);
    	    
    	    waf("#query_sorter").wafGrid("setSelection",rowid);
    	} else {
    		waf.msgBox.showInfo({
				summaryMsg:self.localeStr.SELECT_ONE_LINE  
			});  
    	}
    },

    /*  */
    _moveDown : function() {
        var self = this;
    	var rowid = waf("#query_sorter").jqGrid('getGridParam', 'selrow');
    	if (rowid) {
    	    var rowData = waf("#query_sorter").jqGrid("getRowData", rowid);

    	    var srcrowid;
    	    var ownOne = false;
    	    var lastid = false;
    	    var ids = waf("#query_sorter").jqGrid("getDataIDs");
    	    for (var i in ids) {
    	    	lastid = ids[i];
    		    srcrowid = ids[i];
    		    if (ownOne)
    		        break;
    		    if (ids[i]==rowid) 
    		        ownOne = true;
    	    }
    	    if (lastid == rowid) return;
	    
    	    waf("#query_sorter").jqGrid("delRowData", rowid);
    	    waf("#query_sorter").jqGrid('addRowData',rowid,rowData,"after",srcrowid);
	    
    	    waf("#query_sorter").wafGrid("setSelection",rowid);
    	} else {
    		waf.msgBox.showInfo({
				summaryMsg:self.localeStr.SELECT_ONE_LINE  
			});  
    	}
    },

    /*  */
    _toDefault : function() {
        waf("#query_sorter").dataGrid("editStop");
        var sorterurl = this.options.url + "?method=toDefaultSorter&queryPK=" + this.options.queryPK;	
        waf("#query_sorter").jqGrid("setGridParam", {url : sorterurl}).trigger("reloadGrid");
    },

    /*  */
    _save : function(e) {
        var self = this;
	    self._saveEditCell();
	    var isLegal = self._verify();
	    if (!isLegal)
    		return;
		
    	var filter = self._getCommFilter(),
    	    sorter = self._getCommSorter(),
    	    solutionId = self.selectSolution,
    	    solutionName = waf("#query_solutions a[id='"+ self.selectSolution +"']").text();
    	    if (solutionId == self.defaultSolu)
    	        solutionName = solutionName.substring(0,solutionName.length-self.defText.length);
 	
    	waf.doPost(
		   {url:this.options.url + "?method=saveSolution",
			data:{queryPK:self.options.queryPK,
		          filter:waf.toJSONString(filter),
		          sorter:waf.toJSONString(sorter),
		          solutionName:solutionName,
		          solutionId:solutionId},
			success:function(data) {
			    self._loadCurrentSolution(solutionId);
 				waf.msgBox.showInfo({
				    summaryMsg:self.localeStr.SAVE_SUCCESS 
			    });
			}}
	    );
	    e.preventDefault();    
    },

    /**/
    _getCommFilter : function() {
    	var entryInfo = {};
    	var ids = waf("#query_filter").jqGrid("getDataIDs");
    	for (var i in ids) {
    		entryInfo[i] = waf("#query_filter").wafGrid("getRowRealData", ids[i]);
    	}
    	return entryInfo;
    },

    /**/
    _getCommSorter : function() {
    	var entryInfo = {};
    	var ids = waf("#query_sorter").jqGrid("getDataIDs");
    	for (var i in ids) {
    		entryInfo[i] = waf("#query_sorter").wafGrid("getRowRealData", ids[i]);
    	}
    	return entryInfo;
    },

    /*  */
    _saveAs : function(e) {
    	this._saveEditCell();
    	var isLegal = this._verify();
    	if (!isLegal)
    		return;
		
    	var self = this;
    	waf.msgBox.showPrompt({
				title : self.localeStr.SAVEAS,
				summaryMsg : self.localeStr.INPUT_NAME,
				buttonCallBack : [function(val,dialog) {
				    if (val == "" || val == null) {
				        waf.msgBox.showError({
				            summaryMsg:self.localeStr.NEED_NAME 
			            });
			            return;
				    }
				        
    	            var filter = self._getCommFilter(),
    	                sorter = self._getCommSorter();
    	
    	            waf.doPost(
		               {url:self.options.url + "?method=saveAsSolution",
			            data:{queryPK:self.options.queryPK,
		                      filter:waf.toJSONString(filter),
		                      sorter:waf.toJSONString(sorter),
		                      solutionName:val,
		                      solutionId:null},
			            success:function(newId) {
				           waf("#query_solutions").append('<li id="'+ newId 
				               +'"><a href="#" id="'+ newId+'">'
	                           + val + '</a></li>');
	                       waf("#query_solutions li[id='"+ newId +"']").click(function(e) {
	                           waf("#query_filter").dataGrid("editStop");
	                           waf("#query_sorter").dataGrid("editStop");
				               self._loadCurrentSolution(this.id,e);
			               });
	                       self._loadCurrentSolution(newId);
	                       waf("#query_solutions li[id='"+ newId +"']").css("color","#FFFFFF");
	    
				           waf.msgBox.showInfo({
				               summaryMsg:self.localeStr.SAVE_SUCCESS 
			               });  
			           },
			           error: function(msg) {
				           waf.msgBox.showInfo({
				               summaryMsg:msg  
			               });  
			           }}
	               );
	               waf.msgBox.close(dialog);
                }]
		});
		e.preventDefault();    
    },

    /*  */
    _delete : function(e) {
    	var self = this;
    	if (self.selectSolution == self.defaultSolu){
    	    waf.msgBox.showError({
				summaryMsg:self.localeStr.DEF_SOLUTION 
			});
			e.preventDefault();  
			return;
    	}
    	
     	waf.msgBox.showConfirm({
    		    summaryMsg:self.localeStr.DEL_SOLUTION,
    		    buttonCallBack:[function(dialog) {
    			    waf.doPost(
		                {url:self.options.url + "?method=deleteSolution", 
			             data:{solutionId:self.selectSolution},
			             success:function(data) {
				             waf("#query_solutions li").remove("#query_solutions li[id='"+ self.selectSolution +"']"); 
				             waf.msgBox.showInfo({
				                 summaryMsg:self.localeStr.DEL_SUCCESS  
			                 }); 
				            self._loadCurrentSolution(self.defaultSolu);
			             }}
	                );
    			    waf.msgBox.close(dialog);
    		    }]
    	}); 
    	e.preventDefault();  
    },

    /*  */
    _setDefault : function(e) {
    	var self = this;
    	waf.doPost(
		   {url:self.options.url + "?method=setDefaultSolution", 
			data:{queryPK:self.options.queryPK,
			      oldSoluId:self.defaultSolu,
			      solutionId:self.selectSolution},
			success:function(data) {
			    var oldDefText = waf("#query_solutions a[id='"+ self.defaultSolu +"']").text();
			    waf("#query_solutions a[id='"+ self.defaultSolu +"']").text(oldDefText.substring(0,oldDefText.length-self.defText.length));
			    self.defaultSolu = self.selectSolution;
                waf("#query_solutions li").css("color","#FFFFFF");
	            waf("#query_solutions li[id='"+ self.selectSolution +"']").css("color","#FFA500");
	            var newDefText = waf("#query_solutions a[id='"+ self.selectSolution +"']").text();
	            waf("#query_solutions a[id='"+ self.selectSolution +"']").text(newDefText+self.defText);
				waf.msgBox.showInfo({
				     summaryMsg:self.localeStr.SOLUTION+newDefText+self.localeStr.SET_DEFAULT  
			    });  
			    e.preventDefault();
		        //e.stopPropagation();
			}}
	    );
    },

    /*  */
    _saveEditCell : function() {
    	if (this.fEditRowIndex!=1 || this.fEditColIndex!=0)
	        waf("#query_filter").jqGrid("saveCell", this.fEditRowIndex, this.fEditColIndex);
	    if (this.sEditRowIndex!=1 || this.sEditColIndex!=0)
	        waf("#query_sorter").jqGrid("saveCell", this.sEditRowIndex, this.sEditColIndex);
    },

    /*  */
    _verify : function () {
        var self = this;
    	var bracketNo = 0;
    	var rowCount = waf("#query_filter").jqGrid('getGridParam', 'records');
    	var ids = waf("#query_filter").jqGrid("getDataIDs");
    	for (var i in ids) {
    		var ret = waf("#query_filter").jqGrid("getRowRealData", ids[i]);
    		var rownum = waf("#query_filter").jqGrid("getInd", ids[i]);

    		if (ret.filterField == "" || ret.filterField == null) {
    			waf.msgBox.showInfo({
				    summaryMsg:self.localeStr.NEED_FILTER  
			    });  
    			return false;
    		}

    		if (ret.compareOp == "" || ret.compareOp == null) {
	    		waf.msgBox.showInfo({
				    summaryMsg:self.localeStr.NEED_COMPAREOP  
			    });  
	    		return false;
	    	}

	    	if (((ret.filterValue == ""&&ret.filterValue != 0) || ret.filterValue == null)&& ret.compareOp != "is"
	    			&& ret.compareOp != "is not" && ret.compareOp.indexOf("2")<0) {
	    		waf.msgBox.showInfo({
				    summaryMsg:self.localeStr.NEED_FILTERVAL
			    });  
	    		return false;
	    	}

		    if (rownum != rowCount) {
	    		if (ret.logicalOp == "" || ret.logicalOp == null) {
	    			waf.msgBox.showInfo({
				        summaryMsg:self.localeStr.NEED_LOGICALOP 
			        });  
	    			return false;
	    		}
	    	} else {
	    	    if (ret.logicalOp != null && ret.logicalOp != "") {
	    			waf.msgBox.showInfo({
				        summaryMsg:self.localeStr.NO_LOGICALOP 
			        });  
	    			return false;
	    		}
	    	}

	    	if (ret.leftBracket != null) {
	    	    var lbrackAmount = ret.leftBracket.length;
	    	    for (var j = 0; j < lbrackAmount; j++) {
	    		    bracketNo++;
	    	    }
	    	}
	    	if (ret.rightBracket != null) {
	    	    var rbrackAmount = ret.rightBracket.length;
	    	    for (var j = 0; j < rbrackAmount; j++) {
	    		    bracketNo--;
	    	    }
	    	}
	    }
    	if (bracketNo != 0) {
     		waf.msgBox.showInfo({
				summaryMsg:self.localeStr.BRACKET_ERROR  
			});  
    		return false;
    	}
    	return true;
    },

    /*  */
    getQuerySql : function() {
        var self = this;
    	this._saveEditCell();
    	var isLegal = this._verify();
    	if (!isLegal)
    		return null;

    	var filter = " ";
	    var filteIds = waf("#query_filter").jqGrid("getDataIDs");
	    for (var i in filteIds) {
    		var ret = waf("#query_filter").jqGrid("getRowData", filteIds[i]);
    		var leftBracket = ret.leftBracket==null?"":ret.leftBracket,
    		    rightBracket = ret.rightBracket==null?"":ret.rightBracket,
    		    logicalOp = ret.logicalOp==null?"":ret.logicalOp,
    		    filterField = ret.filterField,
    		    filterValue = ret.filterValue,
    		    compareOp = ret.compareOp;
    		    
    		if (compareOp == "like" || compareOp == "not like"){
    		    filterField = "lower(" + filterField + ")";
    			filterValue = "%" + filterValue.toLowerCase() + "%";
    	    }
    		var isNeedQuotMarks = true,
    		    isNeedId = false,
    		    isDate = false;
    		for (var j in this.filterValueList) {
				var key = this.filterValueList[j].key;
				if (filterField == key) {
					var formatter = this.filterValueList[j].value;
					if (formatter[0] == self.TYPE_F7) {
					    isNeedId = true;
					}
					if (formatter[0] == self.TYPE_DATE || formatter[0] == self.TYPE_NUMBER) {
					    isNeedQuotMarks = false;
					}  
					if (formatter[0] == self.TYPE_DATE) {
					    isDate = true;
					}
					break;
				}
			}
			//
			if (isDate) {
			    var dataFilter = this._getDateSql(filterField,compareOp,filterValue);
			    filter += leftBracket + dataFilter + rightBracket + " " + logicalOp + " ";
			} else {
			    //F7
			    if (isNeedId && filterValue!=null) {
			        if(filterField.indexOf(".id")<0) {
			            filterField = filterField.substring(0, filterField.indexOf("."));
			            filterField += ".id";
			        }
			        filterValue = filterValue.id;
		    	}
		    	//
		    	if (isNeedQuotMarks)
		    	    filterValue = "'" + filterValue + "'";
                if (compareOp == "is" || compareOp == "is not")
    		    	filterValue = "null";
            
    	    	filter += leftBracket + filterField + " " + compareOp + " "
	    			+ filterValue + rightBracket + " " + logicalOp + " ";
    		}
    	}
    	
    	var sorter = "";
    	var sorterIds = waf("#query_sorter").jqGrid("getDataIDs");
	    for (var i in sorterIds) {
    		var ret = waf("#query_sorter").jqGrid("getRowData", sorterIds[i]);
    		var sorterOp = ret.sorterOp;
    		if (sorterOp == "1")
    		    sorter += " " + ret.sorterField + " " + ret.sorterValue + ",";
    	}
    	sorter = sorter.substring(0,sorter.length-1);
        
    	var data = {filter:filter,sorter:sorter};
    	return data;
    },
    
        /* YEAR(createTime)=2012 and MONTH(createTime)=4 and DAYOFMONTH(createTime)=12 */
    _getDateSql:function (filterField, compareOp, filterValue) {
        if (compareOp.indexOf("2")>0) {
            filterValue = compareOp.substring(4,compareOp.length);
            compareOp = "=";
        }
        var dataFilter = "";
        switch (compareOp) {
            case "=":
                var year = filterValue.substring(0,4);
			        month = filterValue.substring(5,7);
			        day = filterValue.substring(8,10);
	            dataFilter = "YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")="+day;
                break;
            case "<>":
                var year = filterValue.substring(0,4);
			        month = filterValue.substring(5,7);
			        day = filterValue.substring(8,10);
	            dataFilter = "(YEAR("+filterField+")>"+year
	                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")>"+month+")"
	                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")>"+day+"))"
	                         +" or (YEAR("+filterField+")<"+year
	                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")<"+month+")"
	                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")<"+day+"))";
                break;
            case ">":
                var year = filterValue.substring(0,4);
			        month = filterValue.substring(5,7);
			        day = filterValue.substring(8,10);
	            dataFilter = "YEAR("+filterField+")>"+year
	                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")>"+month+")"
	                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")>"+day+")";
                break;
            case ">=":
                var year = filterValue.substring(0,4);
			        month = filterValue.substring(5,7);
			        day = filterValue.substring(8,10);
	            dataFilter = "YEAR("+filterField+")>"+year
	                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")>"+month+")"
	                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")>="+day+")";
                break;
            case "<":
                var year = filterValue.substring(0,4);
			        month = filterValue.substring(5,7);
			        day = filterValue.substring(8,10);
	            dataFilter = "YEAR("+filterField+")<"+year
	                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")<"+month+")"
	                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")<"+day+")";
                break;
            case "<=":
                var year = filterValue.substring(0,4);
			        month = filterValue.substring(5,7);
			        day = filterValue.substring(8,10);
	            dataFilter = "YEAR("+filterField+")<"+year
	                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")<"+month+")"
	                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")<="+day+")";
                break;
            case "is":
                dataFilter = filterField+" is null";
                break;
            case "is not":
                dataFilter = filterField+" is not null";
                break;
        }
        return dataFilter;
    },
    
    _queryOk : function(){
    	var sql = this.getQuerySql();
    	if (sql == null)
    		return;
//	    var target = waf.windowMgr.getTargetObj().setWinReturnVal(sql);
//	    waf.window.close(target);
        waf.window.hideWithParam(sql);
    },
    
    _queryCancel : function(){
    	var target = waf.windowMgr.getTargetObj();
//	    waf.window.close(target);
	    waf.window.hide(target);
    }
});















waf.defineClass("waf.webcom.commonquery.commonQuery_LocaleStr_l1",waf.framework.WafCore,{
	TITLE:"Advanced Query",
	DEFAULT:"(Default)",
	DELETE_LINE:"The selected row will be deleted. Are you sure?",
	CLEAR_ALL:"Table data will be cleared. Are you sure?",
	SELECT_ONE_LINE:"Please select one row.",
	SAVE_SUCCESS:"Scheme saved successfully.",
	SAVEAS:"Save Scheme as",
	INPUT_NAME:"Please enter the scheme name:",
	NEED_NAME:"Scheme name cannot be blank.",
	DEF_SOLUTION:"The current scheme is default scheme. Cannot be deleted.",
	DEL_SOLUTION:"Are you sure you want to delete the current scheme?",
	DEL_SUCCESS:"Scheme deleted successfully." ,
	SOLUTION:"Scheme ",
	SET_DEFAULT:" has been set to be default scheme.",
	NEED_FILTER:"Filter condition cannot be blank. Please check.",
	NEED_COMPAREOP:"Comparison operator cannot be blank. Please check." ,
	NEED_FILTERVAL:"Comparison value cannot be blank. Please check.",
	NEED_LOGICALOP:"Logical operator cannot be blank. Please check.",
	NO_LOGICALOP:"Logical operator cannot exist in the last line of condition. Please check.",
	BRACKET_ERROR:"The parentheses are not matched. Please check." ,
	PARAM_ERROR:"Please set the queryPK parameter for web compomnent commonQuery to determine the data source."
});

waf.defineClass("waf.webcom.commonquery.commonQuery_LocaleStr_l2",waf.framework.WafCore,{
	TITLE:"",
	DEFAULT:"()",
	DELETE_LINE:",",
	CLEAR_ALL:"",
	SELECT_ONE_LINE:"!",
	SAVE_SUCCESS:"!",
	SAVEAS:"",
	INPUT_NAME:"",
	NEED_NAME:"",
	DEF_SOLUTION:"",
	DEL_SOLUTION:"",
	DEL_SUCCESS:"!" ,
	SOLUTION:"",
	SET_DEFAULT:"!",
	NEED_FILTER:"",
	NEED_COMPAREOP:"" ,
	NEED_FILTERVAL:"",
	NEED_LOGICALOP:"",
	NO_LOGICALOP:"",
	BRACKET_ERROR:"",
	PARAM_ERROR:"queryPK."
});

waf.defineClass("waf.webcom.commonquery.commonQuery_LocaleStr_l3",waf.framework.WafCore,{
	TITLE:"",
	DEFAULT:"()",
	DELETE_LINE:"",
	CLEAR_ALL:"",
	SELECT_ONE_LINE:"",
	SAVE_SUCCESS:"",
	SAVEAS:"",
	INPUT_NAME:"",
	NEED_NAME:"",
	DEF_SOLUTION:"",
	DEL_SOLUTION:"",
	DEL_SUCCESS:"" ,
	SOLUTION:"",
	SET_DEFAULT:"",
	NEED_FILTER:"",
	NEED_COMPAREOP:"" ,
	NEED_FILTERVAL:"",
	NEED_LOGICALOP:"",
	NO_LOGICALOP:"",
	BRACKET_ERROR:"" ,
	PARAM_ERROR:"queryPK."
});


/****************************************************************************/
/****************JS************************************/
waf.defineClass("waf.dataImpExp.DataExport",waf.framework.WafCore,{
	/*  */
	initalizeAction:function(){
	
	},
	btnExportData_onClick:function(){
		var postData={};

		//
		postData.exportType=waf("#exportType").wafSelect("getValue");
		//
		postData.errorProcess=waf("#errorProcess").wafSelect("getValue");
		//
		postData.solution=document.getElementById("solution").value;
		//
		postData.alias=document.getElementById("alias").value;

		if(postData.solution==null || postData.solution == ""){
			waf.msgBox.showError({
				summaryMsg:_self.localeStr.NOT_FOUND_SOLUTION 
			});
			return ;
		}		
		
		//
		waf.doPost(
			{
				action:'exportData',
				data:postData,
				success:function(data){
					var fileName=data.file;
					var serverFileName=data.serverFile;
					var log=data.log;
					if(log.failRecordCount>0) {
						var summaryMsg,detailMsg;
						summaryMsg =_self.localeStr.SUCCESS_RECORD_COUNT + log.successRecordCount + "! ";
						summaryMsg += "\n";
						summaryMsg += _self.localeStr.FAILTURE_RECORD_COUNT + log.failRecordCount + "!";
						
						detailMsg ="";
						for(var nIndex=0;nIndex<log.errorDetail.length;nIndex++){
							detailMsg += log.errorDetail[nIndex].serialNum + "\t" + log.errorDetail[nIndex].errorMsg + "\t" + log.errorDetail[nIndex].detail + "\n";
						}
	
						waf.msgBox.showInfo({
							summaryMsg:summaryMsg,
							buttonType:"ok",
						    detailMsg:detailMsg
						});
					}
					else {
						waf.msgBox.showInfo({
								autoBtnClose:false,
					        	summaryMsg:_self.localeStr.EXPORT_SUCCESS_AND_DOWNLOAD,   					
					        	buttonType:"ok-cancel",   					
					        	buttonCallBack:[
						        	function(dialog){
						        		waf.redirect("?method=downloadFile&fileName=" + fileName + "&serverFileName=" + serverFileName);
						        		waf.msgBox.close(dialog);
						        	},
						        	function(dialog){
						        		waf.msgBox.close(dialog);
						        	}
					        	]
						});
					}
				}
			}
		);
	},
	/* */
	btnClose_onClick:function(){
		var target = waf.windowMgr.getTargetObj();
		waf.window.close(target);
	}
});
/*  */
waf.defineClass("waf.dataImpExp.DataExport_LocaleStr_l1",null,{
	NOT_FOUND_SOLUTION:"solution not found!",
	SUCCESS_RECORD_COUNT:"success record count:",
	FAILTURE_RECORD_COUNT:"failture record count:",
	DETAIL_INFO:"detail infomation:",
	EXPORT_SUCCESS_AND_DOWNLOAD:"Export success,click the 'confirm' start download file!"
});

waf.defineClass("waf.dataImpExp.DataExport_LocaleStr_l2",null,{
	NOT_FOUND_SOLUTION:"!",
	SUCCESS_RECORD_COUNT:":",
	FAILTURE_RECORD_COUNT:":",
	DETAIL_INFO:":",
	EXPORT_SUCCESS_AND_DOWNLOAD:"''!"
});

waf.defineClass("waf.dataImpExp.DataExport_LocaleStr_l3",null,{
	NOT_FOUND_SOLUTION:"",
	SUCCESS_RECORD_COUNT:":",
	FAILTURE_RECORD_COUNT:":",
	DETAIL_INFO:":",
	EXPORT_SUCCESS_AND_DOWNLOAD:"''!"
});
/****************************************************************************/
/****************JS************************************/
waf.defineClass("waf.dataImpExp.DataImport",waf.framework.WafCore,{
	/*  */
	initalizeAction:function(){
	
	},
	/*  */
	fileUpload_fileUploadCompleted:function(event,data){
		document.getElementById("file").value=data.result[0].name;
	},
	/* */
	fileUpload_onRemoved:function(event,data){
		document.getElementById("file").value=null;
	},
	/*  */
	btnImportData_onClick:function(){
		var fileName=document.getElementById("file").value;
		
		if(fileName==null || fileName == ""){
			waf.msgBox.showError({
				summaryMsg:_self.localeStr.NOT_FOUND_UPLOADFILE 
			});
			return ;
		}

		var postData={};
		//
		postData.fileName=document.getElementById("file").value;
		//
		postData.importStrategy=waf("#importStrategy").wafSelect("getValue");
		//
		postData.errorProcess=waf("#errorProcess").wafSelect("getValue");
		//
		postData.solution=document.getElementById("solution").value;
		//
		postData.alias=document.getElementById("alias").value;
		
		//
		waf.doPost(
			{
				action:'importData',
				data:postData,
				success:function(data){
					var summaryMsg,detailMsg;
					summaryMsg =_self.localeStr.SUCCESS_RECORD_COUNT + data.successRecordCount + "! ";
					summaryMsg += "<BR>";
					summaryMsg += _self.localeStr.FAILTURE_RECORD_COUNT  + data.failRecordCount + "!";
					
					detailMsg ="";
					for(var nIndex=0;nIndex<data.errorDetail.length;nIndex++){
						detailMsg += "<BR>" + data.errorDetail[nIndex].serialNum + "." + data.errorDetail[nIndex].detail ;
					}

					waf.msgBox.showInfo({
						summaryMsg:summaryMsg,
						buttonType:"ok",
					    detailMsg: _self.localeStr.DETAIL_INFO  +  "<font color='red'>" + detailMsg + "</font>",
					    buttonCallBack:[
				        	function(dialog){
				        		var target = waf.windowMgr.getTargetObj();
								waf.window.close(target);
				        	}
				        ]
					});
				}
			}
		);
	},
	/*  */
	btnExportTemplate_onClick:function(){
		var postData={};
		//
		postData.solution=document.getElementById("solution").value;
		//
		postData.alias=document.getElementById("alias").value;

		waf.redirect("?method=exportTemplate&solution=" + postData.solution + "&alias=" + postData.alias);
	},
	/* added*/
	upload_onAdded:function(event,data) {
	
	},
	/* */
	btnClose_onClick:function(){
		var target = waf.windowMgr.getTargetObj();
		waf.window.close(target);
	}
});
/****************JS*******************************/
/*  */
waf.defineClass("waf.dataImpExp.DataImport_LocaleStr_l1",null,{
	NOT_FOUND_UPLOADFILE:"file not found!",
	SUCCESS_RECORD_COUNT:":",
	FAILTURE_RECORD_COUNT:":",
	DETAIL_INFO:"error info:"
});

waf.defineClass("waf.dataImpExp.DataImport_LocaleStr_l2",null,{
	NOT_FOUND_UPLOADFILE:"!",
	SUCCESS_RECORD_COUNT:":",
	FAILTURE_RECORD_COUNT:":",
	DETAIL_INFO:":"
});

waf.defineClass("waf.dataImpExp.DataImport_LocaleStr_l3",null,{
	NOT_FOUND_UPLOADFILE:"!",
	SUCCESS_RECORD_COUNT:":",
	FAILTURE_RECORD_COUNT:":",
	DETAIL_INFO:":"
});
/**
 * 
 */
//mod.defineModule("dataImpExp",["waf","window","dataImpExp_i18n"],function(){
	$.widget("waf.dataImpExp",$.waf.WebComponent,{
		/* */
		importDialog:null,
		/* */
		exportDialog:null,
		options:{
		    id:null,
		    solution:null,
		    alias:null
		},
		/*  */
		_create:function(){
			this.localeStr = this.getLocaleResourceObject("waf.webcom.dataImpExp.DataImpExp");
		},
	    /*  */
	    showImportDataDialog : function(option) {
	    	//
	    	if(this.options.solution==null){
	    		waf.msgBox.showError({
					summaryMsg:this.localeStr.NOT_FOUND_SOLUTION
				});
	    	}
		 	this.importDialog=waf.window.open({
					    url:waf.getContextPath()+"/component/dataImpExp.do?method=initalizeImportData&solution=" + this.options.solution + "&alias=" + this.options.alias,
					    OpenType:"iframe",
					    method:'POST',
					    data:{id:this.options.id,solution:this.options.solution,alias:this.options.alias},
					    modal:true,
					    openFromParent:false,
					    title:this.localeStr.DATA_IMPORT_WND_TITLE,
					    showTitleBar : true,
						autoMax : false,
					    position: 'center',
					    width: 500,
					    height: 400,
					    minHeight:500,
					    minWidth:640,
					    iconCls:"ui-icon-winIcon",
					    draggable: true,
					    resizable: false,
					    style:{'border':'0'},
					    hideEffect: "slide",
					    close:function(event, ui){
					       if(option!=undefined && option.close!=null) {
		    		       	 	option.close(event,ui);
		    	           };
					    }
			});
	    },
	    /*  */
	    showExportDataDialog : function(option) {
	    	//
	    	if(this.options.solution==null){
	    		waf.msgBox.showError({
					summaryMsg:this.localeStr.NOT_FOUND_SOLUTION
				});
	    	}
		 	this.exportDialog=waf.window.open({
					    url:waf.getContextPath()+"/component/dataImpExp.do?method=initalizeExportData&solution=" + this.options.solution + "&alias=" + this.options.alias,
					    OpenType:"iframe",
					    method:'POST',
					    data:{id:this.options.id,solution:this.options.solution,alias:this.options.alias},
					    modal:true,
					    openFromParent:false,
					    title:this.localeStr.DATA_EXPORT_WND_TITLE,
					    showTitleBar : true,
						autoMax : false,
					    position: 'center',
					    width: 500,
					    height: 400,
					    minHeight:500,
					    minWidth:640,
					    iconCls:"ui-icon-winIcon",
					    draggable: true,
					    resizable: false,
					    style:{'border':'0'},
					    hideEffect: "slide",
					    close:function(event, ui){
					       if(option!=undefined && option.close!=null) {
		    		       	 	option.close(event,ui);
		    	           };
					    }
			});
	    }
	});
	
	//
	waf(function(){
		waf.registerComponent("waf.dataImpExp",{
			createDOMFun:function(option){
				return waf("<span id='" + option.id + "'></span>");
			},
			initFun:function(option){
				waf("#" + option.id).dataImpExp(option);
			}
		});
	});
//});
waf.defineClass("waf.webcom.dataImpExp.DataImpExp_LocaleStr_l1",waf.framework.WafCore,{
	DATA_IMPORT_WND_TITLE:"Data Importer",
	DATA_EXPORT_WND_TITLE:"Data Exporter",
	NOT_FOUND_SOLUTION:"solution not found!"
});

waf.defineClass("waf.webcom.dataImpExp.DataImpExp_LocaleStr_l2",waf.framework.WafCore,{
	DATA_IMPORT_WND_TITLE:"" ,
	DATA_EXPORT_WND_TITLE:"",
	NOT_FOUND_SOLUTION:"!"
});

waf.defineClass("waf.webcom.dataImpExp.DataImpExp_LocaleStr_l3",waf.framework.WafCore,{
	DATA_IMPORT_WND_TITLE:"",
	DATA_EXPORT_WND_TITLE:"",
	NOT_FOUND_SOLUTION:""
});
/**
 * 
 */
//mod.defineModule("dataGrid",["waf","grid"],function(){
	(function ($) {
		var formatRowIndex = 0;
	    $.jgrid.extend({
	    	reloadGrid:function(){
				if(this.jqGrid("getGridParam","reloadGridEnabled")==false){}
				else {
					var postData=this.jqGrid("getGridParam","postData");
					this._pingPostData(postData);
					this.trigger("reloadGrid");
				}
	    	},
	    	/* */
			_pingPostData:function(postData){
				if(this.jqGrid("getGridParam","id")!=null){
					postData.componentID=this.jqGrid("getGridParam","id");
				}
				if(this.jqGrid("getGridParam","queryPK")!=null){
					postData.queryPK=this.jqGrid("getGridParam","queryPK");
				}
				if(this.jqGrid("getGridParam","selector")!=null){
					postData.selector=this.jqGrid("getGridParam","selector");
				}
				if(this.jqGrid("getGridParam","botpFilterItems")!=null){
					postData.botpFilterItems=this.jqGrid("getGridParam","botpFilterItems");
				}
				if(this.jqGrid("getGridParam","filterItems")!=null){
					postData.filterItems=this.jqGrid("getGridParam","filterItems");
				}
				if(this.jqGrid("getGridParam","sorterItems")!=null){
					postData.sorterItems=this.jqGrid("getGridParam","sorterItems");
				}
				if(this.jqGrid("getGridParam","includePager")!=null){
					postData.includePager=this.jqGrid("getGridParam","includePager");
				}
				if(this.jqGrid("getGridParam","queryMode")!=null){
					postData.queryMode=this.jqGrid("getGridParam","queryMode");
				}
			},
			/* Excel*/
			exportToExcel:function(isAll,datas,title){
			    var postData=this.jqGrid("getGridParam","postData");
				this._pingPostData(postData);
				postData.isAll = isAll;
				var strColumnModel = "";
				var columns = postData.columnModel.split(",");
				for (var i=0;i<columns.length;i++) {
				    var optionColumn = this.jqGrid("optionColumn",columns[i]);
				    var hidden = optionColumn.hidden,
				        label = optionColumn.label;
				    strColumnModel += columns[i]+","+hidden+","+label+";";
				}
				postData.strColumnModel = strColumnModel;
				var url = waf.getContextPath()+"/component/DataGrid.do?method=exportToExcel";
				url = waf.appendConversationToURL(url);
				$('<form/>').appendTo('body').attr({'id':'exptoExcelform','method':'POST','action':url})
				            .append($('<input/>').attr({'name':'isAll','value':isAll,'type':'hidden'}))
				            .append($('<input/>').attr({'name':'queryPK','value':postData.queryPK,'type':'hidden'}))
				            .append($('<input/>').attr({'name':'ownerUI','value':postData.ownerUI,'type':'hidden'}))
				            .append($('<input/>').attr({'name':'selector','value':postData.selector,'type':'hidden'}))
				            .append($('<input/>').attr({'name':'botpFilterItems','value':postData.botpFilterItems,'type':'hidden'}))
				            .append($('<input/>').attr({'name':'filterItems','value':postData.filterItems,'type':'hidden'}))
				            .append($('<input/>').attr({'name':'sorterItems','value':postData.sorterItems,'type':'hidden'}))
				            .append($('<input/>').attr({'name':'page','value':postData.page,'type':'hidden'}))
				            .append($('<input/>').attr({'name':'rows','value':postData.rows,'type':'hidden'}))
				            .append($('<input/>').attr({'name':'sidx','value':postData.sidx,'type':'hidden'}))
				            .append($('<input/>').attr({'name':'sord','value':postData.sord,'type':'hidden'}))
				            .append($('<input/>').attr({'name':'columnModel','value':waf.encodeURIComponent(postData.strColumnModel),'type':'hidden'}))
				            .append($('<input/>').attr({'name':'title','value':title,'type':'hidden'}))
				            .append($('<input/>').attr({'name':'datas','value':waf.toJSONString(datas),'type':'hidden'}));
				$('#exptoExcelform').submit();
				$('#exptoExcelform').remove();
	    	},
	    	/* */
			hideIncludePager:function(isHide){
			    var postData=this.jqGrid("getGridParam","postData");
				postData.includePager=!isHide;
				this.jqGrid("option","pager",isHide?"":"#pager" + postData.id);
			    this.trigger("reloadGrid");
			}
	    });
	    
	})(jQuery);
	
	$.fn.dataGrid=$.fn.jqGrid;
//});

/**
 * 
 */
//mod.defineModule("dataTree",["waf","tree"],function(){
	(function($){
		$.widget("waf.dataTree",$.ui.wafTree,{
		    zTreeObj: null,
			options:{
				id:null,
				url:null,
				isRootVisible:true,
				rootName:null,
				queryPK:null,
				filterItems:null,
				sorterItems:null,
				gridID:null,
				relationType:"tree",
				relationField:"",
				hasChildren:false,
				selectNode:null,
				afterClick:null
			},
			//
	        nodeList:[],
	        //
	        currentFilter:"",
	        
			getTreeObj:function(){
			    var self = this;
			    return self.zTreeObj;
			},
			
			/*  */
			bindEvent:function(){
			    var self = this;
		    	//onNodeCreated
		    	if (self.option("onNodeCreated")==null) {
		        	self.option("onNodeCreated",function(event, treeId, treeNode) {
		    	        var treeObj = $.fn.zTree.getZTreeObj(treeId);
		    	        self.zTreeObj = treeObj;
		    	        if (treeNode.id == "rootId") {
			               treeObj.selectNode(treeNode);
		                }
		        	});
		        } 
		    	//onClick
		    	if (self.option("onClick")==null) {
			        self.option("onClick",function(event, treeId, treeNode) {
		    	        self.filterAndLoad(treeNode);
			            if(self.options.afterClick!=null) {
		    		       self.options.afterClick(treeId, treeNode);
		    	        };
		        	});
			    }
			    //onAsyncSuccess
		    	if (self.option("onAsyncSuccess")==null) {
		        	self.option("onAsyncSuccess",function(event, treeId, treeNode, msg) {
		        	    if (self.options.selectNode!=null) {
		                    var nodes = self.zTreeObj.getNodes();
		                    if (nodes!=null && nodes.length>0) {
		                        if (nodes.length>1) {
		    	                    for (var i=0;i<nodes.length;i++) {
		    	                        if (nodes[i].id == self.options.selectNode.id) {
			                                self.zTreeObj.selectNode(nodes[i]);
			                                break;
			                            }
			                        }
		                        } else {
		                            if (nodes[0]!=null && nodes[0].children!=null) {
		                                var children = nodes[0].children;
		    	                        for (var i=0;i<children.length;i++) {
		    	                            if (children[i].id == self.options.selectNode.id) {
			                                    self.zTreeObj.selectNode(children[i]);
			                                    break;
			                                }
			                            }
			                        }
			                    }
		                    } 
		                }
		            });
		        } 
			},
			
			filterAndLoad:function(treeNode) {
			    var self = this;
		    	if (treeNode!=null) {
		            self.options.selectNode = treeNode;
		            var filter = "";
		            var async = false;
			        if (self.options.hasChildren && treeNode.isParent) {
			            if (treeNode.id != "rootId") {
			                var currentNode=treeNode;
				        	var nodePath="";
				        	while(currentNode!=null){
				        		if(currentNode.id=="rootId"){
				         			break;
				        		}
				        		if(nodePath=="")
				        			nodePath=currentNode.number;
				        		else
					      			nodePath = currentNode.number + "!" + nodePath;
					
						        currentNode=currentNode.getParentNode();
					     	}
						        	
				         	if(self.options.relationType == "tree") {
				        	    filter += " longnumber like '" + nodePath + "!%' or number = '"+treeNode.number+"'";
				        	} else if (self.options.relationType == "group") {
				        	    var treefilter = " longnumber like '" + nodePath + "!%' or number = '"+treeNode.number+"'";
				        	    async = true;
				        	    waf.doPost(
			                        {url:waf.getContextPath()+"/component/DataTree.do?method=findByCon",
				                     data:{filter:treefilter,
					                       filterItems:self.options.filterItems,
					                       queryPK:self.options.queryPK},
					                 success:function(nodeIds) {
					                     if (nodeIds != null && nodeIds.length > 0) {
				                             filter = self.getRelaField() + " in (";
				                             for (var i=0;i<nodeIds.length;i++) {
				                                 filter += "'"+nodeIds[i]+"',";
				                             }
				                             filter = filter.substring(0,filter.length-1); 
				                             filter += ")"
				                         }
				                         if (self.options.filterItems!=null && self.options.filterItems.length>0) {
			                                 if (filter.length>0) {
			                                     filter = "("+filter+") and ("+self.options.filterItems+")";
			                                 } else {
			                                     filter = self.options.filterItems;
			                                 }
			                             }
			                             self.currentFilter = filter;
			                             self._loadGridList(filter,treeNode.id);
			                         }}
			                     );
			                 }
			            }
		           } else {
	                    if (treeNode.id == "rootId") {
		                    filter += self.getRelaField()+" is null ";
		                } else { 
		                    filter += self.getRelaField()+" = '"+treeNode.id+"' ";
		                    filter += " or " + "id='" + treeNode.id + "' ";
			            }
	               }
	               if (!async) {
	                    if (self.options.filterItems!=null && self.options.filterItems.length>0) {
	                        if (filter.length>0) {
	                            filter = "("+filter+") and ("+self.options.filterItems+")";
			                } else {
			                    filter = self.options.filterItems;
			                }
			            }
			            self.currentFilter = filter;
			            self._loadGridList(filter,treeNode.id);
	                }
			    }
		    },
			
			/*  */
			getRelaField:function() {
			    var relaField = this.options.relationField;
			    if (relaField != null && relaField.length>0) {
			        relaField += ".id";
			    } else {
			        relaField = "parent.id";
			        switch (this.options.relationType) {
			 		    case 'tree' :
		 			    	break;
					    case 'group' :
		                    relaField = "treeid.id";
					    	break;
			    	    }
			    }
			    return relaField;
			},
			
			_loadGridList:function(filter,rowid){
			    var self = this;
			    waf("#"+self.options.gridID).dataGrid("option","filterItems",filter);
			    waf("#"+self.options.gridID).dataGrid("option","page",1);
				waf("#"+self.options.gridID).dataGrid("reloadGrid");
			},
				
			_refreshNode:function(e) {
			    var self = this;
		        var zTree = self.zTreeObj,
		        type = e.type,
		        silent = e.silent,
		        nodes = zTree.getSelectedNodes();
		        if (nodes.length == 0) {
		            return;
		        }
		        for (var i=0, l=nodes.length; i<l; i++) {
		            zTree.reAsyncChildNodes(nodes[i], type, silent);
		            if (!silent) zTree.selectNode(nodes[i]);
		        }
		    },
			
			_loadAllNodes:function(e) {
			    var self = this;
			    var zTree = self.zTreeObj,
		            type = e.type,
		            silent = e.silent;
		        var rootNode = zTree.getNodeByParam("id", "rootId", null);
		        var url = self.options.url;
			    if (url == null || url == "") {
			        url = "/component/DataTree.do?method=getAllTreeData";
			    }
				zTree.setting.async.url=waf.getContextPath()+url;
		        zTree.reAsyncChildNodes(rootNode, type, silent);
		        if (self.options.url == null  || self.options.url == "")
		            zTree.setting.async.url=waf.getContextPath()+"/component/DataTree.do?method=getTreeData";
		    },
		    
		    /*  */
		    expandAll:function(){
			    var self = this;
			    self._loadAllNodes({type:"refresh", silent:false});
			    
			    //
			    var treeObj = self.zTreeObj;
			    var rootNode = treeObj.getNodeByParam("id", "rootId", null);
			    treeObj.selectNode(rootNode);
			    self.options.selectNode = rootNode;
			    
				var filter = "";
			    if (!self.options.hasChildren) {
				    filter += self.getRelaField()+" is null "; 
				} 
			    if (self.options.filterItems!=null && self.options.filterItems.length>0) {
			        if (filter.length>0) {
			            filter = "("+filter+") and ("+self.options.filterItems+")";
			        } else {
			            filter = self.options.filterItems;
			        }
			    }
			    self.currentFilter = filter;
			    self._loadGridList(filter,"rootId");
			},
			
			/*  */
			foldupAll:function(){
				var self = this;
			    var treeObj = self.zTreeObj;
				treeObj.expandAll(false);
				
				//
			    var treeObj = self.zTreeObj;
			    var rootNode = treeObj.getNodeByParam("id", "rootId", null);
			    treeObj.selectNode(rootNode);
			    self.options.selectNode = rootNode;
			    
				var filter = "";
			    if (!self.options.hasChildren) {
				    filter += self.getRelaField()+" is null "; 
				} 
			    if (self.options.filterItems!=null && self.options.filterItems.length>0) {
			        if (filter.length>0) {
			            filter = "("+filter+") and ("+self.options.filterItems+")";
			        } else {
			            filter = self.options.filterItems;
			        }
			    }
			    self.currentFilter = filter;
			    self._loadGridList(filter,"rootId");
			},
			
			/*  */
			reAsyncNode:function(node){
				var self = this;
				var treeObj = self.zTreeObj;
	                         
			    waf.doPost(
				   {url:waf.getContextPath()+"/component/DataTree.do?method=reAsyncNode",
					data:{nodeId:node.id,
					      queryPK:self.options.queryPK},
					success:function(data) {
					     node.id = data.id;
					     node.number = data.number;
					     node.name = data.name;
					     node.isParent = data.isParent;
					     node.propMap = data.propMap;
					     treeObj.updateNode(node);
					     treeObj.reAsyncChildNodes(node,"refresh");
				         treeObj.expandNode(node,true, true, true);
				         treeObj.selectNode(node);
				         self.options.selectNode = node;
					}}
			    );
			},
			
			/*  */
			searchNode:function(val,isFindAll){
				var self = this;
				var treeObj = self.zTreeObj;
	                         
			    for( var i=0, l=self.nodeList.length; i<l; i++) {
			        self.nodeList[i].highlight = false;
			        treeObj.updateNode(self.nodeList[i]);
				}
				
				if (isFindAll) {
				    waf.doPost(
				       {url:waf.getContextPath()+"/component/DataTree.do?method=findByName",
				    	data:{con:val,
					          queryPK:self.options.queryPK},
					    success:function(data) {
					        if (data!=null&&data.length>0) {
					            for (var i=0;i<data.length;i++) {
					                self.nodeList[i] = data[i].node;
					                //
					                var alNode =treeObj.getNodesByParam("id",data[i].node.id);
					                if (alNode==null || alNode.length==0) {
					                    var parent = data[i].parent;
					                    for (var j=0;j<parent.length;j++) {
		                                    //
					                        var pNode =treeObj.getNodesByParam("id",parent[j].id);
					                        if (pNode!=null && pNode.length>0) {
					                            //
					                            treeObj.reAsyncChildNodes(pNode[0]);
					                            treeObj.expandNode(pNode[0],true, true, true);
					                        }
					                    }
					                }
					            }
					        }
			    		}}
			        );
				} else {
	    		    self.nodeList = treeObj.getNodesByParamFuzzy("name",val);
	    		}
				for( var i=0, l=self.nodeList.length; i<l; i++) {
					self.nodeList[i].highlight = true;
					treeObj.updateNode(self.nodeList[i]);
					//level1
					if (self.nodeList[i].level>1) {
					    var parentNode = self.nodeList[i].getParentNode();
					    while(parentNode.level > 1) {
					        //
					        treeObj.expandNode(parentNode,true, false, true);
					        parentNode = parentNode.getParentNode();
					    }
					}
				}
				//
				if(self.nodeList.length>0) {
				    var treeNode = self.nodeList[0];
				    self.options.selectNode = treeNode;
				    treeObj.selectNode(treeNode);
				    var filter = "";
				    var async = false;
					if (self.options.hasChildren && treeNode.isParent) {
					    if (treeNode.id != "rootId") {
					        var currentNode=treeNode;
						    var nodePath="";
						    while(currentNode!=null){
						        if(currentNode.id=="rootId"){
						         	break;
						        }
						        if(nodePath=="")
						        	nodePath=currentNode.number;
						        else
						        	nodePath = currentNode.number + "!" + nodePath;
					
						    	currentNode=currentNode.getParentNode();
						    }
						    if(self.options.relationType == "tree") {
					            filter += " longnumber like '" + nodePath + "!%' or number = '"+treeNode.number+"'";
					        } else if (self.options.relationType == "group") {
						        var treefilter = " longnumber like '" + nodePath + "!%' or number = '"+treeNode.number+"'";
						        async = true;
						        waf.doPost(
				                    {url:waf.getContextPath()+"/component/DataTree.do?method=findByCon",
					                 data:{filter:treefilter,
					                 filterItems:self.options.filterItems,
					                 queryPK:self.options.queryPK},
					                 success:function(nodeIds) {
					                     if (nodeIds != null && nodeIds.length > 0) {
				                             filter = self.getRelaField() + " in (";
				                             for (var i=0;i<nodeIds.length;i++) {
				                                 filter += "'"+nodeIds[i]+"',";
				                             }
				                             filter = filter.substring(0,filter.length-1); 
				                             filter += ")"
				                         }
				                         if (self.options.filterItems!=null && self.options.filterItems.length>0) {
			                                 if (filter.length>0) {
			                                     filter = "("+filter+") and ("+self.options.filterItems+")";
			                                 } else {
			                                     filter = self.options.filterItems;
			                                 }
			                             }
			                             self.currentFilter = filter;
			                             self._loadGridList(filter,treeNode.id);
					                 }}
			                     );
					         }
					    }
				    } else {
				        if (treeNode.id == "rootId") {
			                filter += self.getRelaField()+" is null ";
			            } else { 
			                filter += self.getRelaField()+" = '"+treeNode.id+"' ";
			                filter += " or " + "id='" + treeNode.id + "' ";
			            }
			        }
			        
			        if (!async) {
			            if (self.options.filterItems!=null && self.options.filterItems.length>0) {
			                if (filter.length>0) {
			                    filter = "("+filter+") and ("+self.options.filterItems+")";
			                } else {
			                    filter = self.options.filterItems;
			                }
			            }
			            self.currentFilter = filter;
			            self._loadGridList(filter,treeNode.id);
			        }
			    }
			},
			
			/*  */
			getCurrentFilter:function(){
			    return this.currentFilter;
			},
			/*  */
			setCurrentFilter:function(filter){
			    return this.currentFilter = filter;
			},
			
			_setOption:function (key, value) {
			    var self=this;
	            if (value === undefined) {
	                return;
	            }
	            if (key == "queryPK" || key == "filterItems" || key == "sorterItems"
	                || key == "isRootVisible" || key == "rootName" || key == "allNodes") {
	                self.zTreeObj.setting.async.otherParam[key]=value;
	                key = "otherParam",
	                value = self.zTreeObj.setting.async.otherParam;
	            } 
	            
	            $.ui.wafTree.prototype._setOption.apply(this, arguments);
	        }
		});
	})(jQuery);
//});
/**
 * 
 */
$.widget("waf.fastQuery",$.waf.WebComponent,{
	options:{
		id:null,
		url:null,
		queryPK:null,
		grid:null,
		columnCaption:"",
		columnModel:"",
		dateField:""
	},
	searchKey:null,
	localeStr:null,
	defText:"",
	defaultValue:"",
	solutionList:null,
	defaultSolu:null,
	searchList:null,
	selectQuery:null,
	filters:null,
	filterAlias:null,
	selectClass:"ui-querySelect",
	typeClass:"ui-queryType",
	itemClass:"ui-queryItem",
	position:{my:"left top",
              at:"left bottom"},
	
	/*  */
	_create:function(){
	    var self = this,
	        suppressKeyPress;
	        
	    self.localeStr = self.getLocaleResourceObject("waf.webcom.fastquery.fastQuery");
	    
	    if (self.options.queryPK == null || self.options.queryPK == "" || self.options.queryPK == "null") {
            waf.msgBox.showError(self.localeStr.PARAM_QUERYPK_ERROR);
            return;
        } 
        if (self.options.grid == null || self.options.grid.length <= 0) {
            waf.msgBox.showError(self.localeStr.PARAM_GRIDID_ERROR);
            return;
        } 
    	    
    	self.searchKey = self.options.queryPK+"_"+waf.getContext().currentUserName+"_"+waf.getContext().currentCompanyID+"_"+"search";
	    self.defText = self.localeStr.DEFAULT;
    	self.defaultValue=self.localeStr.INUT+self.options.columnCaption+self.localeStr.SEARCH;
    	waf("#" + self.options.id + "_text").attr("placeholder",self.defaultValue);
		
    	waf("#" + self.options.id + "_text").wafText("option", "onclick", function(e){
            self._open();
        });
        waf("#" + self.options.id + "_text").wafText("option", "onkeyup", function(e){
            var keyCode = $.ui.keyCode;
            if(e.keyCode==keyCode.UP 
                || e.keyCode==keyCode.DOWN
                || e.keyCode==keyCode.ENTER
                || e.keyCode==keyCode.NUMPAD_ENTER ) 
                return;
            if(self.$select){
                self._addSearchFilter(e);
                e.preventDefault();
            }
        });
        
        waf.doPost(
    		{url:self.options.url+"?method=initalize",
    		 data:{queryPK:self.options.queryPK},
    		 success:function(data) {
			     if (data !=null) {
				     self.solutionList = data.solutionList;
				     self.defaultSolu = data.defaultSolu;
				 }
    		}}
    	);
	    
    	self._enter2tab();
	    
    	self.element.bind("keydown.fastQuery", function(e){
            var keyCode = $.ui.keyCode;
            suppressKeyPress = false;
            switch( e.keyCode ) {
                case keyCode.BACKSPACE:
                    self._deleteFilter(e);
                    break;
                case keyCode.UP:
                    if(self.$select){
                        self._previous(e);
                        e.preventDefault();
                    }
                    break;
                case keyCode.DOWN:
                    if(self.$select){
                        self._next(e);
                    }else{
                        self._open();
                    }
                    e.preventDefault();
                    break;
                case keyCode.ENTER:
                case keyCode.NUMPAD_ENTER:
                    if(self.$select){
                        if ( self.active ) {
                            suppressKeyPress = true;
                            self._select(e);
                        }
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    break;
                case keyCode.ESCAPE:
                case keyCode.TAB:
                    if(self.$select){
                        self._close();
                    }
                    break;
                default:
                    break;
            }
        }).bind( "keypress.fastQuery", function(e) {
            if ( suppressKeyPress ) {
                suppressKeyPress = false;
                e.preventDefault();
            }
        });
	},
	
	_open: function(){
        var self = this,
            doc = this.element[0].ownerDocument;

        if (self.$select == null)
            self._createQuerySelect();
        self.$select.appendTo($(".page_margins .page")[0] || "body")
            .css('top', 0)
            .css('left', 0)
            .width(self.element.width()-2)
            .zIndex(self.element.zIndex())
            .bind("click.fastQuery", function(e) {
                if (!$(e.target).closest("." + self.itemClass + " a").length)  return;
                e.preventDefault();
                self._select( e );
            })
            .hide();
            
        if (self.selectQuery != null) {
            waf("#"+self.options.id+"_sel_"+self.selectQuery).css("visibility","visible");
        }

        self.$select.find("a").hover(function(e){
            self._activate( e, $(this).parent() );
        }, function(e){
            self._deactivate();
        });
        
        self.$select.show().position($.extend({of: self.element}, self.position));
        
        $(doc).bind("mousedown.fastQuery", function(e){
            var $target = $(e.target);
            if($target.closest(self.$select).length == 0 && $target.closest(self.element).length == 0){
                self._close();
            }
        });
    },
    
	_createQuerySelect : function(){
	    var self = this;
        self.$select = $('<div id="'+self.options.id+'_querySelect" class="' + self.selectClass + ' ui-widget ui-widget-content ui-corner-all"></div>');
        //query
        self.$ul_searchFilter = $('<ul id="'+self.options.id+'_searchFilter" class="'+self.typeClass+' ui-corner-all"></ul>').appendTo(self.$select);
        self.$ul_recentBill = $('<ul id="'+self.options.id+'_recentBill" class="'+self.typeClass+' ui-corner-all">'+self.localeStr.RECENTBILL+'</ul>').appendTo(self.$select);
        self.$ul_mySolution = $('<ul id="'+self.options.id+'_mySolution" class="'+self.typeClass+' ui-corner-all">'+self.localeStr.MYSOLUTION+'</ul>').appendTo(self.$select);
        self.$ul_recentSearch = $('<ul id="'+self.options.id+'_recentSearch" class="'+self.typeClass+' ui-corner-all">'+self.localeStr.RECENTSEARCH+'</ul>').appendTo(self.$select);
        
        //
        var value = waf("#" + this.options.id + "_text").wafText("getValue");
	    if (value != null && value.length>0) {
	        $('<li id="'+self.options.id+'_filter_all" realfilter="'+self._getFilterAll(value)+'" class="'+self.itemClass+' ui-corner-all"></li>')
                    .append($('<a>'+self.localeStr.ALL+' '+self.localeStr.LIKE+' '+value+'</a>'))
                    .appendTo(self.$ul_searchFilter);
            for(var i = 0, length = self.filters.length; i < length; i++){
                $('<li id="'+self.options.id+'_filter_'+self.filters[i]+'_'+value+'" realfilter="'+self._getFilter(self.filters[i],value)+'" class="'+self.itemClass+' ui-corner-all"></li>')
                    .append($('<a>'+self.filterAlias[i]+' '+self.localeStr.LIKE+' '+value+'</a>'))
                    .appendTo(self.$ul_searchFilter);
            }
        }
        //
        $('<li id="'+self.options.id+'_recentOneWeek" class="'+self.itemClass+' ui-corner-all"></li>')
            .append($('<a>'+self.localeStr.RECENTONEWEEK+'</a>').prepend($('<span id="'+self.options.id+'_sel_recentOneWeek" class="btn-select"></span>')))
            .appendTo(self.$ul_recentBill);
        $('<li id="'+self.options.id+'_recentOneMonth" class="'+self.itemClass+' ui-corner-all"></li>')
            .append($('<a>'+self.localeStr.RECENTONEMONTH+'</a>').prepend($('<span id="'+self.options.id+'_sel_recentOneMonth" class="btn-select"></span>')))
            .appendTo(self.$ul_recentBill);
        $('<li id="'+self.options.id+'_recentThreeMonth" class="'+self.itemClass+' ui-corner-all"></li>')
            .append($('<a>'+self.localeStr.RECENTTHREEMONTH+'</a>').prepend($('<span id="'+self.options.id+'_sel_recentThreeMonth" class="btn-select"></span>')))
            .appendTo(self.$ul_recentBill);
        //
        if (self.solutionList !=null) {
            for(var i = 0, length = self.solutionList.length; i < length; i++){
                var solutionId = self.solutionList[i].id,
                    solutionName = self.solutionList[i].name;
                if (self.defaultSolu !=null && self.defaultSolu.id == solutionId) 
                    solutionName += self.localeStr.DEFAULT;
                $('<li id="'+self.options.id+'_solu_'+i+'" solutionId="'+solutionId+'" class="'+self.itemClass+' ui-corner-all"></li>')
                    .append($('<a>'+solutionName+'</a>').prepend($('<span id="'+self.options.id+'_sel_solu_'+i+'" class="btn-select"></span>')))
                    .appendTo(self.$ul_mySolution);
            }
        }
        //    
        if (localStorage.length>0) {
            for(var i = 1; i < 4; i++){
                var filter = localStorage.getItem(self.searchKey+"Filter"+i),
                    display = localStorage.getItem(self.searchKey+"Display"+i);
                if (filter!=null && display!=null)
                    $('<li id="'+self.options.id+'_search_'+i+'" realfilter="'+filter+'" class="'+self.itemClass+' ui-corner-all"></li>')
                        .append($('<a>'+display+'</a>').prepend($('<span id="'+self.options.id+'_sel_search_'+i+'" class="btn-select"></span>')))
                        .appendTo(self.$ul_recentSearch);
            }
        }
    },
    
    _addSearchFilter : function(event){
	    var self = this;
	    self.filters = self.options.columnModel.split(",");
	    self.filterAlias = self.options.columnCaption.split(",");
	    self.$ul_searchFilter.find("li").remove(); 
    	var value = event.target.value;
	    if (value != null && value.length>0) {
	        $('<li id="'+self.options.id+'_filter_all" realfilter="'+self._getFilterAll(value)+'" class="'+self.itemClass+' ui-corner-all"></li>')
//                    .append($('<a></a>').append($('<p class="filter-input">'+self.localeStr.ALL+'</p>')).append($('<p class="filter-like">'+self.localeStr.LIKE+'</p>')).append($('<p class="filter-input">'+value+'</p>')))
                    .append($('<a>'+self.localeStr.ALL+' '+self.localeStr.LIKE+' '+value+'</a>'))
                    .appendTo(self.$ul_searchFilter);
            for(var i = 0, length = self.filters.length; i < length; i++){
                $('<li id="'+self.options.id+'_filter_'+self.filters[i]+'_'+value+'" realfilter="'+self._getFilter(self.filters[i],value)+'" class="'+self.itemClass+' ui-corner-all"></li>')
//                    .append($('<a>'+' '+self.localeStr.LIKE+' '+'</a>').prepend($('<span class="filter-input">'+self.filterAlias[i]+'</span>').css("font-weight","bold")).append($('<span class="filter-input">'+value+'</span>').css("font-weight","bold")))
                    .append($('<a>'+self.filterAlias[i]+' '+self.localeStr.LIKE+' '+value+'</a>'))
                    .appendTo(self.$ul_searchFilter);
            }
           
            self.$ul_searchFilter.find("a").hover(function(e){
                self._activate( e, $(this).parent() );
            }, function(e){
                self._deactivate();
            });
        }
    },
    
    _getFilterAll: function(value){
        var self = this,
            filterAll = "";
        for(var i = 0, length = self.filters.length; i < length; i++){
            filterAll += self.filters[i]+" like '%"+value+"%'";
            if (i < length-1) 
                filterAll += " or ";
        }
        return "("+filterAll+")";
    },
    
    _getFilter: function(filter,value){
        return filter+" like '%"+value+"%'";
    },
    
    _select: function(e) {
        var self = this;
        var id,
            parent,
            innerHTML,
            searchFilter,
            solutionId,
            recentBill;
        if (e.type == "click") {
            id = e.target.parentNode.parentNode.id;
            parent = e.target.parentNode;
            innerHTML = e.target.innerHTML;
        } else if (e.type == "keydown") {
            id = self.active.parent().attr('id');
            parent = self.active[0];
            innerHTML = self.active[0].children[0].innerHTML;
        }
        
        if (id == self.options.id+"_mySolution") {
            solutionId = parent.attributes.solutionId.value;
            var parId = parent.id;
            self.selectQuery = parId.substring(self.options.id.length+1,parId.length);
            waf("#" + self.options.id + "_queryFilter").empty();
        } else if (id == self.options.id+"_recentBill") {
            var parId = parent.id;
            recentBill = parId.substring(self.options.id.length+1,parId.length);
            self.selectQuery = recentBill;
            waf("#" + self.options.id + "_queryFilter").empty();
        } else if (id == self.options.id+"_recentSearch") {
            searchFilter = parent.attributes.realfilter.value;
            var parId = parent.id;
            self.selectQuery = parId.substring(self.options.id.length+1,parId.length);
            waf("#" + self.options.id + "_queryFilter").empty();
        }
        else if (id == self.options.id+"_searchFilter") {
            searchFilter = parent.attributes.realfilter.value;
            var parId = parent.id;
            var filterId = parId.substring(self.options.id.length+1,parId.length);
            self.selectQuery = null;
            $('<span id="'+self.options.id+'_select_'+filterId+'" realfilter="'+searchFilter+'">'+innerHTML+'</span>').appendTo(waf("#" + self.options.id + "_queryFilter"));
            $('<span id="'+self.options.id+'_del_'+filterId+'" class="btn-del"></span>').click(function(e) {
                    var idattr = this.id.substring(self.options.id.length+5,this.id.length);
	                waf("#"+self.options.id+"_del_"+idattr).remove();
	                waf("#"+self.options.id+"_select_"+idattr).remove();
	                var spans = waf("#" + self.options.id + "_queryFilter").children("span");
                    if (spans.length/2<=0){
	                    waf("#" + self.options.id + "_text").attr("placeholder",self.defaultValue);
	                }
			})
			.appendTo(waf("#" + self.options.id + "_queryFilter"));
			searchFilter = self._saveRecentSearch();
            waf("#" + self.options.id + "_text").wafText("setValue",null);
            waf("#" + self.options.id + "_text").attr("placeholder",null);
        }
        //
        self._close();
        //
        waf.doPost(
		   {url:self.options.url+"?method=getCurrentFilter",
			data:{queryPK:self.options.queryPK,
			      dateField:self.options.dateField,
			      solutionId:solutionId,
			      recentBill:recentBill,
			      searchFilter:searchFilter},
			success:function(data) {
			    self.options.grid.dataGrid("option","filterItems",data.filter);
			    self.options.grid.dataGrid("option","sorterItems",data.sorter);
			    self.options.grid.dataGrid("option","page",1);
		        self.options.grid.dataGrid("reloadGrid");
			}}
	    );
    },
    
    _saveRecentSearch: function(){
        var self = this,
            searchFilter = "",
            searchDisplay = "";
        var spans = waf("#" + self.options.id + "_queryFilter").children("span"),
            strExist = "";
        for (var i=0,length=spans.length;i<length;i++) {
            if (spans[i].id.indexOf("select_filter_")>=0) {
                searchFilter += spans[i].attributes.realfilter.value + " and ";
                searchDisplay += spans[i].innerHTML + self.localeStr.AND;
            }
        }
        if (searchFilter.length>0) {
            searchFilter = searchFilter.substring(0,searchFilter.length-5);
            searchDisplay = searchDisplay.substring(0,searchDisplay.length-4);
        }
            
        //3
        var arr = new Array();
        for (var i=0,length=localStorage.length;i<length;i++) {
            if (localStorage.key(i).indexOf(self.searchKey+"Filter")>=0) {
                arr.push(localStorage.key(i));
            }
        }
        if (arr.length<3) {
            localStorage.setItem(self.searchKey+"Filter"+(arr.length+1), searchFilter);  
            localStorage.setItem(self.searchKey+"Display"+(arr.length+1), searchDisplay);
        } else {
            var filter2 = localStorage.getItem(self.searchKey+"Filter2"),
                display2 = localStorage.getItem(self.searchKey+"Display2"),
                filter3 = localStorage.getItem(self.searchKey+"Filter3"),
                display3 = localStorage.getItem(self.searchKey+"Display3");
            localStorage.setItem(self.searchKey+"Filter1", filter2);  
            localStorage.setItem(self.searchKey+"Display1", display2);
            localStorage.setItem(self.searchKey+"Filter2", filter3);  
            localStorage.setItem(self.searchKey+"Display2", display3);
            
            localStorage.setItem(self.searchKey+"Filter3", searchFilter);  
            localStorage.setItem(self.searchKey+"Display3", searchDisplay);
        } 
        return searchFilter;
    },
    
    _deleteFilter: function(e){
        var self = this,
            $target = $(e.target);
        if ($target[0].id == self.options.id+"_text") {
            var value = waf("#" + this.options.id + "_text").wafText("getValue");
            if (value=="") {
                var spans = waf("#" + self.options.id + "_queryFilter").children("span");
                if (spans.length/2>0){
                    waf(spans[spans.length-1]).remove();
	                waf(spans[spans.length-2]).remove();
	            } 
	            spans = waf("#" + self.options.id + "_queryFilter").children("span");
	            if (spans.length/2<=0){
	                waf("#" + self.options.id + "_text").attr("placeholder",self.defaultValue);
	            }
	            e.preventDefault();
            }
        }
    },
    
    _close: function(){
        var doc = this.element[0].ownerDocument;
        $(doc).unbind("mousedown.fastQuery");
        if (this.$select!=null) {
            this.$select.remove();
            this.$select = null;
        }
        this.active = null;
    },
    
    _enter2tab : function(){
        if($.fn.enter2tab){
            this.element.enter2tab();
        }
    },
    
    _next: function(e) {
        var self = this;
        if (!self.active) {
            self._activate(e, $(".ui-queryItem:first", self.$select));
            return;
        }
        var next = self.active["nextAll"](".ui-queryItem").eq(0);
        if (next.length) {
            self._activate(e, next);
        } else if (self.active.parent().attr('id')==self.options.id+"_searchFilter"){
            next = $("#"+self.options.id+"_recentBill li").eq(0);
            if (next.length>0)
                self._activate(e, next);
        } else if (self.active.parent().attr('id')==self.options.id+"_recentBill"){
            next = $("#"+self.options.id+"_mySolution li").eq(0);
            if (next.length>0)
                self._activate(e, next);
        } else if (self.active.parent().attr('id')==self.options.id+"_mySolution"){
            next = $("#"+self.options.id+"_recentSearch li").eq(0);
            if (next.length>0)
                self._activate(e, next);
        }
    },

    _previous: function(e) {
        var self = this;
        if (!self.active) {
            self._activate(e, $(".ui-queryItem:last", self.$select));
            return;
        }
        var next = self.active["prevAll"](".ui-queryItem").eq(0);
        if (next.length) {
            self._activate(e, next);
        } else if (self.active.parent().attr('id')==self.options.id+"_recentSearch"){
            next = $("#"+self.options.id+"_mySolution li:last-child");
            if (next.length>0)
                self._activate(e, next);
        } else if (self.active.parent().attr('id')==self.options.id+"_mySolution"){
            next = $("#"+self.options.id+"_recentBill li:last-child");
            if (next.length>0)
                self._activate(e, next);
        } else if (self.active.parent().attr('id')==self.options.id+"_recentBill"){
            next = $("#"+self.options.id+"_searchFilter li:last-child");
            if (next.length>0)
                self._activate(e, next);
        } 
    },

    _activate: function(e, activeItem){
        this._deactivate();
        this.active = activeItem.eq(0)
                .children("a")
                .addClass("ui-state-hover")
                .end();
    },

    _deactivate: function(){
        if (!this.active) { return; }
        this.active.children("a").removeClass("ui-state-hover");
        this.active = null;
    }
});

//
waf(function(){
	waf.registerComponent("waf.fastQuery",{
		createDOMFun:function(option){
		    //div
		    var div = waf("<div id='" + option.id + "' class='ui-query-frame' style='" + option.style + "'></div>");
		    //divLayout
		    var divLayout = waf("<div id='" + option.id + "_queryLayout' class='ui-query-layout'></div>");
		    divLayout.css("width",option.width==null?300:option.width);
		    waf.appendDOM(div, divLayout);
		    //divIcon
		    var divIcon = waf("<div id='" + option.id + "_queryIcon' class='ui-query-icon'></div>");
		    waf.appendDOM(divLayout, divIcon);
		    //span
		    var span = waf("<span id='" + option.id + "_queryBtn' class='btn-search'></span>");
		    waf.appendDOM(divIcon, span);
		    //divFilter
		    var divFilter = waf("<div id='" + option.id + "_queryFilter' class='ui-query-filter'></div>");
		    waf.appendDOM(divLayout, divFilter);
		    //divInput
		    var divInput = waf("<div id='" + option.id + "_queryInput' class='ui-query-input'></div>");
		    waf.appendDOM(divLayout, divInput);
		    //text
		    var txtOps = {id:option.id+"_text", name:option.id+"_filter", 
		                  value:option.value, width:"100%", tagClass:"ui-query"};
            var textDom = waf.createDOM("text", txtOps);
            waf.initComponent("text", txtOps, textDom);
            waf.appendDOM(divInput, textDom);
		    
			return div;
		},
		initFun:function(option){
		    var localeStr = waf.createObject(eval("waf.webcom.fastquery.fastQuery" + "_LocaleStr_" + waf.getContext().locale.toLowerCase()));
            if (option.queryPK == null) {
		        waf.msgBox.showError(localeStr.PARAM_QUERYPK_ERROR);
                return;
            }
            if (option.gridID == null) {
                waf.msgBox.showError(localeStr.PARAM_GRIDID_ERROR);
                return;
            }
            option.grid = waf("#"+option.gridID); 
            option.url = waf.getContextPath()+"/component/FastQuery.do"; 
            if(option.dateField == null) option.dateField = "bizDate";
	        if(option.columnModel == null) option.columnModel = "number";
	        if(option.columnCaption == null) option.columnCaption = localeStr.COLUMNCAPTION;
    		
    	    waf("#" + option.id).fastQuery(option);
		}
	});
});
waf.defineClass("waf.webcom.fastquery.fastQuery_LocaleStr_l1",waf.framework.WafCore,{
	INUT:"Please enter ",
	SEARCH:" to make a query",
	DEFAULT:"(Default)",
	RECENTBILL:"Recent Bill",
	MYSOLUTION:"My Solution",
	RECENTSEARCH:"Recent Search",
	RECENTONEWEEK:"Recent One Week",
	RECENTONEMONTH:"Recent One Month",
	RECENTTHREEMONTH:"Recent Three Month",
	ALL:"All",
	LIKE:"Like",
	AND:" And ",
	PARAM_QUERYPK_ERROR:"Please set the queryPK parameter for web compomnent fastQuery to determine the data source.",
	PARAM_GRIDID_ERROR:"Please set the gridID parameter for web compomnent fastQuery to determine the grid to show data.",
	COLUMNCAPTION:"Number"
});

waf.defineClass("waf.webcom.fastquery.fastQuery_LocaleStr_l2",waf.framework.WafCore,{
	INUT:"",
	SEARCH:"",
	DEFAULT:"()",
	RECENTBILL:"",
	MYSOLUTION:"",
	RECENTSEARCH:"",
	RECENTONEWEEK:"",
	RECENTONEMONTH:"",
	RECENTTHREEMONTH:"",
	ALL:"",
	LIKE:"",
	AND:"  ",
	PARAM_QUERYPK_ERROR:"queryPK.",
	PARAM_GRIDID_ERROR:"gridID.",
	COLUMNCAPTION:""
});

waf.defineClass("waf.webcom.fastquery.fastQuery_LocaleStr_l3",waf.framework.WafCore,{
	INUT:"",
	SEARCH:"",
	DEFAULT:"()",
	RECENTBILL:"",
	MYSOLUTION:"",
	RECENTSEARCH:"",
	RECENTONEWEEK:"",
	RECENTONEMONTH:"",
	RECENTTHREEMONTH:"",
	ALL:"",
	LIKE:"",
	AND:"  ",
	PARAM_QUERYPK_ERROR:"queryPK.",
	PARAM_GRIDID_ERROR:"gridID.",
	COLUMNCAPTION:""
});

/**
 * 
 */
$.widget("waf.groupFilter",$.waf.WebComponent,{
	options:{
		id:null,
		url:null,
		businessObject:null,
		viewCtrlType:"dataView",
		viewCtrlId:null,
		filterFields:null
	},
	localeStr:null,
	fieldMap:null,
	filterMap:null,
	curfilterMap:null,
	
	/*  */
	_create:function(){
	    var self = this;
	    self.localeStr = self.getLocaleResourceObject("waf.webcom.groupfilter.groupFilter");
	    
	    if (self.options.businessObject == null || self.options.businessObject == "" || self.options.businessObject == "null") {
            waf.msgBox.showError(self.localeStr.PARAM_OBJECT_ERROR);
            return;
        }
        if (self.options.filterFields == null || self.options.filterFields.length <= 0) {
            waf.msgBox.showError(self.localeStr.PARAM_FIELD_ERROR);
            return;
        } 
        if (self.options.viewCtrlId == null || self.options.viewCtrlId.length <= 0) {
            waf.msgBox.showError(self.localeStr.PARAM_CTRLID_ERROR);
            return;
        }
        self.filterMap = new Map();
        self.curfilterMap = new Map();
        self.fieldMap = new Map();
        for (var i=0;i<self.options.filterFields.length;i++) {
            var filterField = self.options.filterFields[i];
            self.fieldMap.put(filterField.field,filterField);
        }
            
        waf.doPost(
    	    {url:self.options.url+"?method=initalize",
    		 data:{businessObject:self.options.businessObject,
    			   filterField:self.fieldMap.keys().toString()},
    		 success:function(data) {
    		     if (data !=null && data.length>0) {
    		         self._createFacets();
		 	         for (var i=0;i<data.length;i++) {
		 	             var fieldObj = self.fieldMap.get(data[i].field);
		 	             var items = fieldObj.filterItems;
		 	             if (items == null)
		 	                 items = data[i].filterItems;
     			         if (items != null) {
    		 	             //toolbar
            			     var toolbar = self._addBar(data[i].field);
            			     //title
            			     var title = fieldObj.title;
		 	                 if (title == null)
		 	                     title = data[i].title;
        			         self._addTitle(toolbar,title);
        			         //btnAll
        			         if (fieldObj.needAll) {
        			             self._addBtnAll(toolbar,data[i].field,data[i].dataType,data[i].title,items,fieldObj.miltiSelect);
        			             //vsplitbtn
                                 self._addVSplit(toolbar);
        			         } 
	        		         for (var j=0;j<items.length;j++) {
	        		             self._addBtnGen(toolbar,data[i].field,data[i].dataType,items[j],fieldObj.miltiSelect);
                                 //vsplitbtn
                                 if (j<items.length-1) 
                                     self._addVSplit(toolbar);
                             }
                             if (data[i].dataType == "Date" || data[i].dataType == "Timestamp" || data[i].dataType == "ObjectValue") {
                                 self._addMore(toolbar,data[i].field,data[i].dataType,data[i].promptQuery,fieldObj.miltiSelect);
                             }
                         }
                     }
			     }
			 }
    	});
		
		//
		self._viewCtrlBindEvent();
		
		//        
        waf(".choosing").find(".filterchoose a").live("click",function(e){
		    var idstr = this.parentNode.id.substring(7,this.parentNode.id.length);
		    var strs = idstr.split("_");
		    waf(this).parent().remove();
		    if (strs[1]=="apply") {
    		    if (waf("#"+self.options.id+"_"+strs[0]+"_From").length>0) {
                    waf("#"+self.options.id+"_"+strs[0]+"_From").wafDatePicker("setValue",null);
                    waf("#"+self.options.id+"_"+strs[0]+"_To").wafDatePicker("setValue",null);
                }
                if (waf("#"+self.options.id+"_"+strs[0]+"_promptBox").length>0) {
                    waf("#"+self.options.id+"_"+strs[0]+"_promptBox").wafPromptBox("setValue",null);
                }
    	    } else {
        	    var btnId = self.options.id+"_btn_"+idstr;
        	    waf("#"+btnId).wafLinkButton("option","tagClass","group");
    	    }
            var filData = self.curfilterMap.get(strs[0]);
            filData.remove(strs[1]);
            self.curfilterMap.put(strs[0],filData);
            
            self.doFilter();
            
            if (waf(".choosing").find(".filterchoose").length>0) {
                waf("#"+self.options.id+"_text").show();
                waf("#"+self.options.id+"_clear").show();
            } else {
                waf("#"+self.options.id+"_text").hide();
                waf("#"+self.options.id+"_clear").hide();
            }
	    });	
	    
	    waf("#"+self.options.id+"_clear").live("click",function(e){
	        waf(this).parent().parent().find(".filterchoose").each(function(index){
    		    var idstr = this.id.substring(7,this.id.length);
    		    var strs = idstr.split("_");
    		    waf(this).remove();
    		    if (strs[1]=="apply") {
    		        if (waf("#"+self.options.id+"_"+strs[0]+"_From").length>0) {
                        waf("#"+self.options.id+"_"+strs[0]+"_From").wafDatePicker("setValue",null);
                        waf("#"+self.options.id+"_"+strs[0]+"_To").wafDatePicker("setValue",null);
                    }
    		        if (waf("#"+self.options.id+"_"+strs[0]+"_promptBox").length>0) {
                        waf("#"+self.options.id+"_"+strs[0]+"_promptBox").wafPromptBox("setValue",null);
                    }
    		    } else {
        		    var btnId = self.options.id+"_btn_"+idstr;
        		    waf("#"+btnId).wafLinkButton("option","tagClass","group");
    		    }
                var filData = self.curfilterMap.get(strs[0]);
                filData.remove(strs[1]);
                self.curfilterMap.put(strs[0],filData);
            });
            self.doFilter();
            
            waf("#"+self.options.id+"_text").hide();
            waf("#"+self.options.id+"_clear").hide();
	    });	
	},

    _addBar : function(field) {
        var self = this;
        //toolbar
	    var toolBarOpts = {id:self.options.id+"_bar_"+field,tagClass:"groupbar"};
	    var toolbar = waf.createDOM("toolBar", toolBarOpts);
        waf.appendDOM(self.element, toolbar);
        waf.initComponent("toolBar", toolBarOpts, toolbar);
        return toolbar;
    },
    
    _addBtnAll : function(toolbar,field,dataType,title,items,isMulti) {
        var self = this;
        //btnAll
    	var btnAllOpts = {id:self.options.id+"_btn_"+field+"_"+"all",caption:self.localeStr.ALL+"(10)",tagClass:"group blue"};
  	    var btnAll = waf.createDOM("linkButton", btnAllOpts);
        toolbar.wafToolBar('appendChildren', btnAll);
        waf.initComponent("linkButton", btnAllOpts, btnAll);
        toolbar.wafToolBar('showMore');
        btnAll.wafLinkButton("option","onclick",function(e) {
            var target = e.target;
            var tagClass = waf(target).wafLinkButton("option","tagClass");
            if (isMulti) {
                if (tagClass == "group") {
                    waf(target).wafLinkButton("option","tagClass","group blue");
                    var filData = self.curfilterMap.get(field);
                    var filter = self._getAllFilter(field,dataType,items);
                    filData.put("all",filter);
                    self.curfilterMap.put(field,filData);
                    self._addChoose(field,"all",title+self.localeStr.ALL);
                } else {
                    waf(target).wafLinkButton("option","tagClass","group");
                    var filData = self.curfilterMap.get(field);
                    filData.remove("all");
                    self.curfilterMap.put(field,filData);
                    self._removeChoose(field,"all",isMulti);
                }
            } else {
                if (tagClass == "group") {
                    waf("#"+self.options.id+"_bar_"+field+" .group.blue").each(function(index){
                        var id = waf(this).attr("id");
                        if (id.indexOf(self.options.id+"_apply_")<0) {
                            waf(this).wafLinkButton("option","tagClass","group");
                            var filData = self.curfilterMap.get(field);
                            var key = self.options.id+"_btn_"+field+"_";
                            filData.remove(id.substring(key.length,id.length));
                            self.curfilterMap.put(field,filData);
                        }
                    });
                    waf(target).wafLinkButton("option","tagClass","group blue");
                    var filData = self.curfilterMap.get(field);
                    var filter = self._getAllFilter(field,dataType,items);
                    filData.put("all",filter);
                    self.curfilterMap.put(field,filData);
                    self._addChoose(field,"all",title+self.localeStr.ALL);
                    self._removeChoose(field,"all",isMulti);
                } else {
                    return;
                }
            }
            self.doFilter();
        });
        //
        var filter = self._getAllFilter(field,dataType,items);
        var filData = self.filterMap.get(field);
        if (filData == null)
            filData = new Map();
        filData.put("all",filter);
        self.filterMap.put(field,filData);
        //
        var curfilData = self.curfilterMap.get(field);
        if (curfilData == null)
            curfilData = new Map();
        curfilData.put("all",filter);
        self.curfilterMap.put(field,curfilData);
    },
    
    _getAllFilter : function(field,dataType,items) {
        //
        var filter = "";
        for (var i=0;i<items.length;i++) {
            switch (dataType) {
        	    case 'Enum' :
        	          filter += field+"="+items[i].value;
        	          break;
        	    case 'EnumString' :
                      filter += field+"='"+items[i].value+"'";
                      break;
                case "Date":
                case 'Timestamp' :
                      filter += this._getDateFilter(field,items[i].value);
                      break;
                case 'ObjectValue' :
                      filter += field+".number='"+items[i].value+"'";
                      break;
            }
            if (i<items.length-1) 
                filter += " or ";
        }
        return filter;
    },
    
    _addTitle : function(toolbar,title) {
        toolbar.wafToolBar('appendChildren', waf('<span class="grouptitle">'+title+':</span>'));
    },
    
    _addBtnGen : function(toolbar,field,dataType,data,isMulti) {
        var self = this;
        //btn
        var count = data.count;
        if (count == null)
            count = 0;
	    var btnOpts = {id:self.options.id+"_btn_"+field+"_"+data.value,caption:data.alias+"("+count+")",tagClass:"group"};
	    var btn = waf.createDOM("linkButton", btnOpts);
        toolbar.wafToolBar('appendChildren', btn);
        waf.initComponent("linkButton", btnOpts, btn);
        toolbar.wafToolBar('showMore');
        btn.wafLinkButton("option","onclick",function(e) {
            var target = e.target;
            var tagClass = waf(target).wafLinkButton("option","tagClass");
            if (isMulti) {
                if (tagClass == "group") {
                    waf(target).wafLinkButton("option","tagClass","group blue");
                    var filData = self.curfilterMap.get(field);
                    if (filData == null)
                        filData = new Map();
                    var filter = self._getFilter(field,dataType,data.value);
                    filData.put(data.value,filter);
                    self.curfilterMap.put(field,filData);
                    self._addChoose(field,data.value,data.alias);
                } else {
                    waf(target).wafLinkButton("option","tagClass","group");
                    var filData = self.curfilterMap.get(field);
                    filData.remove(data.value);
                    self.curfilterMap.put(field,filData);
                    self._removeChoose(field,data.value,isMulti);
                }
            } else {
                if (tagClass == "group") {
                    waf("#"+self.options.id+"_bar_"+field+" .group.blue").each(function(index){
                        var id = waf(this).attr("id");
                        if (id.indexOf(self.options.id+"_apply_")<0) {
                            waf(this).wafLinkButton("option","tagClass","group");
                            var filData = self.curfilterMap.get(field);
                            var key = self.options.id+"_btn_"+field+"_";
                            filData.remove(id.substring(key.length,id.length));
                            self.curfilterMap.put(field,filData);
                        }
                    });
                    //remove more
                    if (waf("#"+self.options.id+"_"+field+"_From").length>0) {
                        waf("#"+self.options.id+"_"+field+"_From").wafDatePicker("setValue",null);
                        waf("#"+self.options.id+"_"+field+"_To").wafDatePicker("setValue",null);
                        var filData = self.curfilterMap.get(field);
                        if (filData!=null) {
                            filData.remove("apply");
                            self.curfilterMap.put(field,filData);
                        }
                    }
                    if (waf("#"+self.options.id+"_"+field+"_promptBox").length>0) {
                        waf("#"+self.options.id+"_"+field+"_promptBox").wafPromptBox("setValue",null);
                        var filData = self.curfilterMap.get(field);
                        if (filData!=null) {
                            filData.remove("apply");
                            self.curfilterMap.put(field,filData);
                        }
                    }
                    waf(target).wafLinkButton("option","tagClass","group blue");
                    var filData = self.curfilterMap.get(field);
                    if (filData == null)
                        filData = new Map();
                    var filter = self._getFilter(field,dataType,data.value);
                    filData.put(data.value,filter);
                    self.curfilterMap.put(field,filData);
                    self._addChoose(field,data.value,data.alias);
                    self._removeChoose(field,data.value,isMulti);
                } else {
                    return;
                }
            }
            self.doFilter();
       });
       //
        var filData = self.filterMap.get(field);
        if (filData == null)
            filData = new Map();
        var filter = self._getFilter(field,dataType,data.value);
        filData.put(data.value,filter);
        self.filterMap.put(field,filData);
    },
    
    _getFilter : function(field,dataType,value) {
        //
        if (value==null) return "";
        var filter = "";
        switch (dataType) {
    	    case 'Enum' :
    	          filter = field+"="+value;
    	          break;
    	    case 'EnumString' :
                  filter = field+"='"+value+"'";
                  break;
            case "Date":
            case 'Timestamp' :
                  filter = this._getDateFilter(field,value);
                  break;
            case 'ObjectValue' :
                  filter = field+".number='"+value+"'";
                  break;
        }
        return filter;
    },
    
    _getDateFilter : function(field,value) {
         var filter = "";
         if (waf.type.isObject(value)) {
             var fromYear = value.from.getFullYear(),
    	         fromMonth = value.from.getMonth()+1,
    	         fromDay = value.from.getDate();
    	     var fromFilter = "YEAR("+field+")>"+fromYear
	                    +" or (YEAR("+field+")="+fromYear+" and MONTH("+field+")>"+fromMonth+")"
	                    +" or (YEAR("+field+")="+fromYear+" and MONTH("+field+")="+fromMonth+" and DAYOFMONTH("+field+")>="+fromDay+")";
	         var toYear = value.to.getFullYear(),
    	         toMonth = value.to.getMonth()+1,
    	         toDay = value.to.getDate();
	         var toFilter = "YEAR("+field+")<"+toYear
	                    +" or (YEAR("+field+")="+toYear+" and MONTH("+field+")<"+toMonth+")"
	                    +" or (YEAR("+field+")="+toYear+" and MONTH("+field+")="+toMonth+" and DAYOFMONTH("+field+")<="+toDay+")";
    	     filter = "("+fromFilter+") and ("+toFilter+")";
    	     return filter;     
         }
         switch (value) {
    	    case 'today' :
    	          var today = waf.datefunc.today();
    	          filter = "YEAR("+field+")="+today.time.year+" and MONTH("+field+")="+today.time.month+" and DAYOFMONTH("+field+")="+today.time.day;
    	          break;
    	    case 'thisMonth' :
    	          var thisMonth = waf.datefunc.thisMonth();
    	          filter = "YEAR("+field+")="+thisMonth.time.year+" and MONTH("+field+")="+thisMonth.time.month;
    	          break;
    	    case 'thisYear' :
    	          var thisYear = waf.datefunc.thisYear();
    	          filter = "YEAR("+field+")="+thisYear.time.year;
    	          break;
    	    default:
    	          var period = eval("waf.datefunc."+value+"()");
    	          var fromYear = period.time.from.getFullYear(),
    	              fromMonth = period.time.from.getMonth()+1,
    	              fromDay = period.time.from.getDate();
    	          var fromFilter = "YEAR("+field+")>"+fromYear
	                         +" or (YEAR("+field+")="+fromYear+" and MONTH("+field+")>"+fromMonth+")"
	                         +" or (YEAR("+field+")="+fromYear+" and MONTH("+field+")="+fromMonth+" and DAYOFMONTH("+field+")>="+fromDay+")";
	              var toYear = period.time.to.getFullYear(),
    	              toMonth = period.time.to.getMonth()+1,
    	              toDay = period.time.to.getDate();
	              var toFilter = "YEAR("+field+")<"+toYear
	                         +" or (YEAR("+field+")="+toYear+" and MONTH("+field+")<"+toMonth+")"
	                         +" or (YEAR("+field+")="+toYear+" and MONTH("+field+")="+toMonth+" and DAYOFMONTH("+field+")<="+toDay+")";
    	          filter = "("+fromFilter+") and ("+toFilter+")";
    	          break;
    	 }
    	 return filter;
    },
    
    _addVSplit : function(toolbar) {
        toolbar.wafToolBar('appendChildren', waf('<span>|</span>'));
    },
    
    _addMore : function(toolbar,field,dataType,promptQuery,isMulti) {
        var self = this;
        //>>
        var moreOpts = {id:self.options.id+"_more_"+field,caption:self.localeStr.MORE+">>",tagClass:"group"};
	    var more = waf.createDOM("linkButton", moreOpts);
        toolbar.wafToolBar('appendChildren', more);
        waf.initComponent("linkButton", moreOpts, more);
        //
        var moreDom = waf('<div id="'+self.options.id+'_moreCtrl_'+field+'" class="grouptext"></div>')
        toolbar.wafToolBar('appendChildren', moreDom);
        if (dataType == "Date" || dataType == "Timestamp") {
            var fromOpts = {id:self.options.id+"_"+field+"_From",type:"date"};
            var from = waf.createDOM("datePicker", fromOpts);
            waf.appendDOM(moreDom, from);
            waf.initComponent("datePicker", fromOpts, from);
            waf.appendDOM(moreDom, waf('<span class="grouptext">'+self.localeStr.TO+'</span>'));
            var toOpts = {id:self.options.id+"_"+field+"_To",type:"date"};
		    var to = waf.createDOM("datePicker", toOpts);
            waf.appendDOM(moreDom, to);
            waf.initComponent("datePicker", toOpts, to);
            var applyOpts = {id:self.options.id+"_apply_"+field+"_date",caption:self.localeStr.APPLY,tagClass:"group blue"};
        }
        if (dataType == "ObjectValue") {
            var promptBoxOpts = {id:self.options.id+"_"+field+"_promptBox"};
            promptBox = waf.createDOM("promptBox", promptBoxOpts);
            waf.appendDOM(moreDom, promptBox);
            waf.initComponent("promptBox", promptBoxOpts, promptBox);
            var promptOpts = {query:promptQuery,dataUrl:waf.getContextPath()+"/component/F7Quick.do?method=initalize",parentId:self.options.id+"_"+field+"_promptBox"};
            var promptQuick = waf.createDOM("promptQuick", promptOpts);
            waf.initComponent("promptQuick", promptOpts, promptQuick);
            var applyOpts = {id:self.options.id+"_apply_"+field+"_promptBox",caption:self.localeStr.APPLY,tagClass:"group blue"};
        }
        //apply
	    var apply = waf.createDOM("linkButton", applyOpts);
        waf.appendDOM(moreDom, apply);
        waf.initComponent("linkButton", applyOpts, apply);
        toolbar.wafToolBar('showMore');
        moreDom.hide();
        more.wafLinkButton("option","onclick",function(e) {
            var field = this.id.substring(self.options.id.length+6,this.id.length);
            if (waf("#"+self.options.id+"_moreCtrl_"+field).css("display")=="none") {
                waf("#"+self.options.id+"_moreCtrl_"+field).show();
                waf("#"+this.id).wafLinkButton("option","caption",self.localeStr.CLOSE+"<<");
            } else {
                waf("#"+self.options.id+"_moreCtrl_"+field).hide();
                waf("#"+this.id).wafLinkButton("option","caption",self.localeStr.MORE+">>");
            }
        });
        apply.wafLinkButton("option","onclick",function(e) {
            var idkey = this.id.substring(self.options.id.length+7,this.id.length);
            var ids = idkey.split("_");
            var value,alias;
            if (ids[1]=="date") {
                value = {};
                value.from = waf("#"+self.options.id+"_"+field+"_From").wafDatePicker("getValue");
                value.to = waf("#"+self.options.id+"_"+field+"_To").wafDatePicker("getValue");
                alias = waf.datepicker.formatDate("yy-mm-dd", value.from)+self.localeStr.TO+waf.datepicker.formatDate("yy-mm-dd", value.to);
            }
            if (ids[1]=="promptBox") {
                var obj = waf("#"+self.options.id+"_"+idkey).wafPromptBox("getValue");
                if (obj!=null) {
                    value = obj.number;
                    alias = obj.name;
                } else {
                    value = null;
                }
            }
            var filData = self.curfilterMap.get(field);
            if (filData == null)
                filData = new Map();
            var filter = self._getFilter(field,dataType,value);
            filData.remove("apply");
            self._removeChoose(field,"apply",isMulti);
            if (filter!=null && filter!="" && value!=null) {
                filData.put("apply",filter);
                self._addChoose(field,"apply",alias);
            }        
            self.curfilterMap.put(field,filData);
            if (!isMulti) {
                waf("#"+self.options.id+"_bar_"+ids[0]+" .group.blue").each(function(index){
                    var id = waf(this).attr("id");
                    if (id.indexOf(self.options.id+"_apply_")<0) {
                        waf(this).wafLinkButton("option","tagClass","group");
                        var filData = self.curfilterMap.get(field);
                        var key = self.options.id+"_btn_"+field+"_";
                        filData.remove(id.substring(key.length,id.length));
                        self.curfilterMap.put(field,filData);
                    }
                });
            }
            self.doFilter();
        });
    },
    
    /*  */
    doFilter : function() {
    	var self = this;
    	var filter = "";
    	var fields = self.curfilterMap.keys();
    	if (fields!=null && fields.length>0) {
    	    for (var i=0;i<fields.length;i++) {
    	        var filData = self.curfilterMap.get(fields[i]);
    	        if (filData != null) {
    	            var filValues = filData.values();
    	            if (filValues!=null && filValues.length>0) {
    	                if (i>0 && filter.length>0)
    	                    filter += " and ";     
    	                filter += "(";
    	                for (var j=0;j<filValues.length;j++) {
    	                    filter += filValues[j];
    	                    if (j<filValues.length-1)
    	                        filter += " or ";
    	                }
    	                filter += ")"; 
    	            } 
    	        } 
    	    }
    	}
    	self._dataReload(filter);
    },
    
    _dataReload : function(filter) {
        if (this.options.viewCtrlType == "dataView") {
            waf("#"+this.options.viewCtrlId).wafDataView("option","postData",{filterItems:filter});
            waf("#"+this.options.viewCtrlId).wafDataView("reload");
        } else if (this.options.viewCtrlType == "dataGrid") {
            waf("#"+this.options.viewCtrlId).dataGrid("option","page",1);
		    waf("#"+this.options.viewCtrlId).dataGrid("option","filterItems",filter);
		    waf("#"+this.options.viewCtrlId).dataGrid("reloadGrid");		
		}
	},
	
	_viewCtrlBindEvent : function() {
	    var self = this;
	    if (self.options.viewCtrlType == "dataView") {
            
        } else if (self.options.viewCtrlType == "dataGrid") {
            waf("#"+self.options.viewCtrlId).bind("jqGridLoadComplete",function (e,data) {
                //
                waf(".choosing").find("font em").html(data.records);
                //
                var postData = waf("#"+self.options.viewCtrlId).dataGrid("option","postData");
                if (self.filterMap!=null && self.filterMap.size()>0) {
                    postData.filterItems = waf.toJSONString(self.filterMap.elements);
                    waf.doPost(
                	    {url:self.options.url+"?method=getFilterCounts",
                		 data:postData,
                		 success:function(data) {
                		     if (data !=null && data.length>0) {
                		         for (var i=0;i<data.length;i++) {
                		             var field = data[i].field,
                		                 list = data[i].list;
                		             waf.each(list,function (key,val) {
                		                 var caption = waf("#"+self.options.id+"_btn_"+field+"_"+val.value).wafLinkButton("option","caption");
                		                 caption = caption.substring(0,caption.indexOf("("));
                		                 caption += "("+val.count+")";
                		                 waf("#"+self.options.id+"_btn_"+field+"_"+val.value).wafLinkButton("option","caption",caption);
                		             });    
                		         }
                		     }
                		 }
                    });
                }
            });
		}
    },
    
    _createFacets:function(){
        var self = this;
    	var facet = '<div class="choosing">';
    	facet += '<b id="'+self.options.id+'_text">'+self.localeStr.CHOICE+'</b>';
    	facet += '<font id="'+self.options.id+'_total">'+self.localeStr.TOTAL+'<em>'+"xxx"+'</em>'+self.localeStr.DATA+'&nbsp;&nbsp;';
    	facet += '<a id="'+self.options.id+'_clear" class="close">'+self.localeStr.CLEAR+'</a>';
    	facet += '</font></div>';
        waf("#"+self.options.id).append(facet);
        waf("#"+self.options.id+"_text").hide();
        waf("#"+self.options.id+"_clear").hide();
    },
    
    _addChoose:function(field,value,caption){
        var self = this;
        var choose = '<span id="choose_'+field+'_'+value+'" class="filterchoose">'+caption+'<a>x</a></span>';
        waf("#"+self.options.id+"_total").before(choose);
        
        if (waf(".choosing").find(".filterchoose").length>0) {
            waf("#"+self.options.id+"_text").show();
            waf("#"+self.options.id+"_clear").show();
        }
    },
    
     _removeChoose:function(field,value,isMulti){
        var self = this;
        waf(".choosing .filterchoose").each(function(index){
            var id = this.id;
            if (isMulti) {
                if (id=="choose_"+field+"_"+value) {
                    waf(this).remove();
                }
            } else {
                if (id.substring(0,field.length+7)=="choose_"+field && id!="choose_"+field+"_"+value) {
                    waf(this).remove();
                }
            }
        });
        
        if (waf(".choosing").find(".filterchoose").length>0) {
            waf("#"+self.options.id+"_text").show();
            waf("#"+self.options.id+"_clear").show();
        } else {
            waf("#"+self.options.id+"_text").hide();
            waf("#"+self.options.id+"_clear").hide();
        }
    }
});

//
waf(function(){
	waf.registerComponent("waf.groupFilter",{
		createDOMFun:function(option){
			//div
		    var div = waf("<div id='" + option.id + "' class='groupdiv'></div>");
			return div;
		},
		initFun:function(option){
    		var localeStr = waf.createObject(eval("waf.webcom.groupfilter.groupFilter" + "_LocaleStr_" + waf.getContext().locale.toLowerCase()));
            if (option.businessObject == null) {
                waf.msgBox.showError(localeStr.PARAM_OBJECT_ERROR);
                return;
            } 
            if (option.filterFields == null) {
                waf.msgBox.showError(localeStr.PARAM_FIELD_ERROR);
                return;
            } 
            if (option.viewCtrlId == null) {
                waf.msgBox.showError(localeStr.PARAM_CTRLID_ERROR);
                return;
            } 
            
		    option.url = waf.getContextPath()+"/component/GroupFilter.do";
		    if (option.viewCtrlType == null || option.viewCtrlType == ""){
		        option.viewCtrlType = "dataView";
		    }
		    waf("#" + option.id).groupFilter(option);
		}
	});
});













waf.defineClass("waf.webcom.groupfilter.groupFilter_LocaleStr_l1",waf.framework.WafCore,{
    PARAM_OBJECT_ERROR:"Please set the businessObject parameter for web compomnent groupFilter to determine the data source.",
	PARAM_FIELD_ERROR:"Please set the filterField parameter for web compomnent groupFilter to determine the filter field.",
	PARAM_CTRLID_ERROR:"Please set the viewCtrlId parameter for web compomnent groupFilter to determine the view ctrl to show data.",
	ALL:"All",
	MORE:"More",
	CLOSE:"Close",
	APPLY:"Apply",
	TO:"To",
	CHOICE:"Your Choices:",
	TOTAL:"Total of ",
	DATA:" Datas",
	CLEAR:"Clear"
});

waf.defineClass("waf.webcom.groupfilter.groupFilter_LocaleStr_l2",waf.framework.WafCore,{
    PARAM_OBJECT_ERROR:"businessObject.",
	PARAM_FIELD_ERROR:"filterField.",
	PARAM_CTRLID_ERROR:"viewCtrlId.",
	ALL:"",
	MORE:"",
	CLOSE:"",
	APPLY:"",
	TO:"",
	CHOICE:"",
	TOTAL:"",
	DATA:"",
	CLEAR:""
});

waf.defineClass("waf.webcom.groupfilter.groupFilter_LocaleStr_l3",waf.framework.WafCore,{
    PARAM_OBJECT_ERROR:"businessObject.",
	PARAM_FIELD_ERROR:"filterField.",
	PARAM_CTRLID_ERROR:"viewCtrlId.",
	ALL:"",
	MORE:"",
	CLOSE:"",
	APPLY:"",
	TO:"",
	CHOICE:"",
	TOTAL:"",
	DATA:"",
	CLEAR:""
});


/**
* WAF
* @author miaochao
*/
(function ($) {
    waf.datefunc = waf.datefunc || {};
    waf.extend(waf.datefunc, {
        /**/
        sysTime:function () {
            var sysTime = null;
            waf.doPost(
                {url:waf.getContextPath()+"/component/GroupFilter.do?method=getSystemTime",
                 async:false,
                 success:function(data) {
                	sysTime = data;     
                }
            });
            return sysTime;
        },
        /**/
        today:function () {
            var today = {};
            today.value = "today";
            today.alias = "";
            today.time = this.sysTime();
            return today;
        },
        /**/
        thisWeek:function () {
            var thisWeek = {};
            thisWeek.value = "thisWeek";
            thisWeek.alias = "";
            var sysTime = this.sysTime();
            var dayOfWeek = sysTime.dayOfWeek;
            var fromtTime = sysTime.time-1000*60*60*24*(dayOfWeek-1);
            var toTime = sysTime.time+1000*60*60*24*(7-dayOfWeek);
            thisWeek.time = {};
            thisWeek.time.from = new Date(fromtTime);
            thisWeek.time.to =new Date(toTime);
            return thisWeek;
        },
        /**/
        thisMonth:function () {
            var thisMonth = {};
            thisMonth.value = "thisMonth";
            thisMonth.alias = "";
            thisMonth.time = this.sysTime();
            return thisMonth;
        },
        /**/
        thisYear:function () {
            var thisYear = {};
            thisYear.value = "thisYear";
            thisYear.alias = "";
            thisYear.time = this.sysTime();
            return thisYear;
        },
        /**/
        recentThreeMonth:function () {
        
        },
        /**/
        recentSixMonth:function () {
            
        },
        /**/
        recentOneYear:function () {
            
        }
    });
})(jQuery);
/**
 * 
 */
$.widget("waf.quickList",$.waf.WebComponent,{
	options:{
	    id:null,
		relId:null,
		eventType:"click",
		url:null,
		queryPK:null,
		filterItems:"",
		sorterItems:"",
		dataCaption:null,
		rowNum:20,
		page:1,
		width:200
	},
	//
	totalPages:1,
	
	/*  */
	_create:function(){
		var self=this;
		//
		waf("#"+self.options.relId).powerFloat({
		    eventType: self.options.eventType,
            target: waf("#"+self.options.id+"_targetBox"),
            reverseSharp: "false",
            width: self.options.width
        });
        waf("#"+self.options.relId).click(function(){self.showList();});
	},
	
	/*  */
	showList:function(){
		var self=this;
		//
		waf.doPost(
		   {url:self.options.url+"?method=getListData",
			data:{queryPK:self.options.queryPK,
			      dataCaption:self.options.dataCaption,
			      rowNum:self.options.rowNum,
			      page:self.options.page,
			      filterItems:self.options.filterItems,
			      sorterItems:self.options.sorterItems},
			success:function(data) {
			      self.totalPages=data.total,
				  self._loadListData(data);
			}}
	    );
	},
	
	/* */
	_loadListData:function(data){
	    var self=this;
		var rows = data.rows;
	    self._clear();
		if (rows != null) {
		    for (var i=0;i<rows.length;i++) {
				var rowData = rows[i];
				self._addRow(rowData,i+1);
				
		    }
		}  
	},
	
	/* list*/
	_clear:function(){
	    var self = this;
	    waf("#" + self.options.id + "_list tbody").html("");
	},
	
	/* */
	_addRow:function(rowData,i){
	    var self = this;
	    var content = '<tr id="row'+i+'">';
	    content += '<td id="col'+i+'" width="200"><a href="#" id="data'+i+'">'+rowData.toString+'</a></td>';
	    content += '</tr>';
	    waf("#" + self.options.id + "_list").append(content);
	    waf("#data"+i).click(function() {
	        //URLoperateState
		    var param = "";
		    var url = document.location.search.substring(1);
		    var qs = url.split("&");
		    for (var i=0;i<qs.length;i++) {   
                var pos = qs[i].indexOf('=');
                var argname = qs[i].substring(0,pos); 
                if (argname == "operateState") {
                    var arg = qs[i].substring(pos+1,qs[i].length); 
                    if (arg == "addNew") {
                        param = argname+"=edit";
                    } else {
                        param = qs[i];
                    }
                    break;
                }
            }   
	        var modelID = rowData.id;
	        document.location.href="?method=initalize" + "&" + param + "&modelID=" + waf.encodeURIComponent(modelID);
		});
	},
	
	/*  */
	refresh:function(){
	    this.options.page = 1;
	    this.showList();
	},
	
	/*  */
	prevPage:function(){
	    if (this.options.page>1) {
	        this.options.page = this.options.page-1;
	        this.showList();
	    }
	},
	
	/*  */
	nextPage:function(){
	    if (this.options.page<this.totalPages) {
	        this.options.page = this.options.page+1;
	        this.showList();
	    }
	},
	
	/*  */
	firstPage:function(){
	    this.options.page = 1;
	    this.showList();
	},
	
	/*  */
	lastPage:function(){
	    this.options.page = this.totalPages;
	    this.showList();
	}
});

//
waf(function(){
	waf.registerComponent("waf.quickList",{
		createDOMFun:function(option){
		    //div
		    var div = waf("<div id='" + option.id + "'></div>");
		    //divBox
		    var divBox = waf("<div id='" + option.id + "_targetBox'></div>");
		    divBox.css("border","1px solid #aaa")
		          .css("background-color","#fff")
		          .css("display","none");
		    waf.appendDOM(div, divBox);
		    //divUpBtn
		    var divUpBtn = waf("<div id='" + option.id + "_upBtn class='query cf'></div>");
		    divUpBtn.css("background-color","#EDECEA");
		    waf.appendDOM(divBox, divUpBtn);
		    //imgRefresh
            var imgRefreshOps = {id:option.id+"_refresh", src:"/webviews/images/refresh.png", type:"string", height:"20", width:"20", style:"cursor:pointer;float:right"};
            var imgRefreshDom = waf.createDOM("img", imgRefreshOps);
            waf.initComponent("img", imgRefreshOps, imgRefreshDom);
            waf.appendDOM(divUpBtn, imgRefreshDom);
		    //divMain
		    var divMain = waf("<div id='" + option.id + "_main'></div>");
		    waf.appendDOM(divBox, divMain);
            //table
		    var table = waf("<table id='" + option.id + "_list'></table>");
		    waf.appendDOM(divMain, table);
		    //divDownBtn
		    var divDownBtn = waf("<div id='" + option.id + "_downBtn class='query cf'></div>");
		    divDownBtn.css("background-color","#EDECEA");
		    waf.appendDOM(divBox, divDownBtn);
            //imgExNext
            var imgExNextOps = {id:option.id+"_exNext", src:"/webviews/images/expand-right.gif", type:"string", height:"20", width:"20", style:"cursor:pointer;float:right"};
            var imgExNextDom = waf.createDOM("img", imgExNextOps);
            waf.initComponent("img", imgExNextOps, imgExNextDom);
            waf.appendDOM(divDownBtn, imgExNextDom);
            //imgNext
            var imgNextOps = {id:option.id+"_next", src:"/webviews/images/next.gif", type:"string", height:"20", width:"20", style:"cursor:pointer;float:right"};
            var imgNextDom = waf.createDOM("img", imgNextOps);
            waf.initComponent("img", imgNextOps, imgNextDom);
            waf.appendDOM(divDownBtn, imgNextDom);
            //imgPrev
            var imgPrevOps = {id:option.id+"_prev", src:"/webviews/images/prev.gif", type:"string", height:"20", width:"20", style:"cursor:pointer;float:right"};
            var imgPrevDom = waf.createDOM("img", imgNextOps);
            waf.initComponent("img", imgPrevOps, imgPrevDom);
            waf.appendDOM(divDownBtn, imgPrevDom);
            //imgExPrev
            var imgExPrevOps = {id:option.id+"_exPrev", src:"/webviews/images/expand-left.gif", type:"string", height:"20", width:"20", style:"cursor:pointer;float:right"};
            var imgExPrevDom = waf.createDOM("img", imgExPrevOps);
            waf.initComponent("img", imgExPrevOps, imgExPrevDom);
            waf.appendDOM(divDownBtn, imgExPrevDom);

			return div;
		},
		initFun:function(option){
		    option.url = waf.getContextPath()+"/component/QuickList.do";
		    option.rowNum = option.rowNum==null?20:option.rowNum;
		    option.width = option.width==null?200:option.width;
		    waf("#" + option.id).quickList(option);
			waf("#" + option.id + "_refresh").wafImg("option","onclick",function(event) {
		        waf("#" + option.id).quickList("refresh");
		    });
		    waf("#" + option.id + "_exNext").wafImg("option","onclick",function(event) {
		        waf("#" + option.id).quickList("lastPage");
		    });
		    waf("#" + option.id + "_next").wafImg("option","onclick",function(event) {
		        waf("#" + option.id).quickList("nextPage");
		    });
		    waf("#" + option.id + "_prev").wafImg("option","onclick",function(event) {
		        waf("#" + option.id).quickList("prevPage");
		    });
		    waf("#" + option.id + "_exPrev").wafImg("option","onclick",function(event) {
		        waf("#" + option.id).quickList("firstPage");
		    });
		}
	});
});
/**
 * 
 */
//mod.defineModule("quickSearch",["waf","text","autoComplete","dataGrid","quickSearch_i18n"],function(){
	$.widget("waf.quickSearch",$.waf.WebComponent,{
		options:{
			grid:null,
			columnCaption:"",
			columnModel:[],
			logicalOp:"or",
			filterItems:"",
			defaultValue:"",
			beforeSearch:null
		},
		localeStr:null,
		/*  */
		_create:function(){
		    var self = this;
		    if(!self.element.data("domcreated")){
                $(self.element).attr("ctrlrole","waf.quickSearch").attr("data-domcreated","true");
            }
		    self.localeStr = self.getLocaleResourceObject("waf.webcom.quicksearch.quickSearch");
		    
		    //
		    /*
		    if (self.options.grid == null || self.options.grid.length <= 0) {
	            waf.msgBox.showError(self.localeStr.PARAM_GRIDID_ERROR);
	            return;
	        } 
	        */  
	    		
	    	self.options.defaultValue=self.localeStr.INUT+self.options.columnCaption+self.localeStr.SEARCH;
	
	    	waf("#" + this.options.id + "_text").attr("placeholder",this.options.defaultValue);
	    	waf("#" + this.options.id + "_text").attr("title",this.options.defaultValue);
	    	waf("#" + this.options.id +"_img").attr("title",this.options.defaultValue);
			
	    	this.element.bind( "keydown.quickSearch", function( event ) {
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
					case keyCode.ENTER:
					case keyCode.NUMPAD_ENTER: 
					     self.search();
						 return false;
				}
			});
		},
		/* */
		search:function(){
		    var filter = this.getQuerySql();
			
			if (this.options.filterItems !=null && this.options.filterItems.length>0 && this.options.filterItems !="null") {
			    if (filter == "") 
		            filter += this.options.filterItems;
		        else 
			        filter = "(" + filter + ") and (" + this.options.filterItems + ")";
			}
			
			if (this.options.beforeSearch!=null) {
			    filter = this.options.beforeSearch(filter);
			}
			
			if(this.options.grid==undefined || this.options.grid==null || this.options.grid.length<=0){
				this.options.grid=waf("#" + this.options.gridID);	
			}
			this.options.grid.dataGrid("option","filterItems",filter);
			this.options.grid.dataGrid("option","page",1);
			this.options.grid.dataGrid("reloadGrid");
			//this._showInfo();
			
			waf("#" + this.options.id + "_text").focus();
			
		},
		_showInfo:function(){
			
		},
		/* */
		clear:function(){
			waf("#" + this.options.id + "_text").attr("value","");
		},
		/* */
		getQuerySql:function(){
			var value = waf("#" + this.options.id + "_text").val();
			if (value==this.options.defaultValue || value=="") return "";
	
			var filter = "";
			for(var nIndex=0;nIndex<this.options.columnModel.length;nIndex++){
				var column=this.options.columnModel[nIndex];
				filter+="lower("+column+") like '%"+value.toLowerCase()+"%' ";
				if(nIndex<this.options.columnModel.length-1){
					filter = filter + this.options.logicalOp + " ";
				}
			}
			return filter;
		}
	});
	
	//
	waf(function(){
		waf.registerComponent("waf.quickSearch",{
			createDOMFun:function(option){
				var obj = option && option.id && $("#"+option.id);
				if(!(obj&&obj.data("domcreated"))){
				    //div
				    var div = waf("<div id='" + option.id + "' class='" + option.tagClass + "'></div>");
				    //text
				    var txtOps = {id:option.id+"_text", name:option.id+"_text", 
				                  value:option.value, width:option.width==null?200:option.width};
		            var textDom = waf.createDOM("text", txtOps);
		            waf.appendDOM(div, textDom);
		            waf.initComponent("text", txtOps, textDom);
		            //autoComplete
		            txtOps.urlSource="/component/QuickSearch.do?method=initalize";
		            waf.initComponent("autoComplete", txtOps);
		            //img
		            div.append("<div id="+(option.id+"_img")+" class='qsBtn'></div>");
					return div;
				}else{
	                return obj;
	            }
			},
			initFun:function(option){
			    var localeStr = waf.createObject(eval("waf.webcom.quicksearch.quickSearch" + "_LocaleStr_" + waf.getContext().locale.toLowerCase()));
//	            if (option.gridID == null) {
//	                waf.msgBox.showError(localeStr.PARAM_GRIDID_ERROR);
//	                return;
//	            } 
	    		option.grid = waf("#"+option.gridID);
	    		option.url = waf.getContextPath()+"/component/QuickSearch.do";
	    		if(option.columnModel == null) option.columnModel = ['number'];
		        if(option.columnCaption == null) option.columnCaption = localeStr.COLUMNCAPTION;
		        if(option.logicalOp == null) option.logicalOp = "or";
		        
	    		waf("#" + option.id).quickSearch(option);
	    		$("#" + option.id + "_img").bind("click",function(event) {
	                $("#" + option.id).quickSearch("search");
	            });
			}
		});
	});
//});
waf.defineClass("waf.webcom.quicksearch.quickSearch_LocaleStr_l1",waf.framework.WafCore,{
	INUT:"Please enter ",
	SEARCH:" to make a quick query",
	PARAM_GRIDID_ERROR:"Please set the gridID parameter for web compomnent quickSearch to determine the grid to show data",
	COLUMNCAPTION:"Number"
});

waf.defineClass("waf.webcom.quicksearch.quickSearch_LocaleStr_l2",waf.framework.WafCore,{
	INUT:"",
	SEARCH:"",
	PARAM_GRIDID_ERROR:"gridID",
	COLUMNCAPTION:""
});

waf.defineClass("waf.webcom.quicksearch.quickSearch_LocaleStr_l3",waf.framework.WafCore,{
	INUT:"",
	SEARCH:"",
	PARAM_GRIDID_ERROR:"gridID",
	COLUMNCAPTION:""	
});

/**
 * 
 */
//mod.defineModule("report",["waf","window","report_i18n"],function(){
	$.widget("waf.report",$.waf.WebComponent,{
		options:{
			id:null,
			billID:null,
			tdQueryPK:null,
			tdTemplateName:null,
			dataProvider:null,
			url:null
		},
		
		/*  */
		_create:function(){
			var self = this;
            if(!self.element.data("domcreated")){
                $(self.element).attr("ctrlrole","waf.report").attr("data-domcreated","true");
            }
            self.localeStr = self.getLocaleResourceObject("waf.report.report");
		},
		
		/*  */
		report:function(isByDefTemp){
		    var self = this;
			if(self.options.billID==null || self.options.billID=="" 
	//		   ||self.options.tdQueryPK==null || self.options.tdQueryPK=="" 
			   ||self.options.tdTemplateName==null || self.options.tdTemplateName=="") {
				return ;
			}
			var reportWin = waf.window.open({
					    url:waf.getContextPath()+"/component/ReportTemplate.do?method=initalize",
					    OpenType:"iframe",
					    method:'POST',
					    data:{billID:self.options.billID,
					          tdQueryPK:self.options.tdQueryPK,
					          tdTemplateName:self.options.tdTemplateName,
					          dataProvider:self.options.dataProvider,
					          isByDefTemp:isByDefTemp},
					    modal:true,
		        	    title:self.localeStr.TITLE_REPORT,
		         	    position: 'center', 
		     	        width: 600,
					    height: 380,
					    minHeight:0,
					    minWidth:200,
		    	        iconCls:"waf-ui-icon",
		    	        draggable: true,
		    	        minMixBtn: true,
		    	        hideCloseBtn:false,
		        	    resizable: false,
		        	    hideEffect: "slide"
	        });
		}
	});
	
	//
	waf(function(){
		waf.registerComponent("waf.report",{
			createDOMFun:function(option){
				var obj = option && option.id && $("#"+option.id);
				if(!(obj&&obj.data("domcreated"))){
					return waf("<div id='" + option.id + "'></div>");
				}else{
                    return obj;
                }
			},
			initFun:function(option){
				waf("#" + option.id).report(option);
			}
		});
	});
//});
/****************************************************************************/
/****************-JS************************************/

waf.defineClass("waf.report.reportTemplate",waf.framework.WafCore,{
    //
    selectTemp:null,
    
	initalizeDOM:function(){				
		waf.report.reportTemplate.superClass.initalizeDOM.call(this);
		
		waf("#reportTree").dataTree("option","onNodeCreated",function(event, treeId, treeNode) {
	    });
	    waf("#reportTree").dataTree("option","onAsyncSuccess",function(event, treeId, treeNode, msg) {
	    	waf("#rootColumnLayout").wafColumnLayout("adjustLayout");
	    });
	    
	    var isByDefTemp = document.getElementById("isByDefTemp").value;
	    if (isByDefTemp == "true") {
    	    //cookie,
    	    var defaultTemp = _self.getDefault();
    	    if (defaultTemp.length>0) {
	            _self.selectTemp = defaultTemp;
	            _self.reportOk();
	        } else {
	    	    _self.getTemplateList();
	    	}
	    } else {
	        _self.getTemplateList();
	    }
 	}, 
 	
 	/*  */
 	getTemplateList:function(){	
 	    var tdTemplateName = document.getElementById("tdTemplateName").value;
		waf.doPost(
		   {url:"?method=getTemplateList",
		    data:{tdTemplateName:tdTemplateName},
		    success:function(data) {
				_self.loadTemplateList(data);
	    	},
	    	error:function(message) {
				waf.msgBox.showError({
				    summaryMsg:message
			    });
	    	}}
	    );
 	},
 	
 	/*  */
	loadTemplateList:function(data) {
		for (var i in data) {
	        waf("#report_templates").append('<li id="'+ data[i].name+'"><span id="'+ data[i].name+'">'+ data[i].alias + '</span></li>');
	        waf("#report_templates li[id='"+ data[i].name +"']").click(function(e) {
	            waf("#report_templates li").css("background-color","#FFFFFF");
				waf("#report_templates li[id='"+ e.currentTarget.id +"']").css("background-color","#B0E0E6"); 
				_self.selectTemp = e.currentTarget.id;
				var defaultTemp = _self.getDefault();
				if (defaultTemp == _self.selectTemp)
                    waf("#chkDefaultTamp").wafCheckbox("option","checked",true);
                else 
                    waf("#chkDefaultTamp").wafCheckbox("option","checked",false);
			});
			if (i==0) {
			    waf("#report_templates li[id='"+ data[i].name +"']").css("background-color","#B0E0E6");
			    _self.selectTemp = data[i].name;
			    var defaultTemp = _self.getDefault();
			    if (defaultTemp == _self.selectTemp)
                    waf("#chkDefaultTamp").wafCheckbox("option","checked",true);
                else 
                    waf("#chkDefaultTamp").wafCheckbox("option","checked",false);
			}
	    }
	    waf("#report_templates li").css("color","#f1f1f1");
	    waf("#report_templates span").css("cursor","pointer").css("color","#000000");
    },
    
    /*  */
 	reportOk : function(){
 	    var target = waf.windowMgr.getTargetObj();
	    waf.window.max(target);
	    waf.block.show({text:waf.localeResourceObj.AJAX_ASYNC_BLOCK_INFO});
	    _self.reportAction();
	    //waf.block.hide();
    },
    
    /*  */
    reportCancel : function(){
    	var target = waf.windowMgr.getTargetObj();
	    waf.window.close(target);
    },
    
    /*  */
 	reportAction:function(){	
 	    var billID = document.getElementById("billID").value;
 	    var tdQueryPK = document.getElementById("tdQueryPK").value;
 	    var tdTemplatePath = document.getElementById("tdTemplateName").value;
 	    var dataProvider = document.getElementById("dataProvider").value;

	    var url = "?method=report" + "&billID=" + waf.encodeURIComponent(billID)
	                                            + "&tdQueryPK=" + tdQueryPK 
	                                            + "&tdTemplatePath=" + tdTemplatePath
	                                            + "&tdRptTemplate=" + _self.selectTemp
	                                            + (dataProvider==null?"":"&dataProvider=" + dataProvider) ;
	    url = waf.appendConversationToURL(url);
	    document.location.href=url;
 	},
	
	/*  */
	setDefault : function(){
	    var tdTemplatePath = document.getElementById("tdTemplateName").value;
		var key = tdTemplatePath + "." + waf.getContext().currentUserName + "." + waf.getContext().currentCompanyID;
	    //cookie30
 	    var Days = 30; 
        var exp = new Date();  
        exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000); 
        document.cookie = key + "=" + _self.selectTemp + ";expires=" + exp.toGMTString();  
    },
    
	/* cookie */
	getDefault : function(){
		var defaultTemp = "";
		var tdTemplatePath = document.getElementById("tdTemplateName").value;
		var key = tdTemplatePath + "." + waf.getContext().currentUserName + "." + waf.getContext().currentCompanyID;
 		var mycookies = document.cookie.split("; ");
		for (var i=0;i<mycookies.length;i++) {   
            var pos = mycookies[i].indexOf('=');
            var argname = mycookies[i].substring(0,pos); 
            if (argname == key) {
                defaultTemp = mycookies[i].substring(pos+1,mycookies[i].length);
                break;
            }
        }
        return defaultTemp;
    }
});

/****************-JS*******************************/
waf.defineClass("waf.report.reportTemplate_LocaleStr_l1",waf.framework.WafCore,{
	
});

waf.defineClass("waf.report.reportTemplate_LocaleStr_l2",waf.framework.WafCore,{
	
});

waf.defineClass("waf.report.reportTemplate_LocaleStr_l3",waf.framework.WafCore,{
	
});

waf.defineClass("waf.report.report_LocaleStr_l1",waf.framework.WafCore,{
	TITLE_REPORT:"Print"
});

waf.defineClass("waf.report.report_LocaleStr_l2",waf.framework.WafCore,{
	TITLE_REPORT:""
});

waf.defineClass("waf.report.report_LocaleStr_l3",waf.framework.WafCore,{
	TITLE_REPORT:""
});

/**
 * 
 */
//mod.defineModule("searchBar",["waf","datePicker","numberField","select","text","dataGrid","dataView","searchBar_i18n"],function(){
	$.widget("waf.searchBar",$.waf.WebComponent,{
	    options : {
	        view_model:"",
	        queryPK:"",
	        viewCtrlType:"dataView",
	        viewCtrlId:"",
	        searchOptions:null,
	        filterView:null,
	        filterFields:null,
	        beforeSearch:null
	    },
	    fieldContent:"",
	    fields:null,
	    fieldValues:null,
	    rowNum:0,
	    localeStr:null,
	    //
	    currentFilter:"",
	    position:{my:"left top",
	              at:"left bottom"},
	              
	    _create:function(){
	        var self = this;
	        var gridId = self.options.viewCtrlId;
	        var view_model = self.options.view_model;
	        var query = self.options.queryPK;
	        
	        self.localeStr = self.getLocaleResourceObject("waf.webcom.searchbar.searchBar");
	        	
	        var	searchview 	= '<div class="row-fluid oe_searchview">';
			searchview	   +=		'<div class="relative"><div class="oe_searchview_facets"><input id="searchId" value="" maxlength="20" type="text" class="oe_searchview_input"/></div>';
			searchview	   +=			'<input id="oe_view_manager_view_search" class="search-query input-height search-length" value="" type="text" style="width:425px"/>';
			searchview	   +=			'<span><i class="icon-search icon-gray"></i></span><span><i class="custom-filter"></i></span><ul class="typeahead dropdown-menu search-length" style="display: none;width: 200px;"></ul>';
	//		searchview	   += 			'<div class="oe_searchview_drawer dropdown-menu search-length">';
	//		searchview	   += 			'<div><h5><i class="icon-star icon-gray"></i>&nbsp;&nbsp;'+self.localeStr.SOLUTION+'</h5></div>';
	//		searchview	   += 			'<div class="oe_searchview_advanced"><h5><i class="icon-chevron-right icon-gray"></i>&nbsp;&nbsp;'+self.localeStr.ADVANCE_SEARCH+'</h5></div>';
	//		searchview	   +=		'</div></div>';
	        searchview	   +=		'</div>';
			searchview	   += '</div>';
				
			self.element.append(searchview);
			
			var drawer='<div class="oe_searchview_drawer dropdown-menu search-length">';
			drawer+='<div><h5><i class="icon-star icon-gray"></i>&nbsp;&nbsp;'+self.localeStr.SOLUTION+'</h5></div>';
			drawer+='<div class="oe_searchview_advanced"><h5><i class="icon-chevron-right icon-gray"></i>&nbsp;&nbsp;'+self.localeStr.ADVANCE_SEARCH+'</h5></div>';
			drawer+='</div>';
			waf("body").append(drawer);
			
			//	
			var selectContent = "<div class='form'><div class='select_fields'></div>";
			selectContent += '<div><div style="margin: 5px 0px 5px 8px;"><a id="sqAdd" class="seachBar_btn-link" >'+self.localeStr.ADD_SQL+'</a></div>';
			selectContent += '<div style="margin-left: 10px;"><button id="oe_apply" class="shrbtn shrbtn-primary" type="button">'+self.localeStr.APPLY+'</button></div>';
			selectContent += '<div><div id="oe_searchview_custom"><i class="icon-chevron-right icon-gray"></i>&nbsp;<span style="color: gray;">'+self.localeStr.SAVEAS_SOLUTION+'</span></div>';
			selectContent += '<div style="margin-left: 20px;display: none;"><input id="oe_searchview_custom_input" placeholder="'+self.localeStr.SOLUTION_NAME+'" class="input-height input-xlarge" type="text">';
			selectContent += '&nbsp;<button id="sqSave" class="shrbtn shrbtn-primary" type="button">'+self.localeStr.SAVE+'</button>';	
			selectContent += '<div class="oe_defaultView" style="height:30px"><input id="defaultView" type="checkbox">'+self.localeStr.DEFAULT+'</div></div></div></div></div>';
					
			waf(".oe_searchview_drawer").find(".oe_searchview_advanced").append(selectContent);
				
			$('#oe_view_manager_view_search').next('span').next('span').css({
	    		'position': 'absolute',
	    		'right': '5px',
	    		'top': '2px'
	    	});
			$('#oe_view_manager_view_search').next('span').css({
	    		'position': 'absolute',
	    		'left': '5px',
	    		'top': '2px'
	    	});
				
			waf(".oe_searchview_drawer").find(".oe_searchview_advanced .form").hide();
	        	
			waf(".oe_searchview_drawer").find(".oe_searchview_advanced h5").click(function(){
	        	if(waf(".oe_searchview_drawer").find(".oe_searchview_advanced .form").is(':hidden')){
	        		waf(".oe_searchview_drawer").find(".oe_searchview_advanced .form").show();
	        		(this).find("i").attr("class","icon-chevron-down icon-gray");
	        	}else{
	        		waf(".oe_searchview_drawer").find(".oe_searchview_advanced .form").hide();
	        		$(this).find("i").attr("class","icon-chevron-right icon-gray");
	        	}
	        });
	        	
			waf(".oe_searchview_drawer").find("#oe_searchview_custom").click(function(){
	       		if($(this).next().is(':hidden')){
	       			$(this).next().show();
	       			$(this).find("i").attr("class","icon-chevron-down icon-gray");
	       		}else{
	       			$(this).next().hide();
	       			$(this).find("i").attr("class","icon-chevron-right icon-gray");
	       		}
	       	});
				
			$("#searchId").click(function(){
	       		$("#oe_view_manager_view_search").addClass("oe_focused");
	       	});
	        	
	       	$("#oe_view_manager_view_search").click(function(){		   	
	       		$("#searchId").focus();
	       		$("#oe_view_manager_view_search").addClass("oe_focused");
	       	});
	        	
	       	$("#searchId").bind("keyup.wafPromptGrid", function( event ) {
	       		self.getSearchkeyNodes(event,gridId);
	        });
	        	
	       	waf.doPost({
				url: waf.getContextPath() + "/component/SearchBar.do?method=findSearchViewList",
				data: {
					model : view_model,
					query : query
				},
				success: function(data) {
					var views = "";
					for(var i=0;i<data.length;i++){
							views += "<li class='oe_searchview_custom_private' id='"+data[i].id+"'><span>"+data[i].name+"</span><a class='oe_searchview_custom_delete'>x</a></li>";
						}
						$(".oe_searchview_drawer div:eq(0)").append(views);
					}
				});
				
	        	//
	        	this._createSearchView();
	        	
	        	self.element.find(".custom-filter").live("click",function(e){
					var detail = $('.oe_searchview_drawer');
					if (detail.is(':hidden')) {
						detail.show().position($.extend({of: self.element}, self.position));
					} else {
						detail.hide();
					}
				});	
	        	
	        	waf(document).click(function(event) {
					var $target = waf(event.target);
					if ($target.is("#oe_view_manager_view_search") || $target.is('#searchId')  || $target.is('.sqDel') || $target.is('.custom-filter') 
					    || $target.is('label.ui-corner-all') || $target.parents('label.ui-corner-all').length != 0) {
						return;
					}
					if ($target.parents(".ui-datepicker-header").length != 0 || $target.is('.oe_searchview_drawer') || $target.parents('.oe_searchview_drawer').length != 0){
						return;
					}
					if ($target.is(".ui-datepicker") || $target.parents('.ui-datepicker').length != 0){
						return;
					}
					if ($target.is(".ui-dialog") || $target.parents('.ui-dialog').length != 0){
						return;
					}
					
					$(".oe_searchview").find(".typeahead").hide();
					$('#searchId').val("");
					$(".oe_searchview_drawer").hide();
					$("#oe_view_manager_view_search").removeClass("oe_focused");
				});
				
				//
				waf(".oe_searchview_drawer").find("#sqAdd").live("click",function(e){
					var rowId = self.addNew();
				});	
				//
				waf(".oe_searchview_drawer").find(".sqDel").live("click",function(e){
					if(fieldContent == ""){
						fieldContent = waf(".select_fields").html();
					}
					waf(this).parent().parent().remove();
					
					var trs = waf("#select_fieldsList_tb").children().children("tr");
	    			var firstTr = trs.eq(0);
	    			var td = firstTr.children("td");
	    			td.eq(0).children("span").css("display","none");
				});			
				
				
				
				//
				waf(".oe_searchview_drawer").find("#oe_apply").live("click",function(e){
					var filterText = self._getAdvancedFilterText();
					$("#searchId").css("width","50px");
					var fieldLength = $('.searchview_extended_prop_field').length;
					
					$(".oe_searchview_facet").remove();
					self._createFacets(filterText,null,self.localeStr.ADVANCE_OPT);
					self._advancedSearch();
					if(fieldLength>1){
						waf(".oe_facet_values").height(10*fieldLength);
					}
					waf(".oe_searchview_drawer").hide();
					waf("#searchId").attr("readonly","readonly");
				});	
				
				//
				waf(".oe_searchview_drawer").find("#sqSave").live("click",function(e){
					var viewName = waf("#oe_searchview_custom_input").val();
					
					if (viewName == null || viewName == "") {
					    waf.msgBox.showInfo({
					        summaryMsg:self.localeStr.NEED_NAME  
				        }); 
				        return;
				    }       
					var defaultView = waf("#defaultView").attr("checked");
					var searchResult = [];
					waf('.searchview_extended_prop_field').each(function(index){
						var id = $(this).attr("id");
				        var rowId = id.substring(id.indexOf("searchview_fields_row")+21,id.length);
				    
				        var prop_field = waf("#searchview_fields_row"+rowId).wafSelect("getValue"),
	    		        prop_op = waf("#searchview_op_row"+rowId).wafSelect("getValue"),
	    		        prop_value = self._getRealValue(rowId,prop_field);
	    		        
	    		        if (prop_value == null || prop_value == "") return;
						searchResult[index] = {
							prop_field : prop_field,
							prop_op : prop_op,
							prop_value : prop_value
						}
					});
	
					if (searchResult.length<=0) return;
					var searchFilter = JSON.stringify(searchResult);
					waf.doPost({
						url: waf.getContextPath() + "/component/SearchBar.do?method=saveSearchView",
						data: {
							model : view_model,
							query : query,
							viewName : viewName,
							searchFilter : searchFilter,
							defaultView : defaultView
						},
						success: function(data) {
							waf.msgBox.showInfo({
					            summaryMsg:self.localeStr.SAVE_SUCCESS  
				            }); 
							if(data!=null && data.viewId!=null){
							    if (data.oprSta == "addnew") {
								    var views = "<li class='oe_searchview_custom_private' id='"+data.viewId+"'><span>"+viewName+"</span><a class='oe_searchview_custom_delete'>x</a></li>";
								    $(".oe_searchview_drawer div:eq(0)").append(views);
								}
								$(".oe_searchview_custom_private[id='"+data.viewId+"']").find("span").click();
								$(".oe_searchview_drawer").show();
							}
						}
					});
				});
				
				self.element.find(".oe_facet_remove").live("click",function(e){
					var gridId = self.options.viewCtrlId;
					waf(this).parent().remove();
					var width = waf("#searchId").width();
					if( width != 50){
						waf("#searchId").width(width+30);
					}else{
						waf("#searchId").width(200);
					}
					
					self._reloadGrid(gridId);
					$("#searchId").removeAttr("readonly");
				});
				
				//
				waf(".oe_searchview_drawer").find(".oe_searchview_custom_private").live("click",function(e){
					var viewId = $(this).attr("id");
					if(fieldContent == ""){
						fieldContent = $(".select_fields").html();
					}
					var key = $(this).find("span").html();
					waf(".oe_searchview_facet").remove();
					self._createFacets(key,null,null);
					waf.doPost({
						url: waf.getContextPath() + "/component/SearchBar.do?method=findSearchView",
						data: {
							viewId : viewId,
							query : query
						},
						success: function(data) {
							waf(".oe_searchview_custom_private").removeClass("oe_selected");
							waf(this).addClass("oe_selected");
							
							var searchFilter = data.searchFilter;
							var defaultView = data.defaultView;
							if(defaultView){
								waf("#defaultView").attr("checked","checked");
							}else{
								waf("#defaultView").attr("checked",false);
							}
							waf("#select_fieldsList_tb").empty();
							waf("#oe_searchview_custom_input").val(key);
							
							for (var j = 0, len = searchFilter.length; j < len; j++) {
								var rowId = self.addNew();
								var rowData = searchFilter[j],
					            filterFieldItem = self._getFilterFieldSelectItem(searchFilter[j].prop_field),
					            compareOpItem = self._getCompareOpSelectItem(searchFilter[j].prop_op);
				     	        waf("#searchview_fields_row"+rowId).wafSelect("option",{value:filterFieldItem});
				    	        waf("#searchview_op_row"+rowId).wafSelect("option",{value:compareOpItem});
				    	        self._setRealValue(rowId,searchFilter[j].prop_field,searchFilter[j].prop_value);
							}
							
							self._advancedSearch();
						}
					});
				});
				
				waf(".oe_searchview_drawer").find(".oe_searchview_custom_private").live("mouseenter",function(e){
					waf(this).find(".oe_searchview_custom_delete").show();
				}).live("mouseleave",function(e){
					waf(this).find(".oe_searchview_custom_delete").hide();
				});
				
				//
				waf(".oe_searchview_drawer").find(".oe_searchview_custom_private .oe_searchview_custom_delete").live("click",function(e){
					var self = this;
					var viewId = $(self).parent().attr("id");
					waf.doPost({
						url: waf.getContextPath() + "/component/SearchBar.do?method=delSearchView",
						async:false,
						data: {
							viewId : viewId
						},
						success: function(data) {
							waf(self).parent().remove();
						}
					});
					e.stopPropagation();
				});
	        },
	        
	        _createSearchView: function(){
	        	var self = this;
	        	var gridId = self.options.viewCtrlId;
	        	var query = self.options.queryPK;
	        	var view_model = self.options.view_model;
				waf.doPost({
					url: waf.getContextPath() + "/component/SearchBar.do?method=getProperties",
					data: {
						model : view_model,
						query : query
					},
					success: function(data) {
					    if(self.options.filterFields!=null) {
		    		        self.fields = self.options.filterFields;
		    	        } else {
					        self.fields = data.fields;
					    }
						self.fieldValues = new Map();
						for (var i=0;i<self.fields.length;i++) {
						    self.fieldValues.put(self.fields[i].value,self.fields[i]);
						}
						if (self.options.searchOptions == null) {
						    self.options.searchOptions = data.searchOptions;
						} 
						if (self.options.searchOptions == null || self.options.searchOptions.length<=0) {
						    self.options.searchOptions = [{name:"number",label:self.localeStr.CODE}];
						} 
						//div
			            var div = waf("<div id='select_fieldsList'><table id='select_fieldsList_tb' class='select_fieldsList_tb'></table></div>");
			            $(".oe_searchview_advanced .select_fields").append(div);
			            
			            var rowId = self.addNew();
					}
				});
	        	
	        },
	        
	        //
	        getSearchkeyNodes: function (event,gridId) {
	    		var key = $("#searchId").val();
	    		var self = this;
	    		var searchOptions = self.options.searchOptions;
	    		if (event.keyCode == 13){ //
	    			$(".oe_searchview").find(".typeahead").hide();
	    			self._createFacets(key,searchOptions[0].name,searchOptions[0].label);
	    			self._reloadGrid(gridId);
	    			$("#searchId").val("");
	    		}else if (event.keyCode == 8 && $('#searchId').val() == ""){//
	    			$(".oe_searchview").find(".typeahead").hide();
	    		}else{    			
	    			var key = $("#searchId").val();
	    		
	    			$(".oe_searchview").find(".typeahead").empty();
	    			if( key!=null && key!=""){
	    			    for (var i=0;i<searchOptions.length;i++) {
	    			        var dom = "<li class name='"+searchOptions[i].name+"' text='"+searchOptions[i].label+"'><a href='#'>"+self.localeStr.SEARCH+"  "+searchOptions[i].label+": <strong>"+key+"</strong></a></li>";
	    			    	$(".oe_searchview").find(".typeahead").append(dom);
	    				}
	    				//
	    				if (searchOptions.length>1) {
	    				    var domAll = "<li class name='all' text='"+self.localeStr.ALL+"'><a href='#'>"+self.localeStr.SEARCH+"  "+self.localeStr.ALL+": <strong>"+key+"</strong></a></li>";
	    			        $(".oe_searchview").find(".typeahead").append(domAll);
	    			    }
	    				$(".oe_searchview").find(".typeahead").show().position($.extend({of: self.element}, self.position));
	    			}
	    			$(".oe_searchview").find(".typeahead").find('li').click(function(){
	    				var key = $(this).find("strong").html();
	    				var name = $(this).attr("name");
	    				var category = $(this).attr("text");
	    				
	    				$(".oe_searchview").find(".typeahead").hide();
	    				
	    				self._createFacets(key,name,category);
	    				
	    				self._reloadGrid(gridId);
	    				$("#searchId").val("");
	    			});
	    		}			
	    	},
	    	
	    	_createFacets:function(key,name,category){
	    		var facet = '<div class="oe_searchview_facet"><span class="oe_facet_category" name=""></span><span class="oe_facet_remove">x</span>';
				facet += '<span class="oe_facet_values"><span class="oe_facet_value"></span></span></div>';
	
				if(category == null){
					$(".oe_searchview_facets").append(facet);
					$(".oe_searchview_facets .oe_searchview_facet:last").find(".oe_facet_category").html("<i class='icon-star-empty icon-white'></i>");
					$(".oe_searchview_facets .oe_searchview_facet:last").find(".oe_facet_value").html(key);
					var width = $("#searchId").width();
					$("#searchId").width(width-30)
					return;
				}
				
				var facetindex = 0 ;
				$('.oe_searchview_facets .oe_searchview_facet').each(function(index){
					if($(this).find(".oe_facet_category").attr("name") == name){
						facetindex++;
						$(this).find(".oe_facet_values").append('<span class="oe_facet_value">'+key+'</span>');
						var width = $("#searchId").width();
						$("#searchId").width(width-20)
					}
				});
				if(facetindex == 0){
					$(".oe_searchview_facets").append(facet);
					$(".oe_searchview_facets .oe_searchview_facet:last").find(".oe_facet_category").html(category);
					$(".oe_searchview_facets .oe_searchview_facet:last").find(".oe_facet_value").html(key);
					if(name!=null){
						$(".oe_searchview_facets .oe_searchview_facet:last").find(".oe_facet_category").attr("name",name);
						var width = $("#searchId").width();
						$("#searchId").width(width-30)
					}
				}
	    	},
	    	
	    	_getAdvancedFilter:function(){
	    	    var self = this;
	    		var filterItems = "";
				waf('.searchview_extended_prop_field').each(function(index){
				    var id = $(this).attr("id");
				    var rowId = id.substring(id.indexOf("searchview_fields_row")+21,id.length);
				    
				    var filterField = waf("#searchview_fields_row"+rowId).wafSelect("getValue"),
	    		    prop_op = waf("#searchview_op_row"+rowId).wafSelect("getValue"),
	    		    prop_value = self._getRealValue(rowId,filterField);
	    		    
	    		    var curFieldVal = self.fieldValues.get(filterField);
				    var type = curFieldVal.type;
					if(type == "String" || type == "link" || type == "EnumString"){
						if(index == 0){
							if(prop_op == "like" || prop_op == "not like"){
								filterItems += filterField +" "+ prop_op+" '%"+prop_value+"%' ";
							}else{
								filterItems += filterField + prop_op+" '"+prop_value+"' ";
							}
						}else{
							if(prop_op == "like" || prop_op == "not like"){
								filterItems += " and "+filterField +" "+ prop_op+" '%"+prop_value+"%'";
							}else{
								filterItems += " and "+filterField + prop_op+" '"+prop_value+"'";
							}
						}
					}else if(type == "Date" || type == "Timestamp" ){
						if(index == 0){
							filterItems += self._getDateSql(filterField,prop_op,prop_value);
						}else{
							filterItems += " and " + self._getDateSql(filterField,prop_op,prop_value);
						}
					}else{
						if(index == 0){
							filterItems += filterField + prop_op + prop_value;
						}else{
							filterItems += " and " + filterField + prop_op + prop_value;
						}
					}
				});
				return filterItems;
	    	},
	    	
	    	/*value*/
	        _getRealValue : function(rowId,filterField) {
	            var self = this,
	                value = waf("#searchview_value_"+rowId).val();
	        
	    		var curFieldVal = self.fieldValues.get(filterField);
	    		var type = curFieldVal.type;
			
	    		if (type != null) {
	         	    switch (type) {
	                    case 'Boolean' :
	    			    case 'Enum' :
	    			    case 'EnumString' :
	                        value = waf("#searchview_value_"+rowId).wafSelect("getValue");
	                        break;
	                    case "Date":
	                    case 'Timestamp' :
	                        value = waf.wafDatePicker.formatDate("yy-mm-dd",waf("#searchview_value_"+rowId).wafDatePicker("getDate"));
	                        break;
	                    case 'Number' :
	                    case 'Int' :
	                    case 'Short' :
	    			    case 'Double' :
		    		    case 'BigDecimal' :
		    		    case 'Integer' :
		    		    case 'Long' :
		    		    case 'Float' :
	                        value = waf("#searchview_value_"+rowId).wafNumberField("getValue");
	                        break;
	                }
	            }
	        	return value;
	        },
	    
	        /*Text*/
	        _getRealText : function(rowId,filterField) {
	            var self = this,
	                value = waf("#searchview_value_"+rowId).val();
	        
	    		var curFieldVal = self.fieldValues.get(filterField);
	    		var type = curFieldVal.type;
			
	    		if (type != null) {
	         	    switch (type) {
	                    case 'Boolean' :
	    			    case 'Enum' :
	    			    case 'EnumString' :
	                        value = waf("#searchview_value_"+rowId).wafSelect("getSelectedAlias");
	                        break;
	                    case "Date":
	                    case 'Timestamp' :
	                        value = waf.wafDatePicker.formatDate("yy-mm-dd",waf("#searchview_value_"+rowId).wafDatePicker("getDate"));
	                        break;
	                    case 'Number' :
	                    case 'Int' :
	                    case 'Short' :
	    			    case 'Double' :
	    			    case 'BigDecimal' :
	    			    case 'Integer' :
	    			    case 'Long' :
	    			    case 'Float' :
	                        value = waf("#searchview_value_"+rowId).wafNumberField("getValue");
	                        break;
	                }
	            }
	        	return value;
	        },
	    
	    	/* YEAR(createTime)=2012 and MONTH(createTime)=4 and DAYOFMONTH(createTime)=12 */
	        _getDateSql:function (filterField, compareOp, filterValue) {
	            if (compareOp.indexOf("2")>0) {
	                filterValue = compareOp.substring(4,compareOp.length);
	                compareOp = "=";
	            }
	            var dataFilter = "";
	            switch (compareOp) {
	                case "=":
	                    var year = filterValue.substring(0,4);
	    			        month = filterValue.substring(5,7);
	    			        day = filterValue.substring(8,10);
	    	            dataFilter += "YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")="+day;
	                    break;
	                case "!=":
	                    var year = filterValue.substring(0,4);
	    			        month = filterValue.substring(5,7);
	    			        day = filterValue.substring(8,10);
	    	            dataFilter = "(YEAR("+filterField+")>"+year
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")>"+month+")"
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")>"+day+"))"
		                         +" or (YEAR("+filterField+")<"+year
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")<"+month+")"
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")<"+day+"))";
	                    break;
	                case ">":
	                    var year = filterValue.substring(0,4);
	    			        month = filterValue.substring(5,7);
	    			        day = filterValue.substring(8,10);
	    	            dataFilter += "YEAR("+filterField+")>"+year
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")>"+month+")"
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")>"+day+")";
	                    break;
	                case ">=":
	                    var year = filterValue.substring(0,4);
		    		        month = filterValue.substring(5,7);
			    	        day = filterValue.substring(8,10);
		                dataFilter += "YEAR("+filterField+")>"+year
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")>"+month+")"
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")>="+day+")";
	                    break;
	                case "<":
	                    var year = filterValue.substring(0,4);
			    	        month = filterValue.substring(5,7);
				            day = filterValue.substring(8,10);
		                dataFilter += "YEAR("+filterField+")<"+year
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")<"+month+")"
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")<"+day+")";
	                    break;
	                case "<=":
	                    var year = filterValue.substring(0,4);
	    			        month = filterValue.substring(5,7);
		    		        day = filterValue.substring(8,10);
	    	            dataFilter += "YEAR("+filterField+")<"+year
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")<"+month+")"
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")<="+day+")";
	                    break;
	            }
	            if (dataFilter.length>0)
	                dataFilter = "(" + dataFilter + ")";
	            return dataFilter;
	        },
	    
	    	_getAdvancedFilterText:function(){
	    	    var self = this;
	    		var filterText = "";
				$('.searchview_extended_prop_field').each(function(index){
				    var id = $(this).attr("id");
				    var rowId = id.substring(id.indexOf("searchview_fields_row")+21,id.length);
				    
				    var filterField = waf("#searchview_fields_row"+rowId).wafSelect("getValue"),
				    filterFieldText = waf("#searchview_fields_row"+rowId).wafSelect("getSelectedAlias"),
	    		    prop_op = waf("#searchview_op_row"+rowId).wafSelect("getSelectedAlias"),
	    		    prop_value = self._getRealText(rowId,filterField);
				
					if(index == 0){
						filterText += "<li>" + filterFieldText + " " + prop_op + " '"+prop_value+"' </li>";
					}else{
						if( index%2 == 0 ){
							filterText += "<li>"+filterFieldText + " " + prop_op + " '"+prop_value+"' </li>";
						}else{
							filterText += "<li>&   "+filterFieldText + " " + prop_op + " '"+prop_value+"' </li>";
						}
					}
				});
				return filterText;
	    	},
	    	
	    	_advancedSearch:function(){
				var gridId = this.options.viewCtrlId;
				var filterView = {};
					filterView.filterItems = this._getAdvancedFilter();
					filterView.filterValue = "";
					for(var i=0;i<this.element.find(".oe_searchview_facet").length;i++){
						filterView.filterValue += this.element.find(".oe_searchview_facet")[i].outerHTML;
					}
				this.options.filterView = filterView;
				this._dataReload(filterView.filterItems);
	    	},
	    	
	    	_reloadGrid:function(gridId){
	    		var filterItems = "";
	    		var name = "";
	    		var key = "";
	    		var self = this;
	    		var searchOptions = self.options.searchOptions;
	    			                    
	    		$('.oe_searchview_facets .oe_searchview_facet').each(function(index){
					name = $(this).find(".oe_facet_category").attr("name");
					var length = $(this).find(".oe_facet_value").length;
					if(name != null && name != ""){
					    if(index == 0){
							$(this).find(".oe_facet_value").each(function(index){
								key = $(this).html();
								if(length == 1){
								    if (name=="all") {
								        filterItems += "(";
								        for (var i=0;i<searchOptions.length;i++) {
								            filterItems +=  searchOptions[i].name +  " like '%"+key+"%' or ";
								        }
								        filterItems = filterItems.substring(0,filterItems.length-3);
								        filterItems += ") ";
								    } else {
									    filterItems += "(" + name +  " like '%"+key+"%') ";
									}
								}else{
									if(index == 0){
									    if (name=="all") {
						    		        filterItems += "(";
							    	        for (var i=0;i<searchOptions.length;i++) {
								                filterItems +=  searchOptions[i].name +  " like '%"+key+"%' or ";
								            }
								            filterItems = filterItems.substring(0,filterItems.length-3);
								        } else {
								    	    filterItems += "(" + name +  " like '%"+key+"%'";
								    	}
									}else{
									    if (name=="all") {
						    		        filterItems += " or ";
							    	        for (var i=0;i<searchOptions.length;i++) {
								                filterItems +=  searchOptions[i].name +  " like '%"+key+"%' or ";
								            }
								            filterItems = filterItems.substring(0,filterItems.length-3);
								            filterItems += ") ";
								        } else {
								    	    filterItems += " or " + name +  " like '%"+key+"%')" ;
								    	}
									}
								}
							});
						}else{
							$(this).find(".oe_facet_value").each(function(index){
								key = $(this).html();
								if(length == 1){
								    if (name=="all") {
						    		    filterItems += " and (";
							    	    for (var i=0;i<searchOptions.length;i++) {
								            filterItems +=  searchOptions[i].name +  " like '%"+key+"%' or ";
								        }
								        filterItems = filterItems.substring(0,filterItems.length-3);
								        filterItems += ") ";
								    } else {
								    	filterItems += " and (" + name +  " like '%"+key+"%') ";
								    }
								}else{
									if(index == 0){
									    if (name=="all") {
						        		    filterItems += " and (";
							        	    for (var i=0;i<searchOptions.length;i++) {
							    	            filterItems +=  searchOptions[i].name +  " like '%"+key+"%' or ";
							    	        }
							    	        filterItems = filterItems.substring(0,filterItems.length-3);
							    	    } else {
							    	    	filterItems += " and (" + name +  " like '%"+key+"%'";
							    	    }
									}else{
										if (name=="all") {
						    		        filterItems += " or ";
							    	        for (var i=0;i<searchOptions.length;i++) {
								                filterItems +=  searchOptions[i].name +  " like '%"+key+"%' or ";
								            }
								            filterItems = filterItems.substring(0,filterItems.length-3);
								            filterItems += ") ";
								        } else {
								    	    filterItems += " or " + name +  " like '%"+key+"%')" ;
								    	}
									}
								}
							});
						}
					}else{
						filterItems = self._getAdvancedFilter() + filterItems;
					}
				});
	    		this._dataReload(filterItems);
				
				var filterView = {};
				filterView.filterItems = filterItems;
				filterView.filterValue = "";
				for(var i=0;i<this.element.find(".oe_searchview_facet").length;i++){
					filterView.filterValue += this.element.find(".oe_searchview_facet")[i].outerHTML;
				}
				this.options.filterView = filterView;
	    	},
	    	
	    	setFilterView: function(filterView) {
	    		var gridId = this.options.viewCtrlId;
	    		this._dataReload(filterView.filterItems);
	    		$(".oe_searchview_facets").append(filterView.filterValue);
	    		this.options.filterView = filterView;
	    	},
	    	
	        _setOption: function( key, value ) {        
	            $.Widget.prototype._setOption.apply( this, arguments );
	        },
	        
	        _getsearchview_extended_prop_ops: function(type) {
	            var self = this;
	            var searchview_op = new Array();
	            switch (type) {
		 		    case 'String' :
		 		    case 'link' :
		 		        searchview_op[0] = {value:'like',alias:self.localeStr.LIKE};
		 		        searchview_op[1] = {value:'not like',alias:self.localeStr.NOT_LIKE};
		 		        searchview_op[2] = {value:'=',alias:self.localeStr.EQUAL};
		 		        searchview_op[3] = {value:'!=',alias:self.localeStr.NOT_EQUAL};
				    	break;
				    case 'Number' :
				    case 'Int' :
				    case 'Short' :
				    case 'Double' :
				    case 'BigDecimal' :
				    case 'Integer' :
				    case 'Long' :
				    case 'Float' :
				    case 'Date' :
				    case 'Timestamp' :
	                    searchview_op[0] = {value:'=',alias:self.localeStr.EQUAL};
		 		        searchview_op[1] = {value:'!=',alias:self.localeStr.NOT_EQUAL};
		 		        searchview_op[2] = {value:'>',alias:self.localeStr.GREATER_THAN};
		 		        searchview_op[3] = {value:'<',alias:self.localeStr.LESS_THAN};
		 		        searchview_op[4] = {value:'>=',alias:self.localeStr.GREATER_THAN_EQU};
		 		        searchview_op[5] = {value:'<=',alias:self.localeStr.LESS_THAN_EQU};
	                    break;
				    case 'Boolean' :
				    case 'Enum' :
				    case 'EnumString' :
		 		        searchview_op[0] = {value:'=',alias:self.localeStr.EQUAL};
		 		        searchview_op[1] = {value:'!=',alias:self.localeStr.NOT_EQUAL};
				    	break;
				}
				return searchview_op;
	        },
	        
	        addNew: function() {
	            var self = this;
	            self.rowNum += 1;
	            
			    var content = '<tr id="row'+self.rowNum+'">';
		        content += '<td id="row'+self.rowNum+'_col1" width="'+30+'"></td>';
		        content += '<td id="row'+self.rowNum+'_col2" width="'+100+'"></td>';
		        content += '<td id="row'+self.rowNum+'_col3" width="'+90+'"></td>';
		        content += '<td id="row'+self.rowNum+'_col4" width="'+155+'"></td>';
		        content += '<td id="row'+self.rowNum+'_col5"></td>';
		        content += '</tr>';
				waf("#select_fieldsList_tb").append(content);
				
				//
		        self._initRow();
		        return self.rowNum;
			},
			
			_initRow: function() {
	            var self = this;
	            
	            //and	
			    waf("#row"+self.rowNum+"_col1").append("<span class='searchview_extended_prop_and'>and</span>");
			    //searchview_extended_prop_field
				var select_fields_json = {};
				select_fields_json.id = "searchview_fields_row"+self.rowNum;
				select_fields_json.enumSource = self.fields;
				select_fields_json.width = 100;
				select_fields_json.tagClass = "searchview_extended_prop_field input-height";
				select_fields_json.onchange = function(e,ui){
					var rowId = this.id.substring(21,this.id.length);
					waf("#row"+rowId+"_col4").html("");
					waf("#ui-multiselect-menu-searchview_value_"+rowId).remove();
					var curFieldVal = self.fieldValues.get(ui.current);
					var type = curFieldVal.type;
					self._getPropvalueElm(type,rowId,curFieldVal);
				};
	            var select_fields_Dom = waf.createDOM("select", select_fields_json);
	            waf.appendDOM(waf("#row"+self.rowNum+"_col2"), select_fields_Dom);
	            waf.initComponent("select", select_fields_json, select_fields_Dom);
	            //searchview_extended_prop_op
				var curfield = $("#searchview_fields_row"+self.rowNum).wafSelect("getValue");
				var curFieldVal = self.fieldValues.get(curfield);
				var fieldType = curFieldVal.type;
				var select_op_json = {};
				select_op_json.id = "searchview_op_row"+self.rowNum;
				select_op_json.enumSource = self._getsearchview_extended_prop_ops(fieldType);
				select_op_json.width = 90;
				select_op_json.tagClass = "searchview_extended_prop_op input-height";
	            var select_op_Dom = waf.createDOM("select", select_op_json);
	            waf.appendDOM(waf("#row"+self.rowNum+"_col3"), select_op_Dom);
	            waf.initComponent("select", select_op_json, select_op_Dom);
	            //searchview_extended_prop_value
	            self._getPropvalueElm(fieldType,self.rowNum,curFieldVal);
	            var value_json = {};
				//X
				waf.appendDOM(waf("#row"+self.rowNum+"_col5"), '&nbsp;<a class="oe_searchview_custom_delete sqDel">x</a>');
	
				fieldContent = $(".oe_searchview_advanced .select_fields").html();
				
				var trs = waf("#select_fieldsList_tb").children().children("tr");
				var firstTr = trs.eq(0);
				var td = firstTr.children("td");
				td.eq(0).children("span").css("display","none");
	        },
	        
	        _getPropvalueElm:function(type,rowId,curFieldVal){
	            var self = this;
	            if(type == "Date"){
					waf("#searchview_op_row"+rowId).wafSelect("option","enumSource",self._getsearchview_extended_prop_ops(type));
					var date_json = {};
					date_json.id = "searchview_value_"+rowId;
					date_json.type = "date";
					date_json.style = "height:22px;width:97%;vertical-align:middle;";
					var dateDom = waf.createDOM("datePicker", date_json);
	                waf.appendDOM(waf("#row"+rowId+"_col4"), dateDom);
	                waf.initComponent("datePicker", date_json, dateDom);
				}
				if(type == "Timestamp"){
					waf("#searchview_op_row"+rowId).wafSelect("option","enumSource",self._getsearchview_extended_prop_ops(type));
					var date_json = {};
					date_json.id = "searchview_value_"+rowId;
					date_json.type = "datetime";
					date_json.style = "height:22px;width:97%;vertical-align:middle;";
					var dateDom = waf.createDOM("datePicker", date_json);
	                waf.appendDOM(waf("#row"+rowId+"_col4"), dateDom);
	                waf.initComponent("datePicker", date_json, dateDom);
	 			}
				if(type == 'Number' || type == 'Int' || type == "Short" || type == "Double" || type == "BigDecimal" || type == "Integer" || type == "Long" || type == "Float"){
	                waf("#searchview_op_row"+rowId).wafSelect("option","enumSource",self._getsearchview_extended_prop_ops(type));	
	                var number_json = {};
				    number_json.id = "searchview_value_"+rowId;
					number_json.tagClass = "search-input-length input-height searchview_extended_prop_value";
				    var numberDom = waf.createDOM("numberField", number_json);
	                waf.appendDOM(waf("#row"+rowId+"_col4"), numberDom);
	                waf.initComponent("numberField", number_json, numberDom);
	            }
				if(type == "Enum" || type == "EnumString" ){
					waf("#searchview_op_row"+rowId).wafSelect("option","enumSource",self._getsearchview_extended_prop_ops(type));	
					var select_json = {};
					select_json.id = "searchview_value_"+rowId;
					select_json.enumSource = curFieldVal.enumSource;
				    select_json.tagClass = "search-input-length input-height searchview_extended_prop_value";
				    select_json.width = "97%";
	                var select_Dom = waf.createDOM("select", select_json);
	                waf.appendDOM(waf("#row"+rowId+"_col4"), select_Dom);
	                waf.initComponent("select", select_json, select_Dom);
				}
				if(type == "Boolean"){
					waf("#searchview_op_row"+rowId).wafSelect("option","enumSource",self._getsearchview_extended_prop_ops(type));	
					var select_json = {};
					select_json.id = "searchview_value_"+rowId;
					select_json.enumSource = [{value:"1",alias:""},{value:"0",alias:""}];
					select_json.tagClass = "search-input-length input-height searchview_extended_prop_value";
					select_json.width = "97%";
	                var select_Dom = waf.createDOM("select", select_json);
	                waf.appendDOM(waf("#row"+rowId+"_col4"), select_Dom);
	                waf.initComponent("select", select_json, select_Dom);
				}
				if(type == "String" || type == "link"){
				    waf("#searchview_op_row"+rowId).wafSelect("option","enumSource",self._getsearchview_extended_prop_ops(type));	
					var string_json = {};
					string_json.id = "searchview_value_"+rowId;
					string_json.tagClass = "search-input-length input-height searchview_extended_prop_value";
	                var string_Dom = waf.createDOM("text", string_json);
	                waf.appendDOM(waf("#row"+rowId+"_col4"), string_Dom);
	                waf.initComponent("text", string_json, string_Dom);
				}
	        },
	        
	        _getFilterFieldSelectItem:function(val){
	    	    if (this.fields!=null) {
	    	        for (var i=0;i<this.fields.length;i++) {
	    	            if (this.fields[i].value == val) {
	    	                return this.fields[i];
	    	            }
	    	        }
	    	    }
	    	    return null;
	    	},
	    	
	    	_getCompareOpSelectItem:function(val){
	    	    var self = this;
	    	    var searchview_op = null;
	    	    switch (val) {
		 		    case '=' :
		 		        searchview_op = {value:'=',alias:self.localeStr.EQUAL};
		 		        break;
		 		    case '!=' :
		 		        searchview_op = {value:'!=',alias:self.localeStr.NOT_EQUAL};
		 		        break;
		 		    case '>' :
		 		        searchview_op = {value:'>',alias:self.localeStr.GREATER_THAN};
		 		        break;
		 		    case '<' :
		 		        searchview_op = {value:'<',alias:self.localeStr.LESS_THAN};
		 		        break;
		 		    case '>=' :
		 		        searchview_op = {value:'>=',alias:self.localeStr.GREATER_THAN_EQU};
		 		        break;
		 		    case '<=' :
		 		        searchview_op = {value:'<=',alias:self.localeStr.LESS_THAN_EQU};
		 		        break;
		 		    case 'like' :
		 		        searchview_op = {value:'like',alias:self.localeStr.LIKE};
		 		        break;
		 		    case 'not like' :
		 		        searchview_op = {value:'not like',alias:self.localeStr.NOT_LIKE};
				    	break;
				}
				return searchview_op;
	    	},
	
	    	/**/
	        _setRealValue : function(rowId,filterField,value) {
	            var self = this;
	            
	            waf("#searchview_value_"+rowId).attr("value",value);
	        
		    	var curFieldVal = self.fieldValues.get(filterField);
	    		var type = curFieldVal.type;
			
	    		if (type != null) {
	         	    switch (type) {
	                    case 'Boolean' :
	                        if (value == 1) {
		                        waf("#searchview_value_"+rowId).wafSelect("option",{value:{value:"1",alias:self.localeStr.YES}});
		                    } else if (value == 0 ) {
		                        waf("#searchview_value_"+rowId).wafSelect("option",{value:{value:"0",alias:self.localeStr.NO}});      
		                    }
		                    break;
	    			    case 'Enum' :
	    			    case 'EnumString' :
	                        if (curFieldVal.enumSource!=null) {
		                        for (var i=0;i<curFieldVal.enumSource.length;i++) {
		                            if (curFieldVal.enumSource[i].value == value) {
		                                waf("#searchview_value_"+rowId).wafSelect("option",{value:curFieldVal.enumSource[i]});
		                                break;
		                            }
		                       }
		                    }
	                        break;
	                    case "Date":
	                    case 'Timestamp' :
	                        waf("#searchview_value_"+rowId).wafDatePicker("setDate",value);
	                        break;
	                    case 'Number' :
	                    case 'Int' :
	                    case 'Short' :
		    		    case 'Double' :
		    		    case 'BigDecimal' :
		    		    case 'Integer' :
	    			    case 'Long' :
	    			    case 'Float' :
	                        waf("#searchview_value_"+rowId).wafNumberField("setValue",value);
	                        break;
	                }
	            }
	        },
	         
	        _dataReload : function(filter) {
	            var self = this;
	            self.currentFilter = filter;    
	            if (self.options.beforeSearch!=null) {
	    		    filter = self.options.beforeSearch(filter);
	     		}
	            if (self.options.viewCtrlType == "dataView") {
	                waf("#"+self.options.viewCtrlId).wafDataView("option","postData",{filterItems:filter});
	                waf("#"+self.options.viewCtrlId).wafDataView("reload");
	            } else if (self.options.viewCtrlType == "dataGrid") {
	                waf("#"+self.options.viewCtrlId).dataGrid("option","page",1);
			        waf("#"+self.options.viewCtrlId).dataGrid("option","filterItems",filter);
			        waf("#"+self.options.viewCtrlId).dataGrid("reloadGrid");		
				}
			},
			
			/*  */
			getCurrentFilter:function(){
			    return this.currentFilter;
			}	
	    });
	    
	    //
	waf(function(){
		waf.registerComponent("waf.searchBar",{
			createDOMFun:function(option){
			    //div
			    var div = waf("<div id='" + option.id + "' class='searchbardiv'></div>");
				return div;
			},
			initFun:function(option){
	    		var localeStr = waf.createObject(eval("waf.webcom.searchbar.searchBar" + "_LocaleStr_" + waf.getContext().locale.toLowerCase()));
	            if (option.queryPK == null) {
	                waf.msgBox.showError(localeStr.PARAM_QUERYPK_ERROR);
	                return;
	            } 
	            if (option.viewCtrlId == null) {
	                waf.msgBox.showError(localeStr.PARAM_GRIDID_ERROR);
	                return;
	            } 
	            
			    option.url = waf.getContextPath()+"/component/SearchBar.do";
			    if (option.viewCtrlType == null || option.viewCtrlType == ""){
			        option.viewCtrlType = "dataView";
			    }
			    waf("#" + option.id).searchBar(option);
			}
		});
	});
//});

waf.defineClass("waf.webcom.searchbar.searchBar_LocaleStr_l1",waf.framework.WafCore,{
	SAVE_SUCCESS:"Scheme saved successfully.",
	SOLUTION:"Scheme",
	ADVANCE_SEARCH:"Advanced Search",
	ADD_SQL:"Add Query Criteria",
	APPLY:"Apply",
	SAVEAS_SOLUTION:"Save as Scheme",
	SOLUTION_NAME:"Scheme Name",
	SAVE:"Save",
	DEFAULT:"Default Scheme",
	ADVANCE_OPT:"Advanced Option",
	SEARCH:"Search",
	EQUAL:"Equal",
    NOT_EQUAL:"Not equal",
    LIKE:"Like",
    NOT_LIKE:"Not like",
    GREATER_THAN:"Greater than",
    GREATER_THAN_EQU:"Great than or equal to",
    LESS_THAN:"Less than",
    LESS_THAN_EQU:"Less than or equal to",
    YES:"Yes",
    NO:"No",
    CODE:"Code",
    ALL:"All",
    NEED_NAME:"Scheme name cannot be blank.",
    PARAM_QUERYPK_ERROR:"Please set the queryPK parameter for web compomnent searchBar to determine the data source.",
	PARAM_GRIDID_ERROR:"Please set the viewCtrlId parameter for web compomnent searchBar to determine the view ctrl to show data."
});

waf.defineClass("waf.webcom.searchbar.searchBar_LocaleStr_l2",waf.framework.WafCore,{
	SAVE_SUCCESS:"",
	SOLUTION:"",
	ADVANCE_SEARCH:"",
	ADD_SQL:"",
	APPLY:"",
	SAVEAS_SOLUTION:"",
	SOLUTION_NAME:"",
	SAVE:"",
	DEFAULT:"",
	ADVANCE_OPT:"",
	SEARCH:"",
	EQUAL:"",
    NOT_EQUAL:"",
    LIKE:"",
    NOT_LIKE:"",
    GREATER_THAN:"",
    GREATER_THAN_EQU:"",
    LESS_THAN:"",
    LESS_THAN_EQU:"",
    YES:"",
    NO:"",
    CODE:"",
    ALL:"",
    NEED_NAME:"",
	PARAM_QUERYPK_ERROR:"queryPK.",
	PARAM_GRIDID_ERROR:"viewCtrlId."
});

waf.defineClass("waf.webcom.searchbar.searchBar_LocaleStr_l3",waf.framework.WafCore,{
	SAVE_SUCCESS:"",
	SOLUTION:"",
	ADVANCE_SEARCH:"",
	ADD_SQL:"",
	APPLY:"",
	SAVEAS_SOLUTION:"",
	SOLUTION_NAME:"",
	SAVE:"",
	DEFAULT:"",
	ADVANCE_OPT:"",
	SEARCH:"",
	EQUAL:"",
    NOT_EQUAL:"",
    LIKE:"",
    NOT_LIKE:"",
    GREATER_THAN:"",
    GREATER_THAN_EQU:"",
    LESS_THAN:"",
    LESS_THAN_EQU:"",
    YES:"",
    NO:"",
    CODE:"",
    ALL:"",
    NEED_NAME:"",
	PARAM_QUERYPK_ERROR:"queryPK.",
	PARAM_GRIDID_ERROR:"viewCtrlId."
});


/**
 * 
 */
//mod.defineModule("simpleQuery",["waf","text","promptBox","promptQuick","datePicker","numberField","select","img","linkButton","form","dataGrid","simpleQuery_i18n"],function(){
	$.widget("waf.simpleQuery",$.waf.WebComponent,{
		options:{
			id:null,
			url:null,
			queryPK:null,
			grid:null,
			maxFilterCount:999,
			filterFieldWidth:200,
			compareOpWidth:200,
			filterValueWidth:200,
			getMyFilterField:null,
			getMyFilterValueList:null,
			modifyOption:null,
			immediateQuery:false,
			needEmptySlou:false
		},
		
		display:false,
		rowNum:0,
		filterField:null,
		compareOp:null,
		filterValueList:null,
		selectSolution:null,
	    defaultSolu:null,
	    rowMap:new Map(),
	    defText:"",
	    localeStr:null,
	    TYPE_TEXT:"0",
		TYPE_ENUM:"1",
		TYPE_DATE:"2",
		TYPE_F7:"3",
		TYPE_NUMBER:"4",
	    
		/*  */
		_create:function(){
			var self=this;
			self.localeStr = self.getLocaleResourceObject("waf.webcom.simplequery.simpleQuery");
			self.defText = self.localeStr.DEFAULT;
			
			//edit
			waf("#" + this.options.id).hide();
			
			if (self.options.queryPK == null || self.options.queryPK == "" || self.options.queryPK == "null") {
	            waf.msgBox.showError(self.localeStr.PARAM_QUERYPK_ERROR);
	            return;
	        }
	        if (self.options.grid == null || self.options.grid.length <= 0) {
	            waf.msgBox.showError(self.localeStr.PARAM_GRIDID_ERROR);
	            return;
	        }
	        
			waf.doPost(
			   {url:self.options.url+"?method=initalize",
				data:{queryPK:self.options.queryPK},
				success:function(data) {
				        if(self.options.getMyFilterField!=null) {
		    		        self.filterField = self.options.getMyFilterField(data.filterField);
		    	        } else {
					        self.filterField = data.filterField;
					    }
					    self.compareOp = data.compareOp;
					    if(self.options.getMyFilterValueList!=null) {
		    		        self.filterValueList = self.options.getMyFilterValueList(data.filterValueList);
		    	        } else {
					        self.filterValueList = data.filterValueList;
					    }
					    if (data.solutionList!=null && data.solutionList[0]!=null)
					        self.selectSolution = data.solutionList[0];
					    self.defaultSolu = data.defaultSolu;
					    //
					    if (self.options.needEmptySlou)
					        data.solutionList.push({value:"emptySlou",alias:""});
					    waf("#" + self.options.id + "_sel").wafSelect({enumSource:data.solutionList});
					    
					    //selectvalueChange
		                waf("#" + self.options.id + "_sel").wafSelect("option","onchange",function(event){	
		                    self._loadSoution(this.value);
	                    });
	                    
					    if (data.defaultSolu!=null) {
		    			    var defAlias = data.defaultSolu.alias+self.defText;
		                    self._updateSelectItemAlias(waf("#" + self.options.id + "_sel"),self.defaultSolu,self.defaultSolu,defAlias); 
		                    self._loadSoution(self.defaultSolu.value);
		                    //self.search();
		                } else if (self.selectSolution!=null){
		                    self._loadSoution(self.selectSolution.value);
		                } else {
		                    //onchange
	                        var soutionDef = waf("#" + self.options.id + "_sel").wafSelect("getValue");
	                        self._loadSoution(soutionDef);
		                }
				}}
		    );
		},
		
		/* */
		_loadSoution:function(solutionId){
		    var self = this;
		    if (solutionId==null||solutionId=="") {
		        self.clear();
		        self.selectSolution = null;
		        return;
		    }
		    
		    if (solutionId=="emptySlou") {
		        self.clear();
		        self.selectSolution = null;
		        self.setBtnDisabled(waf("#"+self.options.id+"_Save"),true);
		        self.setBtnDisabled(waf("#"+self.options.id+"_delete"),true);
		        self.setBtnDisabled(waf("#"+self.options.id+"_setDef"),true);
		        if (self.options.immediateQuery)
					self.search();
		        return;
		    }
		    
		    self.selectSolution = self._getSelectItem(waf("#" + self.options.id + "_sel"),solutionId);
		    waf.doPost(
			   {url:self.options.url+"?method=getCurrentFilter",
				data:{queryPK:self.options.queryPK,
				      solutionId:solutionId},
				success:function(data) {
				    self.clear();
				    self.setBtnDisabled(waf("#"+self.options.id+"_Save"),false);
		            self.setBtnDisabled(waf("#"+self.options.id+"_delete"),false);
		            self.setBtnDisabled(waf("#"+self.options.id+"_setDef"),false);
					if (data != null) {
					    for (var i=0;i<data.length;i++) {
					        var rowId = self.addNew();
					        var rowData = data[i],
					            filterFieldItem = self._getFilterFieldSelectItem(data[i].filterField),
					            compareOpItem = self._getCompareOpSelectItem(data[i].compareOp);
					        waf("#"+rowId+"1_sel").wafSelect("option",{value:filterFieldItem});
					        waf("#"+rowId+"2_sel").wafSelect("option",{value:compareOpItem});
					        self._setRealValue(rowId,data[i].filterField,data[i].filterValue);
					    }
					}
					if (self.options.immediateQuery)
					    self.search();
				}}
		    );
		},
		
		_getFilterFieldSelectItem:function(val){
		    if (this.filterField!=null) {
		        for (var i=0;i<this.filterField.length;i++) {
		            if (this.filterField[i].value == val) {
		                return this.filterField[i];
		            }
		        }
		    }
		    return null;
		},
		_getCompareOpSelectItem:function(val){
		    if (this.compareOp!=null) {
		        for (var i=0;i<this.compareOp.length;i++) {
		            if (this.compareOp[i].value == val) {
		                return this.compareOp[i];
		            }
		        }
		    }
		    return null;
		},
		/**/
	    _setRealValue : function(rowId,filterField,value) {
	        var self = this,
	            formatter;
	            
	        waf("#"+rowId+"3_vl").attr("value",value);
	        
			for (var i in self.filterValueList) {
				var key = self.filterValueList[i].key;
				if (filterField == key) {
					formatter = self.filterValueList[i].value;
					break;
				}
			}
			if (formatter != null) {
	     	    switch (formatter[0]) {
	                case self.TYPE_ENUM:
	                    if (formatter[1]!=null) {
		                    for (var i=0;i<formatter[1].length;i++) {
		                        if (formatter[1][i].value == value) {
		                            waf("#"+rowId+"3_vl").wafSelect("option",{value:formatter[1][i]});
		                            break;
		                        }
		                   }
		                }
	                    break;
	                case self.TYPE_DATE:
	                    //value = waf.datepicker.formatDate("yy-mm-dd",value);
	                    if (value!=null && value.indexOf(" ")>0)
	                        value = value.substring(0,value.indexOf(" "));
	                    waf("#"+rowId+"3_vl").wafDatePicker("setDate",value);
	                    break;
	                case self.TYPE_F7:
	                    waf("#"+rowId+"3_vl").wafPromptBox("setValue",value);
	                    break;
	                case self.TYPE_NUMBER:
	                    waf("#"+rowId+"3_vl").wafNumberField("setValue",value);
	                    break;
	            }
	        }
	    },
	    
		/* edit*/
		showEdit:function(){
		    if (this.display) {
			    waf("#" + this.options.id).hide();
			    this.display=false;
			} else {
			    waf("#" + this.options.id).show();
			    this.display=true;
			}
		},
		
		/* edit*/
		clear:function(){
		    if (!this.rowMap.isEmpty()) {
		        for (var i=0;i<this.rowMap.size();i++) {
		            var element = this.rowMap.element(i);
		            this._delRow(element.key);
		        }
		        this.rowMap.clear();
		    }
		},
		/*  */
		reset:function(){
			var self = this;
			var solutionId = waf("#" + self.options.id + "_sel").wafSelect("getValue");
			self._loadSoution(solutionId);
		},
		/* */
		addNew:function(){
		    var self = this;
		    if (self.rowMap.size()>=self.options.maxFilterCount)
		        return;
		        
		    self.rowNum += 1;
		    var content = '<tr id="row'+self.rowNum+'">';
		    content += '<td id="col'+self.rowNum+'1" width="'+self.options.filterFieldWidth+'"></td>';
		    content += '<td id="col'+self.rowNum+'2" width="'+self.options.compareOpWidth+'"></td>';
		    content += '<td id="col'+self.rowNum+'3" width="'+self.options.filterValueWidth+'"></td>';
		    content += '<td id="col'+self.rowNum+'4"></td>';
		    content += '<td id="col'+self.rowNum+'5"></td>';
		    content += '</tr>';
		    waf("#" + self.options.id + "_edit").append(content);
		    //
		    self._initRow();
			self.rowMap.put(self.rowNum.toString(),self.rowNum);
			return self.rowNum;
		},
		
		/* */
		_initRow:function(){
		    var self = this;
		    //select
		    var elem2 = self._createWafEl("wafselect",{id:self.rowNum+"2_sel",
		                                               enumSource:self.compareOp,
		                                               onchange:function(event,ui){
	                                                                self._compareOp_changed(this.id,ui.current);
	                                                   }});
		    waf("#col" + self.rowNum + "2").append(elem2);
		    //select
		    var elem1 = self._createWafEl("wafselect",{id:self.rowNum+"1_sel",
		                                               enumSource:self.filterField,
		                                               onchange:function(event,ui){
	                                                                self._filterField_changed(this.id,ui.current);
	                                                   }});
		    waf("#col" + self.rowNum + "1").append(elem1);
		    
	        //:
		    //text
		    if (waf("#" + self.rowNum+"3_vl")==null || waf("#" + self.rowNum+"3_vl").length==0) {
		        var elem3 = self._createWafEl("waftext",{id:self.rowNum+"3_vl"},"");
		        waf("#col" + self.rowNum + "3").append(elem3);
		    }
		    //button
		    var buttonAdd = '<img id="'+self.rowNum+'_sqAdd" style="cursor:pointer;" src="'+waf.getContextPath()+'/webviews/images/add.jpg"/>';
		    waf("#col" + self.rowNum + "4").append(buttonAdd);
		    waf("#"+self.rowNum+"_sqAdd").click(function() {
		        var rowId = this.id.substring(0,this.id.length-6);
			    self._copyRow(rowId);
			});
			//button
		    var buttonDel = '<img id="'+self.rowNum+'_sqDel" style="cursor:pointer;" src="'+waf.getContextPath()+'/webviews/images/delete.gif"/>';
		    waf("#col" + self.rowNum + "5").append(buttonDel);
		    waf("#"+self.rowNum+"_sqDel").click(function() {
		        var rowId = this.id.substring(0,this.id.length-6);
			    self._delRow(rowId);
			    self.rowMap.remove(rowId);
			});
			waf("#"+self.rowNum+"1_sel").wafSelect("option",{width:self.options.filterFieldWidth});
			waf("#"+self.rowNum+"2_sel").wafSelect("option",{width:self.options.compareOpWidth});
		},
		
		_filterField_changed:function(id,filterField) {
		    var self = this;
		    var rowId = id.substring(0,id.length-5);
	        //
		    waf("#col"+rowId+"3").html("");
			//f7.
	        waf("#ui-multiselect-menu-"+rowId+"3_vl").remove();
	        waf("#f7-panel-"+rowId+"3_vl").remove();
	 								
	        var wafElem,
				formatter;
			for (var i in self.filterValueList) {
				var key = self.filterValueList[i].key;
				if (filterField == key) {
					formatter = self.filterValueList[i].value;
					break;
				}
			}
			if (formatter == null) {
	     	    wafElem = self._createWafEl("waftext",{id:rowId+"3_vl"},"");
	 	    } else {
		        switch (formatter[0]) {
		 		    case self.TYPE_ENUM :
		 		        var editor = {edittype:"wafselect",editoptions:{id:rowId+"3_vl",name:rowId+"3_vl",enumSource:formatter[1]}};
		 		        if(self.options.modifyOption!=null) {
		    		        self.options.modifyOption({filterField:filterField,editor:editor});
		    	        } 
	                    wafElem = self._createWafEl(editor.edittype,editor.editoptions);
				    	break;
				    case self.TYPE_DATE :
				        var editor = {edittype:"datepicker",editoptions:{id:rowId+"3_vl",dateFormat:"yy-mm-dd"}};
		 		        if(self.options.modifyOption!=null) {
		    		        self.options.modifyOption({filterField:filterField,editor:editor});
		    	        } 
	                    wafElem = self._createWafEl(editor.edittype,editor.editoptions,"");
				    	break;
				    case self.TYPE_F7 :
				        var editor = {edittype:"f7",editoptions:{id:rowId+"3_vl",subWidgetName:"wafPromptQuick",
	                                                             subTagJson:{query:formatter[1],minLength:0,autoCompleteItem:"name",
	                                                             dataUrl:waf.getContextPath()+"/component/F7Quick.do?method=initalize"}}};
		 		        if(self.options.modifyOption!=null) {
		    		        self.options.modifyOption({filterField:filterField,editor:editor});
		    	        } 
	                    wafElem = self._createWafEl(editor.edittype,editor.editoptions,"");
	                    break;
	                case self.TYPE_NUMBER :
	                    var editor = {edittype:"numberfield",editoptions:{id:rowId+"3_vl"}};
		 		        if(self.options.modifyOption!=null) {
		    		        self.options.modifyOption({filterField:filterField,editor:editor});
		    	        } 
	                    wafElem = self._createWafEl(editor.edittype,editor.editoptions,"");
				    	break;
		    	}
		    }
			waf("#col" + rowId + "3").append(wafElem);
				
			//
			var newEnum = [],
				oldEnum = self.compareOp;
			if (formatter == null) {//text
	     	    for (var i=0;i<oldEnum.length;i++) {
				    if (oldEnum[i].value!=">"&&oldEnum[i].value!=">="&&oldEnum[i].value!="<"&&oldEnum[i].value!="<="&&oldEnum[i].value!="is"&&oldEnum[i].value!="is not"&&oldEnum[i].value.indexOf("2")<0)
				        newEnum[i]=oldEnum[i];
				}
	 	    } else {
	 	        switch (formatter[0]) {
		 		    case self.TYPE_ENUM ://select
	                    for (var i=0;i<oldEnum.length;i++) {
				            if (oldEnum[i].value!="like"&&oldEnum[i].value!="not like"&&oldEnum[i].value!=">"&&oldEnum[i].value!=">="&&oldEnum[i].value!="<"&&oldEnum[i].value!="<="&&oldEnum[i].value!="is"&&oldEnum[i].value!="is not"&&oldEnum[i].value.indexOf("2")<0)
				                newEnum[i]=oldEnum[i];
				        }
				    	break;
				    case self.TYPE_DATE ://date
	                    for (var i=0;i<oldEnum.length;i++) {
				            if (oldEnum[i].value!="<>"&&oldEnum[i].value!="like"&&oldEnum[i].value!="not like")
				                newEnum[i]=oldEnum[i];
				        }
				    	break;
				    case self.TYPE_F7 ://F7
	                    for (var i=0;i<oldEnum.length;i++) {
				            if (oldEnum[i].value!="like"&&oldEnum[i].value!="not like"&&oldEnum[i].value!=">"&&oldEnum[i].value!=">="&&oldEnum[i].value!="<"&&oldEnum[i].value!="<="&&oldEnum[i].value.indexOf("2")<0)
				                newEnum[i]=oldEnum[i];
				        }
	                    break;
	                case self.TYPE_NUMBER ://numberField
	                    for (var i=0;i<oldEnum.length;i++) {
				            if (oldEnum[i].value!="like"&&oldEnum[i].value!="not like"&&oldEnum[i].value.indexOf("2")<0)
				                newEnum[i]=oldEnum[i];
				        }
				    	break;
		    	}
		    }
			waf("#" + rowId + "2_sel").wafSelect("option",{enumSource:newEnum});
		},
		
		_compareOp_changed:function(id,compareOp) {
		    var rowId = id.substring(0,id.length-5);
	        if (compareOp.indexOf("2")>0) {
	            //
	            waf("#" + rowId + "3_vl").wafDatePicker("setDate",null);
	            waf("#" + rowId + "3_vl").wafDatePicker("disable");
	        } else if (compareOp == "is" || compareOp == "is not"){
	            waf("#" + rowId + "3_vl").wafPromptBox("setValue",null);
	            waf("#" + rowId + "3_vl").wafPromptBox("disable");
	        } else {
	            waf("#" + rowId + "3_vl").wafDatePicker("enable");
	            waf("#" + rowId + "3_vl").wafPromptBox("enable");
	        }
		},
		
		_copyRow:function(id){
		    var self = this;
		    if (self.rowMap.size()>=self.options.maxFilterCount)
		        return;
		        
		    self.rowNum += 1;
		    
		    //var table = document.getElementById(self.options.id + "_edit");
		    var table = waf("#" + this.options.id + "_edit")[0];
		    var rows = table.rows,
		        currentNo;
		    for (var i=0;i<rows.length;i++) {
		        if (rows[i].id == "row"+id) {
		            currentNo = i;
		            break;
		        }
		    }
		    //
		    var row = table.insertRow(currentNo+1);
		    row.id = "row"+self.rowNum;
		    //
		    var cell5 = row.insertCell(row.id);
		    cell5.id = "col"+self.rowNum+"5";
		    var cell4 = row.insertCell(row.id);
		    cell4.id = "col"+self.rowNum+"4";
		    var cell3 = row.insertCell(row.id);
		    cell3.id = "col"+self.rowNum+"3";
		    cell3.width = self.options.filterValueWidth;
		    var cell2 = row.insertCell(row.id);
		    cell2.id = "col"+self.rowNum+"2";
		    cell2.width = self.options.compareOpWidth;
		    var cell1 = row.insertCell(row.id);
		    cell1.id = "col"+self.rowNum+"1";
		    cell1.width = self.options.filterFieldWidth;
		    //
		    self._initRow();
		    //
		    var filterFieldItem = waf("#"+id+"1_sel").wafSelect("getValueObject"),
		        compareOpItem = waf("#"+id+"2_sel").wafSelect("getValueObject"),
		        filterValue = waf("#"+id+"3_vl").val();
		    waf("#"+self.rowNum+"1_sel").wafSelect("option",{value:filterFieldItem});
			waf("#"+self.rowNum+"2_sel").wafSelect("option",{value:compareOpItem});
			waf("#"+self.rowNum+"3_vl").attr("value",filterValue);
					        
			self.rowMap.put(self.rowNum.toString(),self.rowNum);
			return self.rowNum;
		},
		
		_delRow:function(id){
		    waf("#row" + id).remove();
		},
		
		/*  */
	    saveSolu : function() {
		    var isLegal = this._verify();
		    if (!isLegal)
	     		return;
	
			var self = this;
			var filter = self._getFilter();
			
	    	if (self.selectSolution==null) {
	    	    waf.msgBox.showPrompt({
					title : self.localeStr.SAVE,
					summaryMsg : self.localeStr.INPUT_NAME,
					buttonCallBack : [function(val,dialog) {
					    if (val == "" || val == null) {
					        waf.msgBox.showError({
					            summaryMsg:self.localeStr.NEED_NAME 
				            });
				            return;
					    }
					    self._doSave(self.options.id,self.options.url,filter,"saveSolution",val);
	    	            
		                waf.msgBox.close(dialog);
	                }]
			    });
	    	} else {
	    	    var solutionName = waf("#" + self.options.id + "_sel").wafSelect("getSelectedAlias");
	    	    var solutionId = waf("#" + self.options.id + "_sel").wafSelect("getValue");
	    	    self._doSave(self.options.id,self.options.url,filter,"saveSolution",solutionName,solutionId);
	    	}
	    },
	    
	    /**/
	    _getFilter : function() {
	    	var filter = {};
	    	//var table = document.getElementById(this.options.id + "_edit");
	    	var table = waf("#" + this.options.id + "_edit")[0];
		    var rows = table.rows,
		        currentNo;
		    for (var i=0;i<rows.length;i++) {
		        var rowId = rows[i].id;
		        rowId = rowId.substring(3,rowId.length);
		        filter[i+1] = {};
	    		filter[i+1].filterField = waf("#"+rowId+"1_sel").wafSelect("getValue");
	    		filter[i+1].compareOp = waf("#"+rowId+"2_sel").wafSelect("getValue");
	    		filter[i+1].filterValue = this._getRealValue(rowId,filter[i+1].filterField);
		    }
	    	return filter;
	    },
		
		/*value*/
	    _getRealValue : function(rowId,filterField) {
	        var self = this,
	            formatter,
	            value = waf("#"+rowId+"3_vl").val();
	        
			for (var i in self.filterValueList) {
				var key = self.filterValueList[i].key;
				if (filterField == key) {
					formatter = self.filterValueList[i].value;
					break;
				}
			}
			if (formatter != null) {
	     	    switch (formatter[0]) {
	                case self.TYPE_ENUM:
	                    value = waf("#"+rowId+"3_vl").wafSelect("getValue");
	                    break;
	                case self.TYPE_DATE:
	                    value = waf.wafDatePicker.formatDate("yy-mm-dd",waf("#"+rowId+"3_vl").wafDatePicker("getDate"));
	                    break;
	                case self.TYPE_F7:
	                    value = waf("#"+rowId+"3_vl").wafPromptBox("getValue");
	                    break;
	                case self.TYPE_NUMBER:
	                    value = waf("#"+rowId+"3_vl").wafNumberField("getValue");
	                    break;
	            }
	        }
	    	return value;
	    },
	    
		_doSave : function(id,url,filter,action,solutionName,solutionId) {
		    var self = this;
		    waf.doPost(
			   {url:url + "?method="+action,
			    data:{queryPK:self.options.queryPK,
			          data:waf.toJSONString(filter),
			          solutionName:solutionName,
			          solutionId:solutionId},
				success:function(newId) {
				    //select
				    if(newId) {
				        var enumSource = waf("#" + id + "_sel").wafSelect("option","enumSource");
				        if (self.options.needEmptySlou)
				            enumSource.splice(enumSource.length-1,0,{alias:solutionName,value:newId});
				        else 
				            enumSource.push({alias:solutionName,value:newId});
				        waf("#" + id + "_sel").wafSelect("option",{enumSource:enumSource});
				        waf("#" + id + "_sel").wafSelect("setValue",newId);
					}
	
					waf.msgBox.showInfo({
					     summaryMsg:self.localeStr.SAVE_SUCCESS  
				    });      
			    },
				error: function(msg) {
				    waf.msgBox.showInfo({
					     summaryMsg:msg  
				    });  
				}}
		    );
	    },
	    
	    /*  */
	    saveAsSolu : function() {
		    var isLegal = this._verify();
		    if (!isLegal)
	   		    return;
	
			var self = this;
			var filter = self._getFilter();
			
	    	waf.msgBox.showPrompt({
				title : self.localeStr.SAVEAS,
				summaryMsg : self.localeStr.INPUT_NAME,
				buttonCallBack : [function(val,dialog) {
					if (val == "" || val == null) {
					    waf.msgBox.showError({
					        summaryMsg:self.localeStr.NEED_NAME 
				        });
				        return;
					}
					self._doSave(self.options.id,self.options.url,filter,"saveAsSolution",val);
	    	            
		            waf.msgBox.close(dialog);
	            }]
			});
	    },
	    
	    /*  */
	    deleteSolu : function() {
	    	var self = this;
	    	if (self.selectSolution==null) return;
	    	
	    	var solutionId = waf("#" + self.options.id + "_sel").wafSelect("getValue"),
	    	    enumSource = waf("#" + self.options.id + "_sel").wafSelect("option","enumSource");
	    	
	        waf.msgBox.showConfirm({
	    		    summaryMsg:self.localeStr.DEL_SOLUTION,
	    		    buttonCallBack:[function(dialog) {
	    			    waf.doPost(
			                {url:self.options.url + "?method=deleteSolution", 
			                 data:{solutionId:solutionId},
				             success:function(obj) {
					             for (var i=0;i<enumSource.length;i++) {
				                     if (enumSource[i].value==solutionId) {
				                         enumSource.splice(i,1);
				                         break;
				                     }
				                 }
				                waf("#" + self.options.id + "_sel").wafSelect("option",{enumSource:enumSource});
				        
					            waf.msgBox.showInfo({
					                summaryMsg:self.localeStr.DEL_SUCCESS  
				                }); 
				            }}
		                );
	    			    waf.msgBox.close(dialog);
	    		    }]
	    	    }); 
	    },
	    
	    /*  */
	    setDefaultSolu : function() {
	    	var self = this;
	    	if (self.selectSolution==null) return;
	    	
	    	waf.doPost(
			   {url:self.options.url + "?method=setDefaultSolution", 
				data:{queryPK:self.options.queryPK,
				      oldSoluId:self.defaultSolu==null?"":self.defaultSolu.value,
				      solutionId:self.selectSolution.value},
				success:function(data) {
				    if (self.defaultSolu!=null) {
				        var oldAlias = self.defaultSolu.alias.substring(0,self.defaultSolu.alias.length-self.defText.length);
				        self._updateSelectItemAlias(waf("#" + self.options.id + "_sel"),self.selectSolution,self.defaultSolu,oldAlias);
				    }
				    self.defaultSolu = self.selectSolution;
				    var newDefText = waf("#" + self.options.id + "_sel").wafSelect("getSelectedAlias");
		            var newAlias = newDefText+self.defText;
		            self._updateSelectItemAlias(waf("#" + self.options.id + "_sel"),self.selectSolution,self.selectSolution,newAlias); 
		            
					waf.msgBox.showInfo({
					     summaryMsg:self.localeStr.SOLUTION+newDefText+self.localeStr.SET_DEFAULT  
				    });  
				}}
		    );
	    },
	    
	    _updateSelectItemAlias : function(selObj,value,selectItem,newAlias) {
	        var self = this;
	        var enumSource = selObj.wafSelect("option","enumSource");
			for (var i=0;i<enumSource.length;i++) {
				if (enumSource[i].value==selectItem.value) {
				    enumSource[i].alias = newAlias;
				    selectItem.alias = newAlias;
				}
			}
	        selObj.unbind(); 
		    selObj.wafSelect("option",{enumSource:enumSource});
	        selObj.wafSelect({onchange:function(event){	
		        self._loadSoution(this.value);
	        }}); 
	        selObj.wafSelect("option",{value:value});
	    },
	    
	    _getSelectItem : function(selObj,value) {
	        var selectItem;
	        var oldEnum = selObj.wafSelect("option","enumSource");
	 		for (var i=0;i<oldEnum.length;i++) {
				if (oldEnum[i].value==value) {
				    selectItem = oldEnum[i];
				    break;
				} 
			}
			return selectItem;
	    },
	    
	    /*  */
	    _verify : function () {
	        var self = this;
	    	for (var i=0;i<this.rowMap.size();i++) {
	    	    var element = this.rowMap.element(i);
	    	    var rowId = element.key;
	    	    
	    		var filterField = waf("#"+rowId+"1_sel").wafSelect("getValue"),
	    		    compareOp = waf("#"+rowId+"2_sel").wafSelect("getValue"),
	    		    filterValue = waf("#"+rowId+"3_vl").val();
	
	    		if ((filterValue == "" || filterValue == null)&& compareOp != "is"
		    			&& compareOp != "is not" && compareOp.indexOf("2")<0) {
		    		waf.msgBox.showInfo({
					    summaryMsg:self.localeStr.NEED_FILTERVAL  
				    });  
		    		return false;
		    	}
		    }
	     	return true;
	    },
	    
	    /* */
		search:function(){
		    var self = this;
		    var sql = self.getQuerySql();
	    	if (sql == null)
	    		return;
	        
	        //
	        if (sql.indexOf("$macro")>=0) {
	            waf.doPost(
			       {url:self.options.url+"?method=macroExec",
			    	data:{sql:sql},
			    	success:function(transSql) {
					    self.options.grid.dataGrid("option","filterItems",transSql);
		    	        self.options.grid.dataGrid("option","page",1);
	    	        	self.options.grid.dataGrid("reloadGrid");
			    	}}
		        );
	        } else {
	            self.options.grid.dataGrid("option","filterItems",sql);
		    	self.options.grid.dataGrid("option","page",1);
	    		self.options.grid.dataGrid("reloadGrid");
			}
		},
	    
	    /* */
	    getQuerySql : function() {
	        var self = this;
	    	var isLegal = this._verify();
	    	if (!isLegal)
	    		return null;
	
	    	var filter = " ";
		    for (var i=0;i<this.rowMap.size();i++) {
	    	    var element = this.rowMap.element(i);
	    	    var rowId = element.key;
	    	    
	    		var filterField = waf("#"+rowId+"1_sel").wafSelect("getValue"),
	    		    compareOp = waf("#"+rowId+"2_sel").wafSelect("getValue"),
	    		    filterValue = this._getRealValue(rowId,filterField);
	    		    
	    		if (compareOp == "like" || compareOp == "not like") {
	    		    if (filterValue.indexOf("$macro")<0) {
	    			    filterField = "lower(" + filterField + ")";
	    		        filterValue = "%" + filterValue.toLowerCase() + "%";
	    		    } else {
	    		        filterValue = "%" + filterValue + "%";
	    		    }
	    	    }
	    		var isNeedQuotMarks = true,
	    		    isNeedId = false,
	    		    isDate = false;
	    		for (var j in this.filterValueList) {
					var key = this.filterValueList[j].key;
					if (filterField == key) {
						var formatter = this.filterValueList[j].value;
						if (formatter[0] == self.TYPE_F7) {
						    isNeedId = true;
						} 
						if (formatter[0] == self.TYPE_DATE || formatter[0] == self.TYPE_NUMBER) {
						    isNeedQuotMarks = false;
						} 
						if (formatter[0] == self.TYPE_DATE) {
						    isDate = true;
						}
						break;
					}
				}
				//
				if (isDate) {
				    var dataFilter = this._getDateSql(filterField,compareOp,filterValue);
				    filter += dataFilter;
				} else {
				    //F7
				    if (isNeedId && filterValue != null) {
				        if(filterField.indexOf(".id")<0) {
				            filterField = filterField.substring(0, filterField.indexOf("."));
				            filterField += ".id";
				        }
				        filterValue = filterValue.id;
			    	}
			    	//
			    	if (isNeedQuotMarks)
			    	    filterValue = "'" + filterValue + "'";
	                if (compareOp == "is" || compareOp == "is not")
	    		    	filterValue = "null";
	            
	    	    	filter += filterField + " " + compareOp + " " + filterValue;
	    		}
	    		
	    		if (i!=this.rowMap.size()-1) 
	    		    filter += " and ";
	    	}
	
	    	return filter;
	    },
	    
	    /* YEAR(createTime)=2012 and MONTH(createTime)=4 and DAYOFMONTH(createTime)=12 */
	    _getDateSql:function (filterField, compareOp, filterValue) {
	        if (compareOp.indexOf("2")>0) {
	            filterValue = compareOp.substring(4,compareOp.length);
	            compareOp = "=";
	        }
	        var dataFilter = "";
	        switch (compareOp) {
	            case "=":
	                var year = filterValue.substring(0,4);
				        month = filterValue.substring(5,7);
				        day = filterValue.substring(8,10);
		            dataFilter += "YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")="+day;
	                break;
	            case "<>":
	                var year = filterValue.substring(0,4);
				        month = filterValue.substring(5,7);
				        day = filterValue.substring(8,10);
		            dataFilter = "(YEAR("+filterField+")>"+year
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")>"+month+")"
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")>"+day+"))"
		                         +" or (YEAR("+filterField+")<"+year
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")<"+month+")"
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")<"+day+"))";
	                break;
	            case ">":
	                var year = filterValue.substring(0,4);
				        month = filterValue.substring(5,7);
				        day = filterValue.substring(8,10);
		            dataFilter += "YEAR("+filterField+")>"+year
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")>"+month+")"
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")>"+day+")";
	                break;
	            case ">=":
	                var year = filterValue.substring(0,4);
				        month = filterValue.substring(5,7);
				        day = filterValue.substring(8,10);
		            dataFilter += "YEAR("+filterField+")>"+year
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")>"+month+")"
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")>="+day+")";
	                break;
	            case "<":
	                var year = filterValue.substring(0,4);
				        month = filterValue.substring(5,7);
				        day = filterValue.substring(8,10);
		            dataFilter += "YEAR("+filterField+")<"+year
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")<"+month+")"
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")<"+day+")";
	                break;
	            case "<=":
	                var year = filterValue.substring(0,4);
				        month = filterValue.substring(5,7);
				        day = filterValue.substring(8,10);
		            dataFilter += "YEAR("+filterField+")<"+year
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")<"+month+")"
		                         +" or (YEAR("+filterField+")="+year+" and MONTH("+filterField+")="+month+" and DAYOFMONTH("+filterField+")<="+day+")";
	                break;
	            case "is":
	                dataFilter = filterField+" is null";
	                break;
	            case "is not":
	                dataFilter = filterField+" is not null";
	                break;
	        }
	        if (dataFilter.length>0)
	            dataFilter = "(" + dataFilter + ")";
	        return dataFilter;
	    },
	    
	    getDefaultSolu:function() {
	        return this.defaultSolu;
	    },
	    
	    setBtnDisabled:function(btn,disabled) {
	        btn.wafLinkButton("option","disabled",disabled);
	    },
	    
	    _createWafEl:function (eltype, options, vl, autowidth, ajaxso) {
	            var elem = "";
	
	            function filterOptions(options){
	                var exclude = ['dataInit', 'dataEvents', 'dataUrl', 'buildSelect', 'sopt', 'searchhidden',
	                    'defaultValue', 'attr', 'textJson', 'autoCompleteJson',
	                    'datepickerjson','selectJson','enumJson','inputJson','filterJson',
	                    'f7Json','displayFormat','editFormat','subWidgetName','subTagJson' ,'grid'
	                ];
	
	                for(var item in options){
	                    if ($.inArray(item, exclude) === -1) {
	                    }else{
	                        options[item] = undefined;
	                        delete options[item];
	                    }
	                }
	            }
	
	            function createInput(eltype, options, vl, autowidth, ajaxso,role) {
	                var  elem;
	                elem = document.createElement("input");
	                elem.id = options.id;
	                elem.type = eltype;
	                elem.value = vl;
	                elem.ctrlrole = role;
	                return elem;
	            }
	
	            switch (eltype) {
	                case "wafpassword" :
	                    var tmptype = "password";
	                    elem = createInput(tmptype, options, vl, autowidth, ajaxso,tmptype);
	                    $(elem).attr("ctrlrole","password");
	                    var inputJson = options.inputJson;
	                    filterOptions(options);
	                    options.value = vl;
	                    if (inputJson) {
	                        inputJson = $.extend(inputJson,options);
	                        $(elem).wafPassword(inputJson);
	                        if(options.validateJson){
	                            options.validateJson.errorShowMode="float";
	                            options.validateJson.validateOnSumbit=false;
	                            waf.validator.loadValidateAttr($(elem),options.validateJson);
	                        }
	                    }
	                    break;
	                case "wafcheckbox":
	                    var tmptype = "checkbox";
	                    elem = createInput(tmptype, options, vl, autowidth, ajaxso,tmptype);
	                    $(elem).attr("ctrlrole","checkbox");
	                    var inputJson = options.inputJson;
	                    filterOptions(options);
	                    options.value = vl;
	                    if (inputJson) {
	                        inputJson = $.extend(inputJson,options);
	                        $(elem).wafCheckbox(inputJson);
	                        if(options.validateJson){
	                            options.validateJson.errorShowMode="float";
	                            options.validateJson.validateOnSumbit=false;
	                            waf.validator.loadValidateAttr($(elem),options.validateJson);
	                        }
	                    }
	                    break;
	                case "wafradio":
	                    var tmptype = "radio";
	                    elem = createInput(tmptype, options, vl, autowidth, ajaxso,tmptype);
	                    var inputJson = options.inputJson;
	                    filterOptions(options);
	                    options.value = vl;
	                    if (inputJson) {
	                        inputJson = $.extend(inputJson,options);
	                        //TODO:Radio
	                    }
	                    break;
	                case "waftext":
	                    var tmptype = "text";
	                    elem = createInput(tmptype, options, vl, autowidth, ajaxso,tmptype);
	                    $(elem).attr("ctrlrole","text");
	                    //WAF.
	                    var inputJson = options.inputJson;
	                    filterOptions(options);
	                    options.value = vl;
	                    if (inputJson) {
	                        inputJson = $.extend(inputJson,options);
	                        $(elem).wafText(inputJson);
	                        if(options.validateJson){
	                            options.validateJson.errorShowMode="float";
	                            options.validateJson.validateOnSumbit=false;
	                            waf.validator.loadValidateAttr($(elem),options.validateJson);
	                        }
	                    }
	                    $(elem).css("width","100%");
	                    break;
	                case "autoComplete":
	                    elem = createInput("text", options, vl, autowidth, ajaxso,"autoComplete");
	                    $(elem).attr("ctrlrole","autoComplete");
	                    var inputJson = options.inputJson;
	                    var autoCompleteJson = options.autoCompleteJson;
	                    filterOptions(options);
	                    options.value = vl;
	                    if (inputJson) {
	                        inputJson = $.extend(inputJson,options);
	                        $(elem).wafText(inputJson);
	                        if(options.validateJson){
	                            options.validateJson.errorShowMode="float";
	                            options.validateJson.validateOnSumbit=false;
	                            waf.validator.loadValidateAttr($(elem),options.validateJson);
	                        }
	                    }
	                    if (autoCompleteJson) {
	                        $(elem).autocomplete(autoCompleteJson);
	                    }
	                    $(elem).css("width","100%");
	                    break;
	                case "f7":
	                    var input = createInput("text", options, vl, autowidth, ajaxso,"f7");
	                    if(options){
	                        var f7Json = options.f7Json,subWidgetName = options.subWidgetName,subTagJson = options.subTagJson;
	                        filterOptions(options);
	                        var f7_json = f7Json || {};
	                        f7_json=$.extend(f7_json,options);
	                        f7_json.subWidgetName = subWidgetName;
	                        f7_json.subWidgetOptions = subTagJson;
	                        $(input).wafPromptBox(f7_json);
	                        if(vl && vl!=null && typeof vl === "object"){
	                            $(input).wafPromptBox("setValue",vl);
	                        }
	                        if(options.validateJson){
	                            options.validateJson.errorShowMode="float";
	                            options.validateJson.validateOnSumbit=false;
	                            waf.validator.loadValidateAttr($(input),options.validateJson);
	                        }
	
	                        //hidden
	                        var hidden = document.createElement("input");
	                        hidden.type="hidden";
	                        hidden.value = vl;
	                        hidden.name = "hidd_name_"+options.id;
	                        hidden.id= options.id+"_el";
	
	                        $(input).attr("ctrlrole","promptBox");
	                        $(input).css("width","100%");
	                        elem = $(input).closest(".ui-f7-frame").eq(0);
	                        $(hidden).appendTo($(elem));
	                        $(elem).css("width","100%");
	                        $(elem).css("display","block");
	                    }
	                    break;
	                case "datepicker" :
	                    elem = createInput("text", options, vl, autowidth, ajaxso,"datepicker");
	                    //WAF.
	                    var datepickerjson = {};
	                    if (options.datepickerjson!=null)
	                        datepickerjson = options.datepickerjson;
	                    datepickerjson.value = vl;
	                    filterOptions(options);
	                    if (datepickerjson) {
	                        datepickerjson=$.extend(datepickerjson,options);
	                        $(elem).wafDatePicker(datepickerjson);
	                        if(options.validateJson){
	                            options.validateJson.errorShowMode="float";
	                            options.validateJson.validateOnSumbit=false;
	                            waf.validator.loadValidateAttr($(elem),options.validateJson);
	                        }
	                    }
	
	                    //hidden
	                    var hidden = document.createElement("input");
	                    hidden.type="hidden";
	                    hidden.value = vl;
	                    hidden.name = "hidd_name_"+options.id;
	                    hidden.id= options.id+"_el";
	
	                    $(elem).attr("ctrlrole","datePicker");
	                    $(elem).css("width","100%");
	                    elem = $(elem).closest(".ui-datepicker-frame").eq(0);
	                    $(hidden).appendTo($(elem));
	                    $(elem).css("width","100%");
	                    $(elem).css("display","block");
	                    break;
	                case "wafselect":
	                    elem = document.createElement("select");
	                    elem.setAttribute("ctrlrole", "select");
	                    elem.id = options.id;
	                    var  selectJson = options.selectJson;
	                    if(options.filterJson){
	                        selectJson.filterJson=options.filterJson;
	                    }
	                    filterOptions(options);
	                    selectJson = $.extend(selectJson,options);
	                    selectJson.value = vl;
	                    $(elem).wafSelect(selectJson);
	                    if(options.validateJson){
	                        options.validateJson.errorShowMode="float";
	                        options.validateJson.validateOnSumbit=false;
	                        waf.validator.loadValidateAttr($(elem),options.validateJson);
	                    }
	                    $(elem).wrap("<div></div>");
	                    $(elem).parent().css("width","100%");
	                    var tmp = $(elem).data("multiselect");
	                    tmp._trigger("onchange", "onchange", {"previous":"", "current":options.enumSource[0].value});
	                    $(tmp.button).appendTo($(elem).parent());
	
	                    //hidden
	                    var hidden = document.createElement("input");
	                    hidden.type="hidden";
	                    hidden.value = vl;
	                    hidden.name = "hidd_name_"+options.id;
	                    hidden.id= options.id+"_hidden";
	                    $(hidden).appendTo($(elem).parent());
	
	                    $(tmp.button).css("width","100%");
	                    elem = $(elem).parent();
	                    break;
	                case "numberfield":
	                    var tmptype = "text";
	                    elem = createInput(tmptype, options, vl, autowidth, ajaxso,tmptype);
	                    $(elem).attr("ctrlrole","numberField");
	                    //WAF.
	                    var inputJson = {};
	                    if (options.inputJson!=null)
	                        inputJson = options.inputJson;
	                    filterOptions(options);
	                    options.value = vl;
	                    if (inputJson) {
	                        inputJson = $.extend(inputJson,options);
	                        $(elem).wafNumberField(inputJson);
	                        $(elem).css("width",this.options.filterValueWidth-2);
	                        if(options.validateJson){
	                            options.validateJson.errorShowMode="float";
	                            options.validateJson.validateOnSumbit=false;
	                            waf.validator.loadValidateAttr($(elem),options.validateJson);
	                        }
	                        //hidden
	                        var hidden = document.createElement("input");
	                        hidden.type="hidden";
	                        hidden.value = vl;
	                        hidden.name = "hidd_name_"+options.id;
	                        hidden.id= options.id+"_el";
	
	                        $(elem).wrap("<div></div>");
	                        elem =  $(elem).parent();
	                        $(elem).css("width",this.options.filterValueWidth-2);
	                        $(hidden).appendTo($(elem));
	                    }
	                    break;
	                case "wafTextArea":
	                    var elem = document.createElement("textarea");
	                    elem.id = options.id;
	                    elem.value = vl;
	                    $(elem).attr("ctrlrole","textarea");
	                    var inputJson = options.inputJson;
	                    filterOptions(options);
	                    options.value = vl;
	                    if (inputJson) {
	                        inputJson = $.extend(inputJson,options);
	                        $(elem).wafTextarea(inputJson);
	                        if(options.validateJson){
	                            options.validateJson.errorShowMode="float";
	                            options.validateJson.validateOnSumbit=false;
	                            waf.validator.loadValidateAttr($(elem),options.validateJson);
	                        }
	                    }
	                    $(elem).css({"width":"100%","height":"100%","overflow-y":"auto"});
	//                    $(elem).css("height","100%");
	//                    $(elem).css("overflow-y","auto");
	                    break;
	                default:
	                    return $.jgrid.createEl(eltype, options, vl, autowidth, ajaxso);
	            }
	            return elem;
	        }
	});
	
	//
	waf(function(){
		waf.registerComponent("waf.simpleQuery",{
			createDOMFun:function(option){
			    //divList
			    var divList = waf("<div id='" + option.id + "_queryList' class='query cf' style='" + option.style + "'></div>");
			    //select
			    var selOps = {id:option.id+"_sel", name:option.id+"_sel", width:200};
	            var selectDom = waf.createDOM("select", selOps);
	            waf.initComponent("select", selOps, selectDom);
	            waf.appendDOM(divList, selectDom);
	            //imgSearch
	            var imgSearchOps = {id:option.id+"_search", src:"/webviews/images/search.png", type:"string", height:"20", width:"20", style:"cursor:pointer;"};
	            var imgSearchDom = waf.createDOM("img", imgSearchOps);
	            waf.initComponent("img", imgSearchOps, imgSearchDom);
	            waf.appendDOM(divList, imgSearchDom);
	            //imgMore
	            var imgMoreOps = {id:option.id+"_more", src:"/webviews/images/arrow_down.gif", type:"string", height:"20", width:"20", style:"cursor:pointer;"};
	            var imgMoreDom = waf.createDOM("img", imgMoreOps);
	            waf.initComponent("img", imgMoreOps, imgMoreDom);
	            waf.appendDOM(divList, imgMoreDom);
	            
			    //div
			    var div = waf("<div id='" + option.id + "' class='cf' style='" + option.editStyle + "'></div>");
			    //divBtn
			    var divBtn = waf("<div id='" + option.id + "_button'></div>");
			    waf.appendDOM(div, divBtn);
			    //btnAddNew
			    var btnAddNewOps = {id:option.id+"_AddNew", caption:""};
	            var btnAddNewDom = waf.createDOM("linkButton", btnAddNewOps);
	            waf.initComponent("linkButton", btnAddNewOps, btnAddNewDom);
	            waf.appendDOM(divBtn, btnAddNewDom);
	            //btnSave
			    var btnSaveOps = {id:option.id+"_Save", caption:""};
	            var btnSaveDom = waf.createDOM("linkButton", btnSaveOps);
	            waf.initComponent("linkButton", btnSaveOps, btnSaveDom);
	            waf.appendDOM(divBtn, btnSaveDom);
	            //btnSaveAs
			    var btnSaveAsOps = {id:option.id+"_SaveAs", caption:""};
	            var btnSaveAsDom = waf.createDOM("linkButton", btnSaveAsOps);
	            waf.initComponent("linkButton", btnSaveAsOps, btnSaveAsDom);
	            waf.appendDOM(divBtn, btnSaveAsDom);
	            //btnDelete
			    var btnDeleteOps = {id:option.id+"_Delete", caption:""};
	            var btnDeleteDom = waf.createDOM("linkButton", btnDeleteOps);
	            waf.initComponent("linkButton", btnDeleteOps, btnDeleteDom);
	            waf.appendDOM(divBtn, btnDeleteDom);
	            //btnSetDef
			    var btnSetDefOps = {id:option.id+"_SetDef", caption:""};
	            var btnSetDefDom = waf.createDOM("linkButton", btnSetDefOps);
	            waf.initComponent("linkButton", btnSetDefOps, btnSetDefDom);
	            waf.appendDOM(divBtn, btnSetDefDom);
	            //btnReset
			    var btnResetOps = {id:option.id+"_Reset", caption:""};
	            var btnResetDom = waf.createDOM("linkButton", btnResetOps);
	            waf.initComponent("linkButton", btnResetOps, btnResetDom);
	            waf.appendDOM(divBtn, btnResetDom);
	            
	            //divMain
			    var divMain = waf("<div id='" + option.id + "_main'></div>");
			    waf.appendDOM(div, divMain);
			    //form
			    var formOps = {id:option.id+"_form"};
	            var formDom = waf.createDOM("form", formOps);
	            waf.initComponent("form", formOps, formDom);
	            waf.appendDOM(divMain, formDom);
	            //table
			    var table = waf("<table id='" + option.id + "_edit'></table>");
			    waf.appendDOM(formDom, table);
			    
			    //divQuery
			    var divQuery = waf("<div></div>");
			    waf.appendDOM(divQuery, divList);
			    waf.appendDOM(divQuery, div);
				return divQuery;
			},
			initFun:function(option){
	    		var localeStr = waf.createObject(eval("waf.webcom.simplequery.simpleQuery" + "_LocaleStr_" + waf.getContext().locale.toLowerCase()));
	            if (option.queryPK == null) {
	                waf.msgBox.showError(localeStr.PARAM_QUERYPK_ERROR);
	                return;
	            } 
	            if (option.gridID == null) {
	                waf.msgBox.showError(localeStr.PARAM_GRIDID_ERROR);
	                return;
	            } 
	            
			    option.grid = waf("#"+option.gridID);
			    option.url = waf.getContextPath()+"/component/SimpleQuery.do";
			    option.maxFilterCount = option.maxFilterCount==null?999:option.maxFilterCount;
			    option.filterFieldWidth = option.filterFieldWidth==null?200:option.filterFieldWidth;
			    option.compareOpWidth = option.compareOpWidth==null?200:option.compareOpWidth;
			    option.filterValueWidth = option.filterValueWidth==null?200:option.filterValueWidth;
			    waf("#" + option.id).simpleQuery(option);
				waf("#" + option.id + "_search").wafImg("option","onclick",function(event) {
			        waf("#" + option.id).simpleQuery("search");
			    });
			    waf("#" + option.id + "_more").wafImg("option","onclick",function(event) {
			        waf("#" + option.id).simpleQuery("showEdit");
			    });
			    waf("#" + option.id + "_AddNew").wafLinkButton("option","onclick",function(event) {
			        waf("#" + option.id).simpleQuery("addNew");
			    });
			    waf("#" + option.id + "_Save").wafLinkButton("option","onclick",function(event) {
			        waf("#" + option.id).simpleQuery("saveSolu");
			    });
			    waf("#" + option.id + "_SaveAs").wafLinkButton("option","onclick",function(event) {
			        waf("#" + option.id).simpleQuery("saveAsSolu");
			    });
			    waf("#" + option.id + "_Delete").wafLinkButton("option","onclick",function(event) {
			        waf("#" + option.id).simpleQuery("deleteSolu");
			    });
			    waf("#" + option.id + "_SetDef").wafLinkButton("option","onclick",function(event) {
			        waf("#" + option.id).simpleQuery("setDefaultSolu");
			    });
			    waf("#" + option.id + "_Reset").wafLinkButton("option","onclick",function(event) {
			        waf("#" + option.id).simpleQuery("reset");
			    });
			}
		});
	});
//});
waf.defineClass("waf.webcom.simplequery.simpleQuery_LocaleStr_l1",waf.framework.WafCore,{
	DEFAULT:"(Default)",
	SAVE_SUCCESS:"Scheme saved successfully.",
	SAVE:"Save Scheme",
	SAVEAS:"Save Scheme as",
	INPUT_NAME:"Please enter the scheme name:",
	NEED_NAME:"Scheme name cannot be blank.",
	DEL_SOLUTION:"Are you sure you want to delete the current scheme?",
	DEL_SUCCESS:"Scheme deleted successfully." ,
	SOLUTION:"Scheme  [",
	SET_DEFAULT:"] has been set to be default scheme.",
	NEED_FILTERVAL:"Comparison value cannot be blank. Please check.",
	PARAM_QUERYPK_ERROR:"Please set the queryPK parameter for web compomnent simpleQuery to determine the data source.",
	PARAM_GRIDID_ERROR:"Please set the gridID parameter for web compomnent simpleQuery to determine the grid to show data."
});

waf.defineClass("waf.webcom.simplequery.simpleQuery_LocaleStr_l2",waf.framework.WafCore,{
	DEFAULT:"()",
	SAVE_SUCCESS:"",
	SAVE:"",
	SAVEAS:"",
	INPUT_NAME:"",
	NEED_NAME:"",
	DEL_SOLUTION:"",
	DEL_SUCCESS:"" ,
	SOLUTION:"[",
	SET_DEFAULT:"]",
	NEED_FILTERVAL:"",
	PARAM_QUERYPK_ERROR:"queryPK.",
	PARAM_GRIDID_ERROR:"gridID."
});

waf.defineClass("waf.webcom.simplequery.simpleQuery_LocaleStr_l3",waf.framework.WafCore,{
	DEFAULT:"()",
	SAVE_SUCCESS:"",
	SAVE:"",
	SAVEAS:"",
	INPUT_NAME:"",
	NEED_NAME:"",
	DEL_SOLUTION:"",
	DEL_SUCCESS:"" ,
	SOLUTION:"[",
	SET_DEFAULT:"]",
	NEED_FILTERVAL:"",
	PARAM_QUERYPK_ERROR:"queryPK.",
	PARAM_GRIDID_ERROR:"gridID."
});


/**
 * WAF
 * @author JASON LIU
 * @constructor
 */
waf.extend({
    /**
     * :
     */
    execRule:function (ruleName, options) {
        var rule = waf.createObject(eval(ruleName));
        rule.exec(options);
    }
});


/**
* WAF
* @author miaochao
*/
waf.defineClass("waf.WafRule",null,{
    /**/
    clear:function (wafCmp) {
        var id = wafCmp.attr("id"),
            ctrlrole = wafCmp.attr("ctrlrole");
        var strScript = "waf('#" + id + "')." + waf.getCmpType(ctrlrole);
        if (ctrlrole === "grid" || ctrlrole === "editGrid") {
            strScript += "('clearGridData');";
        } else {
            strScript += "('setValue',null);";
        }
        eval(strScript);
    },
    /**/
    setValue: function(wafCmp, value){
        var id = wafCmp.attr("id"),
            ctrlrole = wafCmp.attr("ctrlrole");
        var strScript = "waf('#" + id + "')." + waf.getCmpType(ctrlrole) + "('setValue',value);";
        eval(strScript);    
    },
    /**/
    getValue: function(wafCmp){
        var id = wafCmp.attr("id"),
            ctrlrole = wafCmp.attr("ctrlrole");
        var strScript = "waf('#" + id + "')." + waf.getCmpType(ctrlrole) + "('getValue');";
        return eval(strScript);    
    },
    /**/
    setGridValue: function(gridid, rowid, colname, value){
        var strScript = "waf('#" + gridid + "').wafGrid" + "('setCell', rowid, colname, value);";
        eval(strScript);    
    },
    /**/
    getGridValue: function(gridid, rowid, iCol){
        var strScript = "waf('#" + gridid + "').wafGrid" + "('getCell', rowid, iCol);";
        return eval(strScript);    
    },
    /**/
    enable: function(wafCmp){
        var id = wafCmp.attr("id"),
            ctrlrole = wafCmp.attr("ctrlrole");
        var strScript = "waf('#" + id + "')." + waf.getCmpType(ctrlrole) + "('enable');";
        eval(strScript);    
    },
    /**/
    disable: function(wafCmp){
        var id = wafCmp.attr("id"),
            ctrlrole = wafCmp.attr("ctrlrole");
        var strScript = "waf('#" + id + "')." + waf.getCmpType(ctrlrole) + "('disable');";
        eval(strScript);    
    },
    /**/
    show: function(wafCmp){
        var id = wafCmp.attr("id"),
            ctrlrole = wafCmp.attr("ctrlrole");
        var strScript = "waf('#" + id + "').";
        if (ctrlrole === "grid" || ctrlrole === "editGrid") {
            strScript += waf.getCmpType(ctrlrole) + "('option','hidden',false);";
        } else {
            strScript += "show();";
        }
        eval(strScript);    
    },
    /**/
    hide: function(wafCmp){
        var id = wafCmp.attr("id"),
            ctrlrole = wafCmp.attr("ctrlrole");
        var strScript = "waf('#" + id + "').";
        if (ctrlrole === "grid" || ctrlrole === "editGrid") {
            strScript += waf.getCmpType(ctrlrole) + "('option','hidden',true);";
        } else {
            strScript += "hide();";
        }
        eval(strScript);    
    }
});
/**
* 
* @author miaochao
*/
waf.defineClass("waf.webrule.Clear",waf.WafRule,{
    exec:function (options) {
        //params
        var wafCmps = options.wafCmps;
        //todo
		if (wafCmps && wafCmps.length>0) {
            for (var i=0;i<wafCmps.length;i++) {
                this.clear(wafCmps[i]);	
	        }
	    }
    }
});

/**
* 
* @author miaochao
*/
waf.defineClass("waf.webrule.Disable",waf.WafRule,{
    exec:function (options) {
        //params
        var wafCmps = options.wafCmps;
        //todo
		if (wafCmps && wafCmps.length>0) {
            for (var i=0;i<wafCmps.length;i++) {
                this.disable(wafCmps[i]);
	        }
	    }
    }
});
/**
* 
* @author miaochao
*/
waf.defineClass("waf.webrule.Display",waf.WafRule,{
    exec:function (options) {
        //params
        var wafCmps = options.wafCmps;
        //todo
		if (wafCmps && wafCmps.length>0) {
            for (var i=0;i<wafCmps.length;i++) {
                this.show(wafCmps[i]);
	        }
	    }
    }
});
/**
* 
* @author miaochao
*/
waf.defineClass("waf.webrule.Enable",waf.WafRule,{
    exec:function (options) {
        //params
        var wafCmps = options.wafCmps;
        //todo
		if (wafCmps && wafCmps.length>0) {
            for (var i=0;i<wafCmps.length;i++) {
                this.enable(wafCmps[i]);
	        }
	    }
    }
});
/**
* F7
* @author miaochao
*/
waf.defineClass("waf.webrule.GridPromptRel",waf.WafRule,{
    exec:function (options) {
        //params
        var pmtColumn = options.pmtColumn;
        var colname = options.colname;
        var promptValues = options.promptValues;
        var destRowId = options.destRowId;
        var destColumns = options.destColumns;
        
        //todo
        if (pmtColumn.column == colname) {
            for (var i=0;i<destColumns.length;i++) {
                var destGrid = destColumns[i].grid;
                this.setGridValue(destGrid,destRowId,destColumns[i].column,promptValues[i]);	
    	    }
	    }
    }
});
/**
* 
* @author miaochao
*/
waf.defineClass("waf.webrule.Hide",waf.WafRule,{
    exec:function (options) {
        //params
        var wafCmps = options.wafCmps;
        //todo
		if (wafCmps && wafCmps.length>0) {
	        for (var i=0;i<wafCmps.length;i++) {
                this.hide(wafCmps[i]);
	        }
	    }
    }
});
/**
* F7
* @author miaochao
*/
waf.defineClass("waf.webrule.PromptRel",waf.WafRule,{
    exec:function (options) {
        //params
        var promptValues = options.promptValues;
        var destCmps = options.destCmps;
        //todo
		for (var i=0;i<destCmps.length;i++) {
            this.setValue(destCmps[i],promptValues[i]);	
	    }
    }
});
    /**
     * WAFII 
     */
    waf.pageBuilder={

        /**
         * 
         */
        pageMsgAreaBox:null,

        /**
         * 
         */
        _componentBuilderLib:new Map(),

        /**
         * Render
         */
        beforeRender:null,

        /**
         * 
         */
        _registerComponentBuilder:function(metaType,componentType,componentBuilder){
            var builderElement=new Object();
            builderElement.metaType=metaType;
            builderElement.componentType=componentType;
            var builder=null;
            if(componentBuilder!=null) {
                builder=new componentBuilder();
                builder.componentType=componentType;
                builderElement.componentBuilder=builder;
            }

            this._componentBuilderLib.put(metaType,builderElement);
        },
        /**
         * 
         */
        _initComponentBuilder:function(){
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.RootPane","rootPane",null);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.GridLayoutPanel","gridLayoutPanel",waf.GridLayoutPanelComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.GridLayoutCell","gridLayoutCell",null);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.ColumnLayoutPanel","panel",waf.ColumnLayoutPanelBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.ColumnLayoutCell","column",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.IteratorPanel","iteratorPanel",null);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.Section","section",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.Form","form",waf.FormComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.ToolBar","toolBar",waf.ToolbarComponentBuilder);
            //this._registerComponentBuilder("com.kingdee.bos.ctrl.web.Validator","validator",waf.ValidatorComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.InfoBlock","infoBlock",waf.InfoBlockComponentBuilder)
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.Button","linkButton",waf.ButtonComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.MsgArea","msgArea",waf.MsgAreaComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.QuickSearch","waf.quickSearch",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.CommonQuery","waf.commonQuery",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.Report","waf.report",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.DataImpExp","waf.dataImpExp",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.GeneralSearch","waf.simpleQuery",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.SearchBar","waf.searchBar",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.Botp","waf.botp",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.Html","waf.botp",waf.HtmlComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.WorkFlow","workFlow",null);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.WebAttachment","waf.webAttachment",waf.WebAttachmentComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.DataGrid","grid",waf.DataGridComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.LabelContainer","labelContainer",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.TextField","text",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.NumberField","numberField",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.DateField","datePicker",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.TimePicker","timePicker",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.PromptBox","promptBox",waf.PromptBoxComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.ComboBox","select",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.CheckBox","checkbox",waf.CheckBoxComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.MultiLangBox","multiLangBox",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.MultiLangArea","multiLangArea",waf.MultiLangAreaComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.TextArea","textarea",waf.TextAreaComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.BizCommonQuery","waf.bizCommonQuery",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.BreadCrumbs","waf.breadCrumbs",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.TabPanel","tabPanel",waf.TabPanelComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.MenuButton","menuButton",waf.MenuButtonComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.MenuItem","menuItem",waf.MenuItemComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.RadioGroup","radioGroup",waf.GeneralComponentBuilder);
            //this._registerComponentBuilder("com.kingdee.bos.ctrl.web.Tab","tab",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.Hidden","hidden",waf.GeneralComponentBuilder);
            this._registerComponentBuilder("com.kingdee.bos.ctrl.web.Label","label",waf.GeneralComponentBuilder);

        },

        /**
         * 
         * @param {} pageMetadata
         */
        _getComponentBuilder:function(metaType){
            return this._componentBuilderLib.get(metaType);
        },

        /**
         * 
         * @param {} pageMetadata 
         */
        render:function(pageMetadata,dataBindEnabled,domRender,comInit) {
            if(dataBindEnabled==undefined || dataBindEnabled==null){
                dataBindEnabled=true;
            }
            if(domRender==undefined || domRender==null){
                domRender=true;
            }
            if(comInit==undefined || comInit==null){
                comInit=true;
            }

            this._initComponentBuilder();
            var pageStatelessMetadata=$.extend(true,{},pageMetadata);
            this.model = _self&&_self.getCurrentModel && _self.getCurrentModel();
            this._buildComponent(pageMetadata,null,null,dataBindEnabled,domRender,comInit);
            return pageStatelessMetadata;
        },
        /*
         * _
         */
        searchComponent:function(componentId,pageMetadata){
            /*  */
            if(pageMetadata==null || pageMetadata==undefined)
                return null;

            if(pageMetadata.id==componentId) {
                return pageMetadata;
            }

            for(var index=0;index<pageMetadata.childrens.length;index++){
                var result=this.searchComponent(componentId,pageMetadata.childrens[index]);
                if(result!=null){
                    return result;
                }
            }

            return null;
        },
        /**
         * 
         * @param {} metaComponent
         * @param {} parentComponent
         * @param {} iteratorKey
         * @param {} dataBindEnabled
         */
        searchComponentByDataBind:function(property,pageMetadata){
            /*  */
            if(pageMetadata==null || pageMetadata==undefined)
                return null;

            if(pageMetadata.field==property) {
                return pageMetadata;
            }

            for(var index=0;index<pageMetadata.childrens.length;index++){
                var result=this.searchComponentByDataBind(property,pageMetadata.childrens[index]);
                if(result!=null){
                    return result;
                }
            }

            return null;
        },
        /**
         * 
         * @param {} type
         */
        _buildComponent:function(metaComponent,parentComponent,iteratorKey,dataBindEnabled,domRender,comInit){
            if(metaComponent==null){
                return ;
            }

            if(domRender==undefined || domRender==null){
                domRender=true;
            }
            if(comInit==undefined || comInit==null){
                comInit=true;
            }

            //
            var componentBuilder;
            var needIteratorRender=true;
            var componentBuildElement=this._getComponentBuilder(metaComponent.componentType);
            if(componentBuildElement!=undefined || componentBuildElement!=null) {
                if(componentBuildElement.componentBuilder!=null && componentBuildElement.componentBuilder!=undefined) {
                    componentBuilder=componentBuildElement.componentBuilder;
                    //
                    metaComponent=componentBuilder.specialProperty(metaComponent,parentComponent,metaComponent.parentEl,iteratorKey);
                    //
                    if(this.beforeRender){
                        metaComponent.properties=this.beforeRender(metaComponent.properties);
                    }
                    //
                    needIteratorRender=componentBuilder.render(metaComponent,parentComponent,metaComponent.parentEl,null,iteratorKey,domRender,comInit) && componentBuilder.isIteratorAble();

                    //
                    if(parentComponent.componentType==""){
                        //todo:
                    }


                    //
                    if(dataBindEnabled && componentBuilder.getDataBinderEnabled()==true && waf.dataBinder) {
                        if(metaComponent.field!=undefined && metaComponent.field!=null) {
                            var xtype,dataBinderProp;
                            xtype=waf.wafCmpTypeLib.get(componentBuildElement.componentType);
                            dataBinderProp=componentBuilder.getDataBinderProp();
                            if(xtype==undefined || xtype==null){
                                xtype=componentBuildElement.componentType;
                            }
                            if(dataBinderProp==undefined || dataBinderProp==null){
                                dataBinderProp="value";
                            }
                            waf.dataBinder.registerDataBinder(metaComponent.field,metaComponent.id,xtype,dataBinderProp,componentBuilder.getComponentValueType());
                        }
                    }
                }
            }

            //
            if(componentBuildElement!=undefined || componentBuildElement!=null) {
                if(componentBuildElement.componentBuilder!=null && componentBuildElement.componentBuilder!=undefined) {
                    componentBuilder=componentBuildElement.componentBuilder;
                    componentBuilder.createComplete(metaComponent,parentComponent,metaComponent.parentEl,iteratorKey);
                }
            }

            if(needIteratorRender){
                for(var index in metaComponent.childrens){
                    this._buildComponent(metaComponent.childrens[index],metaComponent,iteratorKey,dataBindEnabled,domRender,comInit);
                }
            }

            //
            if(componentBuildElement!=undefined || componentBuildElement!=null) {
                if(componentBuildElement.componentBuilder!=null && componentBuildElement.componentBuilder!=undefined) {
                    componentBuilder=componentBuildElement.componentBuilder;
                    componentBuilder.createAllComplete(metaComponent,parentComponent,metaComponent.parentEl,iteratorKey);
                }
            }
        }
    };

    /**
     * WAFII 
     */
    waf.defineClass("waf.GeneralComponentBuilder",null,{
        /**
         * 
         */
        componentType:null,

        /**
         * 
         */
        getDataBinderProp:function(){
            return "value";
        },
        /**
         * 
         */
        getComponentValueType:function(){
            return "object";
        },
        /**
         * 
         */
        getDataBinderEnabled:function(){
            return true;
        },
        /**
         * 
         */
        specialProperty:function(component,parent,parentEl,operateStatus,iteratorKey){
            if(parent!=null && parent.componentType=="com.kingdee.bos.ctrl.web.LabelContainer"){
                component.parentEl=component.parentEl + "_ctrl";
            }
            return component;
        },
        /**
         * 
         */
        render:function(component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit) {
            var parentComponent=waf("#" + parentEl);
            //
            var cmpType=this.componentType;
            this.escapeSpecialCharOfObject(component.properties);

            var dom = null;

            if(domRender){
                dom=waf.createDOM(cmpType, component.properties);
                waf.appendDOM(parentComponent,dom);
            }

            if(comInit){
                waf.initComponent(cmpType,component.properties,dom);
                //
                this.appendValidator(component,dom,parent,parentEl,operateStatus,iteratorKey);
            }

            //true,false,
            return true;
        },
        /**
         * 
         * @return {Boolean}
         */
        isIteratorAble:function() {
            return true;
        },
        appendValidator:function(component,component_dom,parent,parentEl,operateStatus,iteratorKey){
            if(component.properties.validator_rules==undefined || component.properties.validator_rules==null){
                return ;
            }
            var validatorProperty={};
            for(var properties in component.properties){
                if(properties.indexOf("_")>0) {
                    if(properties.substr(0,properties.indexOf("_"))=="validator") {
                            hasValidator=true;
                            var key=properties.substr(properties.indexOf("_")+1);
                            var value=component.properties[properties];
                            eval("validatorProperty." + key + "=value");
                    }
                }
            }

            waf.initComponent("validator",validatorProperty,component_dom);
            waf("#" + parentEl).wafLabelContainer('initRequiredMask');
        },
        /**
         * )
         */
        createComplete:function(component,parent,parentEl,operateStatus,iteratorKey){},

        /**
         * 
         */
        createAllComplete:function(component,parent,parentEl,operateStatus,iteratorKey){},

        /**
         * JSONObjectjs
         */
        checkJSObjectValue:function(value){
            if(value==undefined || value==null){
                return value;
            }

            var nStartPrefix=value.indexof("<jsonobject>");
            var nEndPrefix=value.indexof("</jsonobject>")-13;

            if(value.indexOf("<jsonobject>")==0 && value.indexOf("</jsonobject>")==value.length-13){
                value=value.substr(nStartPrefix,nEndPrefix);
            }

            return eval(value);
        },
        escapeSpecialCharOfObject:function(properties){
            if(properties){
                //TODO:
                var regexp = /@(.*?)@/gi;
                var jsonArr,value;
                for(var p in properties){
                    value = properties[p];
                    if(value && $.type.isString(value)){
                        jsonArr = value.match(regexp);
                        if(jsonArr && $.isArray(jsonArr) && jsonArr.length>0){
                            properties[p] = eval(value.substring(1,value.length-1));
                        }
                    }
                    if($.type.isObject(value) && !$.isFunction(value)){
                        this.escapeSpecialCharOfObject(value);
                    }
                }
            }
        }
    });

    /**
     * 
     */
    waf.defineClass("waf.ColumnLayoutPanelBuilder",waf.GeneralComponentBuilder,{
        /**
         * 
         */
        specialProperty:function(component,parent,parentEl,operateStatus,iteratorKey) {
            component.properties.layout="column";

            return component;
        },

        /**
         * )
         */
        createAllComplete:function(component,parent,parentEl,operateStatus,iteratorKey){
            waf("#" + component.id).wafColumnLayout();
        }
    });

    /**
     * 
     */
    waf.defineClass("waf.MsgAreaComponentBuilder",waf.GeneralComponentBuilder,{
        /**
         * 
         */
        render:function(component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit) {
            waf.MsgAreaComponentBuilder.superClass.render.call(this,component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit);

            if(waf.getPageMsgAreaBox()==null){
                waf.setPageMsgAreaBox(waf("#" + component.id));
            }

            return component;
        }
    });

    /**
     * 
     */
    waf.defineClass("waf.HtmlComponentBuilder",waf.GeneralComponentBuilder,{
        /**
         * 
         */
        render:function(component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit) {
            //
            if(domRender){
                waf("#" + parentEl).append(component.properties.htmlContent);
            }

            return component;
        }
    });

    waf.defineClass("waf.TabPanelComponentBuilder",waf.GeneralComponentBuilder,{
        render:function(component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit) {
            waf.TabPanelComponentBuilder.superClass.render.call(this,component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit);

            if(comInit){
                for(var nIndex=0;nIndex<component.childrens.length;nIndex++){
                    var tab=component.childrens[nIndex];
                    this.escapeSpecialCharOfObject(tab.properties);
                    waf("#" + component.id).wafTabs("add",tab.properties);
                }
            }

            return component;
        }
    });
    waf.defineClass("waf.WebAttachmentComponentBuilder",waf.GeneralComponentBuilder,{
        /**
         * 
         */
        specialProperty:function(component,parent,parentEl,operateStatus,iteratorKey){
            component=waf.WebAttachmentComponentBuilder.superClass.specialProperty.call(this,component,parent,parentEl,operateStatus,iteratorKey);
            component.properties.id=component.id;
            component.properties.url=waf.getContextPath() + "/component/WebAttachment.do";
            return component;
        }
    });

    waf.defineClass("waf.ToolbarComponentBuilder",waf.GeneralComponentBuilder,{
        /**
         * 
         */
        specialProperty:function(component,parent,parentEl,operateStatus,iteratorKey){
            var urlParams=waf.getUrlParams(document.location.href);
            if(urlParams.hasToolbar=="false"){
                component.properties.hidden=true;
                component.properties.style="display:none";
            }

            return component;
        }
    });

    waf.defineClass("waf.MultiLangAreaComponentBuilder",waf.GeneralComponentBuilder,{
        /**
         * 
         */
        specialProperty:function(component,parent,parentEl,operateStatus,iteratorKey){
            component=waf.MultiLangAreaComponentBuilder.superClass.specialProperty.call(this,component,parent,parentEl,operateStatus,iteratorKey);
            return component;
        }
    });

    waf.defineClass("waf.TextAreaComponentBuilder",waf.GeneralComponentBuilder,{
        /**
         * 
         */
        specialProperty:function(component,parent,parentEl,operateStatus,iteratorKey){
            component=waf.TextAreaComponentBuilder.superClass.specialProperty.call(this,component,parent,parentEl,operateStatus,iteratorKey);
            if(parent.classType=="com.kingdee.bos.ctrl.web.GridLayoutCell") {
                var rowSpan=parent.properties.endRow-parent.properties.startRow;
                var colSpan=parent.properties.endCol-parent.properties.startCol;
            }
            return component;
        }
    });

    waf.defineClass("waf.FormComponentBuilder",waf.GeneralComponentBuilder,{
        /**
         * 
         */
        specialProperty:function(component,parent,parentEl,operateStatus,iteratorKey){
            component=waf.FormComponentBuilder.superClass.specialProperty.call(this,component,parent,parentEl,operateStatus,iteratorKey);
            component.properties.validateOptions = "{errorContainer:waf('#msgArea1')}";
            return component;
        }
    });

    waf.defineClass("waf.InfoBlockComponentBuilder",waf.GeneralComponentBuilder,{
        /**
         * 
         */
        getDataBinderProp:function(){
            return "data";
        },
        specialProperty:function(component,parent,parentEl,operateStatus,iteratorKey){
            component=waf.InfoBlockComponentBuilder.superClass.specialProperty.call(this,component,parent,parentEl,operateStatus,iteratorKey);
            component.properties.id=component.id;


            var infoBlock={
                buttonPanel:component.childrens[1],
                rowButtonPanel:component.childrens[2]
            };

            infoBlock.rowObject={id:"rowObject",parent:component.id,parentEl:component.id,properties:{}};
            component.childrens[0].parent="rowObject";
            component.childrens[0].parentEl="rowObject";
            infoBlock.rowObject.childrens=[component.childrens[0]];
            component.childrens=[infoBlock];
            component.properties.rowMeta=$.extend(true,{},component);
            component.properties.rowMeta.properties={};
            component.field=component.properties.entryProp;
            if(component.field!=null){
                component.field=component.field.substr(0,1).toLowerCase() + component.field.substr(1);
            }

            if(component.properties.seq==undefined || component.properties.seq==null){
                component.properties.seq=true;
            }

            return component;
        },
        render:function(component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit) {
            var parentComponent=waf("#" + parentEl);
            //
            var cmpType=this.componentType;
            this.escapeSpecialCharOfObject(component.properties);
            var dom = null;

            if(domRender){
                dom=waf.createDOM(cmpType, component.properties);
                waf.appendDOM(parentComponent,dom);
            }

            if(comInit){
                waf.initComponent(cmpType,component.properties,dom);
            }

            return false;
        }
    });

    waf.defineClass("waf.ButtonComponentBuilder",waf.GeneralComponentBuilder,{
        /**
         * 
         */
        specialProperty:function(component,parent,parentEl,operateStatus,iteratorKey){
            component=waf.ButtonComponentBuilder.superClass.specialProperty.call(this,component,parent,parentEl,operateStatus,iteratorKey);
            //ActionActionActionAction
            if(component.properties.actionBinding!=null){
                component.properties.actionBinding=component.properties.actionBinding + "Action";
            }
            /*
            if(component.properties.tagClass==undefined || component.properties.tagClass==null){
                component.properties.tagClass="btn blue";
            }
            */

            return component;
        }
        ,
        render:function(component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit) {
            if(parent.componentType==="com.kingdee.bos.ctrl.web.ToolBar" && domRender) {
                parentEl=component.id + "_content";
                var parentContent=waf("#" + parent.id).children(".ui-toolbar-main").children(".ui-toolbar-ul");
                parentContent.append("<li id='" + parentEl + "'></li>");
            }
            waf.ButtonComponentBuilder.superClass.render.call(this,component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit);
            return true;
        }
    });

    waf.defineClass("waf.MenuButtonComponentBuilder",waf.GeneralComponentBuilder,{
        /**
         * 
         */
        specialProperty:function(component,parent,parentEl,operateStatus,iteratorKey){
            component=waf.ButtonComponentBuilder.superClass.specialProperty.call(this,component,parent,parentEl,operateStatus,iteratorKey);
            //ActionActionActionAction
            if(component.properties.actionBinding!=null){
                component.properties.actionBinding=component.properties.actionBinding + "Action";
            }
            /*
            if(component.properties.tagClass==undefined || component.properties.tagClass==null){
                component.properties.tagClass="btn blue";
            }
            */

            return component;
        }
        ,
        render:function(component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit) {
            if(parent.componentType==="com.kingdee.bos.ctrl.web.ToolBar" && domRender) {
                parentEl=component.id + "_content";
                var parentContent=waf("#" + parent.id).children(".ui-toolbar-main").children(".ui-toolbar-ul");
                parentContent.append("<li id='" + parentEl + "'></li>");
            }
            waf.ButtonComponentBuilder.superClass.render.call(this,component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit);
            return true;
        }
    });

    waf.defineClass("waf.MenuItemComponentBuilder",waf.GeneralComponentBuilder,{
        /**
         * 
         */
        specialProperty:function(component,parent,parentEl,operateStatus,iteratorKey){
            component=waf.ButtonComponentBuilder.superClass.specialProperty.call(this,component,parent,parentEl,operateStatus,iteratorKey);
            //ActionActionActionAction
            if(component.properties.actionBinding!=null){
                component.properties.actionBinding=component.properties.actionBinding + "Action";
            }
            /*
            if(component.properties.tagClass==undefined || component.properties.tagClass==null){
                component.properties.tagClass="btn blue";
            }
            */

            return component;
        }
        ,
        render:function(component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit) {
            if(parent.componentType==="com.kingdee.bos.ctrl.web.MenuButton") {
                var cmpType=this.componentType;
                this.escapeSpecialCharOfObject(component.properties);
                var dom = null;
                if(domRender){
                    dom=waf.createDOM(cmpType, component.properties);
                    waf("#" + parentEl).wafMenuButton("appendChildren",dom);
                }
                if(comInit){
                    waf.initComponent(cmpType,component.properties,dom);
                }
            }
            return true;
        }
    });

    waf.defineClass("waf.ValidatorComponentBuilder",waf.GeneralComponentBuilder,{
        /**
         * 
         */
        specialProperty:function(component,parent,parentEl,operateStatus,iteratorKey){
            component=waf.ValidatorComponentBuilder.superClass.specialProperty.call(this,component,parent,parentEl,operateStatus,iteratorKey);
            return component;
        },
        render:function(component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit) {

        }
    });

    /**
     * :
     */
    waf.defineClass("waf.GridLayoutPanelComponentBuilder",waf.GeneralComponentBuilder,{

        /**
         * 
         */
        render:function(component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit) {
            var parentComponent=null;
            if(parentEl==null || parentEl==undefined){
                parentComponent=waf(".page_margins ");
            }
            else {
                parentComponent=waf("#" + parentEl);
            }

            var cellMerge=this.findTableMergeCell(component);
            var tableDomDesc="<table id='" + component.id + "' border='0' width='100%' class='commontable'>";
            var colWidth=100/component.properties.cols;
            for(var nRow=1;nRow<=component.properties.rows;nRow++){
                var row="<tr>";
                //
                rowFetch=nRow;
                for(var nColumn=1;nColumn<=component.properties.cols;nColumn++){
                    if(cellMerge.colMerge.get(nColumn)==null  || cellMerge.colMerge.get(nColumn)==undefined){
                        continue;
                    }

                    //,
                    var currentCell;
                    var rowSpan=1,colSpan=1;
                    for(var nCellIndex=0;nCellIndex<component.childrens.length;nCellIndex++){
                        var componentCell=component.childrens[nCellIndex];
                        if(componentCell.properties.startRow==nRow && componentCell.properties.startCol==nColumn) {
                            rowSpan=componentCell.properties.endRow-componentCell.properties.startRow + 1;
                            colSpan=componentCell.properties.endCol-componentCell.properties.startCol + 1;
                        }
                        if(componentCell.properties.startRow==nRow && componentCell.properties.startCol==nColumn){
                            currentCell=componentCell;
                            break;
                        }
                    }

                    var abortGen=false;
                    if(currentCell.properties.startRow!=currentCell.properties.endRow || currentCell.properties.startCol!=currentCell.properties.endCol){
                        for(var nCellIndex=0;nCellIndex<component.childrens.length;nCellIndex++){
                            var componentCell=component.childrens[nCellIndex];

                            if(componentCell.properties.startRow>=nRow && componentCell.properties.startCol>=nColumn)
                                continue;

                            if(componentCell.properties.startRow<nRow && (componentCell.properties.startRow+(componentCell.properties.endRow-componentCell.properties.startRow)>=nRow)){
                                if(componentCell.properties.startCol<nColumn && (componentCell.properties.startCol+(componentCell.properties.endCol-componentCell.properties.startCol)>=nColumn)){
                                    abortGen=true;
                                    break;
                                }
                            }
                        }
                    }

                    if(abortGen)
                        continue;

                    row = row + "<td id='" + currentCell.id  + "' style='padding:0' rowspan='" + rowSpan + "' colspan='" + colSpan + "' width='" + (colWidth * colSpan) + "%'>";
                    row = row + "</td>"
                }

                row=row + "</tr>";
                tableDomDesc=tableDomDesc+row;
            }
            tableDomDesc = tableDomDesc + "</table>";
            parentComponent.append(tableDomDesc);

            for(var nCellIndex=0;nCellIndex<component.childrens.length;nCellIndex++){
                var componentCell=component.childrens[nCellIndex];
                if(componentCell.properties.align!=null || componentCell.properties.align!=undefined){
                    waf("#" + component.id + "_" + componentCell.properties.startRow + "_" + componentCell.properties.startCol).attr("align",componentCell.properties.align);
                }
                if(componentCell.properties.valign!=null || componentCell.properties.valign!=undefined){
                    waf("#" + component.id + "_" + componentCell.properties.startRow + "_" + componentCell.properties.startCol).attr("valign",componentCell.properties.valign);
                }
            }

            return true;
        },
        /*  */
        findTableMergeCell:function(tableLayout){
            var result=new Object();
            var rowMerge=new Map();
            var colMerge=new Map();
            var cellMerge=new Map();
            for(var index=0;index<tableLayout.childrens.length;index++){
                var tableLayoutCell=tableLayout.childrens[index];
                rowMerge.put(tableLayoutCell.properties.startRow,tableLayoutCell);
                colMerge.put(tableLayoutCell.properties.startCol,tableLayoutCell);
            }
            result.rowMerge=rowMerge;
            result.colMerge=colMerge;
            return result;
        }
    });

    /**
     * WAFII 
     */
    waf.defineClass("waf.DataGridComponentBuilder",waf.GeneralComponentBuilder,{

        /**
         * 
         */
        getDataBinderProp:function(){
            return "gridData";
        },

        /**
         * 
         */
        specialProperty:function(component,parent,parentEl,operateStatus,iteratorKey){
            component=waf.DataGridComponentBuilder.superClass.specialProperty.call(this,component,parent,parentEl,operateStatus,iteratorKey);
            if(component.properties.isEditGrid){
                return this.specialEditDataGrid(component);
            }
            else {
                return this.specialDataGrid(component);
            }
        },
        /**
         * 
         */
        specialDataGrid:function(component){
            component.properties.id=component.id;
            if(component.properties.datatype==undefined || component.properties.datatype==null) {
                component.properties.datatype="json";
            }
            if(component.properties.url==undefined || component.properties.url==null) {
                component.properties.url="?method=doEvent&uipk=" + _self.getUIPk() + "&action=listData&conversationid=" + waf.getConversationID();
            }
            component.properties.loadInit=false;
            component.properties.pagerModel="block";
            component.properties.colModel=new Array();
            var colDesc="";
            for(var nIndex=0;nIndex<component.childrens.length;nIndex++){
                var children=component.childrens[nIndex];
                children.properties.index=children.id;
                children.properties.name=children.properties.dataBind;
                children.properties.index=children.properties.dataBind;
                component.properties.colModel.push(children.properties);
                colDesc=colDesc + children.properties.dataBind;
                if(nIndex<component.childrens.length-1){
                    colDesc = colDesc + ",";
                }
                if(children.properties.csCL && children.properties.csCL==true){
                    var actions = [];
                    if(children.childrens.length>0){
                        for(var i=0;i<children.childrens.length;i++){
                            var tmp = {};
                            tmp.linkJson = children.childrens[i].properties;
                            tmp.visible = true;
                            tmp.actionBindingName = children.childrens[i].properties.actionBinding;
                            actions.push(tmp);
                        }
                        children.properties.formatter = "operations";
                        children.properties.formatoptions = actions;
                    }
                }
            }
            if(component.properties.rowList==undefined || component.properties.rowList==null){
                component.properties.rowList=[5, 10, 20, 40, 50];
            }
            if(component.properties.rowNum==undefined || component.properties.rowNum==null){
                component.properties.rowNum=20;
            }
            waf.extend(component.properties, {pager:"#pager" + component.id, rowList:component.properties.rowList, rowNum:component.properties.rowNum});
            var postData=new Object();
            postData.filterItems=component.properties.filterItems;
            postData.queryPK=component.properties.queryPK;
            postData.sorterItems=component.properties.sorterItems;
            postData.businessObject=component.properties.businessObject;
            postData.queryMode=component.properties.queryMode;
            postData.columnModel=colDesc;
            postData.includePager=true;

            component.properties.postData=postData;

            return component;
        },
        /**
         * 
         */
        specialEditDataGrid:function(component){
            var grid_option=component.properties;
            grid_option.id=component.id;
            grid_option.datatype="local";
            if(grid_option.editable==undefined)grid_option.editable=true;
            /*
            if(grid_option.editModelOptions){
                var editModelOptions=waf.toJSONObject(grid_option.editModelOptions.replace(new RegExp("'", 'g'), "\""));
                grid_option.editModelOptions=editModelOptions;
            }
            */
            grid_option.cellsubmit="clientArray";
            grid_option._type_="EditGrid";
            component.field=component.properties.entryProp;
            grid_option.colModel=new Array();
            for(var nIndex=0;nIndex<component.childrens.length;nIndex++){
                var children=component.childrens[nIndex];
                children.properties.name=children.properties.dataBind;
                if(children.properties.editable==undefined || children.properties.editable==null){
                    children.properties.editable=true;
                }
                if(children.componentType=="com.kingdee.bos.ctrl.web.Column"){
                    if(children.childrens.length>0){
                        var editor=children.childrens[0];
                        var editor_option={};
                        if(editor.componentType=="com.kingdee.bos.ctrl.web.TextField"){
                             editor_option.edittype="waftext";
                             editor_option.formatter="waftext";
                             editor_option.editoptions=editor_option.editoptions||{};
                             editor_option.editoptions.inputJson=$.extend(editor_option.editoptions.inputJson||{},editor.properties);
                        }
                        if(editor.componentType=="com.kingdee.bos.ctrl.web.TextArea"){
                             editor_option.edittype="wafTextArea";
                             editor_option.formatter="wafTextArea";
                            editor_option.editoptions=editor_option.editoptions||{};
                             editor_option.editoptions.inputJson=$.extend(editor_option.editoptions.inputJson||{},editor.properties);
                        }
                        if(editor.componentType=="com.kingdee.bos.ctrl.web.CheckBox"){
                             editor_option.edittype="wafcheckbox";
                             editor_option.formatter="wafcheckbox";
                             editor_option.editoptions=editor_option.editoptions||{};
                             editor_option.editoptions.inputJson=$.extend(editor_option.editoptions.inputJson||{},editor.properties);
                        }
                        if(editor.componentType=="com.kingdee.bos.ctrl.web.NumberField"){
                             editor_option.edittype="numberfield";
                             editor_option.formatter="numberfield";
                             editor_option.editoptions=editor_option.editoptions||{};
                             editor_option.editoptions.inputJson=$.extend(editor_option.editoptions.inputJson||{},editor.properties);
                        }
                        if(editor.componentType=="com.kingdee.bos.ctrl.web.DateField"){
                             editor_option.edittype="datepicker";
                             editor_option.formatter="datepicker";
                             editor_option.editoptions=editor_option.editoptions||{};
                             editor_option.editoptions.datepickerjson=$.extend(editor_option.editoptions.datepickerjson||{},editor.properties);
                        }
                        if(editor.componentType=="com.kingdee.bos.ctrl.web.ComboBox"){
                             editor_option.edittype="wafselect";
                             editor_option.formatter="wafselect";
                             editor_option.editoptions=editor_option.editoptions||{};
                             editor_option.editoptions.selectJson=editor.properties;
                             editor_option.editoptions.enumSource=$.extend(editor_option.editoptions.enumSource||[],editor.properties.enumSource);
                        }
                        else if(editor.componentType=="com.kingdee.bos.ctrl.web.PromptBox"){
                            editor_option.edittype="f7";
                            editor_option.formatter="f7";
                            editor_option.editoptions=editor_option.editoptions||{f7Json:{}};
                            var showType = "";
                            if(editor.properties.F7Type=="F7Quick"){
                                editor_option.editoptions.subWidgetName="wafPromptQuick";
                                showType = "F7Quick";
                                editor_option.editoptions.subTagJson={dataUrl:waf.getContextPath() + "/component/F7Quick.do?method=initalize"};
                            }
                            else if(editor.properties.F7Type=="F7Tree"){
                                editor_option.editoptions.subWidgetName="wafPromptTree";
                                showType = "F7Tree";
                                editor_option.editoptions.subTagJson={dataUrl:waf.getContextPath() + "/component/promptTree.do?method=getTreeData"};
                            }
                            else if(editor.properties.F7Type=="F7Grid"){
                                editor_option.editoptions.subWidgetName="wafPromptGrid";
                                showType = "F7Grid";
                                editor_option.editoptions.subTagJson={dataUrl:waf.getContextPath() + "/component/F7Grid.do?method=initalize"};
                            }
                            else if(editor.properties.F7Type=="F7Iframe"){
                                editor_option.editoptions.subWidgetName="wafPromptIFrame";
                                showType = "F7Iframe";
                                editor_option.editoptions.subTagJson={url:waf.getContextPath() + editor.properties.F7Iframe_url};
                            }
                            else if(editor.properties.F7Type=="F7Standard"){
                                editor_option.editoptions.subWidgetName="wafPromptStandard";
                                showType = "F7Standard";
                                editor_option.editoptions.subTagJson={dataUrl:waf.getContextPath() + "/component/F7Standard.do?method=initalize"};
                            }
                            else if(editor.properties.F7Type=="F7Table"){
                                editor_option.editoptions.subWidgetName="wafPromptTable";
                                showType = "F7Table";
                                editor_option.editoptions.subTagJson={url:waf.getContextPath() + "/component/promptTable.do"};
                            }else if(editor.properties.F7Type=="F7Autocomplete"){
                                editor_option.editoptions.subWidgetName="wafPromptAutoComplete";
                                showType = "F7Autocomplete";
                                editor_option.editoptions.subTagJson={urlSource:waf.getContextPath() + "/component/promptAutoComplete.do?method=getData"};
                            }
                            var prop,pos;
                            for(var p in editor.properties){
                                pos = p.indexOf(showType);
                                if(pos>-1){
                                    prop = p.substring(pos+showType.length+1);
                                    editor_option.editoptions.subTagJson[prop] = editor.properties[p];
                                }
                            }
                        }
                        var option = {};
                        waf.extend(true,option,editor_option,children.properties);
                        children.properties = option;
                    }
                    grid_option.colModel.push(children.properties);
                }
            }
            if(component.properties && component.properties.pagerModel && component.properties.pagerModel == "undefined"){
                component.properties.pagerModel = "traditional";
            }
            return component;
        },
        render:function(component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit) {
            waf.DataGridComponentBuilder.superClass.render.call(this,component,parent,parentEl,operateStatus,iteratorKey,domRender,comInit);
            return false;
        },
        isIteratorAble:function(){
            return false;
        }
    });

    /**
     * WAFII F7
     */
    waf.defineClass("waf.PromptBoxComponentBuilder",waf.GeneralComponentBuilder,{

        /**
         * 
         */
        specialProperty:function(component,parent,parentEl,operateStatus,iteratorKey){
            component=waf.PromptBoxComponentBuilder.superClass.specialProperty.call(this,component,parent,parentEl,operateStatus,iteratorKey);
            if(component.properties.F7Type=="F7Quick") {
                component.properties.submitField= "#" + component.id + "_el";
                component.properties.subWidgetName="wafPromptQuick";
                component.properties.inIframe=true;

                this.specialSubProperty(component,"subWidgetOptions","F7Quick",parent,parentEl,operateStatus,iteratorKey);
                waf.extend(component.properties.subWidgetOptions,{data:component.properties.data,dataUrl:waf.getContextPath() + "/component/F7Quick.do?method=initalize",submitField:component.id + "_el"});
                //component.properties.subWidgetOptions={data:component.properties.data,dataUrl:waf.getContextPath() + "/component/F7Quick.do?method=initalize",submitField:component.id + "_el"};
            }
            else if(component.properties.F7Type=="F7Grid") {
                component.properties.submitField= "#" + component.id + "_el";
                component.properties.subWidgetName="wafPromptGrid";
                component.properties.inIframe=true;
                this.specialSubProperty(component,"subWidgetOptions","F7Grid",parent,parentEl,operateStatus,iteratorKey);
                waf.extend(component.properties.subWidgetOptions,{data:component.properties.data,dataUrl:waf.getContextPath() + "/component/F7Grid.do?method=initalize",submitField:component.id + "_el"});
                //component.properties.subWidgetOptions={data:component.properties.data,dataUrl:waf.getContextPath() + "/component/F7Grid.do?method=initalize",submitField:component.id + "_el"};
            }
            else if(component.properties.F7Type=="F7Tree") {
                component.properties.submitField= "#" + component.id + "_el";
                component.properties.subWidgetName="wafPromptTree";
                component.properties.inIframe=true;
                this.specialSubProperty(component,"subWidgetOptions","F7Tree",parent,parentEl,operateStatus,iteratorKey);
                waf.extend(component.properties.subWidgetOptions,{data:component.properties.data,dataUrl:waf.getContextPath() + "/component/F7Tree.do?method=initalize",submitField:component.id + "_el"});
                //component.properties.subWidgetOptions={data:component.properties.data,dataUrl:waf.getContextPath() + "/component/F7Tree.do?method=initalize",submitField:component.id + "_el"};
            }
            else if(component.properties.F7Type=="F7Iframe"){
                component.properties.submitField= "#" + component.id + "_el";
                component.properties.subWidgetName="wafPromptIframe";
                component.properties.inIframe=true;
                this.specialSubProperty(component,"subWidgetOptions","F7Iframe",parent,parentEl,operateStatus,iteratorKey);
                waf.extend(component.properties.subWidgetOptions,{data:component.properties.data,submitField:component.id + "_el"});
                if(component.properties.subWidgetOptions.url) {
                    component.properties.subWidgetOptions.url= waf.getContextPath() + component.properties.subWidgetOptions.url;
                }
            }
            else if(component.properties.F7Type=="F7Table"){
                component.properties.submitField= "#" + component.id + "_el";
                component.properties.subWidgetName="wafPromptTable";
                component.properties.inIframe=true;
                this.specialSubProperty(component,"subWidgetOptions","F7Table",parent,parentEl,operateStatus,iteratorKey);
                waf.extend(component.properties.subWidgetOptions,{data:component.properties.data,submitField:component.id + "_el"});
                if(!component.properties.subWidgetOptions.url) {
                    component.properties.subWidgetOptions.url= waf.getContextPath() + "/component/promptTable.do";
                }else{
                    component.properties.subWidgetOptions.url= waf.getContextPath() + component.properties.subWidgetOptions.url;
                }
            }
            else if(component.properties.F7Type=="F7Standard"){
                component.properties.submitField= "#" + component.id + "_el";
                component.properties.subWidgetName="wafPromptStandard";
                component.properties.inIframe=true;
                this.specialSubProperty(component,"subWidgetOptions","F7Standard",parent,parentEl,operateStatus,iteratorKey);
                waf.extend(component.properties.subWidgetOptions,{data:component.properties.data,submitField:component.id + "_el"});
                if(!component.properties.subWidgetOptions.url) {
                    component.properties.subWidgetOptions.url= waf.getContextPath() + "/component/F7Standard.do";
                }else{
                    component.properties.subWidgetOptions.url= waf.getContextPath() + component.properties.subWidgetOptions.url;
                }
            }
            else if(component.properties.F7Type=="F7Autocomplete"){
                component.properties.submitField= "#" + component.id + "_el";
                component.properties.subWidgetName="wafPromptAutoComplete";
                component.properties.inIframe=true;
                this.specialSubProperty(component,"subWidgetOptions","F7Autocomplete",parent,parentEl,operateStatus,iteratorKey);
                waf.extend(component.properties.subWidgetOptions,{data:component.properties.data,submitField:component.id + "_el"});
                if(!component.properties.subWidgetOptions.urlSource) {
                    component.properties.subWidgetOptions.urlSource= waf.getContextPath() + "/component/promptAutoComplete.do?method=getData";
                }else{
                    component.properties.subWidgetOptions.urlSource= waf.getContextPath() + component.properties.subWidgetOptions.urlSource;
                }
            }
            return component;
        },
        specialSubProperty:function(component,subPropName,subPropKey,parent,parentEl,operateStatus,iteratorKey){
            for(var p in component.properties){
                 // 
                 if(typeof(component.properties[p])=="function"){
                     continue;
                 }else{
                     var prop=p;
                     if(prop.indexOf(subPropKey + "_")==0){
                        var realPropKey=prop.substr(subPropKey.length+1);
                        var properties=component.properties;
                        if(!properties){
                            properties={};
                        }
                        if(!eval("properties." + subPropName)){
                            eval("properties." + subPropName + "={};");
                        }
                        eval("properties." + subPropName + "." + realPropKey + " = properties[prop];");
                     }
                 }
            }
        }
    });

    /**
     * WAFII 
     */
    waf.defineClass("waf.CheckBoxComponentBuilder",waf.GeneralComponentBuilder,{

        /**
         * 
         */
        getDataBinderProp:function(){
            return "checked";
        },
        /**
         * 
         */
        getComponentValueType:function(){
            return "boolean";
        }
    });

/**
 * WAFII 
 */
waf.dataBinder={
	/** 
	 *  
	 */
	_dataBinder:new Map(),

	/**
	 * 
	 */
	registerDataBinder:function(field,comId,xtype,property,dataType) {
		var dataBinder=new Object();
		dataBinder.field=field;
		dataBinder.componentID=comId;
		dataBinder.componentType=xtype;
		dataBinder.property=property;
		dataBinder.dataType=dataType;
		this._dataBinder.put(field,dataBinder);
	},
	/**
	 * 
	 */
	getComponentByProperty:function(property) {
		for(var index in this._dataBinder.keys()){
			var key=this._dataBinder.keys()[index];
			var dataBinder=this._dataBinder.get(key);
			if(dataBinder.field==property){
				var component=waf("#" + dataBinder.componentID);
				return component;
			}
		}
	},
	/**
	 * 
	 * @param {} field
	 * @param {} value
	 */
	setFieldValue:function(field,value){
		var dataBinder=this._dataBinder.get(field);

		var bindProp=dataBinder.property;
		var bindPropSetter="set" + bindProp.substr(0,1).toUpperCase() + bindProp.substr(1);
		eval("waf('#" + dataBinder.componentID + "')." + dataBinder.componentType + "('" + bindPropSetter + "',value)");
	},
	/**
	 * 
	 * @param {} field
	 * @param {} value
	 */
	getFieldValue:function(field){
		var dataBinder=this._dataBinder.get(field);
		var bindProp=dataBinder.property;
		var bindPropGetter=(dataBinder.dataType=="boolean"?"is":"get") + bindProp.substr(0,1).toUpperCase() + bindProp.substr(1);
		var fieldValue;
		fieldValue=eval("waf('#" + dataBinder.componentID + "')." + dataBinder.componentType + "('" + bindPropGetter + "')");
		
		//
		if(fieldValue!=undefined && fieldValue!=null && dataBinder.componentType=="wafDatePicker") {
			fieldValue="" + fieldValue.getFullYear() + "-" + (fieldValue.getMonth() + 1) + "-" + fieldValue.getDate();
		}
		else if(dataBinder.componentType=="wafMultiLangBox"){
			fieldValue=eval("waf('#" + dataBinder.componentID + "')." + dataBinder.componentType + "('option','value')");
		}
		return fieldValue;
	},
    clearField:function(){
        for(var nIndex=0;nIndex<this._dataBinder.size();nIndex++){
            var key=this._dataBinder.keys()[nIndex];
            var dataBinder=this._dataBinder.get(key);
            if(key=="msgArea1"){
                continue;
            }
            var bindProp=dataBinder.property;
            var bindPropSetter="set" + bindProp.substr(0,1).toUpperCase() + bindProp.substr(1);
            eval("waf('#" + dataBinder.componentID + "')." + dataBinder.componentType + "('" + bindPropSetter + "',null)");
            if("wafGrid"==dataBinder.componentType){
                waf("#"+dataBinder.componentID).wafGrid("clearGridData");
            }
        }
    },
	/**
	 * 
	 */
	loadField:function(model){
        waf.dataBinder.clearField();
		for(var nIndex=0;nIndex<this._dataBinder.size();nIndex++){
			var key=this._dataBinder.keys()[nIndex];
			var dataBinder=this._dataBinder.get(key);
			if(key=="msgArea1"){
			     continue;   
			}
			var fieldValue=eval("model." + key);
			if(fieldValue==undefined || fieldValue==null)
				continue;
			
			if(dataBinder.componentType=="wafSelect" && waf.isEnumValue(fieldValue)){
				fieldValue=fieldValue.value;
			}
				
			var bindProp=dataBinder.property;
			var bindPropSetter="set" + bindProp.substr(0,1).toUpperCase() + bindProp.substr(1);
			eval("waf('#" + dataBinder.componentID + "')." + dataBinder.componentType + "('" + bindPropSetter + "',fieldValue)");
		}
	}, 
	/**
	 * model
	 */
	storeField:function(model){
		for(var nIndex=0;nIndex<this._dataBinder.size();nIndex++){
			var key=this._dataBinder.keys()[nIndex];
			var dataBinder=this._dataBinder.get(key);
			var bindProp=dataBinder.property;
			var bindPropGetter=(dataBinder.dataType=="boolean"?"is":"get") + bindProp.substr(0,1).toUpperCase() + bindProp.substr(1);
			var fieldValue;
			fieldValue=eval("waf('#" + dataBinder.componentID + "')." + dataBinder.componentType + "('" + bindPropGetter + "')");
			
			//
			if(fieldValue!=undefined && fieldValue!=null && dataBinder.componentType=="wafDatePicker") {
				fieldValue="" + fieldValue.getFullYear() + "-" + (fieldValue.getMonth() + 1) + "-" + fieldValue.getDate();
			}
			else if(dataBinder.componentType=="wafMultiLangBox"){
				fieldValue=eval("waf('#" + dataBinder.componentID + "')." + dataBinder.componentType + "('option','value')");
			}
			//model 
			eval("model."+ key + "=fieldValue");
		}
	}
}
/**
 * WAFII 
 */
waf.EventElement={
	pointcut:null,  /* before/after/overwrite */
	event:null,
	handler:null
};

/**
 * WAF
 * @type 
 */
/*
waf.Event={
	source:null,
	dead:false,

	setSource:function(source){
		this.source=source;
	},
	getSource:function(){
		return this.source;
	},
	setDead:function(dead){
		this.dead=dead;
	},
	isLive:function(){
		return !dead;
	},
	kill:function(){
		this.setDead(true);
	}
};
*/

/**
 * WAF
 * @type 
 */
waf.EventBus={
	listeners:{
		eventMap:new Map(),
		add:function(event,fn,pointcut){
			if(pointcut!="before" && pointcut!="after" && pointcut!="overwrite") {
				
				//return ;
			}
			var eventList=this.eventMap.get(event);
			if(eventList==undefined && eventList==null){
				eventList=[];
				this.eventMap.put(event,eventList);
			}
			
			var eventElement={};
			eventElement.pointcut=pointcut;
			eventElement.event=event;
			eventElement.handler=fn;
			
			eventList[eventList.length]=eventElement;
		},
		remove:function(event){
			this.eventMap.remove(event);
		}
	},
	/**
	 * 
	 */
	subscribe:function(event,fn,pointcut){
		this.listeners.add(event,fn,pointcut);
	},
	/**
	 * 
	 */
	unSubscribe:function(event){
		this.listeners.remove(event);
	},
	/**
	 * 
	 */
	on:function(event,fn){
		this.subscribe(event,fn);
	},
	/**
	 * 
	 */
	fireEvent:function(event){
		//console.log("Start fire event:'", event);
		//console.trace();
		var eventList=this.listeners.eventMap.get(event);
		if(eventList==undefined || eventList==null) {
			//console("event " + event + " not found!");
			return ;
		}
		
		var beforeEventList=[];
		var afterEventList=[];
		var overWriteEventList=[];
		var currentEventList=[];
		for(var nIndex=0;nIndex<eventList.length;nIndex++) {
			var eventElement=eventList[nIndex];
			if(eventElement.pointcut=="before") {
				beforeEventList[beforeEventList.length]=eventElement.handler;
			}
			else if(eventElement.pointcut=="after"){
				afterEventList[afterEventList.length]=eventElement.handler;
			}
			else if(eventElement.pointcut=="overwrite") {
				overWriteEventList[overWriteEventList.length]=eventElement.handler;
			}
			else {
				currentEventList[currentEventList.length]=eventElement.handler;
			}
		}

		//
		for(var nIndex=0;nIndex<beforeEventList.length;nIndex++){
            if(!!window.debug){
                var start = $.log.start();
            }
			var handler=beforeEventList[nIndex];
			//handler.apply(this,[].slice.call(arguments,1));
			var isAbort=eval(this.resolveEventHandlerMethod(handler,[].slice.call(arguments,1)));
            if(!!window.debug){
                $.log.end(start,"Before-"+event+"("+beforeEventList.length+")"+":");
            }
			if(isAbort!=undefined && isAbort==false) {
				return false;
			}
		}
		
		//
		if(overWriteEventList.length>0){
			currentEventList=overWriteEventList;
		}
		for(var nIndex=0;nIndex<currentEventList.length;nIndex++){
            if(!!window.debug){
                var start = $.log.start();
            }
			var handler=currentEventList[nIndex];
			var isAbort=eval(this.resolveEventHandlerMethod(handler,[].slice.call(arguments,1)));
            if(!!window.debug){
                $.log.end(start,"Normal-"+event+"("+currentEventList.length+")"+":");
            }
			if(isAbort!=undefined && isAbort==false){
				return false;
			}
		}
		
		//
		for(var nIndex=0;nIndex<afterEventList.length;nIndex++){
            if(!!window.debug){
                var start = $.log.start();
            }
			var handler=afterEventList[nIndex];
			var isAbort=eval(this.resolveEventHandlerMethod(handler,[].slice.call(arguments,1)));
            if(!!window.debug){
                $.log.end(start,"After-"+event+"("+afterEventList.length+")"+":");
            }
			if(isAbort!=undefined && isAbort==false){
				return false;
			}
		}
		
		//console.log("End fire event:'", event);
		
		return true;
	},
	resolveEventHandlerMethod:function(handler,parameters){
		var params=parameters[0];
		var paramStr="";
		for(var nIndex=0;nIndex<params.length;nIndex++){
			paramStr=paramStr + "arguments[" + (nIndex+1) + "]";
			if(nIndex<params.length-1){
				paramStr = paramStr + ",";
			}
		}
		
		if(paramStr==null || paramStr==""){
			return "handler.apply(this)";
		}
		else {
			return "handler.apply(this," + paramStr + ")";
		}
	}
};
/****WafPageDeclareBegin************/
waf.defineClass("waf.framework.DynamicForm",waf.framework.WafCore,{
	/**/
	_uipk:null,
	/**/
	_pageMetadata:null,
	/**/
	_pageOriginMetadata:null,
	/**/
	_pageInitData:null,
	/**/
	_localeStr:null,
	/**/
	_pageTitle:null,
	/**
	 * uipk
	 */
	setUIPk:function(uipk){
		_self._uipk=uipk;
	},
	getUIPk:function(){
		return _self._uipk;
	},
	/**
	 * pageTitle
	 */
	setPageTitle:function(pageTitle){
		_self._pageTitle=pageTitle;
		document.title=pageTitle;
	},
	getPageTitle:function(){
		return _self._pageTitle;
	},
	/**
	 * url
	 */
	 getUrlParam:function(param){
		_urlParams=waf.getUrlParams(document.location.href);
	 	return _urlParams[param];
	 },
	 /**
	  * url
	  */
	 getUrlParams:function(){
	 	return _self._urlParams;
	 },
	 /**
	  * url
	  */
	 setUrlParams:function(params){
	 	_self._urlParams=params;
	 },
	/**
	 * 
	 */
	setPageMetadata:function(pageMetadata){
		_self._pageMetadata=pageMetadata;
	},
	getPageMetadata:function(){
		return _self._pageMetadata;
	},
	/**
	 * 
	 */
	setPageOriginMetadata:function(pageMetadata){
		_self._pageOriginMetadata=pageMetadata;
	},
	getPageOriginMetadata:function(){
		return _self._pageOriginMetadata;
	},
	/**
	 * 
	 */
	setPageInitData:function(pageInitData){
		_self._pageInitData=pageInitData;
	},
	getPageInitData:function(){
		return _self._pageInitData;
	},
	/**
	 * 
	 */
	getEventBus:function(){
		return waf.EventBus;
	},
	/**
	 * 
	 */
	searchComponent:function(componentID){
		return waf.pageBuilder.searchComponent(componentID,_self.getPageOriginMetadata())
	},
	/**
	 * 
	 */
	showMessage:function(msg){
		waf("#msgArea1").wafMsgArea("show",{
			type:"info",
			summaryMsg:msg,
			closeDetailTime:3
		});
	},
	/**
	 * 
	 */
	subscribeEvent:function(event,fn,pointcut){
		_self.getEventBus().subscribe(event,fn,pointcut);
	},
	/**
	 * 
	 */
	unSubscribeEvent:function(event){
		_self.getEventBus().unSubscribe(event);
	},
	/**
	 * 
	 */
	fireEvent:function(event){
		_self.getEventBus().fireEvent(event,[].slice.call(arguments,1));
	},
	/**
	 * 
	 */
	initalizeEvent:function(){
		// 
		_self.subscribeEvent("pageOnLoadEvent",_self._pageOnLoadEventHandler);
		//
		_self.subscribeEvent("pageOnRenderEvent",_self._pageOnRenderEventHandler);
		// 
		_self.subscribeEvent("pageOnCloseEvent",_self._pageOnCloseEventHandler);
	},
	/**
	 * 
	 */
	initalizeAction:function(){
        /* */
        _self.isInitLoadding = true;
        try{
			if(waf.dataBinder._dataBinder.size()==0 && window._dataBinders_){
				var tmp,len=window._dataBinders_.length;
				for(var i=0;i<len;i++){
					tmp =window._dataBinders_[i]; 
				    waf.dataBinder._dataBinder.put(tmp.field,tmp);
				}
		    }
            /*   */
            _self.fireEvent("pageOnLoadEvent");
        }catch(e){}
        finally{
            _self.isInitLoadding = false;
        }
	},
	/**
	 * 
	 */
	showError:function(summary,detailInfo){
		var pageMsgAreaBox=waf.getPageMsgAreaBox();
		if(pageMsgAreaBox==null){
			waf.msgBox.showError({ 		
						summaryMsg:summary
			});
		}
		else {
			pageMsgAreaBox.wafMsgArea("show",{
				        type:"error",
				        summaryMsg:summary,
				        detailMsg:detailInfo
			});
		}
	},
	/**
	 * 
	 */
	showInfo:function(summary,detailInfo){
		var pageMsgAreaBox=waf.getPageMsgAreaBox();
		if(pageMsgAreaBox==null){
			waf.msgBox.showInfo({ 		
						summaryMsg:summary
			});
		}
		else {
			pageMsgAreaBox.wafMsgArea("show",{
				        type:"info",
				        summaryMsg:summary,
				        detailMsg:detailInfo
			});
		}
	},
	/**
	 * 
	 */
	showWarning:function(summary,detailInfo){
		var pageMsgAreaBox=waf.getPageMsgAreaBox();
		if(pageMsgAreaBox==null){
			waf.msgBox.showInfo({ 		
						summaryMsg:summary
			});
		}
		else {
			pageMsgAreaBox.wafMsgArea("show",{
				        type:"warning",
				        summaryMsg:summary,
				        detailMsg:detailInfo
			});
		}
	},
	/**
	 * 
	 */
	_pageOnLoadEventHandler:function(){
		//_self.fireEvent("pageOnRenderEvent",_self.getPageOriginMetadata(),true,true);
		//$(window).resize();

		/*
		//
		var urlParams=waf.getUrlParams(document.location.href);
		var uipk=urlParams["uipk"];
		if(uipk==undefined || uipk==null){
			alert("uipk,!");
			return ;
		}
		_self.setUIPk(uipk);
		
		/*
		var domain=new waf.Domain();
		domain.domain="bos-webframework-core";
		domain.version="7.5.1.1";
		domain.invokeService({
				service:"GeneralWebPageServices",
				serviceMethod:"initialize",
				parameters:{solution:uipk},
				success:function(initData){
					//,,getPageInitData
					_self.setPageInitData(initData);
					//UIPK
					_self.setUIPk(initData.uipk);
					//
					_self.setPageOriginMetadata(initData.pageMetadata.rootComponent);

					//
					_initContext(initData.context);
					//
					_loadExtendJSLibrary(initData.pageExtendScripts);
					//CSS
					_loadExtendCSSLibrary(initData.pageExtendStyleSheets);
					
					//
					_self.fireEvent("pageOnRenderEvent",_self.getPageOriginMetadata());
					
					//
					waf(window).resize();
				}
		});
		*/
		
		/**
		 * 
		 */
		/*
		function _initContext(context){
			waf.context=context;
		};
		*/
		
		/**
		 * 
		 */
		/*
		function _loadExtendJSLibrary(pageExtendScripts){
			for(nIndex=0;nIndex<pageExtendScripts.length;nIndex++) {
				var item=pageExtendScripts[nIndex];
				waf.loadJSLibrary(waf.getContextPath() + item.reference + "/" + item.name);
			}
		};
		*/
		
		/**
		 * 
		 */
		/*
		function _loadExtendCSSLibrary(pageExtendStyleSheets){
			//
			for(nIndex=0;nIndex<pageExtendStyleSheets.length;nIndex++) {
				var item=pageExtendStyleSheets[nIndex];
				waf.loadJSLibrary(waf.getContextPath() + item.reference + "/" + item.name);
			}
		};
		*/
	},
	/**
	 *  
	 * @param {} msg
	 */
	_pageOnRenderEventHandler:function(params,domRender,comInit){
		var pageOriginMetadata=params;
		var newPageMetadata = waf.pageBuilder.render(pageOriginMetadata,null,domRender,comInit);
		_self.setPageMetadata(newPageMetadata);
	},
	/**
	 * 
	 */
	_pageOnCloseEventHandler:function(){
		waf.doPost(
			{
				action:'close',
				success:function(data){
					if (waf.isInFramePage()) {
						    waf.closeCurPageTab();
					} else {
						if (waf.windowMgr.getTargetObj()){
							waf.window.close();
						} else{ 
						    window.close();
						}
					}
				}
			}
		);
	}
});

/****WafPageDeclareEnd************/
/****WafPageDeclareBegin************/
waf.defineClass("waf.framework.DynamicList",waf.framework.DynamicForm,{
	editUrl:null,
	viewUrl:null,
	botpTrace:false,
	botpFilter:null,
	listRefreshEnabled:true,
	/**
	 * 
	 */
	setEditUrl:function(editUrl){
		_self.editUrl=editUrl;
	},
	/**
	 * 
	 */
	getEditUrl:function(){
		return _self.editUrl;
	},
	/**
	 * 
	 */
	setViewUrl:function(viewUrl){
		_self.viewUrl=viewUrl;
	},
	/**
	 * 
	 */
	getViewUrl:function(){
		return _self.viewUrl;
	},
	getCurrentModel:function(){
		return null;
	},
	setBotpFilter:function(botpFilter){
		_self.botpFilter=botpFilter;
	},
	getBotpFilter:function(){
		return _self.botpFilter;
	},
	isBotpTrace:function(){
		return _self.botpTrace;
	},
	setBotpTrace:function(value){
		_self.botpTrace=value;
	},
	enableListRefresh:function(){
		_self.listRefreshEnabled=true;
	},
	pauseListRefresh:function(value){
		_self.listRefreshEnabled=false;
	},
	initalizeEvent:function(){
		//
		waf.framework.DynamicList.superClass.initalizeEvent.call(this);
		//
		_self.subscribeEvent("pageOnLoadEvent",_self._listPageOnLoadEventHandler,"after");
		// 
		_self.subscribeEvent("addNewActionEvent",_self._addNewActionEventHandler);
		// 
		_self.subscribeEvent("editActionEvent",_self._editActionEventHandler);
		// 
		_self.subscribeEvent("viewActionEvent",_self._viewActionEventHandler);
		// 
		_self.subscribeEvent("deleteActionEvent",_self._deleteActionEventHandler);
		//
		_self.subscribeEvent("refreshActionEvent",_self._refreshActionEventHandler);
		// 
		_self.subscribeEvent("reportActionEvent",_self._reportActionEventHandler);
		//
		_self.subscribeEvent("advanceSearchActionEvent",_self._advanceSearchActionEventHandler);
		//
		_self.subscribeEvent("createToAssBillActionEvent",_self._createToAssBillActionEventHandler);
		//
		_self.subscribeEvent("traceUpActionEvent",_self._traceUpActionEventHandler);
		//
		_self.subscribeEvent("traceDownActionEvent",_self._traceDownActionEventHandler);
		//
		_self.subscribeEvent("importDataActionEvent",_self._importDataActionEventHandler);
		//
		_self.subscribeEvent("exportDataActionEvent",_self._exportDataActionEventHandler);
		//
		_self.subscribeEvent("viewProcessDiagramActionEvent",_self._viewProcessDiagramActionEventHandler);
		//
		_self.subscribeEvent("viewOpinionActionEvent",_self._viewOpinionActionEventHandler);
		// 
		_self.subscribeEvent("multiApproveActionEvent",_self._multiApproveActionEventHandler);
		//
		_self.subscribeEvent("viewActivityListActionEvent",_self._viewActivityListActionEventHandler);
		//
		_self.subscribeEvent("specifyNextPersonActionEvent",_self._specifyNextPersonActionEventHandler);
		//
		_self.subscribeEvent("exitActionEvent",_self._exitActionEventHandler);
		// 
		_self.subscribeEvent("pageOnCloseEvent",_self._pageOnCloseEventHandler,"overwrite");
	},
	_listPageOnLoadEventHandler:function(){

		//botp
		var urlParams=waf.getUrlParams(document.location.href);
		if(urlParams.hasToolbar=="false"){
			waf("#toolBar").wafToolBar("option","style","display:none;");
		}
		
		if(_self.getBotpFilter()!=null && _self.getBotpFilter()!="") {
			_self.setBotpTrace(true);
			waf("#queryGrid").dataGrid("option","botpFilterItems",_self.getBotpFilter());
		}
		
		//
		if (waf("#bizCommonQuery").length>0) {
    		var filter = waf("#bizCommonQuery").bizCommonQuery("getCurrentFilter");
    		waf("#queryGrid").dataGrid("option","filterItems",filter);
		}
		
		//
		waf("#queryGrid").dataGrid("reloadGrid");
		waf("#queryGrid").dataGrid("option","ondblClickRow",function(rowid, iRow, iCol, e){
			var modelID=waf("#queryGrid").wafGrid("getCell",rowid,"id");
			
			if (waf.isInFramePage()) {
    			var url=waf.getDynamicEditContextPath() + "?method=doEvent&event=initialize&uipk=" + (_self.getViewUrl()==""?_self.getEditUrl():_self.getViewUrl()) + "&operateState=VIEW&billId=" + waf.encodeURIComponent(modelID);
    			var options = {source:url,
    			               onRemove:function(){
    			                   waf("#queryGrid").dataGrid("reloadGrid");
    		                   }
    		    };
    		    waf.addPageTab(options);
		    } else {
    			var winProperties=_self.getEditWinStyle();
    			winProperties.url=waf.getDynamicEditContextPath() + "?method=doEvent&event=initialize&uipk=" + (_self.getViewUrl()==""?_self.getEditUrl():_self.getViewUrl()) + "&operateState=VIEW&billId=" + waf.encodeURIComponent(modelID);
    			winProperties.close=function(event,ui){
    				waf("#queryGrid").dataGrid("reloadGrid");
    			}
    			winProperties.onOpenCompleted=function(event,ui){
    				waf(window).unbind("resize",$.window.doResize);
    	            waf(window).bind("resize",$.window.doResize);
    			} 
    			_self.editWin = waf.window.open(winProperties);
			}
		});
	},
	/**
	 * 
	 */
	_addNewActionEventHandler:function(){
	    if (waf.isInFramePage()) {
    	    var url=waf.getDynamicEditContextPath() + "?method=doEvent&event=initialize&operateState=ADDNEW&uipk=" + _self.getEditUrl();
    		var options = {source:url,
    			           onRemove:function(){
    			               waf("#queryGrid").dataGrid("reloadGrid");
    		               }
     		};
    		waf.addPageTab(options);
	    } else {
    	    var winProperties=_self.getEditWinStyle();
    		winProperties.url=waf.getDynamicEditContextPath() + "?method=doEvent&event=initialize&operateState=ADDNEW&uipk=" + _self.getEditUrl();
    		winProperties.close=function(event,ui){
    			waf("#queryGrid").dataGrid("reloadGrid");
    		}
    		winProperties.onOpenCompleted=function(event,ui){
    			waf(window).unbind("resize",$.window.doResize);
                waf(window).bind("resize",$.window.doResize);
    		} 
    		_self.editWin = waf.window.open(winProperties);
		}
	},
	/**
	 * 
	 */
	_editActionEventHandler:function(){
	    var selectedId = waf("#queryGrid").dataGrid("getSelectedRow");
    	if(selectedId==undefined || selectedId==null){
    		_self.showWarning("!");
    		return ;
    	}
    	var modelID=waf("#queryGrid").wafGrid("getCell",selectedId,"id");
	    
	    if (waf.isInFramePage()) {
    	    var url=waf.getDynamicEditContextPath() + "?method=doEvent&event=initialize&operateState=EDIT&uipk=" + _self.getEditUrl() + "&operateState=EDIT&billId=" + waf.encodeURIComponent(modelID);
    		var options = {source:url,
    			           onRemove:function(){
    			               waf("#queryGrid").dataGrid("reloadGrid");
    		               }
    		};
    		waf.addPageTab(options);
	    } else {
    		var winProperties=_self.getEditWinStyle();
    		winProperties.url=waf.getDynamicEditContextPath() + "?method=doEvent&event=initialize&operateState=EDIT&uipk=" + _self.getEditUrl() + "&operateState=EDIT&billId=" + waf.encodeURIComponent(modelID);
    		winProperties.close=function(event,ui){
    			waf("#queryGrid").dataGrid("reloadGrid");
    		}
    		winProperties.onOpenCompleted=function(event,ui){
    			waf(window).unbind("resize",$.window.doResize);
                waf(window).bind("resize",$.window.doResize);
    		} 
    		_self.editWin = waf.window.open(winProperties);
		}
	},
	/**
	 * 
	 */
	_viewActionEventHandler:function(){
		var selectedId = waf("#queryGrid").dataGrid("getSelectedRow");
		if(selectedId==undefined || selectedId==null){
			_self.showWarning("!");
			return ;
		}
		var modelID=waf("#queryGrid").wafGrid("getCell",selectedId,"id");
		
		if (waf.isInFramePage()) {
    		var url=waf.getDynamicEditContextPath() + "?method=doEvent&event=initialize&uipk=" + (_self.getViewUrl()==""?_self.getEditUrl():_self.getViewUrl()) + "&operateState=VIEW&billId=" + waf.encodeURIComponent(modelID);
    		var options = {source:url,
    			           onRemove:function(){
    			               waf("#queryGrid").dataGrid("reloadGrid");
    		               }
    		};
    		waf.addPageTab(options);
		} else {
    		var winProperties=_self.getEditWinStyle();
    		winProperties.url=waf.getDynamicEditContextPath() + "?method=doEvent&event=initialize&uipk=" + (_self.getViewUrl()==""?_self.getEditUrl():_self.getViewUrl()) + "&operateState=VIEW&billId=" + waf.encodeURIComponent(modelID);
    		winProperties.close=function(event,ui){
    			waf("#queryGrid").dataGrid("reloadGrid");
    		}
    		winProperties.onOpenCompleted=function(event,ui){
    			waf(window).unbind("resize",$.window.doResize);
                waf(window).bind("resize",$.window.doResize);
    		} 
    		_self.editWin = waf.window.open(winProperties);
		}
	},
	/**
	 * 
	 */
	_deleteActionEventHandler:function(){
		var selectedIds = waf("#queryGrid").dataGrid("getSelectedRows");
		if(selectedIds==undefined || selectedIds.length<=0){
			_self.showWarning("!");
			return ;
		}
		var modelIDMap = new Map();
		var modelIDs="";
	    for (var i=0;i<selectedIds.length;i++) {
	            var modelID = $("#queryGrid").wafGrid("getCell",selectedIds[i],"id");
	            if (!modelIDMap.containsKey(modelID)) {
	                modelIDMap.put(modelID,modelID);
					if(modelIDs!=""){
						modelIDs = modelIDs + "," + modelID;
					}
					else {
						modelIDs= modelIDs + modelID;
					}
				}
	    }
		waf.msgBox.showConfirm({
					autoBtnClose:false,
		        	summaryMsg:"?",
		        	buttonType:"ok-cancel",   					
		        	buttonCallBack:[
			        	function(dialog){
			        		waf.msgBox.close(dialog);
							waf.doPost(
								{
									action:'delete',
									param:"modelID=" + waf.encodeURIComponent(modelIDs.toString()),
									success:function(data){
										//
										waf("#queryGrid").dataGrid("reloadGrid");
										//
										_self.showInfo(_self.localeStr.DELETE_SUCCESS);
									}
								}
							);
			        	},
			        	function(){
			        		//waf.msgBox.close(dialog);
			        	}
		        	]
		});
	},
	/**
	 * 
	 */
	_refreshActionEventHandler:function(){
		waf("#queryGrid").reloadGrid();
	},
	/**
	 * 
	 * @action
	 */
	_advanceSearchActionEventHandler:function(){
		waf("#commonQuery").commonQuery("showCommonQueryDialog",
			    {confirm:function(data){
			    	if (data!=null) {
			    	    waf("#queryGrid").dataGrid("option","filterItems",data.filter);
			    	    waf("#queryGrid").dataGrid("option","sorterItems",data.sorter);
			    	    waf("#queryGrid").dataGrid("option","page",1);
		                waf("#queryGrid").dataGrid("reloadGrid");
		                waf("#queryGrid_native").jqGrid("setGridParam",{page:1});
		            }
			    },
			    cancel:function(){
				    
				}
			}
		);
	},
	/**
	 * :
	 * @action
	 */
	_reportActionEventHandler:function(){
		var selectedIds = waf("#queryGrid").dataGrid("getSelectedRows");
        if(selectedIds.length>0){
            var modelIDs = new Map();
	        for (var i=0;i<selectedIds.length;i++) {
	            var modelID = $("#queryGrid").wafGrid("getCell",selectedIds[i],"id");
	            if (!modelIDs.containsKey(modelID))
	                modelIDs.put(modelID,modelID);
	        }
	        waf("#report").report("option","billID",modelIDs.keys().toString());
	        waf("#report").report("report",true);
	    } else {
		    _self.showWarning("!");
            return ;
		}
	},
	/**
	 * -
	 */
	_createToAssBillActionEventHandler:function(){
		var selectedIds = waf("#queryGrid").dataGrid("getSelectedRows");
		if(selectedIds==undefined || selectedIds.length<=0){
			_self.showWarning("!");
			return ;
		}
		var modelIDMap = new Map();
		var modelIDs="";
	    for (var i=0;i<selectedIds.length;i++) {
	            var modelID = $("#queryGrid").wafGrid("getCell",selectedIds[i],"id");
	            if (!modelIDMap.containsKey(modelID)) {
	                modelIDMap.put(modelID,modelID);
					if(modelIDs!=""){
						modelIDs = modelIDs + "," + modelID;
					}
					else {
						modelIDs= modelIDs + modelID;
					}
				}
	    }

		waf("#botp").botp("openCreateToAssBillDialog",{billIds:modelIDs});
	},
	/**
	 * -
	 */
	_traceUpActionEventHandler:function(){
		var selectedId = waf("#queryGrid").dataGrid("getSelectedRow");
	    if(selectedId==undefined || selectedId==null){
			_self.showWarning("!");
			return ;
		}
	    var modelID=waf("#queryGrid").wafGrid("getCell",selectedId,"id");
	    
		waf("#botp").botp("openTraceUpDialog",{billIds:modelID});
	},
	/**
	 * -
	 */
	_traceDownActionEventHandler:function(){
	    var selectedId = waf("#queryGrid").dataGrid("getSelectedRow");
	    if(selectedId==undefined || selectedId==null){
			_self.showWarning("!");
			return ;
		}
		var modelID=waf("#queryGrid").wafGrid("getCell",selectedId,"id");
		waf("#botp").botp("openTraceDownDialog",{billIds:modelID});
	},
	/**
	 * 
	 */
	_importDataActionEventHandler:function(){
		waf("#dataImpExp").dataImpExp("showImportDataDialog",{
		     close:function(){
		     	waf("#queryGrid").dataGrid("reloadGrid");
			 }
		});
	}
	,
	/**
	 * 
	 */
	_exportDataActionEventHandler:function(){
		waf("#dataImpExp").dataImpExp("showExportDataDialog");
	},
	/** 
	 * :
	 * @action
	 */
	_viewProcessDiagramActionEventHandler:function(){
		var selectedId = waf("#queryGrid").dataGrid("getSelectedRow");
	    if(selectedId==undefined || selectedId==null){
			_self.showWarning("!");
			return ;
		}
		var modelID=waf("#queryGrid").wafGrid("getCell",selectedId,"id");
		waf.openNativeWindow("?method=doEvent&uipk=" + _self.getUIPk() + "&action=viewProcessDiagram&billID=" + waf.encodeURIComponent(modelID),"");
	},
	/**
	 * :
	 * @action
	 */
	_viewOpinionActionEventHandler:function(){
		var selectedId = waf("#queryGrid").dataGrid("getSelectedRow");
	    if(selectedId==undefined || selectedId==null){
			_self.showWarning("!");
			return ;
		}
		var modelID=waf("#queryGrid").wafGrid("getCell",selectedId,"id");
		waf.openNativeWindow("?method=doEvent&uipk=" + _self.getUIPk() + "&action=viewOpinion&billID=" + waf.encodeURIComponent(modelID),"");
	},
	/**
	 * :
	 * @action
	 */
	_multiApproveActionEventHandler:function(){
		var selectedId = waf("#queryGrid").dataGrid("getSelectedRow");
	    if(selectedId==undefined || selectedId==null){
			_self.showWarning("!");
			return ;
		}
		var modelID=waf("#queryGrid").wafGrid("getCell",selectedId,"id");
		waf.openNativeWindow("?method=doEvent&uipk=" + _self.getUIPk() + "&action=multiApprove&billID=" + waf.encodeURIComponent(modelID),"");
	},
	/**
	 * :
	 */
	_viewActivityListActionEventHandler:function(){
		var selectedId = waf("#queryGrid").dataGrid("getSelectedRow");
	    if(selectedId==undefined || selectedId==null){
			_self.showWarning("!");
			return ;
		}
		var modelID=waf("#queryGrid").wafGrid("getCell",selectedId,"id");
		waf.openNativeWindow("?method=doEvent&uipk=" + _self.getUIPk() + "&action=viewActivityList&billID=" + waf.encodeURIComponent(modelID),"");
	},
	/**
	 * :
	 * @action
	 */
	_specifyNextPersonActionEventHandler:function(){
		var selectedId = waf("#queryGrid").dataGrid("getSelectedRow");
	    if(selectedId==undefined || selectedId==null){
			_self.showWarning("!");
			return ;
		}
		var modelID=waf("#queryGrid").wafGrid("getCell",selectedId,"id");
		waf.openNativeWindow("?method=doEvent&uipk=" + _self.getUIPk() + "&action=specifyNextPerson&billID=" + waf.encodeURIComponent(modelID),"");
	},
	/**
	 * '','',''
	 */
	 getEditWinStyle:function(){
	 	var winStyle={
	 				OpenType:"iframe",
				    //bgiframe: false,
				    method:'POST',
				    modal:true,
				    openFromParent:false,
				    position:'center',
				    showTitleBar : false,
					autoMax : true,
				    width: 850,
				    height: 600,
				    minHeight:600,
				    minWidth:850,
				    iconCls:"ui-icon-winIcon",
				    draggable: true,
				    resizable: false,
				    //hideCloseBtn:true,
				    //showEffect:"slide",

				    hideEffect: "slide"
		};
		return winStyle;
	 },
	 /**
	 * 
	 */
	 _exitActionEventHandler:function(){
	 	_self.fireEvent("pageOnCloseEvent"); 
	 },
});
/****WafPageDeclareEnd************/
/****WafPageDeclareBegin************/
waf.defineClass("waf.framework.DynamicEdit",waf.framework.DynamicForm,{
	/*  */
	operateState:"VIEW",
	/* */
	_model:null,
	_modelOnReady:false,
	/* */
	entryMap:new Map(),
	getCurrentModel:function(){
		return _self._model;
	},
	setCurrentModel:function(model){
		_self._model=model;
	},
	getCurrentOperateState:function(){
		return _self.operateState;
	},
	initalizeEvent:function(){
		//
		waf.framework.DynamicEdit.superClass.initalizeEvent.call(this);
		//
		_self.subscribeEvent("pageOnLoadEvent",_self._editPageOnLoadEventHandler,"after");
		//
		//_self.subscribeEvent("modelOnCreateEvent",_self._modelOnCreateEventHandler);
		//_self.subscribeEvent("modelOnLoadEvent",_self._modelOnLoadEventHandler);
		// 
		_self.subscribeEvent("fieldOnLoadEvent",_self._fieldOnLoadEventHandler);
		// 
		_self.subscribeEvent("fieldOnStoreEvent",_self._fieldOnStoreEventHandler);
		// 
		_self.subscribeEvent("saveActionEvent",_self._saveActionEventHandler);
		// 
		_self.subscribeEvent("submitActionEvent",_self._submitActionEventHandler);
		// 
		_self.subscribeEvent("appendRowActionEvent",_self._appendRowActionEventHandler);
		// 
		_self.subscribeEvent("deleteRowActionEvent",_self._deleteRowActionEventHandler);
		// 
		_self.subscribeEvent("appendEntryRowActionEvent",_self._appendEntryRowActionEventHandler);
		// 
		_self.subscribeEvent("deleteEntryRowActionEvent",_self._deleteEntryRowActionEventHandler);
		// 
		_self.subscribeEvent("reportActionEvent",_self._reportActionEventHandler);
		//
		_self.subscribeEvent("createToAssBillActionEvent",_self._createToAssBillActionEventHandler);
		//
		_self.subscribeEvent("traceUpActionEvent",_self._traceUpActionEventHandler);
		//
		_self.subscribeEvent("traceDownActionEvent",_self._traceDownActionEventHandler);
		//
		_self.subscribeEvent("importDataActionEvent",_self._importDataActionEventHandler);
		//
		_self.subscribeEvent("exportDataActionEvent",_self._exportDataActionEventHandler);
		//
		_self.subscribeEvent("viewProcessDiagramActionEvent",_self._viewProcessDiagramActionEventHandler);
		//
		_self.subscribeEvent("viewOpinionActionEvent",_self._viewOpinionActionEventHandler);
		// 
		_self.subscribeEvent("multiApproveActionEvent",_self._multiApproveActionEventHandler);
		//
		_self.subscribeEvent("viewActivityListActionEvent",_self._viewActivityListActionEventHandler);
		//
		_self.subscribeEvent("exitActionEvent",_self._exitActionEventHandler);
		// 
		_self.subscribeEvent("pageOnCloseEvent",_self._editPageOnCloseEventHandler,"overwrite");
	},
	/**
	 * 
	 */
	_editPageOnLoadEventHandler:function(){
		var billId=_self.getUrlParam("billId");
		if(billId){
			_self.fireEvent("modelOnLoadEvent");
		}
		else {
			_self.fireEvent("modelOnCreateEvent");
		}
		
		//while(_self._modelOnReady){};
		
		_self.fireEvent("fieldOnLoadEvent");
		
		// 
		if(waf.getUrlParams(document.location.href).operateState=="VIEW") {
			waf.wafutil.disableAll();
			waf(".requiredspan").attr("style","display:none");
		}
	},
	_modelOnCreateEventHandler:function(){
		waf.doPost({
			event:'modelCreate',
			async:false,
			showBlock:false,
			success:function(model){
				_self.setCurrentModel(model);
				//
				_self.fireEvent("fieldOnLoadEvent");
				
				_self._modelOnReady=true;
			}
		});
	},
	_modelOnLoadEventHandler:function(){
		var billId=_self.getUrlParam("billId");
		if(billId){
			waf.doPost({
				event:'modelLoad',
				data:{billId:billId},
				showBlock:false,
				success:function(model){
					_self.setCurrentModel(model);
					//
					_self.fireEvent("fieldOnLoadEvent");
					
					_self._modelOnReady=true;
				}
			});
		}
	},
	/**
	 * model
	 */
	_fieldOnLoadEventHandler:function(){
		/*
		 *  
		 */
//        if(!_self.isInitLoadding){
            waf.dataBinder.loadField(_self.getCurrentModel());
//        }

		/* 
		 * modelID
		 */
		var webAttachment = waf("#webAttachment");
        if (webAttachment.length > 0 && _self.getCurrentModel()) {
            webAttachment.webAttachment("setBillID", _self.getCurrentModel().id);
            if(_self.getCurrentOperateState()!="ADDNEW")
	            webAttachment.webAttachment("showFiles");
        }
	},
	/**
	 *  
	 */
	_fieldOnStoreEventHandler:function(){
		//
		waf.dataBinder.storeField(_self.getCurrentModel());
	},
	/**
	 * 
	 * @param {} field
	 * @param {} value
	 */
	setFieldValue:function(field,value){
		waf.dataBinder.setFieldValue(field,value);
	},
	/**
	 * 
	 * @param {} field
	 * @param {} value
	 */
	getFieldValue:function(field){
		waf.dataBinder.getFieldValue(field);
	},
	/**
	 * 
	 */
	_saveActionEventHandler:function(){
		//
		_self.fireEvent("fieldOnStoreEvent");
		
		var result=waf("#form").wafFormValidator("validateForm");
		if(result==true) {
		 	var editModel=null;
		 	try{
		 		editModel=waf.toJSONString(_self.getCurrentModel());
		 	}
		 	catch(e){
		 		alert(e);
		 	}
			waf.doPost({
				//form:"form",
				action:"save",
				data:{model:editModel},
				success:function(objectPK){
					_self.showInfo("!");
					_self.getCurrentModel().id=objectPK;
					var curWinTarget=waf.getUrlParams(document.location.href).curWinTarget;
					document.location.href="?method=doEvent&uipk=" + _self.getUIPk() + "&event=initialize" + "&billId=" + waf.encodeURIComponent(objectPK) + "&operateState=EDIT&curWinTarget=" + curWinTarget;
				}
			});
		 }
	},
	/**
	 * 
	 */
	_submitActionEventHandler:function(){
		//
		_self.fireEvent("fieldOnStoreEvent");

		var result=waf("#form").wafFormValidator("validateForm");
		if(result==true){
			var editModel=null;
		 	try{
		 		editModel=waf.toJSONString(_self.getCurrentModel());
		 	}
		 	catch(e){
		 		alert(e);
		 	}
			waf.doPost({
				action:"submit",
				data:{model:editModel},
				success:function(objectPK){
					_self.getCurrentModel().id=objectPK;
					var urlParam=waf.getUrlParams(document.location.href);
					if(urlParam["isFromWorkflow"]=="true"){
						waf.msgBox.showInfo({
								summaryMsg:"",
								buttonType:"ok",   					
					        	buttonCallBack:[
						        	function(dialog){
						        		_self._editPageOnCloseEventHandler();
						        	}
					        	]
						});
					}
					else {
						waf("#msgArea1").wafMsgArea("show",{
					     type:"info",
					     summaryMsg:""
						});
						_self._editPageOnCloseEventHandler();
					}
				}
			});
		}
	},
	/**
	 * 
	 */
	_appendRowActionEventHandler:function(){
		waf.doPost(
		{
				action:'appendRow',
				data:{entryKey:'entrys'},
				success:function(rowData){
				    if (rowData == null) {
				        waf("#entrySection").wafInfoBlock("addRow");
				    }
				    else { 
					    waf("#entrySection").wafInfoBlock("addRow",{data:rowData});
				    }
				}
		});
	},
	/**
	 * 
	 */
	_deleteRowActionEventHandler:function(){
		var rowId = waf("#entrySection").wafInfoBlock("getCurrentRowId");
		if(rowId==undefined || rowId==null){
			_self.showWarning("!");
			return ;
		}
		waf.doPost(
		{
			action:'deleteRow',
			success:function(data){
        		 waf("#entrySection").wafInfoBlock("delRow",rowId);
			}
		});
	},
	/**
	 * (
	 */
	 _appendEntryRowActionEventHandler:function(){
		waf.doPost(
		{
				action:'appendRow',
				data:{entryKey:'entrys'},
				success:function(rowData){
				    if (rowData == null) {
				        waf("#editGrid").jqGrid("addRow");
				    }
				    else { 
					    waf("#editGrid").jqGrid("addRow",{data:rowData});
				    }
				}
		});
	 },
	/**
	 * (
	 */
	 _deleteEntryRowActionEventHandler:function(){
		var selectedRowId=waf("#editGrid").jqGrid("getGridParam","selrow");
		if(selectedRowId==undefined || selectedRowId==null){
			_self.showWarning("!");
			return ;
		}
		waf.doPost(
		{
			action:'deleteRow',
			success:function(data){
        		 waf("#editGrid").jqGrid("delRow", selectedRowId);
			}
		});
	 }, 
	/**
	 * 
	 */
	_reportActionEventHandler:function(){
		var billID = _self.getCurrentModel().id;
		if(billID==null || billID=="") {
			return ;
		}
		var tdQueryPK = waf("#report").report("option","tdQueryPK");
		if(tdQueryPK==null || tdQueryPK=="") {
			return ;
		}
		var tdTemplateName = waf("#report").report("option","tdTemplateName");
		if(tdTemplateName==null || tdTemplateName=="") {
			return ;
		}
		
		var dataProvider = waf("#report").report("option","dataProvider");
		var reportWin = waf.window.open({
				    url:waf.getContextPath()+"/component/ReportTemplate.do?method=initalize",
				    OpenType:"iframe",
				    method:'POST',
				    data:{billID:billID,
				          tdQueryPK:tdQueryPK,
				          tdTemplateName:tdTemplateName,
				          dataProvider:dataProvider,
				          isByDefTemp:true},
				    modal:true,
	        	    title:"",
	         	    position: 'center', 
	     	        width: 600,
				    height: 380,
				    minHeight:0,
				    minWidth:200,
	    	        iconCls:"waf-ui-icon",
	    	        draggable: true,
	    	        minMixBtn: true,
	    	        hideCloseBtn:false,
	        	    resizable: false
//	        	    hideEffect: "slide"
        });
	},
	/**
	 * 
	 */
	_createToAssBillActionEventHandler:function(){
		var billId = _self.getCurrentModel().id;
	    if(billId==undefined || billId==null){
	    	return ;
	    }
	    
		waf("#botp").botp("openCreateToAssBillDialog",{billIds:billId});
	},
	/**
	 * -
	 */
	_traceUpActionEventHandler:function(){
		var billId = _self.getCurrentModel().id;
	    if(billId==undefined || billId==null){
	    	return ;
	    }
	    
		waf("#botp").botp("openTraceUpDialog",{billIds:billId});
	},
	/**
	 * -
	 */
	_traceDownActionEventHandler:function(){
		var billId = _self.getCurrentModel().id;
	    if(billId==undefined || billId==null){
	    	return ;
	    }
		//waf.redirect("?method=edit&modelID=" + waf.encodeURIComponent(selectedIds));
		waf("#botp").botp("openTraceDownDialog",{billIds:billId});
	},
	/**
	 * 
	 */
	_importDataActionEventHandler:function(){
		waf("#dataImpExp").dataImpExp("showImportDataDialog",{
		     close:function(){
		     	waf("#grid").dataGrid("reloadGrid");
			 }
		});
	}
	,
	/**
	 * 
	 */
	_exportDataActionEventHandler:function(){
		waf("#dataImpExp").dataImpExp("showExportDataDialog");
	},
	/** 
	 * :
	 * @action
	 */
	_viewProcessDiagramActionEventHandler:function(){
		var billId = _self.getCurrentModel().id;
	    if(billId==undefined || billId==null){
	    	return ;
	    }
		waf.openNativeWindow("?method=doEvent&uipk=" + _self.getUIPk() + "&action=viewProcessDiagram&billID=" + waf.encodeURIComponent(billId),"");
	},
	/**
	 * :
	 * @action
	 */
	_viewOpinionActionEventHandler:function(){
		var billId = _self.getCurrentModel().id;
	    if(billId==undefined || billId==null){
	    	return ;
	    }
		waf.openNativeWindow("?method=doEvent&uipk=" + _self.getUIPk() + "&action=viewOpinion&billID=" + waf.encodeURIComponent(billId),"");
	},
	/**
	 * :
	 * @action
	 */
	_multiApproveActionEventHandler:function(){
		var billId = _self.getCurrentModel().id;
	    if(billId==undefined || billId==null){
	    	return ;
	    }
		waf.openNativeWindow("?method=doEvent&uipk=" + _self.getUIPk() + "&action=multiApprove&billID=" + waf.encodeURIComponent(billId),"");
	},
	/**
	 * :
	 */
	_viewActivityListActionEventHandler:function(){
		var billId = _self.getCurrentModel().id;
	    if(billId==undefined || billId==null){
	    	return ;
	    }
		waf.openNativeWindow("?method=doEvent&uipk=" + _self.getUIPk() + "&action=viewActivityList&billID=" + waf.encodeURIComponent(billId),"");
	},
	/**
	 * 
	 */
	 _exitActionEventHandler:function(){
	 	_self.fireEvent("pageOnCloseEvent"); 
	 },
	 /**
	 * 
	 */
	 _editPageOnCloseEventHandler:function(){
//	    waf.popMsgBox.showConfirm(waf("#toolBar_exit"),
//	        {title:"",
//	         content:"",
//	         width:200,
//	         placement:"bottom"
//	        },
//			function(){
			_self._pageOnCloseEventHandler();
//			},
//			function(){
//			}
//		);
	 }
});
/****WafPageDeclareEnd************/


